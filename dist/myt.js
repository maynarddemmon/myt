/**
Myt: A simple javascript UI framework
http://github.com/maynarddemmon/myt
Copyright (c) 2012-2014 Maynard Demmon and contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Parts of the Software incorporates code and/or design patterns from various
public domain sources and has been noted as such in the source.

Parts of the Software incorporates code from the following open-source 
projects:
* MIT License
*   JS.Class, Copyright (c) 2007-2012 James Coglan and contributors 
*   parseUri 1.2.2, Copyright (c) Steven Levithan <stevenlevithan.com>
*   Spin.js 1.3.0, Copyright (c) 2011-2013 Felix Gnass
*   k-d Tree JavaScript - v1.0, Copyright (c) Mircea Pricop <pricop@ubilabs.net>,
*                                             Martin Kleppe <kleppe@ubilabs.net>,
*                                             Ubilabs http://ubilabs.net
*   jQuery Cookie Plugin v1.3.1, Copyright (c) 2013 Klaus Hartl (MIT License)
*   Spectrum Colorpicker v1.4.1, Copyright (c) Brian Grinstead https://github.com/bgrins/spectrum
*
* BSD License
*   Easing Functions, Copyright (c) 2001 Robert Penner
*   jQuery Easing v1.3, Copyright (c) 2008 George McGinley Smith
*
* New BSD License
*   History.js, Copyright (c) 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/** Based on browser detection from: http://www.quirksmode.org/js/detect.html
    
    Events:
        none
    
    Attributes:
        browser:string The browser name.
        version:number The browser version number.
        os:string The operating system.
*/
BrowserDetect = (function() {
    var versionSearchString,
        
        searchString = function(data) {
            var dataItem, i = data.length;
            while (i) {
                dataItem = data[--i];
                versionSearchString = dataItem.ver || dataItem.id;
                if ((dataItem.str && dataItem.str.indexOf(dataItem.sub) >= 0) || dataItem.prop) return dataItem.id;
            }
        },
        
        searchVersion = function(dataString) {
            var index = dataString.indexOf(versionSearchString);
            if (index >= 0) return parseFloat(dataString.substring(index + versionSearchString.length + 1));
        },
        
        userAgent = navigator.userAgent, 
        platform = navigator.platform, 
        unknown = 'UNKNOWN';
    
    return {
        browser:searchString([
            {str:userAgent,        sub:"OmniWeb", id:"OmniWeb",  ver:"OmniWeb/"},
            {prop:window.opera,                   id:"Opera",    ver:"Version"},
            {str:navigator.vendor, sub:"Apple",   id:"Safari",   ver:"Version"},
            {str:userAgent,        sub:"Firefox", id:"Firefox"},
            {str:userAgent,        sub:"Chrome",  id:"Chrome"},
            {str:userAgent,        sub:"MSIE",    id:"Explorer", ver:"MSIE"}
        ]) || unknown,
        
        version:searchVersion(userAgent) || searchVersion(navigator.appVersion) || unknown,
        
        os:searchString([
            {str:userAgent, sub:"iPhone", id:"iPhone/iPod"},
            {str:platform,  sub:"Linux",  id:"Linux"},
            {str:platform,  sub:"Mac",    id:"Mac"},
            {str:platform,  sub:"Win",    id:"Windows"}
        ]) || unknown,
    };
})();


/** Creates a console object on old versions of IE to prevent errors. It
    doesn't actually do anything. */
if (typeof console !== 'object') {
    console = {
        log: function(v) {},
        warn: function(v) {},
        error: function(v) {}
    };
}


/** json2.js
    2012-10-08

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());


if (!global.mytNoHistoryShim) { // FIXME: remove conditional once old code has been updated.
    /**
     * History.js Native Adapter
     * @author Benjamin Arthur Lupton <contact@balupton.com>
     * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
     * @license New BSD License <http://creativecommons.org/licenses/BSD/>
     */
    // Closure
    (function(window,undefined){
        "use strict";
    
        // Localise Globals
        var History = window.History = window.History||{};
    
        // Check Existence
        if ( typeof History.Adapter !== 'undefined' ) {
            throw new Error('History.js Adapter has already been loaded...');
        }
    
        // Add the Adapter
        History.Adapter = {
            /**
             * History.Adapter.handlers[uid][eventName] = Array
             */
            handlers: {},
    
            /**
             * History.Adapter._uid
             * The current element unique identifier
             */
            _uid: 1,
    
            /**
             * History.Adapter.uid(element)
             * @param {Element} element
             * @return {String} uid
             */
            uid: function(element){
                return element._uid || (element._uid = History.Adapter._uid++);
            },
    
            /**
             * History.Adapter.bind(el,event,callback)
             * @param {Element} element
             * @param {String} eventName - custom and standard events
             * @param {Function} callback
             * @return
             */
            bind: function(element,eventName,callback){
                // Prepare
                var uid = History.Adapter.uid(element);
    
                // Apply Listener
                History.Adapter.handlers[uid] = History.Adapter.handlers[uid] || {};
                History.Adapter.handlers[uid][eventName] = History.Adapter.handlers[uid][eventName] || [];
                History.Adapter.handlers[uid][eventName].push(callback);
    
                // Bind Global Listener
                element['on'+eventName] = (function(element,eventName){
                    return function(event){
                        History.Adapter.trigger(element,eventName,event);
                    };
                })(element,eventName);
            },
    
            /**
             * History.Adapter.trigger(el,event)
             * @param {Element} element
             * @param {String} eventName - custom and standard events
             * @param {Object} event - a object of event data
             * @return
             */
            trigger: function(element,eventName,event){
                // Prepare
                event = event || {};
                var uid = History.Adapter.uid(element),
                    i,n;
    
                // Apply Listener
                History.Adapter.handlers[uid] = History.Adapter.handlers[uid] || {};
                History.Adapter.handlers[uid][eventName] = History.Adapter.handlers[uid][eventName] || [];
    
                // Fire Listeners
                for ( i=0,n=History.Adapter.handlers[uid][eventName].length; i<n; ++i ) {
                    History.Adapter.handlers[uid][eventName][i].apply(this,[event]);
                }
            },
    
            /**
             * History.Adapter.extractEventData(key,event,extra)
             * @param {String} key - key for the event data to extract
             * @param {String} event - custom and standard events
             * @return {mixed}
             */
            extractEventData: function(key,event){
                var result = (event && event[key]) || undefined;
                return result;
            },
    
            /**
             * History.Adapter.onDomLoad(callback)
             * @param {Function} callback
             * @return
             */
            onDomLoad: function(callback) {
                var timeout = window.setTimeout(function(){
                    callback();
                },2000);
                window.onload = function(){
                    clearTimeout(timeout);
                    callback();
                };
            }
        };
    
        // Try to Initialise History
        if ( typeof History.init !== 'undefined' ) {
            History.init();
        }
    })(window);
    
    
    /**
     * History.js HTML4 Support
     * Depends on the HTML5 Support
     * @author Benjamin Arthur Lupton <contact@balupton.com>
     * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
     * @license New BSD License <http://creativecommons.org/licenses/BSD/>
     */
    (function(window,undefined){
        "use strict";
    
        // ========================================================================
        // Initialise
    
        // Localise Globals
        var
            document = window.document, // Make sure we are using the correct document
            setTimeout = window.setTimeout||setTimeout,
            clearTimeout = window.clearTimeout||clearTimeout,
            setInterval = window.setInterval||setInterval,
            History = window.History = window.History||{}; // Public History Object
    
        // Check Existence
        if ( typeof History.initHtml4 !== 'undefined' ) {
            throw new Error('History.js HTML4 Support has already been loaded...');
        }
    
    
        // ========================================================================
        // Initialise HTML4 Support
    
        // Initialise HTML4 Support
        History.initHtml4 = function(){
            // Initialise
            if ( typeof History.initHtml4.initialized !== 'undefined' ) {
                // Already Loaded
                return false;
            }
            else {
                History.initHtml4.initialized = true;
            }
    
    
            // ====================================================================
            // Properties
    
            /**
             * History.enabled
             * Is History enabled?
             */
            History.enabled = true;
    
    
            // ====================================================================
            // Hash Storage
    
            /**
             * History.savedHashes
             * Store the hashes in an array
             */
            History.savedHashes = [];
    
            /**
             * History.isLastHash(newHash)
             * Checks if the hash is the last hash
             * @param {string} newHash
             * @return {boolean} true
             */
            History.isLastHash = function(newHash){
                // Prepare
                var oldHash = History.getHashByIndex(),
                    isLast;
    
                // Check
                isLast = newHash === oldHash;
    
                // Return isLast
                return isLast;
            };
    
            /**
             * History.isHashEqual(newHash, oldHash)
             * Checks to see if two hashes are functionally equal
             * @param {string} newHash
             * @param {string} oldHash
             * @return {boolean} true
             */
            History.isHashEqual = function(newHash, oldHash){
                newHash = encodeURIComponent(newHash).replace(/%25/g, "%");
                oldHash = encodeURIComponent(oldHash).replace(/%25/g, "%");
                return newHash === oldHash;
            };
    
            /**
             * History.saveHash(newHash)
             * Push a Hash
             * @param {string} newHash
             * @return {boolean} true
             */
            History.saveHash = function(newHash){
                // Check Hash
                if ( History.isLastHash(newHash) ) {
                    return false;
                }
    
                // Push the Hash
                History.savedHashes.push(newHash);
    
                // Return true
                return true;
            };
    
            /**
             * History.getHashByIndex()
             * Gets a hash by the index
             * @param {integer} index
             * @return {string}
             */
            History.getHashByIndex = function(index){
                // Prepare
                var hash = null;
    
                // Handle
                if ( typeof index === 'undefined' ) {
                    // Get the last inserted
                    hash = History.savedHashes[History.savedHashes.length-1];
                }
                else if ( index < 0 ) {
                    // Get from the end
                    hash = History.savedHashes[History.savedHashes.length+index];
                }
                else {
                    // Get from the beginning
                    hash = History.savedHashes[index];
                }
    
                // Return hash
                return hash;
            };
    
    
            // ====================================================================
            // Discarded States
    
            /**
             * History.discardedHashes
             * A hashed array of discarded hashes
             */
            History.discardedHashes = {};
    
            /**
             * History.discardedStates
             * A hashed array of discarded states
             */
            History.discardedStates = {};
    
            /**
             * History.discardState(State)
             * Discards the state by ignoring it through History
             * @param {object} State
             * @return {true}
             */
            History.discardState = function(discardedState,forwardState,backState){
                //History.debug('History.discardState', arguments);
                // Prepare
                var discardedStateHash = History.getHashByState(discardedState),
                    discardObject;
    
                // Create Discard Object
                discardObject = {
                    'discardedState': discardedState,
                    'backState': backState,
                    'forwardState': forwardState
                };
    
                // Add to DiscardedStates
                History.discardedStates[discardedStateHash] = discardObject;
    
                // Return true
                return true;
            };
    
            /**
             * History.discardHash(hash)
             * Discards the hash by ignoring it through History
             * @param {string} hash
             * @return {true}
             */
            History.discardHash = function(discardedHash,forwardState,backState){
                //History.debug('History.discardState', arguments);
                // Create Discard Object
                var discardObject = {
                    'discardedHash': discardedHash,
                    'backState': backState,
                    'forwardState': forwardState
                };
    
                // Add to discardedHash
                History.discardedHashes[discardedHash] = discardObject;
    
                // Return true
                return true;
            };
    
            /**
             * History.discardedState(State)
             * Checks to see if the state is discarded
             * @param {object} State
             * @return {bool}
             */
            History.discardedState = function(State){
                // Prepare
                var StateHash = History.getHashByState(State),
                    discarded;
    
                // Check
                discarded = History.discardedStates[StateHash]||false;
    
                // Return true
                return discarded;
            };
    
            /**
             * History.discardedHash(hash)
             * Checks to see if the state is discarded
             * @param {string} State
             * @return {bool}
             */
            History.discardedHash = function(hash){
                // Check
                var discarded = History.discardedHashes[hash]||false;
    
                // Return true
                return discarded;
            };
    
            /**
             * History.recycleState(State)
             * Allows a discarded state to be used again
             * @param {object} data
             * @param {string} title
             * @param {string} url
             * @return {true}
             */
            History.recycleState = function(State){
                //History.debug('History.recycleState', arguments);
                // Prepare
                var StateHash = History.getHashByState(State);
    
                // Remove from DiscardedStates
                if ( History.discardedState(State) ) {
                    delete History.discardedStates[StateHash];
                }
    
                // Return true
                return true;
            };
    
    
            // ====================================================================
            // HTML4 HashChange Support
    
            if ( History.emulated.hashChange ) {
                /*
                 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
                 */
    
                /**
                 * History.hashChangeInit()
                 * Init the HashChange Emulation
                 */
                History.hashChangeInit = function(){
                    // Define our Checker Function
                    History.checkerFunction = null;
    
                    // Define some variables that will help in our checker function
                    var lastDocumentHash = '',
                        iframeId, iframe,
                        lastIframeHash, checkerRunning,
                        startedWithHash = Boolean(History.getHash());
    
                    // Handle depending on the browser
                    if ( History.isInternetExplorer() ) {
                        // IE6 and IE7
                        // We need to use an iframe to emulate the back and forward buttons
    
                        // Create iFrame
                        iframeId = 'historyjs-iframe';
                        iframe = document.createElement('iframe');
    
                        // Adjust iFarme
                        // IE 6 requires iframe to have a src on HTTPS pages, otherwise it will throw a
                        // "This page contains both secure and nonsecure items" warning.
                        iframe.setAttribute('id', iframeId);
                        iframe.setAttribute('src', '#');
                        iframe.style.display = 'none';
    
                        // Append iFrame
                        document.body.appendChild(iframe);
    
                        // Create initial history entry
                        iframe.contentWindow.document.open();
                        iframe.contentWindow.document.close();
    
                        // Define some variables that will help in our checker function
                        lastIframeHash = '';
                        checkerRunning = false;
    
                        // Define the checker function
                        History.checkerFunction = function(){
                            // Check Running
                            if ( checkerRunning ) {
                                return false;
                            }
    
                            // Update Running
                            checkerRunning = true;
    
                            // Fetch
                            var
                                documentHash = History.getHash(),
                                iframeHash = History.getHash(iframe.contentWindow.document);
    
                            // The Document Hash has changed (application caused)
                            if ( documentHash !== lastDocumentHash ) {
                                // Equalise
                                lastDocumentHash = documentHash;
    
                                // Create a history entry in the iframe
                                if ( iframeHash !== documentHash ) {
                                    //History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);
    
                                    // Equalise
                                    lastIframeHash = iframeHash = documentHash;
    
                                    // Create History Entry
                                    iframe.contentWindow.document.open();
                                    iframe.contentWindow.document.close();
    
                                    // Update the iframe's hash
                                    iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
                                }
    
                                // Trigger Hashchange Event
                                History.Adapter.trigger(window,'hashchange');
                            }
    
                            // The iFrame Hash has changed (back button caused)
                            else if ( iframeHash !== lastIframeHash ) {
                                //History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);
    
                                // Equalise
                                lastIframeHash = iframeHash;
                                
                                // If there is no iframe hash that means we're at the original
                                // iframe state.
                                // And if there was a hash on the original request, the original
                                // iframe state was replaced instantly, so skip this state and take
                                // the user back to where they came from.
                                if (startedWithHash && iframeHash === '') {
                                    History.back();
                                }
                                else {
                                    // Update the Hash
                                    History.setHash(iframeHash,false);
                                }
                            }
    
                            // Reset Running
                            checkerRunning = false;
    
                            // Return true
                            return true;
                        };
                    }
                    else {
                        // We are not IE
                        // Firefox 1 or 2, Opera
    
                        // Define the checker function
                        History.checkerFunction = function(){
                            // Prepare
                            var documentHash = History.getHash()||'';
    
                            // The Document Hash has changed (application caused)
                            if ( documentHash !== lastDocumentHash ) {
                                // Equalise
                                lastDocumentHash = documentHash;
    
                                // Trigger Hashchange Event
                                History.Adapter.trigger(window,'hashchange');
                            }
    
                            // Return true
                            return true;
                        };
                    }
    
                    // Apply the checker function
                    History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));
    
                    // Done
                    return true;
                }; // History.hashChangeInit
    
                // Bind hashChangeInit
                History.Adapter.onDomLoad(History.hashChangeInit);
    
            } // History.emulated.hashChange
    
    
            // ====================================================================
            // HTML5 State Support
    
            // Non-Native pushState Implementation
            if ( History.emulated.pushState ) {
                /*
                 * We must emulate the HTML5 State Management by using HTML4 HashChange
                 */
    
                /**
                 * History.onHashChange(event)
                 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
                 */
                History.onHashChange = function(event){
                    //History.debug('History.onHashChange', arguments);
    
                    // Prepare
                    var currentUrl = ((event && event.newURL) || History.getLocationHref()),
                        currentHash = History.getHashByUrl(currentUrl),
                        currentState = null,
                        currentStateHash = null,
                        currentStateHashExits = null,
                        discardObject;
    
                    // Check if we are the same state
                    if ( History.isLastHash(currentHash) ) {
                        // There has been no change (just the page's hash has finally propagated)
                        //History.debug('History.onHashChange: no change');
                        History.busy(false);
                        return false;
                    }
    
                    // Reset the double check
                    History.doubleCheckComplete();
    
                    // Store our location for use in detecting back/forward direction
                    History.saveHash(currentHash);
    
                    // Expand Hash
                    if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
                        //History.debug('History.onHashChange: traditional anchor', currentHash);
                        // Traditional Anchor Hash
                        History.Adapter.trigger(window,'anchorchange');
                        History.busy(false);
                        return false;
                    }
    
                    // Create State
                    currentState = History.extractState(History.getFullUrl(currentHash||History.getLocationHref()),true);
    
                    // Check if we are the same state
                    if ( History.isLastSavedState(currentState) ) {
                        //History.debug('History.onHashChange: no change');
                        // There has been no change (just the page's hash has finally propagated)
                        History.busy(false);
                        return false;
                    }
    
                    // Create the state Hash
                    currentStateHash = History.getHashByState(currentState);
    
                    // Check if we are DiscardedState
                    discardObject = History.discardedState(currentState);
                    if ( discardObject ) {
                        // Ignore this state as it has been discarded and go back to the state before it
                        if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
                            // We are going backwards
                            //History.debug('History.onHashChange: go backwards');
                            History.back(false);
                        } else {
                            // We are going forwards
                            //History.debug('History.onHashChange: go forwards');
                            History.forward(false);
                        }
                        return false;
                    }
    
                    // Push the new HTML5 State
                    //History.debug('History.onHashChange: success hashchange');
                    History.pushState(currentState.data,currentState.title,encodeURI(currentState.url),false);
    
                    // End onHashChange closure
                    return true;
                };
                History.Adapter.bind(window,'hashchange',History.onHashChange);
    
                /**
                 * History.pushState(data,title,url)
                 * Add a new State to the history object, become it, and trigger onpopstate
                 * We have to trigger for HTML4 compatibility
                 * @param {object} data
                 * @param {string} title
                 * @param {string} url
                 * @return {true}
                 */
                History.pushState = function(data,title,url,queue){
                    //History.debug('History.pushState: called', arguments);
    
                    // We assume that the URL passed in is URI-encoded, but this makes
                    // sure that it's fully URI encoded; any '%'s that are encoded are
                    // converted back into '%'s
                    url = encodeURI(url).replace(/%25/g, "%");
    
                    // Check the State
                    if ( History.getHashByUrl(url) ) {
                        throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
                    }
    
                    // Handle Queueing
                    if ( queue !== false && History.busy() ) {
                        // Wait + Push to Queue
                        //History.debug('History.pushState: we must wait', arguments);
                        History.pushQueue({
                            scope: History,
                            callback: History.pushState,
                            args: arguments,
                            queue: queue
                        });
                        return false;
                    }
    
                    // Make Busy
                    History.busy(true);
    
                    // Fetch the State Object
                    var newState = History.createStateObject(data,title,url),
                        newStateHash = History.getHashByState(newState),
                        oldState = History.getState(false),
                        oldStateHash = History.getHashByState(oldState),
                        html4Hash = History.getHash(),
                        wasExpected = History.expectedStateId == newState.id;
    
                    // Store the newState
                    History.storeState(newState);
                    History.expectedStateId = newState.id;
    
                    // Recycle the State
                    History.recycleState(newState);
    
                    // Force update of the title
                    History.setTitle(newState);
    
                    // Check if we are the same State
                    if ( newStateHash === oldStateHash ) {
                        //History.debug('History.pushState: no change', newStateHash);
                        History.busy(false);
                        return false;
                    }
    
                    // Update HTML5 State
                    History.saveState(newState);
    
                    // Fire HTML5 Event
                    if(!wasExpected)
                        History.Adapter.trigger(window,'statechange');
    
                    // Update HTML4 Hash
                    if ( !History.isHashEqual(newStateHash, html4Hash) && !History.isHashEqual(newStateHash, History.getShortUrl(History.getLocationHref())) ) {
                        History.setHash(newStateHash,false);
                    }
                    
                    History.busy(false);
    
                    // End pushState closure
                    return true;
                };
    
                /**
                 * History.replaceState(data,title,url)
                 * Replace the State and trigger onpopstate
                 * We have to trigger for HTML4 compatibility
                 * @param {object} data
                 * @param {string} title
                 * @param {string} url
                 * @return {true}
                 */
                History.replaceState = function(data,title,url,queue){
                    //History.debug('History.replaceState: called', arguments);
    
                    // We assume that the URL passed in is URI-encoded, but this makes
                    // sure that it's fully URI encoded; any '%'s that are encoded are
                    // converted back into '%'s
                    url = encodeURI(url).replace(/%25/g, "%");
    
                    // Check the State
                    if ( History.getHashByUrl(url) ) {
                        throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
                    }
    
                    // Handle Queueing
                    if ( queue !== false && History.busy() ) {
                        // Wait + Push to Queue
                        //History.debug('History.replaceState: we must wait', arguments);
                        History.pushQueue({
                            scope: History,
                            callback: History.replaceState,
                            args: arguments,
                            queue: queue
                        });
                        return false;
                    }
    
                    // Make Busy
                    History.busy(true);
    
                    // Fetch the State Objects
                    var newState        = History.createStateObject(data,title,url),
                        newStateHash = History.getHashByState(newState),
                        oldState        = History.getState(false),
                        oldStateHash = History.getHashByState(oldState),
                        previousState   = History.getStateByIndex(-2);
    
                    // Discard Old State
                    History.discardState(oldState,newState,previousState);
    
                    // If the url hasn't changed, just store and save the state
                    // and fire a statechange event to be consistent with the
                    // html 5 api
                    if ( newStateHash === oldStateHash ) {
                        // Store the newState
                        History.storeState(newState);
                        History.expectedStateId = newState.id;
        
                        // Recycle the State
                        History.recycleState(newState);
        
                        // Force update of the title
                        History.setTitle(newState);
                        
                        // Update HTML5 State
                        History.saveState(newState);
    
                        // Fire HTML5 Event
                        //History.debug('History.pushState: trigger popstate');
                        History.Adapter.trigger(window,'statechange');
                        History.busy(false);
                    }
                    else {
                        // Alias to PushState
                        History.pushState(newState.data,newState.title,newState.url,false);
                    }
    
                    // End replaceState closure
                    return true;
                };
    
            } // History.emulated.pushState
    
    
    
            // ====================================================================
            // Initialise
    
            // Non-Native pushState Implementation
            if ( History.emulated.pushState ) {
                /**
                 * Ensure initial state is handled correctly
                 */
                if ( History.getHash() && !History.emulated.hashChange ) {
                    History.Adapter.onDomLoad(function(){
                        History.Adapter.trigger(window,'hashchange');
                    });
                }
    
            } // History.emulated.pushState
    
        }; // History.initHtml4
    
        // Try to Initialise History
        if ( typeof History.init !== 'undefined' ) {
            History.init();
        }
    })(window);
    
    
    /**
     * History.js Core
     * @author Benjamin Arthur Lupton <contact@balupton.com>
     * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
     * @license New BSD License <http://creativecommons.org/licenses/BSD/>
     */
    (function(window,undefined){
        "use strict";
    
        // ========================================================================
        // Initialise
    
        // Localise Globals
        var
            console = window.console||undefined, // Prevent a JSLint complain
            document = window.document, // Make sure we are using the correct document
            navigator = window.navigator, // Make sure we are using the correct navigator
            sessionStorage = false, // sessionStorage
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            setInterval = window.setInterval,
            clearInterval = window.clearInterval,
            JSON = window.JSON,
            alert = window.alert,
            History = window.History = window.History||{}, // Public History Object
            history = window.history; // Old History Object
    
        try {
            sessionStorage = window.sessionStorage; // This will throw an exception in some browsers when cookies/localStorage are explicitly disabled (i.e. Chrome)
            sessionStorage.setItem('TEST', '1');
            sessionStorage.removeItem('TEST');
        } catch(e) {
            sessionStorage = false;
        }
    
        // MooTools Compatibility
        JSON.stringify = JSON.stringify||JSON.encode;
        JSON.parse = JSON.parse||JSON.decode;
    
        // Check Existence
        if ( typeof History.init !== 'undefined' ) {
            throw new Error('History.js Core has already been loaded...');
        }
    
        // Initialise History
        History.init = function(options){
            // Check Load Status of Adapter
            if ( typeof History.Adapter === 'undefined' ) {
                return false;
            }
    
            // Check Load Status of Core
            if ( typeof History.initCore !== 'undefined' ) {
                History.initCore();
            }
    
            // Check Load Status of HTML4 Support
            if ( typeof History.initHtml4 !== 'undefined' ) {
                History.initHtml4();
            }
    
            // Return true
            return true;
        };
    
    
        // ========================================================================
        // Initialise Core
    
        // Initialise Core
        History.initCore = function(options){
            // Initialise
            if ( typeof History.initCore.initialized !== 'undefined' ) {
                // Already Loaded
                return false;
            }
            else {
                History.initCore.initialized = true;
            }
    
    
            // ====================================================================
            // Options
    
            /**
             * History.options
             * Configurable options
             */
            History.options = History.options||{};
    
            /**
             * History.options.hashChangeInterval
             * How long should the interval be before hashchange checks
             */
            History.options.hashChangeInterval = History.options.hashChangeInterval || 100;
    
            /**
             * History.options.safariPollInterval
             * How long should the interval be before safari poll checks
             */
            History.options.safariPollInterval = History.options.safariPollInterval || 500;
    
            /**
             * History.options.doubleCheckInterval
             * How long should the interval be before we perform a double check
             */
            History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;
    
            /**
             * History.options.disableSuid
             * Force History not to append suid
             */
            History.options.disableSuid = History.options.disableSuid || false;
    
            /**
             * History.options.storeInterval
             * How long should we wait between store calls
             */
            History.options.storeInterval = History.options.storeInterval || 1000;
    
            /**
             * History.options.busyDelay
             * How long should we wait between busy events
             */
            History.options.busyDelay = History.options.busyDelay || 250;
    
            /**
             * History.options.debug
             * If true will enable debug messages to be logged
             */
            History.options.debug = History.options.debug || false;
    
            /**
             * History.options.initialTitle
             * What is the title of the initial state
             */
            History.options.initialTitle = History.options.initialTitle || document.title;
    
            /**
             * History.options.html4Mode
             * If true, will force HTMl4 mode (hashtags)
             */
            History.options.html4Mode = History.options.html4Mode || false;
    
            /**
             * History.options.delayInit
             * Want to override default options and call init manually.
             */
            History.options.delayInit = History.options.delayInit || false;
    
    
            // ====================================================================
            // Interval record
    
            /**
             * History.intervalList
             * List of intervals set, to be cleared when document is unloaded.
             */
            History.intervalList = [];
    
            /**
             * History.clearAllIntervals
             * Clears all setInterval instances.
             */
            History.clearAllIntervals = function(){
                var i, il = History.intervalList;
                if (typeof il !== "undefined" && il !== null) {
                    for (i = 0; i < il.length; i++) {
                        clearInterval(il[i]);
                    }
                    History.intervalList = null;
                }
            };
    
    
            // ====================================================================
            // Debug
    
            /**
             * History.debug(message,...)
             * Logs the passed arguments if debug enabled
             */
            History.debug = function(){
                if ( (History.options.debug||false) ) {
                    History.log.apply(History,arguments);
                }
            };
    
            /**
             * History.log(message,...)
             * Logs the passed arguments
             */
            History.log = function(){
                // Prepare
                var
                    consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
                    textarea = document.getElementById('log'),
                    message,
                    i,n,
                    args,arg
                    ;
    
                // Write to Console
                if ( consoleExists ) {
                    args = Array.prototype.slice.call(arguments);
                    message = args.shift();
                    if ( typeof console.debug !== 'undefined' ) {
                        console.debug.apply(console,[message,args]);
                    }
                    else {
                        console.log.apply(console,[message,args]);
                    }
                }
                else {
                    message = ("\n"+arguments[0]+"\n");
                }
    
                // Write to log
                for ( i=1,n=arguments.length; i<n; ++i ) {
                    arg = arguments[i];
                    if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
                        try {
                            arg = JSON.stringify(arg);
                        }
                        catch ( Exception ) {
                            // Recursive Object
                        }
                    }
                    message += "\n"+arg+"\n";
                }
    
                // Textarea
                if ( textarea ) {
                    textarea.value += message+"\n-----\n";
                    textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
                }
                // No Textarea, No Console
                else if ( !consoleExists ) {
                    alert(message);
                }
    
                // Return true
                return true;
            };
    
    
            // ====================================================================
            // Emulated Status
    
            /**
             * History.getInternetExplorerMajorVersion()
             * Get's the major version of Internet Explorer
             * @return {integer}
             * @license Public Domain
             * @author Benjamin Arthur Lupton <contact@balupton.com>
             * @author James Padolsey <https://gist.github.com/527683>
             */
            History.getInternetExplorerMajorVersion = function(){
                var result = History.getInternetExplorerMajorVersion.cached =
                        (typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
                    ?	History.getInternetExplorerMajorVersion.cached
                    :	(function(){
                            var v = 3,
                                    div = document.createElement('div'),
                                    all = div.getElementsByTagName('i');
                            while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
                            return (v > 4) ? v : false;
                        })()
                    ;
                return result;
            };
    
            /**
             * History.isInternetExplorer()
             * Are we using Internet Explorer?
             * @return {boolean}
             * @license Public Domain
             * @author Benjamin Arthur Lupton <contact@balupton.com>
             */
            History.isInternetExplorer = function(){
                var result =
                    History.isInternetExplorer.cached =
                    (typeof History.isInternetExplorer.cached !== 'undefined')
                        ?	History.isInternetExplorer.cached
                        :	Boolean(History.getInternetExplorerMajorVersion())
                    ;
                return result;
            };
    
            /**
             * History.emulated
             * Which features require emulating?
             */
    
            if (History.options.html4Mode) {
                History.emulated = {
                    pushState : true,
                    hashChange: true
                };
            }
    
            else {
    
                History.emulated = {
                    pushState: !Boolean(
                        window.history && window.history.pushState && window.history.replaceState
                        && !(
                            (/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
                            || (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
                        )
                    ),
                    hashChange: Boolean(
                        !(('onhashchange' in window) || ('onhashchange' in document))
                        ||
                        (History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
                    )
                };
            }
    
            /**
             * History.enabled
             * Is History enabled?
             */
            History.enabled = !History.emulated.pushState;
    
            /**
             * History.bugs
             * Which bugs are present
             */
            History.bugs = {
                /**
                 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
                 * https://bugs.webkit.org/show_bug.cgi?id=56249
                 */
                setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),
    
                /**
                 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
                 * https://bugs.webkit.org/show_bug.cgi?id=42940
                 */
                safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),
    
                /**
                 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
                 */
                ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),
    
                /**
                 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
                 */
                hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
            };
    
            /**
             * History.isEmptyObject(obj)
             * Checks to see if the Object is Empty
             * @param {Object} obj
             * @return {boolean}
             */
            History.isEmptyObject = function(obj) {
                for ( var name in obj ) {
                    if ( obj.hasOwnProperty(name) ) {
                        return false;
                    }
                }
                return true;
            };
    
            /**
             * History.cloneObject(obj)
             * Clones a object and eliminate all references to the original contexts
             * @param {Object} obj
             * @return {Object}
             */
            History.cloneObject = function(obj) {
                var hash,newObj;
                if ( obj ) {
                    hash = JSON.stringify(obj);
                    newObj = JSON.parse(hash);
                }
                else {
                    newObj = {};
                }
                return newObj;
            };
    
    
            // ====================================================================
            // URL Helpers
    
            /**
             * History.getRootUrl()
             * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
             * @return {String} rootUrl
             */
            History.getRootUrl = function(){
                // Create
                var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
                if ( document.location.port||false ) {
                    rootUrl += ':'+document.location.port;
                }
                rootUrl += '/';
    
                // Return
                return rootUrl;
            };
    
            /**
             * History.getBaseHref()
             * Fetches the `href` attribute of the `<base href="...">` element if it exists
             * @return {String} baseHref
             */
            History.getBaseHref = function(){
                // Create
                var
                    baseElements = document.getElementsByTagName('base'),
                    baseElement = null,
                    baseHref = '';
    
                // Test for Base Element
                if ( baseElements.length === 1 ) {
                    // Prepare for Base Element
                    baseElement = baseElements[0];
                    baseHref = baseElement.href.replace(/[^\/]+$/,'');
                }
    
                // Adjust trailing slash
                baseHref = baseHref.replace(/\/+$/,'');
                if ( baseHref ) baseHref += '/';
    
                // Return
                return baseHref;
            };
    
            /**
             * History.getBaseUrl()
             * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
             * @return {String} baseUrl
             */
            History.getBaseUrl = function(){
                // Create
                var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();
    
                // Return
                return baseUrl;
            };
    
            /**
             * History.getPageUrl()
             * Fetches the URL of the current page
             * @return {String} pageUrl
             */
            History.getPageUrl = function(){
                // Fetch
                var
                    State = History.getState(false,false),
                    stateUrl = (State||{}).url||History.getLocationHref(),
                    pageUrl;
    
                // Create
                pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
                    return (/\./).test(part) ? part : part+'/';
                });
    
                // Return
                return pageUrl;
            };
    
            /**
             * History.getBasePageUrl()
             * Fetches the Url of the directory of the current page
             * @return {String} basePageUrl
             */
            History.getBasePageUrl = function(){
                // Create
                var basePageUrl = (History.getLocationHref()).replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
                    return (/[^\/]$/).test(part) ? '' : part;
                }).replace(/\/+$/,'')+'/';
    
                // Return
                return basePageUrl;
            };
    
            /**
             * History.getFullUrl(url)
             * Ensures that we have an absolute URL and not a relative URL
             * @param {string} url
             * @param {Boolean} allowBaseHref
             * @return {string} fullUrl
             */
            History.getFullUrl = function(url,allowBaseHref){
                // Prepare
                var fullUrl = url, firstChar = url.substring(0,1);
                allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;
    
                // Check
                if ( /[a-z]+\:\/\//.test(url) ) {
                    // Full URL
                }
                else if ( firstChar === '/' ) {
                    // Root URL
                    fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
                }
                else if ( firstChar === '#' ) {
                    // Anchor URL
                    fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
                }
                else if ( firstChar === '?' ) {
                    // Query URL
                    fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
                }
                else {
                    // Relative URL
                    if ( allowBaseHref ) {
                        fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
                    } else {
                        fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
                    }
                    // We have an if condition above as we do not want hashes
                    // which are relative to the baseHref in our URLs
                    // as if the baseHref changes, then all our bookmarks
                    // would now point to different locations
                    // whereas the basePageUrl will always stay the same
                }
    
                // Return
                return fullUrl.replace(/\#$/,'');
            };
    
            /**
             * History.getShortUrl(url)
             * Ensures that we have a relative URL and not a absolute URL
             * @param {string} url
             * @return {string} url
             */
            History.getShortUrl = function(url){
                // Prepare
                var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();
    
                // Trim baseUrl
                if ( History.emulated.pushState ) {
                    // We are in a if statement as when pushState is not emulated
                    // The actual url these short urls are relative to can change
                    // So within the same session, we the url may end up somewhere different
                    shortUrl = shortUrl.replace(baseUrl,'');
                }
    
                // Trim rootUrl
                shortUrl = shortUrl.replace(rootUrl,'/');
    
                // Ensure we can still detect it as a state
                if ( History.isTraditionalAnchor(shortUrl) ) {
                    shortUrl = './'+shortUrl;
                }
    
                // Clean It
                shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');
    
                // Return
                return shortUrl;
            };
    
            /**
             * History.getLocationHref(document)
             * Returns a normalized version of document.location.href
             * accounting for browser inconsistencies, etc.
             *
             * This URL will be URI-encoded and will include the hash
             *
             * @param {object} document
             * @return {string} url
             */
            History.getLocationHref = function(doc) {
                doc = doc || document;
    
                // most of the time, this will be true
                if (doc.URL === doc.location.href)
                    return doc.location.href;
    
                // some versions of webkit URI-decode document.location.href
                // but they leave document.URL in an encoded state
                if (doc.location.href === decodeURIComponent(doc.URL))
                    return doc.URL;
    
                // FF 3.6 only updates document.URL when a page is reloaded
                // document.location.href is updated correctly
                if (doc.location.hash && decodeURIComponent(doc.location.href.replace(/^[^#]+/, "")) === doc.location.hash)
                    return doc.location.href;
    
                if (doc.URL.indexOf('#') == -1 && doc.location.href.indexOf('#') != -1)
                    return doc.location.href;
                
                return doc.URL || doc.location.href;
            };
    
    
            // ====================================================================
            // State Storage
    
            /**
             * History.store
             * The store for all session specific data
             */
            History.store = {};
    
            /**
             * History.idToState
             * 1-1: State ID to State Object
             */
            History.idToState = History.idToState||{};
    
            /**
             * History.stateToId
             * 1-1: State String to State ID
             */
            History.stateToId = History.stateToId||{};
    
            /**
             * History.urlToId
             * 1-1: State URL to State ID
             */
            History.urlToId = History.urlToId||{};
    
            /**
             * History.storedStates
             * Store the states in an array
             */
            History.storedStates = History.storedStates||[];
    
            /**
             * History.savedStates
             * Saved the states in an array
             */
            History.savedStates = History.savedStates||[];
    
            /**
             * History.noramlizeStore()
             * Noramlize the store by adding necessary values
             */
            History.normalizeStore = function(){
                History.store.idToState = History.store.idToState||{};
                History.store.urlToId = History.store.urlToId||{};
                History.store.stateToId = History.store.stateToId||{};
            };
    
            /**
             * History.getState()
             * Get an object containing the data, title and url of the current state
             * @param {Boolean} friendly
             * @param {Boolean} create
             * @return {Object} State
             */
            History.getState = function(friendly,create){
                // Prepare
                if ( typeof friendly === 'undefined' ) { friendly = true; }
                if ( typeof create === 'undefined' ) { create = true; }
    
                // Fetch
                var State = History.getLastSavedState();
    
                // Create
                if ( !State && create ) {
                    State = History.createStateObject();
                }
    
                // Adjust
                if ( friendly ) {
                    State = History.cloneObject(State);
                    State.url = State.cleanUrl||State.url;
                }
    
                // Return
                return State;
            };
    
            /**
             * History.getIdByState(State)
             * Gets a ID for a State
             * @param {State} newState
             * @return {String} id
             */
            History.getIdByState = function(newState){
    
                // Fetch ID
                var id = History.extractId(newState.url),
                    str;
    
                if ( !id ) {
                    // Find ID via State String
                    str = History.getStateString(newState);
                    if ( typeof History.stateToId[str] !== 'undefined' ) {
                        id = History.stateToId[str];
                    }
                    else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
                        id = History.store.stateToId[str];
                    }
                    else {
                        // Generate a new ID
                        while ( true ) {
                            id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
                            if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
                                break;
                            }
                        }
    
                        // Apply the new State to the ID
                        History.stateToId[str] = id;
                        History.idToState[id] = newState;
                    }
                }
    
                // Return ID
                return id;
            };
    
            /**
             * History.normalizeState(State)
             * Expands a State Object
             * @param {object} State
             * @return {object}
             */
            History.normalizeState = function(oldState){
                // Variables
                var newState, dataNotEmpty;
    
                // Prepare
                if ( !oldState || (typeof oldState !== 'object') ) {
                    oldState = {};
                }
    
                // Check
                if ( typeof oldState.normalized !== 'undefined' ) {
                    return oldState;
                }
    
                // Adjust
                if ( !oldState.data || (typeof oldState.data !== 'object') ) {
                    oldState.data = {};
                }
    
                // ----------------------------------------------------------------
    
                // Create
                newState = {};
                newState.normalized = true;
                newState.title = oldState.title||'';
                newState.url = History.getFullUrl(oldState.url?oldState.url:(History.getLocationHref()));
                newState.hash = History.getShortUrl(newState.url);
                newState.data = History.cloneObject(oldState.data);
    
                // Fetch ID
                newState.id = History.getIdByState(newState);
    
                // ----------------------------------------------------------------
    
                // Clean the URL
                newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
                newState.url = newState.cleanUrl;
    
                // Check to see if we have more than just a url
                dataNotEmpty = !History.isEmptyObject(newState.data);
    
                // Apply
                if ( (newState.title || dataNotEmpty) && History.options.disableSuid !== true ) {
                    // Add ID to Hash
                    newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
                    if ( !/\?/.test(newState.hash) ) {
                        newState.hash += '?';
                    }
                    newState.hash += '&_suid='+newState.id;
                }
    
                // Create the Hashed URL
                newState.hashedUrl = History.getFullUrl(newState.hash);
    
                // ----------------------------------------------------------------
    
                // Update the URL if we have a duplicate
                if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
                    newState.url = newState.hashedUrl;
                }
    
                // ----------------------------------------------------------------
    
                // Return
                return newState;
            };
    
            /**
             * History.createStateObject(data,title,url)
             * Creates a object based on the data, title and url state params
             * @param {object} data
             * @param {string} title
             * @param {string} url
             * @return {object}
             */
            History.createStateObject = function(data,title,url){
                // Hashify
                var State = {
                    'data': data,
                    'title': title,
                    'url': url
                };
    
                // Expand the State
                State = History.normalizeState(State);
    
                // Return object
                return State;
            };
    
            /**
             * History.getStateById(id)
             * Get a state by it's UID
             * @param {String} id
             */
            History.getStateById = function(id){
                // Prepare
                id = String(id);
    
                // Retrieve
                var State = History.idToState[id] || History.store.idToState[id] || undefined;
    
                // Return State
                return State;
            };
    
            /**
             * Get a State's String
             * @param {State} passedState
             */
            History.getStateString = function(passedState){
                // Prepare
                var State, cleanedState, str;
    
                // Fetch
                State = History.normalizeState(passedState);
    
                // Clean
                cleanedState = {
                    data: State.data,
                    title: passedState.title,
                    url: passedState.url
                };
    
                // Fetch
                str = JSON.stringify(cleanedState);
    
                // Return
                return str;
            };
    
            /**
             * Get a State's ID
             * @param {State} passedState
             * @return {String} id
             */
            History.getStateId = function(passedState){
                // Prepare
                var State, id;
    
                // Fetch
                State = History.normalizeState(passedState);
    
                // Fetch
                id = State.id;
    
                // Return
                return id;
            };
    
            /**
             * History.getHashByState(State)
             * Creates a Hash for the State Object
             * @param {State} passedState
             * @return {String} hash
             */
            History.getHashByState = function(passedState){
                // Prepare
                var State, hash;
    
                // Fetch
                State = History.normalizeState(passedState);
    
                // Hash
                hash = State.hash;
    
                // Return
                return hash;
            };
    
            /**
             * History.extractId(url_or_hash)
             * Get a State ID by it's URL or Hash
             * @param {string} url_or_hash
             * @return {string} id
             */
            History.extractId = function ( url_or_hash ) {
                // Prepare
                var id,parts,url, tmp;
    
                // Extract
                
                // If the URL has a #, use the id from before the #
                if (url_or_hash.indexOf('#') != -1)
                {
                    tmp = url_or_hash.split("#")[0];
                }
                else
                {
                    tmp = url_or_hash;
                }
                
                parts = /(.*)\&_suid=([0-9]+)$/.exec(tmp);
                url = parts ? (parts[1]||url_or_hash) : url_or_hash;
                id = parts ? String(parts[2]||'') : '';
    
                // Return
                return id||false;
            };
    
            /**
             * History.isTraditionalAnchor
             * Checks to see if the url is a traditional anchor or not
             * @param {String} url_or_hash
             * @return {Boolean}
             */
            History.isTraditionalAnchor = function(url_or_hash){
                // Check
                var isTraditional = !(/[\/\?\.]/.test(url_or_hash));
    
                // Return
                return isTraditional;
            };
    
            /**
             * History.extractState
             * Get a State by it's URL or Hash
             * @param {String} url_or_hash
             * @return {State|null}
             */
            History.extractState = function(url_or_hash,create){
                // Prepare
                var State = null, id, url;
                create = create||false;
    
                // Fetch SUID
                id = History.extractId(url_or_hash);
                if ( id ) {
                    State = History.getStateById(id);
                }
    
                // Fetch SUID returned no State
                if ( !State ) {
                    // Fetch URL
                    url = History.getFullUrl(url_or_hash);
    
                    // Check URL
                    id = History.getIdByUrl(url)||false;
                    if ( id ) {
                        State = History.getStateById(id);
                    }
    
                    // Create State
                    if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
                        State = History.createStateObject(null,null,url);
                    }
                }
    
                // Return
                return State;
            };
    
            /**
             * History.getIdByUrl()
             * Get a State ID by a State URL
             */
            History.getIdByUrl = function(url){
                // Fetch
                var id = History.urlToId[url] || History.store.urlToId[url] || undefined;
    
                // Return
                return id;
            };
    
            /**
             * History.getLastSavedState()
             * Get an object containing the data, title and url of the current state
             * @return {Object} State
             */
            History.getLastSavedState = function(){
                return History.savedStates[History.savedStates.length-1]||undefined;
            };
    
            /**
             * History.getLastStoredState()
             * Get an object containing the data, title and url of the current state
             * @return {Object} State
             */
            History.getLastStoredState = function(){
                return History.storedStates[History.storedStates.length-1]||undefined;
            };
    
            /**
             * History.hasUrlDuplicate
             * Checks if a Url will have a url conflict
             * @param {Object} newState
             * @return {Boolean} hasDuplicate
             */
            History.hasUrlDuplicate = function(newState) {
                // Prepare
                var hasDuplicate = false,
                    oldState;
    
                // Fetch
                oldState = History.extractState(newState.url);
    
                // Check
                hasDuplicate = oldState && oldState.id !== newState.id;
    
                // Return
                return hasDuplicate;
            };
    
            /**
             * History.storeState
             * Store a State
             * @param {Object} newState
             * @return {Object} newState
             */
            History.storeState = function(newState){
                // Store the State
                History.urlToId[newState.url] = newState.id;
    
                // Push the State
                History.storedStates.push(History.cloneObject(newState));
    
                // Return newState
                return newState;
            };
    
            /**
             * History.isLastSavedState(newState)
             * Tests to see if the state is the last state
             * @param {Object} newState
             * @return {boolean} isLast
             */
            History.isLastSavedState = function(newState){
                // Prepare
                var isLast = false,
                    newId, oldState, oldId;
    
                // Check
                if ( History.savedStates.length ) {
                    newId = newState.id;
                    oldState = History.getLastSavedState();
                    oldId = oldState.id;
    
                    // Check
                    isLast = (newId === oldId);
                }
    
                // Return
                return isLast;
            };
    
            /**
             * History.saveState
             * Push a State
             * @param {Object} newState
             * @return {boolean} changed
             */
            History.saveState = function(newState){
                // Check Hash
                if ( History.isLastSavedState(newState) ) {
                    return false;
                }
    
                // Push the State
                History.savedStates.push(History.cloneObject(newState));
    
                // Return true
                return true;
            };
    
            /**
             * History.getStateByIndex()
             * Gets a state by the index
             * @param {integer} index
             * @return {Object}
             */
            History.getStateByIndex = function(index){
                // Prepare
                var State = null;
    
                // Handle
                if ( typeof index === 'undefined' ) {
                    // Get the last inserted
                    State = History.savedStates[History.savedStates.length-1];
                }
                else if ( index < 0 ) {
                    // Get from the end
                    State = History.savedStates[History.savedStates.length+index];
                }
                else {
                    // Get from the beginning
                    State = History.savedStates[index];
                }
    
                // Return State
                return State;
            };
            
            /**
             * History.getCurrentIndex()
             * Gets the current index
             * @return (integer)
            */
            History.getCurrentIndex = function(){
                // Prepare
                var index = null;
                
                // No states saved
                if(History.savedStates.length < 1) {
                    index = 0;
                }
                else {
                    index = History.savedStates.length-1;
                }
                return index;
            };
    
            // ====================================================================
            // Hash Helpers
    
            /**
             * History.getHash()
             * @param {Location=} location
             * Gets the current document hash
             * Note: unlike location.hash, this is guaranteed to return the escaped hash in all browsers
             * @return {string}
             */
            History.getHash = function(doc){
                var url = History.getLocationHref(doc),
                    hash;
                hash = History.getHashByUrl(url);
                return hash;
            };
    
            /**
             * History.unescapeHash()
             * normalize and Unescape a Hash
             * @param {String} hash
             * @return {string}
             */
            History.unescapeHash = function(hash){
                // Prepare
                var result = History.normalizeHash(hash);
    
                // Unescape hash
                result = decodeURIComponent(result);
    
                // Return result
                return result;
            };
    
            /**
             * History.normalizeHash()
             * normalize a hash across browsers
             * @return {string}
             */
            History.normalizeHash = function(hash){
                // Prepare
                var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');
    
                // Return result
                return result;
            };
    
            /**
             * History.setHash(hash)
             * Sets the document hash
             * @param {string} hash
             * @return {History}
             */
            History.setHash = function(hash,queue){
                // Prepare
                var State, pageUrl;
    
                // Handle Queueing
                if ( queue !== false && History.busy() ) {
                    // Wait + Push to Queue
                    //History.debug('History.setHash: we must wait', arguments);
                    History.pushQueue({
                        scope: History,
                        callback: History.setHash,
                        args: arguments,
                        queue: queue
                    });
                    return false;
                }
    
                // Log
                //History.debug('History.setHash: called',hash);
    
                // Make Busy + Continue
                History.busy(true);
    
                // Check if hash is a state
                State = History.extractState(hash,true);
                if ( State && !History.emulated.pushState ) {
                    // Hash is a state so skip the setHash
                    //History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);
    
                    // PushState
                    History.pushState(State.data,State.title,State.url,false);
                }
                else if ( History.getHash() !== hash ) {
                    // Hash is a proper hash, so apply it
    
                    // Handle browser bugs
                    if ( History.bugs.setHash ) {
                        // Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249
    
                        // Fetch the base page
                        pageUrl = History.getPageUrl();
    
                        // Safari hash apply
                        History.pushState(null,null,pageUrl+'#'+hash,false);
                    }
                    else {
                        // Normal hash apply
                        document.location.hash = hash;
                    }
                }
    
                // Chain
                return History;
            };
    
            /**
             * History.escape()
             * normalize and Escape a Hash
             * @return {string}
             */
            History.escapeHash = function(hash){
                // Prepare
                var result = History.normalizeHash(hash);
    
                // Escape hash
                result = window.encodeURIComponent(result);
    
                // IE6 Escape Bug
                if ( !History.bugs.hashEscape ) {
                    // Restore common parts
                    result = result
                        .replace(/\%21/g,'!')
                        .replace(/\%26/g,'&')
                        .replace(/\%3D/g,'=')
                        .replace(/\%3F/g,'?');
                }
    
                // Return result
                return result;
            };
    
            /**
             * History.getHashByUrl(url)
             * Extracts the Hash from a URL
             * @param {string} url
             * @return {string} url
             */
            History.getHashByUrl = function(url){
                // Extract the hash
                var hash = String(url)
                    .replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
                    ;
    
                // Unescape hash
                hash = History.unescapeHash(hash);
    
                // Return hash
                return hash;
            };
    
            /**
             * History.setTitle(title)
             * Applies the title to the document
             * @param {State} newState
             * @return {Boolean}
             */
            History.setTitle = function(newState){
                // Prepare
                var title = newState.title,
                    firstState;
    
                // Initial
                if ( !title ) {
                    firstState = History.getStateByIndex(0);
                    if ( firstState && firstState.url === newState.url ) {
                        title = firstState.title||History.options.initialTitle;
                    }
                }
    
                // Apply
                try {
                    document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
                }
                catch ( Exception ) { }
                document.title = title;
    
                // Chain
                return History;
            };
    
    
            // ====================================================================
            // Queueing
    
            /**
             * History.queues
             * The list of queues to use
             * First In, First Out
             */
            History.queues = [];
    
            /**
             * History.busy(value)
             * @param {boolean} value [optional]
             * @return {boolean} busy
             */
            History.busy = function(value){
                // Apply
                if ( typeof value !== 'undefined' ) {
                    //History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
                    History.busy.flag = value;
                }
                // Default
                else if ( typeof History.busy.flag === 'undefined' ) {
                    History.busy.flag = false;
                }
    
                // Queue
                if ( !History.busy.flag ) {
                    // Execute the next item in the queue
                    clearTimeout(History.busy.timeout);
                    var fireNext = function(){
                        var i, queue, item;
                        if ( History.busy.flag ) return;
                        for ( i=History.queues.length-1; i >= 0; --i ) {
                            queue = History.queues[i];
                            if ( queue.length === 0 ) continue;
                            item = queue.shift();
                            History.fireQueueItem(item);
                            History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
                        }
                    };
                    History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
                }
    
                // Return
                return History.busy.flag;
            };
    
            /**
             * History.busy.flag
             */
            History.busy.flag = false;
    
            /**
             * History.fireQueueItem(item)
             * Fire a Queue Item
             * @param {Object} item
             * @return {Mixed} result
             */
            History.fireQueueItem = function(item){
                return item.callback.apply(item.scope||History,item.args||[]);
            };
    
            /**
             * History.pushQueue(callback,args)
             * Add an item to the queue
             * @param {Object} item [scope,callback,args,queue]
             */
            History.pushQueue = function(item){
                // Prepare the queue
                History.queues[item.queue||0] = History.queues[item.queue||0]||[];
    
                // Add to the queue
                History.queues[item.queue||0].push(item);
    
                // Chain
                return History;
            };
    
            /**
             * History.queue (item,queue), (func,queue), (func), (item)
             * Either firs the item now if not busy, or adds it to the queue
             */
            History.queue = function(item,queue){
                // Prepare
                if ( typeof item === 'function' ) {
                    item = {
                        callback: item
                    };
                }
                if ( typeof queue !== 'undefined' ) {
                    item.queue = queue;
                }
    
                // Handle
                if ( History.busy() ) {
                    History.pushQueue(item);
                } else {
                    History.fireQueueItem(item);
                }
    
                // Chain
                return History;
            };
    
            /**
             * History.clearQueue()
             * Clears the Queue
             */
            History.clearQueue = function(){
                History.busy.flag = false;
                History.queues = [];
                return History;
            };
    
    
            // ====================================================================
            // IE Bug Fix
    
            /**
             * History.stateChanged
             * States whether or not the state has changed since the last double check was initialised
             */
            History.stateChanged = false;
    
            /**
             * History.doubleChecker
             * Contains the timeout used for the double checks
             */
            History.doubleChecker = false;
    
            /**
             * History.doubleCheckComplete()
             * Complete a double check
             * @return {History}
             */
            History.doubleCheckComplete = function(){
                // Update
                History.stateChanged = true;
    
                // Clear
                History.doubleCheckClear();
    
                // Chain
                return History;
            };
    
            /**
             * History.doubleCheckClear()
             * Clear a double check
             * @return {History}
             */
            History.doubleCheckClear = function(){
                // Clear
                if ( History.doubleChecker ) {
                    clearTimeout(History.doubleChecker);
                    History.doubleChecker = false;
                }
    
                // Chain
                return History;
            };
    
            /**
             * History.doubleCheck()
             * Create a double check
             * @return {History}
             */
            History.doubleCheck = function(tryAgain){
                // Reset
                History.stateChanged = false;
                History.doubleCheckClear();
    
                // Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
                // Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
                if ( History.bugs.ieDoubleCheck ) {
                    // Apply Check
                    History.doubleChecker = setTimeout(
                        function(){
                            History.doubleCheckClear();
                            if ( !History.stateChanged ) {
                                //History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
                                // Re-Attempt
                                tryAgain();
                            }
                            return true;
                        },
                        History.options.doubleCheckInterval
                    );
                }
    
                // Chain
                return History;
            };
    
    
            // ====================================================================
            // Safari Bug Fix
    
            /**
             * History.safariStatePoll()
             * Poll the current state
             * @return {History}
             */
            History.safariStatePoll = function(){
                // Poll the URL
    
                // Get the Last State which has the new URL
                var
                    urlState = History.extractState(History.getLocationHref()),
                    newState;
    
                // Check for a difference
                if ( !History.isLastSavedState(urlState) ) {
                    newState = urlState;
                }
                else {
                    return;
                }
    
                // Check if we have a state with that url
                // If not create it
                if ( !newState ) {
                    //History.debug('History.safariStatePoll: new');
                    newState = History.createStateObject();
                }
    
                // Apply the New State
                //History.debug('History.safariStatePoll: trigger');
                History.Adapter.trigger(window,'popstate');
    
                // Chain
                return History;
            };
    
    
            // ====================================================================
            // State Aliases
    
            /**
             * History.back(queue)
             * Send the browser history back one item
             * @param {Integer} queue [optional]
             */
            History.back = function(queue){
                //History.debug('History.back: called', arguments);
    
                // Handle Queueing
                if ( queue !== false && History.busy() ) {
                    // Wait + Push to Queue
                    //History.debug('History.back: we must wait', arguments);
                    History.pushQueue({
                        scope: History,
                        callback: History.back,
                        args: arguments,
                        queue: queue
                    });
                    return false;
                }
    
                // Make Busy + Continue
                History.busy(true);
    
                // Fix certain browser bugs that prevent the state from changing
                History.doubleCheck(function(){
                    History.back(false);
                });
    
                // Go back
                history.go(-1);
    
                // End back closure
                return true;
            };
    
            /**
             * History.forward(queue)
             * Send the browser history forward one item
             * @param {Integer} queue [optional]
             */
            History.forward = function(queue){
                //History.debug('History.forward: called', arguments);
    
                // Handle Queueing
                if ( queue !== false && History.busy() ) {
                    // Wait + Push to Queue
                    //History.debug('History.forward: we must wait', arguments);
                    History.pushQueue({
                        scope: History,
                        callback: History.forward,
                        args: arguments,
                        queue: queue
                    });
                    return false;
                }
    
                // Make Busy + Continue
                History.busy(true);
    
                // Fix certain browser bugs that prevent the state from changing
                History.doubleCheck(function(){
                    History.forward(false);
                });
    
                // Go forward
                history.go(1);
    
                // End forward closure
                return true;
            };
    
            /**
             * History.go(index,queue)
             * Send the browser history back or forward index times
             * @param {Integer} queue [optional]
             */
            History.go = function(index,queue){
                //History.debug('History.go: called', arguments);
    
                // Prepare
                var i;
    
                // Handle
                if ( index > 0 ) {
                    // Forward
                    for ( i=1; i<=index; ++i ) {
                        History.forward(queue);
                    }
                }
                else if ( index < 0 ) {
                    // Backward
                    for ( i=-1; i>=index; --i ) {
                        History.back(queue);
                    }
                }
                else {
                    throw new Error('History.go: History.go requires a positive or negative integer passed.');
                }
    
                // Chain
                return History;
            };
    
    
            // ====================================================================
            // HTML5 State Support
    
            // Non-Native pushState Implementation
            if ( History.emulated.pushState ) {
                /*
                 * Provide Skeleton for HTML4 Browsers
                 */
    
                // Prepare
                var emptyFunction = function(){};
                History.pushState = History.pushState||emptyFunction;
                History.replaceState = History.replaceState||emptyFunction;
            } // History.emulated.pushState
    
            // Native pushState Implementation
            else {
                /*
                 * Use native HTML5 History API Implementation
                 */
    
                /**
                 * History.onPopState(event,extra)
                 * Refresh the Current State
                 */
                History.onPopState = function(event,extra){
                    // Prepare
                    var stateId = false, newState = false, currentHash, currentState;
    
                    // Reset the double check
                    History.doubleCheckComplete();
    
                    // Check for a Hash, and handle apporiatly
                    currentHash = History.getHash();
                    if ( currentHash ) {
                        // Expand Hash
                        currentState = History.extractState(currentHash||History.getLocationHref(),true);
                        if ( currentState ) {
                            // We were able to parse it, it must be a State!
                            // Let's forward to replaceState
                            //History.debug('History.onPopState: state anchor', currentHash, currentState);
                            History.replaceState(currentState.data, currentState.title, currentState.url, false);
                        }
                        else {
                            // Traditional Anchor
                            //History.debug('History.onPopState: traditional anchor', currentHash);
                            History.Adapter.trigger(window,'anchorchange');
                            History.busy(false);
                        }
    
                        // We don't care for hashes
                        History.expectedStateId = false;
                        return false;
                    }
    
                    // Ensure
                    stateId = History.Adapter.extractEventData('state',event,extra) || false;
    
                    // Fetch State
                    if ( stateId ) {
                        // Vanilla: Back/forward button was used
                        newState = History.getStateById(stateId);
                    }
                    else if ( History.expectedStateId ) {
                        // Vanilla: A new state was pushed, and popstate was called manually
                        newState = History.getStateById(History.expectedStateId);
                    }
                    else {
                        // Initial State
                        newState = History.extractState(History.getLocationHref());
                    }
    
                    // The State did not exist in our store
                    if ( !newState ) {
                        // Regenerate the State
                        newState = History.createStateObject(null,null,History.getLocationHref());
                    }
    
                    // Clean
                    History.expectedStateId = false;
    
                    // Check if we are the same state
                    if ( History.isLastSavedState(newState) ) {
                        // There has been no change (just the page's hash has finally propagated)
                        //History.debug('History.onPopState: no change', newState, History.savedStates);
                        History.busy(false);
                        return false;
                    }
    
                    // Store the State
                    History.storeState(newState);
                    History.saveState(newState);
    
                    // Force update of the title
                    History.setTitle(newState);
    
                    // Fire Our Event
                    History.Adapter.trigger(window,'statechange');
                    History.busy(false);
    
                    // Return true
                    return true;
                };
                History.Adapter.bind(window,'popstate',History.onPopState);
    
                /**
                 * History.pushState(data,title,url)
                 * Add a new State to the history object, become it, and trigger onpopstate
                 * We have to trigger for HTML4 compatibility
                 * @param {object} data
                 * @param {string} title
                 * @param {string} url
                 * @return {true}
                 */
                History.pushState = function(data,title,url,queue){
                    //History.debug('History.pushState: called', arguments);
    
                    // Check the State
                    if ( History.getHashByUrl(url) && History.emulated.pushState ) {
                        throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
                    }
    
                    // Handle Queueing
                    if ( queue !== false && History.busy() ) {
                        // Wait + Push to Queue
                        //History.debug('History.pushState: we must wait', arguments);
                        History.pushQueue({
                            scope: History,
                            callback: History.pushState,
                            args: arguments,
                            queue: queue
                        });
                        return false;
                    }
    
                    // Make Busy + Continue
                    History.busy(true);
    
                    // Create the newState
                    var newState = History.createStateObject(data,title,url);
    
                    // Check it
                    if ( History.isLastSavedState(newState) ) {
                        // Won't be a change
                        History.busy(false);
                    }
                    else {
                        // Store the newState
                        History.storeState(newState);
                        History.expectedStateId = newState.id;
    
                        // Push the newState
                        history.pushState(newState.id,newState.title,newState.url);
    
                        // Fire HTML5 Event
                        History.Adapter.trigger(window,'popstate');
                    }
    
                    // End pushState closure
                    return true;
                };
    
                /**
                 * History.replaceState(data,title,url)
                 * Replace the State and trigger onpopstate
                 * We have to trigger for HTML4 compatibility
                 * @param {object} data
                 * @param {string} title
                 * @param {string} url
                 * @return {true}
                 */
                History.replaceState = function(data,title,url,queue){
                    //History.debug('History.replaceState: called', arguments);
    
                    // Check the State
                    if ( History.getHashByUrl(url) && History.emulated.pushState ) {
                        throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
                    }
    
                    // Handle Queueing
                    if ( queue !== false && History.busy() ) {
                        // Wait + Push to Queue
                        //History.debug('History.replaceState: we must wait', arguments);
                        History.pushQueue({
                            scope: History,
                            callback: History.replaceState,
                            args: arguments,
                            queue: queue
                        });
                        return false;
                    }
    
                    // Make Busy + Continue
                    History.busy(true);
    
                    // Create the newState
                    var newState = History.createStateObject(data,title,url);
    
                    // Check it
                    if ( History.isLastSavedState(newState) ) {
                        // Won't be a change
                        History.busy(false);
                    }
                    else {
                        // Store the newState
                        History.storeState(newState);
                        History.expectedStateId = newState.id;
    
                        // Push the newState
                        history.replaceState(newState.id,newState.title,newState.url);
    
                        // Fire HTML5 Event
                        History.Adapter.trigger(window,'popstate');
                    }
    
                    // End replaceState closure
                    return true;
                };
    
            } // !History.emulated.pushState
    
    
            // ====================================================================
            // Initialise
    
            /**
             * Load the Store
             */
            if ( sessionStorage ) {
                // Fetch
                try {
                    History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
                }
                catch ( err ) {
                    History.store = {};
                }
    
                // Normalize
                History.normalizeStore();
            }
            else {
                // Default Load
                History.store = {};
                History.normalizeStore();
            }
    
            /**
             * Clear Intervals on exit to prevent memory leaks
             */
            History.Adapter.bind(window,"unload",History.clearAllIntervals);
    
            /**
             * Create the initial State
             */
            History.saveState(History.storeState(History.extractState(History.getLocationHref(),true)));
    
            /**
             * Bind for Saving Store
             */
            if ( sessionStorage ) {
                // When the page is closed
                History.onUnload = function(){
                    // Prepare
                    var	currentStore, item, currentStoreString;
    
                    // Fetch
                    try {
                        currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
                    }
                    catch ( err ) {
                        currentStore = {};
                    }
    
                    // Ensure
                    currentStore.idToState = currentStore.idToState || {};
                    currentStore.urlToId = currentStore.urlToId || {};
                    currentStore.stateToId = currentStore.stateToId || {};
    
                    // Sync
                    for ( item in History.idToState ) {
                        if ( !History.idToState.hasOwnProperty(item) ) {
                            continue;
                        }
                        currentStore.idToState[item] = History.idToState[item];
                    }
                    for ( item in History.urlToId ) {
                        if ( !History.urlToId.hasOwnProperty(item) ) {
                            continue;
                        }
                        currentStore.urlToId[item] = History.urlToId[item];
                    }
                    for ( item in History.stateToId ) {
                        if ( !History.stateToId.hasOwnProperty(item) ) {
                            continue;
                        }
                        currentStore.stateToId[item] = History.stateToId[item];
                    }
    
                    // Update
                    History.store = currentStore;
                    History.normalizeStore();
    
                    // In Safari, going into Private Browsing mode causes the
                    // Session Storage object to still exist but if you try and use
                    // or set any property/function of it it throws the exception
                    // "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to
                    // add something to storage that exceeded the quota." infinitely
                    // every second.
                    currentStoreString = JSON.stringify(currentStore);
                    try {
                        // Store
                        sessionStorage.setItem('History.store', currentStoreString);
                    }
                    catch (e) {
                        if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {
                            if (sessionStorage.length) {
                                // Workaround for a bug seen on iPads. Sometimes the quota exceeded error comes up and simply
                                // removing/resetting the storage can work.
                                sessionStorage.removeItem('History.store');
                                sessionStorage.setItem('History.store', currentStoreString);
                            } else {
                                // Otherwise, we're probably private browsing in Safari, so we'll ignore the exception.
                            }
                        } else {
                            throw e;
                        }
                    }
                };
    
                // For Internet Explorer
                History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));
    
                // For Other Browsers
                History.Adapter.bind(window,'beforeunload',History.onUnload);
                History.Adapter.bind(window,'unload',History.onUnload);
    
                // Both are enabled for consistency
            }
    
            // Non-Native pushState Implementation
            if ( !History.emulated.pushState ) {
                // Be aware, the following is only for native pushState implementations
                // If you are wanting to include something for all browsers
                // Then include it above this if block
    
                /**
                 * Setup Safari Fix
                 */
                if ( History.bugs.safariPoll ) {
                    History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
                }
    
                /**
                 * Ensure Cross Browser Compatibility
                 */
                if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
                    /**
                     * Fix Safari HashChange Issue
                     */
    
                    // Setup Alias
                    History.Adapter.bind(window,'hashchange',function(){
                        History.Adapter.trigger(window,'popstate');
                    });
    
                    // Initialise Alias
                    if ( History.getHash() ) {
                        History.Adapter.onDomLoad(function(){
                            History.Adapter.trigger(window,'hashchange');
                        });
                    }
                }
    
            } // !History.emulated.pushState
    
    
        }; // History.initCore
    
        // Try to Initialise History
        if (!History.options || !History.options.delayInit) {
            History.init();
        }
    })(window);
}


/** Provides support for Object.keys in IE8 and earlier.
    Taken from: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation */
Object.keys = Object.keys || (function() {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !{toString:null}.propertyIsEnumerable("toString"),
        DontEnums = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor'
        ],
        DontEnumsLength = DontEnums.length;
    
    return function(o) {
        if (typeof o !== "object" && typeof o !== "function" || o === null)
            throw new TypeError("Object.keys called on non-object");
        
        var result = [], n;
        for (n in o) {
            if (hasOwnProperty.call(o, n)) result.push(n);
        }
        
        if (hasDontEnumBug) {
            for (var i = 0; i < DontEnumsLength; ++i) {
                if (hasOwnProperty.call(o, DontEnums[i])) result.push(DontEnums[i]);
            }
        }
        
        return result
    }
})();

/** Provides support for Array.isArray in IE8 and earlier.
    Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray */
Array.isArray = Array.isArray || function(v) {
    return Object.prototype.toString.call(v) === "[object Array]"
};

/** Provides support for Date.now in IE8 and ealier.
    Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now */
Date.now = Date.now || function() {
    return new Date().getTime()
};

/** Provides support for String.trim in IE8 and earlier.
    Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim */
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g,'')
    };
    String.prototype.trimLeft = function() {
        return this.replace(/^\s+/,'')
    };
    String.prototype.trimRight = function() {
        return this.replace(/\s+$/,'')
    };
}


JS = {
  extend: function(destination, source, overwrite) {
    if (destination && source) {
      for (var field in source) {
        if (destination[field] !== source[field] && (overwrite || !destination.hasOwnProperty(field))) {
          destination[field] = source[field];
        }
      }
    }
    return destination;
  },
  
  makeClass: function(parent) {
    var constructor = function() {
      var init = this.initialize;
      return init ? init.apply(this, arguments) || this : this;
    };
    
    var bridge = function() {};
    bridge.prototype = (parent || Object).prototype;
    constructor.prototype = new bridge();
    
    return constructor;
  }
};

JS.Method = JS.makeClass();
JS.extend(JS.Method.prototype, {
  initialize: function(module, name, callable) {
    this.module = module;
    this.name = name;
    this.callable = callable;
    this._hasSuper = typeof callable === 'function' && callable.toString().indexOf('callSuper') !== -1;
  },

  call: function() {
    return this.callable.call.apply(this.callable, arguments);
  },

  apply: function(receiver, args) {
    return this.callable.apply(receiver, args);
  },

  compile: function(environment) {
    var method = this,
        callable = method.callable,
        keywordCallSuper = JS.Method.keywordCallSuper,
        superFunc = method._hasSuper && keywordCallSuper ? keywordCallSuper : null;
    
    return superFunc === null ? callable : function() {
      var prevValue, prevOwn, 
        existing = this.callSuper,
        doSuper = !existing || existing.__kwd__;
      
      if (doSuper) {
        prevValue = existing;
        prevOwn = this.hasOwnProperty('callSuper');
        var kwd = this.callSuper = superFunc(method, environment, this, arguments);
        if (kwd) kwd.__kwd__ = true;
      }
      
      var returnValue = callable.apply(this, arguments);
      
      if (doSuper) {
        if (prevOwn) {
          this.callSuper = prevValue;
        } else {
          delete this.callSuper;
        }
      }
      
      return returnValue;
    };
  }
});

JS.Method.create = function(module, name, callable) {
  return (callable && callable.__inc__ && callable.__fns__) || typeof callable !== 'function' ? callable : new this(module, name, callable);
};

JS.Method.compile = function(method, environment) {
  return method instanceof this ? method.compile(environment) : method;
};

JS.Module = JS.makeClass();
JS.extend(JS.Module.prototype, {
  initialize: function(name, methods, options) {
    this.__inc__ = [];
    this.__dep__ = [];
    this.__fns__ = {};
    this.__tgt__ = (options || {})._target;
    this.__anc__ = null;
    this.__mct__ = {};
    
    this.include(methods, {_resolve:false});
  },

  /** Adds a single named method to a JS.Class/JS.Module. If youre modifying 
      a class, the method instantly becomes available in instances of the 
      class, and in its subclasses.
      @param name:string The name of the method to add.
      @param callable:function The method implementation.
      @param options:object (optional)
      @returns void */
  define: function(name, callable, options) {
    this.__fns__[name] = JS.Method.create(this, name, callable);
    if ((options || {})._resolve !== false) this.resolve();
  },

  /** Mixes in a module to this module.
      @param module:JS.Module The module to mix in.
      @param options:object (optional)
      @returns JS.Module this module. */
  include: function(module, options) {
    if (module) {
      options = options || {};
      var extend  = module.extend,
          include = module.include,
          extended, field, value, mixins, i, n, resolveFalse;
      
      if (module.__fns__ && module.__inc__) {
        this.__inc__.push(module);
        module.__dep__.push(this);
        
        if (extended = options._extended) {
          if (typeof module.extended === 'function') module.extended(extended);
        } else {
          if (typeof module.included === 'function') module.included(this);
        }
      } else {
        resolveFalse = {_resolve:false};
        if (this._ignore(extend)) {
          mixins = [].concat(extend);
          for (i = 0, n = mixins.length; i < n;) this.extend(mixins[i++]);
        }
        if (this._ignore(include)) {
          mixins = [].concat(include);
          for (i = 0, n = mixins.length; i < n;) this.include(mixins[i++], resolveFalse);
        }
        for (field in module) {
          if (module.hasOwnProperty(field)) {
            value = module[field];
            if ((field === 'extend' || field === 'include') && this._ignore(value)) continue;
            this.define(field, value, resolveFalse);
          }
        }
      }
      
      if (options._resolve !== false) this.resolve();
    }
    return this;
  },

  /** @private */
  _ignore: function(value) {
    return typeof value !== 'function' || (value.__fns__ && value.__inc__);
  },

  resolve: function(host) {
    host = host || this;
    var target = host.__tgt__,
        inc = this.__inc__,
        fns = this.__fns__,
        i, n, key, compiled;
    
    if (host === this) {
      this.__anc__ = null;
      this.__mct__ = {};
      i = this.__dep__.length;
      while (i) this.__dep__[--i].resolve();
    }

    if (target) {
      for (i = 0, n = inc.length; i < n;) inc[i++].resolve(host);
      
      for (key in fns) {
        compiled = JS.Method.compile(fns[key], host);
        if (target[key] !== compiled) target[key] = compiled;
      }
    }
  },

  /** Gets the ancestor classes array.
      @param list:array (optional) An array of ancestors that will have
        ancestor classes pushed onto. If not provided a new array will
        be created.
      @return array */
  ancestors: function(list) {
    var cachable = !list,
        inc = this.__inc__;
    list = list || [];
    
    if (cachable && this.__anc__) return this.__anc__.slice();
    
    for (var i = 0, n = inc.length; i < n;) inc[i++].ancestors(list);
    
    if (list.indexOf(this) < 0) list.push(this);
    
    if (cachable) this.__anc__ = list.slice();
    return list;
  },

  /** Gets an array of JS.Methods for the provided method name.
      @param name:string The name of the method to lookup.
      @return array An array of JS.Methods from the ancestors chain. */
  lookup: function(name) {
    var cached = this.__mct__[name];
    if (cached) return cached.slice();
    
    var ancestors = this.ancestors(), 
      n = ancestors.length,
      methods = [], fns, i = 0;
    for (; i < n;) {
      fns = ancestors[i++].__fns__;
      if (fns.hasOwnProperty(name)) methods.push(fns[name]);
    }
    this.__mct__[name] = methods.slice();
    return methods;
  },

  /** Checks if this module includes the provided module.
      @param module:JS.Module The module to check for.
      @return boolean True if the module is included, otherwise false. */
  includes: function(module) {
    if (module === this) return true;
    
    var inc = this.__inc__, n = inc.length, i = 0;
    for (; i < n;) {
      if (inc[i++].includes(module)) return true;
    }
    return false;
  },

  /** Extracts a single named method from a module.
      @param name:string The name of the method to extract.
      @return JS.Method The extracted method. */
  instanceMethod: function(name) {
    return this.lookup(name).pop();
  }
});

JS.Kernel = new JS.Module('Kernel', {
  __eigen__: function() {
    var meta = this.__meta__;
    if (meta) return meta;
    meta = this.__meta__ = new JS.Module('', null, {_target: this});
    return meta.include(this.klass, {_resolve: false});
  },

  equals: function(other) {
    return this === other;
  },

  extend: function(module, options) {
    if (module) this.__eigen__().include(module, {_extended:this, _resolve:(options || {})._resolve});
    return this;
  },

  /** Checks if this object includes, extends or is the provided module.
      @param module:JS.Module The module to check for.
      @return boolean */
  isA: function(module) {
    return (typeof module === 'function' && this instanceof module) || this.__eigen__().includes(module);
  },

  method: function(name) {
    var cache = this.__mct__ || (this.__mct__ = {}),
        value = cache[name],
        field = this[name];
    
    if (typeof field !== 'function') return field;
    if (value && field === value._value) return value._bound;
    
    var bound = field.bind(this);
    cache[name] = {_value:field, _bound:bound};
    return bound;
  }
});

JS.Class = JS.makeClass(JS.Module);
JS.extend(JS.Class.prototype, {
  initialize: function(name, parent, methods, options) {
    if (typeof parent !== 'function') {
      options = methods;
      methods = parent;
      parent  = Object;
    }
    
    JS.Module.prototype.initialize.call(this);
    
    var resolve = (options || {})._resolve,
      resolveFalse = {_resolve:false},
      klass = JS.makeClass(parent);
    klass.__displayName = name;
    JS.extend(klass, this);
    klass.prototype.constructor = klass.prototype.klass = klass;
    klass.__eigen__().include(parent.__meta__, {_resolve:resolve});
    klass.__tgt__ = klass.prototype;
    
    var parentModule = parent === Object ? {} : (parent.__fns__ ? parent : new JS.Module(parent.prototype, resolveFalse));
    klass.include(JS.Kernel, resolveFalse).include(parentModule, resolveFalse).include(methods, resolveFalse);
     
    if (resolve !== false) klass.resolve();
    if (typeof parent.inherited === 'function') parent.inherited(klass);
    
    return klass;
  }
});

(function() {
  var JS_METHOD = JS.Method, JS_KERNEL = JS.Kernel, 
    JS_CLASS = JS.Class, JS_MODULE = JS.Module,
    classify = function(klass, parent) {
      klass.__inc__ = [];
      klass.__dep__ = [];
      var proto = klass.prototype,
        methods = {}, 
        field;
      for (field in proto) {
        if (proto.hasOwnProperty(field)) methods[field] = JS_METHOD.create(klass, field, proto[field]);
      }
      klass.__fns__ = methods;
      klass.__tgt__ = proto;
      
      proto.constructor = proto.klass = klass;
      
      JS.extend(klass, JS_CLASS.prototype);
      klass.include(parent);
      
      klass.constructor = klass.klass = JS_CLASS;
    };
  classify(JS_METHOD, JS_KERNEL);
  classify(JS_MODULE, JS_KERNEL);
  classify(JS_CLASS,  JS_MODULE);
  
  var eigen = JS_KERNEL.instanceMethod('__eigen__');
  eigen.call(JS_METHOD).resolve();
  eigen.call(JS_MODULE).resolve();
  eigen.call(JS_CLASS).include(JS_MODULE.__meta__);
})();

// Must come after classification.
JS.Method.keywordCallSuper = function(method, env, receiver, args) {
  var methods = env.lookup(method.name),
      stackIndex = methods.length - 1,
      params = Array.prototype.slice.call(args);
  
  if (stackIndex === 0) return undefined;
  
  var _super = function() {
    var i = arguments.length;
    while (i) params[--i] = arguments[i];
    
    stackIndex--;
    if (stackIndex === 0) delete receiver.callSuper;
    var returnValue = methods[stackIndex].apply(receiver, params);
    receiver.callSuper = _super;
    stackIndex++;
    
    return returnValue;
  };
  
  return _super;
};

/** Create a single instance of a "private" class. */
JS.Singleton = new JS.Class('Singleton', {
  initialize: function(name, parent, methods) {
    return new (new JS.Class(name, parent, methods));
  }
});

/**
 * Myt: A simple javascript UI framework
 * http://github.com/maynarddemmon/myt
 * Copyright (c) 2012-2014 Maynard Demmon and contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * Parts of the Software incorporates code and/or design patterns from various
 * public domain sources and has been noted as such in the source.
 * 
 * Parts of the Software incorporates code from the following open-source 
 * projects:
 * * JS.Class, (c) 2007-2012 James Coglan and contributors (MIT License)
 * * Easing Functions, (c) 2001 Robert Penner (BSD License)
 * * jQuery Easing v1.3, (c) 2008 George McGinley Smith (BSD License)
 * * jQuery Cookie Plugin v1.3.1, (c) 2013 Klaus Hartl (MIT License)
 * * parseUri 1.2.2, (c) Steven Levithan <stevenlevithan.com> (MIT License)
 * * Spin.js 1.3.0 (c) 2011-2013 Felix Gnass (the MIT license)
 * * k-d Tree JavaScript - v1.0 (c) Mircea Pricop <pricop@ubilabs.net>,
 *                                  Martin Kleppe <kleppe@ubilabs.net>,
 *                                  Ubilabs http://ubilabs.net (MIT License)
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
myt = {
    /** The root path to image assets for the myt package. MYT_IMAGE_ROOT
        should be set by the page that includes this script. */
    IMAGE_ROOT: global.MYT_IMAGE_ROOT || '',
    
    /** Used to generate globally unique IDs. */
    __GUID_COUNTER: 0,
    
    /** Generates a globally unique id, (GUID).
        @return number */
    generateGuid: function() {
        return ++this.__GUID_COUNTER;
    },
    
    /** Event listener code Adapted from:
            http://javascript.about.com/library/bllisten.htm
        A more robust solution can be found here:
            http://msdn.microsoft.com/en-us/magazine/ff728624.aspx */
    addEventListener: function() {
        if (window.addEventListener) {
            /** Adds an event listener to a dom element. 
                @param elem:DomElement the dom element to listen to.
                @param type:string the name of the event to listen to.
                @param callback:function the callback function that will be
                    registered for the event.
                @param capture:boolean (optional) indicates if the listener is 
                    registered during the capture phase or bubble phase.
                @returns void */
            return function(elem, type, callback, capture) {
                elem.addEventListener(type, callback, capture || false);
            };
        } else {
            return function(elem, type, callback) {
                var prop = type + callback;
                elem['e' + prop] = callback;
                elem[prop] = function(){elem['e' + prop](window.event);}
                elem.attachEvent('on' + type, elem[prop]);
            };
        }
    }(),
    removeEventListener: function() {
        if (window.addEventListener) {
            return function(elem, type, callback, capture) {
                elem.removeEventListener(type, callback, capture || false);
            };
        } else {
            return function(elem, type, callback) {
                var prop = type + callback;
                elem.detachEvent('on' + type, elem[prop]);
                elem[prop] = null;
                elem["e" + prop] = null;
            };
        }
    }(),
    
    /** Takes a '.' separated string such as "foo.bar.baz" and resolves it
        into the value found at that location relative to a starting scope.
        If no scope is provided global scope is used.
        @param objName:string|array The name to resolve or an array of path
            parts in descending order.
        @param scope:Object (optional) The scope to resolve from. If not
            provided global scope is used.
        @returns The referenced object or undefined if resolution failed. */
    resolveName: function(objName, scope) {
        if (!objName || objName.length === 0) return undefined;
        
        var scope = scope || global,
            parts = Array.isArray(objName) ? objName : objName.split("."),
            i = 0, len = parts.length;
        for (; i < len; ++i) {
            scope = scope[parts[i]];
            if (!scope) {
                console.warn("resolveName failed for:", objName, "at part:", i, parts[i]);
                return undefined;
            }
        }
        return scope;
    },
    
    // Text Templating
    /** Populates a text "template" with 1 or more arguments. The
        template consists of a string with text interspersed with 
        curly-braced indices. The arguments are replaced in order one at
        a time into the template. For example:
        
            myt.fillTextTemplate("{0}/{2}/{1} hey {0}", 1, 2, 3) 
            will return "1/3/2 hey 1".
        
        @param (first arg):string The template to use.
        @param (remaining args):(coerced to string) The parameters for the
            template.
        @returns A populated string. */
    fillTextTemplate: function() {
        var params = Array.prototype.slice.call(arguments),
            template = params.shift();
        
        if (template == null) return '';
        
        var param, i = 0, len = params.length;
        for (; len > i; ++i) {
            param = params[i];
            template = template.split("{" + i + "}").join(param == null ? '' : param);
        }
        return template;
    },
    
    /** Generates the text for an "a href" html element that when clicked on
        executes a provided callback method name. To resolve the callback
        method name, an ancestor search is performed on the dom starting with
        the link element. The first myt managed dom element encountered is
        used as the scope for the method.
        @param text:string the text to put inside the link.
        @param callbackMethodName:string the name of the method to execute.
        @param attrs:object (optional) a map of additional attributes that
            will be inserted into the tag.
        @param data:object (optional) Data that will be serialized as JSON
            and provided to the link handler.
        @returns void */
    generateLink: function(text, callbackMethodName, attrs, data) {
        var optAttrs = '';
        if (attrs) {
            for (var name in attrs) optAttrs += ' ' + name + '="' + attrs[name] + '"';
        }
        
        return this.fillTextTemplate(
            '<a href="#" onclick=\'myt.__handleGeneratedLink(this, "{0}", &apos;{3}&apos;); return false;\'{2}>{1}</a>', 
            callbackMethodName, text, optAttrs, JSON.stringify(data)
        );
    },
    
    /** See myt.generateLink for documentation.
        @private
        @returns void */
    __handleGeneratedLink: function(elem, callbackMethodName, data) {
        var model;
        while (elem) {
            model = elem.model;
            if (model) {
                var value;
                try {
                    if (data) value = JSON.parse(data);
                } catch(e) {
                    myt.dumpStack(e);
                }
                
                model[callbackMethodName].call(model, value);
                break;
            }
            elem = elem.parentNode;
        }
    },
    
    /** Dynamically load a script into the dom.
        @param src:string the URL to the script file.
        @param callback:function a callback when the script loads.
        @returns void */
    loadScript: function(src, callback) {
        // Prevent reloading the same script
        if (!this._loadedScripts) this._loadedScripts = {};
        if (this._loadedScripts[src]) {
            console.warn("script already loaded for src", src);
            return;
        }
        this._loadedScripts[src] = true;
        
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = src + '?cacheBust=' + Date.now();
        if (callback) {
            var r = false;
            s.onload = s.onreadystatechange = function() {
                if (!r && (!this.readyState || this.readyState == 'complete')) {
                    r = true; // Prevent refiring callback
                    callback();
                }
            };
        }
        this.getElement('head').appendChild(s);
    },
    
    /** Used to wrap the first function with the second function. The first
        function is exposed as this.callSuper within the wrapper function.
        @param fn:function the function to wrap.
        @param wrapperFn:function the wrapper function.
        @returns a wrapped function. */
    wrapFunction: function(fn, wrapperFn) {
        return function() {
            // Store existing callSuper function so we can put it back later.
            var oldSuper = this.callSuper;
            
            // Assign new callSuper and execute wrapperFn
            this.callSuper = fn;
            var retval = wrapperFn.apply(this, arguments);
            
            // Restore existing callSuper or delete new callSuper
            if (oldSuper !== undefined) {
                this.callSuper = oldSuper;
            } else {
                delete this.callSuper;
            }
            
            return retval;
        };
    },
    
    /** Dumps a stacktrace to the console.
        @param err: Error:string the error or message to dump stack for.
        @param type:string (optional) the type of console message to write.
            Allowed values are 'error', 'warn', 'log' and 'debug'. Defaults to
            'error'.
        @returns void */
    dumpStack: function(err, type) {
        if (!err || typeof err === 'string') err = new Error(err);
        console[type ? type : 'error'](err.stack || err.stacktrace)
    },
    
    // Collection Utilities
    /** Removes an item or items from the provided array that matches based 
        on the provided search function.
        @param arr:array the array to search.
        @param search:function|object (optional) the function used to determine
            a match or an object to search for. If not provided all undefined
            array values will be removed. The search function takes two
            arguments: the first is the index of the item in the array and
            the second is the item to match against, and should return true 
            if the item should be removed.
        @param multiple:boolean (optional) if true all items matching the
            search will be removed and returned. Defaults to false.
        @returns the removed item or null if not found, or an array of removed
            items if multiple is true. */
    filterArray: function(arr, search, multiple) {
        var retval = multiple ? [] : null;
        
        if (Array.isArray(arr)) {
            var i = arr.length, value,
                matchFunc = (search == null || typeof search !== 'function') ? function(i, v) {return v === search;} : search;
            while (i) {
                value = arr[--i];
                if (matchFunc(i, value)) {
                    arr.splice(i, 1);
                    if (multiple) {
                        retval.push(value);
                    } else {
                        return value;
                    }
                }
            }
        }
        
        return retval;
    },
    
    /** Removes an item or items from the provided object that matches based 
        on the provided search function.
        @param obj:object the object to search.
        @param search:function|object (optional) the function used to determine
            a match or an object to search for. If not provided all undefined
            object values will be removed. The search function takes two 
            arguments, the object and the value for that key, and should 
            return true if the item should be removed.
        @param multiple:boolean (optional) if true all items matching the
            search will be removed and returned. Defaults to false.
        @returns the removed item or null if not found, or an array of removed
            items if multiple is true. */
    filterObject: function(obj, search, multiple) {
        var retval = multiple ? [] : null;
        
        if (obj && typeof obj === 'object') {
            var keys = Object.keys(obj), i = keys.length, key, value,
                matchFunc = (search == null || typeof search !== 'function') ? function(k, v) {return v === search;} : search;
            while (i) {
                key = keys[--i];
                value = obj[key];
                if (matchFunc(key, value)) {
                    delete obj[key];
                    if (multiple) {
                        retval.push(value);
                    } else {
                        return value;
                    }
                }
            }
        }
        
        return retval;
    },
    
    // Random numbers
    /** @returns a random number between 0 (inclusive) and 1 (exclusive)
        @param func:function (optional) a distribution function for the
            random numbers. The function should map a number between 0 and 1
            to another number between 0 (inclusive) and 1 (exclusive). If not 
            provided a flat distribution will be used. Example functions:
                - function(v) {return v * v;} will skew the value towards 0.
                - function(v) {return 0.9999999999 - v * v;} will skew the 
                  value towards a value very close to 1.
        @returns number: a random number between 0 and almost 1. */
    getRandom: function(func) {
        var v = Math.random();
        if (func) {
            v = func(v);
            
            // Correct for badly behaved skew functions.
            if (v >= 1) {
                v = 0.9999999999;
            } else if (v < 0) {
                v = 0;
            }
        }
        return v;
    },
    
    /** @returns a random number between min (inclusive) and max (exclusive).
        @param min:number the minimum value returned.
        @param max:number the maximum value returned.
        @param func:function a skew function. See myt.getRandom for more info.
        @returns number: between min and max. */
    getRandomArbitrary: function(min, max, func) {
        if (min > max) {
            var tmp = min;
            min = max;
            max = tmp;
        }
        return this.getRandom(func) * (max - min) + min;
    },
    
    /** @returns a random integer between min (inclusive) and max (inclusive)
        @param min:number the minimum value returned.
        @param max:number the maximum value returned.
        @param func:function a skew function. See myt.getRandom for more info.
        @returns number: an integer between min and max. */
    getRandomInt: function(min, max, func) {
        if (min > max) {
            var tmp = min;
            min = max;
            max = tmp;
        }
        return Math.floor(this.getRandom(func) * (max - min + 1) + min);
    },
    
    // Equality
    /** Tests if two floats are essentially equal to each other.
        @param a:float
        @param b:float
        @param epsilon:float (optional) the percent of difference allowed
            between a and b. Defaults to 0.000001 if not provided.
        @return true if equal, false otherwise. */
    areFloatsEqual: function(a, b, epsilon) {
        var A = Math.abs(a), B = Math.abs(b);
        epsilon = epsilon ? Math.abs(epsilon) : 0.000001;
        return Math.abs(a - b) <= (A > B ? B : A) * epsilon;
    },
    
    /** Tests if two array are equal. For a more complete deep equal
        implementation use underscore.js */
    areArraysEqual: function(a, b) {
        if (a !== b) {
            if (a == null || b == null) return false;
            var i = a.length;
            if (i !== b.length) return false;
            
            while (i) {
                if (a[--i] !== b[i]) return false;
            }
        }
        return true;
    },
    
    // DOM
    /** Gets the dom element of the provided tagname and index.
        @param tagname:string (optional) the name of the tag to search for.
            Defaults to 'body' if not provided
        @param index:int (optional) the index of the tag to get. Defaults to
            0 if not provided.
        @returns a dom element or undefined if none exist. */
    getElement: function(tagname, index) {
        return document.getElementsByTagName(tagname || 'body')[index > 0 ? index : 0];
    },
    
    // Misc
    /** Make a deep or shallow copy of an object.
        @param obj:object the object to copy.
        @param shallow:boolean (optional) If true is provided a shallow copy
            will be created in a more performant way than a deep copy.
        @returns object a copy of the object. */
    clone: function(obj, shallow) {
        if (shallow) {
            var tmp = function(){};
            tmp.prototype = obj;
            return new tmp();
        } else {
            return JSON.parse(JSON.stringify(obj));
        }
    },
    
    /** Memoize a function.
        @param f:function The function to memoize
        @returns function: The memoized function. */
    memoize: function(f) {
        return function() {
            var hash = JSON.stringify(arguments),
                cache = f.__cache || (f.__cache = {});
            return (hash in cache) ? cache[hash] : cache[hash] = f.apply(this, arguments);
        };
    },
    
    /** Copies properties from the source objects to the target object.
        @param targetObj:object The object that properties will be copied into.
        @param sourceObj:object The object that properties will be copied from.
        @param arguments... Additional arguments beyond the second will also
            be used as source objects and copied in order from left to right.
        @param mappingFunction:function (optional) If the last argument is a 
            function it will be used to copy values from the source to the
            target. The function will be passed three values, the key, the 
            target and the source. The mapping function should copy the
            source value into the target value if so desired.
        @returns The target object. */
    extend: function(targetObj, sourceObj) {
        var iterable = targetObj, 
            result = iterable,
            args = arguments, argsLength = args.length, argsIndex = 0,
            key, mappingFunc, ownIndex, ownProps, length;
        
        if (iterable) {
            if (argsLength > 2 && typeof args[argsLength - 1] === 'function') mappingFunc = args[--argsLength];
            
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                
                if (iterable) {
                    ownIndex = -1;
                    ownKeys = Object.keys(iterable);
                    length = ownKeys ? ownKeys.length : 0;
                    
                    while (++ownIndex < length) {
                        key = ownKeys[ownIndex];
                        if (mappingFunc) {
                            mappingFunc(key, result, iterable);
                        } else {
                            result[key] = iterable[key];
                        }
                    }
                }
            }
        }
        return result
    }
};


/** Browser cookie utility functions.
    
    Ported from:
        jQuery Cookie Plugin v1.3.1
        https://github.com/carhartl/jquery-cookie
        Copyright 2013 Klaus Hartl
        Released under the MIT license
*/
myt.Cookie = {
    // Attributes //////////////////////////////////////////////////////////////
    _pluses: /\+/g,
    
    /** Default cookie properties and settings. */
    defaults: {
        raw:false, // If true, don't use encodeURIComponent/decodeURIComponent
        json:false // If true, do JSON stringify and parse
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Function to return a raw cookie name/value. */
    _raw: function(s) {
        return s;
    },
    
    /** Function to return a URI decoded cookie name/value. */
    _decoded: function(s) {
        return decodeURIComponent(s.replace(this._pluses, ' '));
    },
    
    /** Function to convert a stored cookie value into a value that can
        be returned. */
    _converted: function(s, useJson) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }
        
        try {
            return useJson ? JSON.parse(s) : s;
        } catch(er) {}
    },
    
    /** Reads a cookie.
        @param key:string the name of the cookie to read.
        @param options:object options that determine how the cookie is read
            and/or parsed. Supported options are:
                raw:boolean If true the cookie key and value will be used as is.
                    Otherwise decodeURIComponent will be used.
                json:boolean If true JSON.parse will be used to parse the
                    cookie value before it is returned.
        @returns The cookie value string or a parsed cookie value. */
    read: function(key, options) {
        options = myt.extend({}, this.defaults, options);
        
        var decodeFunc = options.raw ? this._raw : this._decoded,
            useJson = options.json,
            cookies = document.cookie.split('; '),
            result = key ? undefined : {},
            parts, name, cookie, i, len = cookies.length;
        for (i = 0; i < len; i++) {
            parts = cookies[i].split('=');
            name = decodeFunc(parts.shift());
            cookie = decodeFunc(parts.join('='));
            
            if (key && key === name) {
                result = this._converted(cookie, useJson);
                break;
            }
            
            if (!key) {
                result[name] = this._converted(cookie, useJson);
            }
        }
        
        return result;
    },
    
    /** Stores a cookie.
        @param key:string the name of the cookie to store.
        @param value:* the value to store.
        @param options:object options that determine how the cookie is
            written and stored. Supported options are:
                expires:number the number of days until the cookie expires.
                path:string the path scope for the cookie.
                domain:string the domain scope for the cookie.
                secure:boolean the cookie must be secure.
                raw:boolean If true the cookie key and value will be used as is.
                    Otherwise encodeURIComponent will be used.
                json:boolean If true JSON.stringify will be used to encode
                    the cookie value.
        @returns void */
    write: function(key, value, options) {
        options = myt.extend({}, this.defaults, options);
        
        if (typeof options.expires === 'number') {
            var days = options.expires;
            var t = options.expires = new Date();
            t.setDate(t.getDate() + days);
        }
        
        value = options.json ? JSON.stringify(value) : String(value);
        
        return (document.cookie = [
            options.raw ? key : encodeURIComponent(key),
            '=',
            options.raw ? value : encodeURIComponent(value),
            options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
            options.path    ? '; path=' + options.path : '',
            options.domain  ? '; domain=' + options.domain : '',
            options.secure  ? '; secure' : ''
        ].join(''));
    },
    
    /** Removes a stored cookie by setting it's expires option to -1 days.
        @param key:string the name of the cookie to remove.
        @param options:object options used to read/write the cookie.
        @returns true if a cookie was removed, false otherwise. */
    remove: function(key, options) {
        if (this.read(key, options) !== undefined) {
            // Must not alter options, thus extending a fresh object.
            this.write(key, '', myt.extend({}, options, {expires: -1}));
            return true;
        }
        return false;
    }
};


/** Apply this mixin to any Object that needs to fire events.
    
    Attributes:
        None
    
    Private Attributes:
        __obsbt:object Stores arrays of myt.Observers and method names 
            by event type
        __aet:object Stores active event type strings. An event type is active
            if it has been fired from this Observable as part of the current 
            call stack. If an event type is "active" it will not be fired 
            again. This provides protection against infinite event loops.
*/
myt.Observable = new JS.Module('Observable', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Adds the observer to the list of event recipients for the event type.
        @param observer:myt.Observer The observer that will observe this
            observable. If methodName is a function this object will be the
            context for the function when it is called.
        @param methodName:string|function The name of the method to call, or
            a function, on the observer when the event fires.
        @param type:string The name of the event the observer will listen to.
        @returns boolean true if the observer was successfully attached, 
            false otherwise. */
    attachObserver: function(observer, methodName, type) {
        if (observer && methodName && type) {
            this.getObservers(type).push(methodName, observer);
            return true;
        }
        return false;
    },
    
    /** Removes the observer from the list of observers for the event type.
        @param observer:myt.Observer The observer that will no longer be
            observing this observable.
        @param methodName:string|function The name of the method that was
            to be called or the function to be called.
        @param type:string The name of the event the observer will no longer
            be listening to.
        @returns boolean true if the observer was successfully detached, 
            false otherwise. */
    detachObserver: function(observer, methodName, type) {
        if (observer && methodName && type) {
            var observersByType = this.__obsbt;
            if (observersByType) {
                var observers = observersByType[type];
                if (observers) {
                    // Remove all instances of the observer and methodName 
                    // combination.
                    var retval = false, i = observers.length;
                    while (i) {
                        // Ensures we decrement twice. First with --i, then 
                        // with i-- since the part after && may not be executed.
                        --i;
                        if (observer === observers[i--] && methodName === observers[i]) {
                            observers.splice(i, 2); // <- Detach Activity that detachAllObservers cares about.
                            retval = true;
                        }
                    }
                    return retval;
                }
            }
        }
        return false;
    },
    
    /** Removes all observers from this Observable.
        @returns void */
    detachAllObservers: function() {
        var observersByType = this.__obsbt;
        if (observersByType) {
            var observers, observer, methodName, i, type;
            for (type in observersByType) {
                observers = observersByType[type];
                i = observers.length;
                while (i) {
                    observer = observers[--i];
                    methodName = observers[--i];
                    
                    // If an observer is registered more than once the list may 
                    // get shortened by observer.detachFrom. If so, just 
                    // continue decrementing downwards.
                    if (observer && methodName) {
                        if (typeof observer.detachFrom !== 'function' || 
                            !observer.detachFrom(this, methodName, type)
                        ) {
                            // Observer may not have a detachFrom function or 
                            // observer may not have attached via 
                            // Observer.attachTo so do default detach activity 
                            // as implemented in Observable.detachObserver
                            observers.splice(i, 2);
                        }
                    }
                }
            }
        }
    },
    
    /** Gets an array of observers and method names for the provided type.
        The array is structured as:
            [methodName1, observerObj1, methodName2, observerObj2,...].
        @param type:string The name of the event to get observers for.
        @returns array: The observers of the event. */
    getObservers: function(type) {
        var observersByType = this.__obsbt || (this.__obsbt = {});
        return observersByType[type] || (observersByType[type] = []);
    },
    
    /** Checks if any observers exist for the provided event type.
        @param type:string The name of the event to check.
        @returns boolean: True if any exist, false otherwise. */
    hasObservers: function(type) {
        var observersByType = this.__obsbt;
        if (!observersByType) return false;
        var observers = observersByType[type];
        return observers && observers.length > 0;
    },
    
    /** Sends the provided Event to all observers for the provided event's type.
        The named method is called on each observer in the order they were 
        registered. If the called method returns true the Event is considerd 
        "consumed" and will not be sent to any other observers. Consuming an 
        event should be used when more than one observer may be listening for 
        an Event but only one observer needs to handle the Event.
        @param event:object The event to fire.
        @param observers:array (Optional) If provided the event will
            be sent to this specific list of observers and no others.
        @return void */
    fireEvent: function(event, observers) {
        if (event && event.source === this) {
            // Determine observers to use
            var type = event.type;
            observers = observers || (this.hasObservers(type) ? this.__obsbt[type] : null);
            
            // Fire event
            if (observers) this.__fireEvent(event, observers);
        }
    },
    
    /** Generates a new event from the provided type and value and fires it
        to the provided observers or the registered observers.
        @param type:string The event type to fire.
        @param value:* The value to set on the event.
        @param observers:array (Optional) If provided the event will
            be sent to this specific list of observers and no others.
        @returns void */
    fireNewEvent: function(type, value, observers) {
        // Determine observers to use
        observers = observers || (this.hasObservers(type) ? this.__obsbt[type] : null);
        
        // Fire event
        if (observers) this.__fireEvent({source:this, type:type, value:value}, observers); // Inlined from this.createEvent
    },
    
    /** Creates a new event with the type and value and using this as 
        the source.
        @param type:string The event type.
        @param value:* The event value.
        @returns An event object consisting of source, type and value. */
    createEvent: function(type, value) {
        return {source:this, type:type, value:value}; // Inlined in this.fireNewEvent
    },
    
    /** Fire the event to the observers.
        @private
        @param event:Object The event to fire.
        @param observers:array An array of method names and contexts to invoke
            providing the event as the sole argument.
        @returns void */
    __fireEvent: function(event, observers) {
        // Prevent "active" events from being fired again
        var activeEventTypes = this.__aet || (this.__aet = {}),
            type = event.type;
        if (activeEventTypes[type] === true) {
            myt.dumpStack("Attempt to refire active event: " + type);
        } else {
            // Mark event type as "active"
            activeEventTypes[type] = true;
            
            // Walk through observers backwards so that if the observer is
            // detached by the event handler the index won't get messed up.
            // FIXME: If necessary we could queue up detachObserver calls that 
            // come in during iteration or make some sort of adjustment to 'i'.
            var i = observers.length, observer, methodName;
            while (i) {
                observer = observers[--i]
                methodName = observers[--i];
                
                // Sometimes the list gets shortened by the method we called so
                // just continue decrementing downwards.
                if (observer && methodName) {
                    // Stop firing the event if it was "consumed".
                    try {
                        if (typeof methodName === 'function') {
                            if (methodName.call(observer, event)) break;
                        } else {
                            if (observer[methodName](event)) break;
                        }
                    } catch (err) {
                        myt.dumpStack(err);
                    }
                }
            }
            
            // Mark event type as "inactive"
            activeEventTypes[type] = false;
        }
    }
});


/** Provides a mechanism to remember which Observables this instance has 
    registered itself with. This can be useful when we need to cleanup the 
    instance later.
    
    When this module is used registration and unregistration must be done 
    using the methods below. Otherwise, it is possible for the relationship 
    between observer and observable to be broken.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __obt:object Stores arrays of Observables by event type
        __methodNameCounter:int Used to create unique method names when a
            callback should only be called once.
        __DO_ONCE_*:function The names used for methods that only get run
            one time. */
myt.Observer = new JS.Module('Observer', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Does the same thing as this.attachToAndCallbackIfAttrNotEqual with
        a value of undefined.
        @param observable:myt.Observable the Observable to attach to.
        @param methodName:string the method name on this instance to execute.
        @param eventType:string the event type to attach for.
        @param attrName:string (optional: the eventType will be used if not
            provided) the name of the attribute on the Observable
            to pull the value from.
        @param once:boolean (optional) if true  this Observer will detach
            from the Observable after the event is handled once.
        @returns void */
    attachToAndCallbackIfAttrExists: function(observable, methodName, eventType, attrName, once) {
        this.attachToAndCallbackIfAttrNotEqual(observable, methodName, eventType, undefined, attrName, once);
    },
    
    /** Does the same thing as this.attachTo and also immediately calls the
        method if the provided attrName on the observable is exactly equal to 
        the provided value.
        @param observable:myt.Observable the Observable to attach to.
        @param methodName:string the method name on this instance to execute.
        @param eventType:string the event type to attach for.
        @param value:* the value to test equality against.
        @param attrName:string (optional: the eventType will be used if not
            provided) the name of the attribute on the Observable
            to pull the value from.
        @param once:boolean (optional) if true  this Observer will detach
            from the Observable after the event is handled once.
        @returns void */
    attachToAndCallbackIfAttrEqual: function(observable, methodName, eventType, value, attrName, once) {
        if (attrName === undefined) attrName = eventType;
        if (observable.get(attrName) === value) {
            this.syncTo(observable, methodName, eventType, attrName, once);
        } else {
            this.attachTo(observable, methodName, eventType, once);
        }
    },
    
    /** Does the same thing as this.attachTo and also immediately calls the
        method if the provided attrName on the observable does not exactly 
        equal the provided value.
        @param observable:myt.Observable the Observable to attach to.
        @param methodName:string the method name on this instance to execute.
        @param eventType:string the event type to attach for.
        @param value:* the value to test inequality against.
        @param attrName:string (optional: the eventType will be used if not
            provided) the name of the attribute on the Observable
            to pull the value from.
        @param once:boolean (optional) if true  this Observer will detach
            from the Observable after the event is handled once.
        @returns void */
    attachToAndCallbackIfAttrNotEqual: function(observable, methodName, eventType, value, attrName, once) {
        if (attrName === undefined) attrName = eventType;
        if (observable.get(attrName) !== value) {
            this.syncTo(observable, methodName, eventType, attrName, once);
        } else {
            this.attachTo(observable, methodName, eventType, once);
        }
    },
    
    /** Does the same thing as this.attachTo and also immediately calls the
        method with an event containing the attributes value. If 'once' is
        true no attachment will occur which means this probably isn't the
        correct method to use in that situation.
        @param observable:myt.Observable the Observable to attach to.
        @param methodName:string the method name on this instance to execute.
        @param eventType:string the event type to attach for.
        @param attrName:string (optional: the eventType will be used if not
            provided) the name of the attribute on the Observable
            to pull the value from.
        @param once:boolean (optional) if true  this Observer will detach
            from the Observable after the event is handled once.
        @returns void */
    syncTo: function(observable, methodName, eventType, attrName, once) {
        if (attrName === undefined) attrName = eventType;
        try {
            this[methodName](observable.createEvent(eventType, observable.get(attrName)));
        } catch (err) {
            myt.dumpStack(err);
        }
        
        // Providing a true value for once means we'll never actually attach.
        if (once) return;
        
        this.attachTo(observable, methodName, eventType, once);
    },
    
    /** Checks if this Observer is attached to the provided observable for
        the methodName and eventType.
        @param observable:myt.Observable the Observable to check with.
        @param methodName:string the method name on this instance to execute.
        @param eventType:string the event type to check for.
        @returns true if attached, false otherwise. */
    isAttachedTo: function(observable, methodName, eventType) {
        if (observable && methodName && eventType) {
            var observablesByType = this.__obt;
            if (observablesByType) {
                var observables = observablesByType[eventType];
                if (observables) {
                    var i = observables.length;
                    while (i) {
                        // Ensures we decrement twice. First with --i, then 
                        // with i-- since the part after && may not be executed.
                        --i;
                        if (observable === observables[i--] && methodName === observables[i]) return true;
                    }
                }
            }
        }
        return false;
    },
    
    /** Gets an array of observables and method names for the provided type.
        The array is structured as:
            [methodName1, observableObj1, methodName2, observableObj2,...].
        @param eventType:string the event type to check for.
        @returns an array of observables. */
    getObservables: function(eventType) {
        var observablesByType = this.__obt || (this.__obt = {});
        return observablesByType[eventType] || (observablesByType[eventType] = []);
    },
    
    /** Checks if any observables exist for the provided event type.
        @param eventType:string the event type to check for.
        @returns true if any exist, false otherwise. */
    hasObservables: function(eventType) {
        var observablesByType = this.__obt;
        if (!observablesByType) return false;
        var observables = observablesByType[eventType];
        return observables && observables.length > 0;
    },
    
    /** Registers this Observer with the provided Observable
        for the provided eventType.
        @param observable:myt.Observable the Observable to attach to.
        @param methodName:string the method name on this instance to execute.
        @param eventType:string the event type to attach for.
        @param once:boolean (optional) if true  this Observer will detach
            from the Observable after the event is handled once.
        @returns boolean true if the observable was successfully registered, 
            false otherwise. */
    attachTo: function(observable, methodName, eventType, once) {
        if (observable && methodName && eventType) {
            var observables = this.getObservables(eventType);
            
            // Setup wrapper method when 'once' is true.
            if (once) {
                var self = this, origMethodName = methodName;
                
                // Generate one time method name.
                if (this.__methodNameCounter === undefined) this.__methodNameCounter = 0;
                methodName = '__DO_ONCE_' + this.__methodNameCounter++;
                
                // Setup wrapper method that will do the detachFrom.
                this[methodName] = function(event) {
                    self.detachFrom(observable, methodName, eventType);
                    delete self[methodName];
                    return self[origMethodName](event);
                };
            }
            
            // Register this observer with the observable
            if (observable.attachObserver(this, methodName, eventType)) {
                observables.push(methodName, observable);
                return true;
            }
        }
        return false;
    },
    
    /** Unregisters this Observer from the provided Observable
        for the provided eventType.
        @param observable:myt.Observable the Observable to attach to.
        @param methodName:string the method name on this instance to execute.
        @param eventType:string the event type to attach for.
        @returns boolean true if one or more detachments occurred, false 
            otherwise. */
    detachFrom: function(observable, methodName, eventType) {
        if (observable && methodName && eventType) {
            // No need to unregister if observable array doesn't exist.
            var observablesByType = this.__obt;
            if (observablesByType) {
                var observables = observablesByType[eventType];
                if (observables) {
                    // Remove all instances of this observer/methodName/eventType 
                    // from the observable
                    var retval = false, i = observables.length;
                    while (i) {
                        --i;
                        if (observable === observables[i--] && methodName === observables[i]) {
                            if (observable.detachObserver(this, methodName, eventType)) {
                                observables.splice(i, 2);
                                retval = true;
                            }
                        }
                    }
                    
                    // Source wasn't found
                    return retval;
                }
            }
        }
        return false;
    },
    
    /** Tries to detach this Observer from all Observables it
        is attached to.
        @returns void */
    detachFromAllObservables: function() {
        var observablesByType = this.__obt;
        if (observablesByType) {
            var observables, i;
            for (var eventType in observablesByType) {
                observables = observablesByType[eventType];
                i = observables.length;
                while (i) observables[--i].detachObserver(this, observables[--i], eventType);
                observables.length = 0;
            }
        }
    }
});


/** Provides the ability to apply and release constraints.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __cbmn:object Holds arrays of constraints by method name.
*/
myt.Constrainable = new JS.Module('Constrainable', {
    include: [myt.Observer],
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Creates a constraint. The method will be executed on this object
        whenever any of the provided observables fire the indicated event type.
        @param methodName:String The name of the method to call on this object.
        @param observables:array An array of observable/type pairs. An observer
            will attach to each observable for the event type.
        @returns void */
    applyConstraint: function(methodName, observables) {
        if (methodName && observables) {
            // Make sure an even number of observable/type was provided
            var len = observables.length;
            if (len % 2 !== 0) {
                console.log("Observables was not even.", this);
                return;
            }
            
            // Lazy instantiate constraints array.
            var constraints = this.__cbmn || (this.__cbmn = {});
            var constraint = constraints[methodName] || (constraints[methodName] = []);
            
            // Don't allow a constraint to be clobbered.
            if (constraint.length > 0) {
                console.log("Constraint already exists for " + methodName + " on " + this);
                return;
            }
            
            var observable, type, i = 0;
            for (; len !== i;) {
                observable = observables[i++];
                type = observables[i++];
                if (observable && type) {
                    this.attachTo(observable, methodName, type);
                    constraint.push(observable, type);
                }
            }
            
            // Call constraint method once so it can "sync" the constraint
            try {
                this[methodName]();
            } catch (err) {
                myt.dumpStack(err);
            }
        }
    },
    
    /** Removes a constraint.
        @returns void */
    releaseConstraint: function(methodName) {
        if (methodName) {
            // No need to remove if the constraint is already empty.
            var constraints = this.__cbmn;
            if (constraints) {
                var constraint = constraints[methodName];
                if (constraint) {
                    var i = constraint.length, type, observable;
                    while (i) {
                        type = constraint[--i];
                        observable = constraint[--i];
                        this.detachFrom(observable, methodName, type);
                    }
                    constraint.length = 0;
                }
            }
        }
    },
    
    /** Removes all constraints.
        @returns void */
    releaseAllConstraints: function() {
        var constraints = this.__cbmn;
        if (constraints) {
            for (var methodName in constraints) this.releaseConstraint(methodName);
        }
    }
});


/** Holds references to "global" objects. Fires events when these globals
    are registered and unregistered.
    
    Events:
        register<key>:object Fired when an object is stored under the key.
        unregister<key>:object Fired when an object is removed from the key.
*/
myt.global = new JS.Singleton('Global', {
    include: [myt.Observable],
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Registers the provided global under the key. Fires a register<key>
        event. If a global is already registered under the key the existing
        global is unregistered first.
        @returns void */
    register: function(key, v) {
        if (this.hasOwnProperty(key)) {
            console.log("Warning: myt.global key in use: ", key);
            this.unregister(key);
        }
        this[key] = v;
        this.fireNewEvent('register' + key, v);
    },
    
    /** Unegisters the global for the provided key. Fires an unregister<key>
        event if the key exists.
        @returns void */
    unregister: function(key) {
        if (this.hasOwnProperty(key)) {
            var v = this[key];
            delete this[key];
            this.fireNewEvent('unregister' + key, v);
        } else {
            console.log("Warning: myt.global key not in use: ", key);
        }
    }
});


/** Provides a dom element for this instance. Also assigns a reference to this
    DomElementProxy to a property named "model" on the dom element.
    
    Events:
        None
    
    Attributes:
        domElement:domElement the dom element hidden we are a proxy for.
        deStyle:object a shortcut reference to the style attribute of 
            the dom element.
*/
myt.DomElementProxy = new JS.Module('DomElementProxy', {
    // Class Methods ///////////////////////////////////////////////////////////
    extend: {
        /** Creates a new dom element.
            @param tagname:string the name of the element to create.
            @param styles:object (optional) a map of style keys and values to 
                add to the style property of the new element.
            @param props:object (optional) a map of keys and values to add to 
                the new element.
            @returns the created element. */
        createDomElement: function(tagname, styles, props) {
            var de = document.createElement(tagname), key;
            if (props) for (key in props) de[key] = props[key];
            if (styles) for (key in styles) de.style[key] = styles[key];
            return de;
        },
        
        /** Gets the computed style for a dom element.
            @param elem:dom element the dom element to get the style for.
            @returns object the style object. */
        getComputedStyle: function(elem) {
            // getComputedStyle is IE's proprietary way.
            var g = global;
            return g.getComputedStyle ? g.getComputedStyle(elem, '') : elem.currentStyle;
        },
        
        /** Tests if a dom element is visible or not.
            @param elem:DomElement the element to check visibility for.
            @returns boolean True if visible, false otherwise. */
        isDomElementVisible: function(elem) {
            // Special Case: hidden input elements should be considered not visible.
            if (elem.nodeName === 'INPUT' && elem.type === 'hidden') return false;
            
            var style;
            while (elem) {
                if (elem === document) return true;
                
                style = this.getComputedStyle(elem);
                if (style.display === 'none' || style.visibility === 'hidden') break;
                
                elem = elem.parentNode;
            }
            return false;
        },
        
        /** Gets the z-index of a dom element relative to an ancestor dom
            element.
            @returns int */
        getZIndexRelativeToAncestor: function(elem, ancestor) {
            if (elem && ancestor) {
                var ancestors = this.getAncestorArray(elem, ancestor),
                    i = ancestors.length - 1, style, zIdx, isAuto;
                
                while (i) {
                    style = this.getComputedStyle(ancestors[--i]);
                    zIdx = style.zIndex;
                    isAuto = zIdx === 'auto';
                    
                    if (i !== 0 && isAuto && parseInt(style.opacity, 10) === 1) {
                        continue;
                    } else {
                        return isAuto ? 0 : parseInt(zIdx, 10);
                    }
                }
            }
            return 0;
        },
        
        /** Gets an array of ancestor dom elements including the element
            itself.
            @param elem:DomElement the element to start from.
            @param ancestor:DomElement (optional) The dom element to stop
                getting ancestors at.
            @returns an array of ancestor dom elements. */
        getAncestorArray: function(elem, ancestor) {
            var ancestors = [];
            while (elem) {
                ancestors.push(elem);
                if (elem === ancestor) break;
                elem = elem.parentNode;
            }
            return ancestors;
        },
        
        /** Gets the z-index of the dom element or, if it does not define a 
            stacking context, the highest z-index of any of the dom element's 
            descendants.
            @param elem:DomElement
            @returns int */
        getHighestZIndex: function(elem) {
            // See https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
            var style = this.getComputedStyle(elem),
                zIdx = style.zIndex, 
                isAuto = zIdx === 'auto';
            if (isAuto && parseInt(style.opacity, 10) === 1) {
                // No new stacking context.
                zIdx = 0;
                var children = elem.childNodes, i = children.length, child;
                while (i) {
                    child = children[--i];
                    if (child.nodeType === 1) zIdx = Math.max(zIdx, this.getHighestZIndex(child));
                }
            } else {
                zIdx = isAuto ? 0 : parseInt(zIdx, 10);
            }
            return zIdx;
        },
        
        /** Gets the x and y position of the dom element relative to the 
            ancestor dom element or the page. Transforms are not supported.
            Use getTruePagePosition if you need support for transforms.
            @param elem:domElement The dom element to get the position for.
            @param ancestorElem:domElement (optional) An ancestor dom element
                that if encountered will halt the page position calculation
                thus giving the position of elem relative to ancestorElem.
            @returns object with 'x' and 'y' keys or null if an error has
                occurred. */
        getPagePosition: function(elem, ancestorElem) {
            if (!elem) return null;
            
            var x = 0, y = 0, s,
                borderMultiplier = BrowserDetect.browser === 'Firefox' ? 2 : 1; // I have no idea why firefox needs it twice, but it does.
            
            // elem.nodeName !== "BODY" test prevents looking at the body
            // which causes problems when the document is scrolled on webkit.
            while (elem && elem.nodeName !== "BODY" && elem !== ancestorElem) {
                x += elem.offsetLeft;
                y += elem.offsetTop;
                elem = elem.offsetParent;
                if (elem && elem.nodeName !== "BODY") {
                    s = this.getComputedStyle(elem);
                    x += borderMultiplier * parseInt(s.borderLeftWidth, 10) - elem.scrollLeft;
                    y += borderMultiplier * parseInt(s.borderTopWidth, 10) - elem.scrollTop;
                }
            }
            
            return {x:x, y:y};
        },
        
        /** Gets the x and y position of the dom element relative to the page
            with support for transforms.
            @param elem:domElement The dom element to get the position for.
            @returns object with 'x' and 'y' keys or null if an error has
                occurred. */
        getTruePagePosition: function(elem) {
            if (!elem) return null;
            var pos = $(elem).offset();
            return {x:pos.left, y:pos.top};
        },
        
        /** Generates a dom event on a dom element. Adapted from:
                http://stackoverflow.com/questions/6157929/how-to-simulate-mouse-click-using-javascript
            @param elem:domElement the element to simulate the event on.
            @param eventName:string the name of the dom event to generate.
            @param customOpts:Object (optional) a map of options that will
                be added onto the dom event object.
            @returns void */
        simulateDomEvent: function(elem, eventName, customOpts) {
            if (elem) {
                var opts = {
                    pointerX:0, pointerY:0, button:0,
                    ctrlKey:false, altKey:false, shiftKey:false, metaKey:false,
                    bubbles:true, cancelable:true
                };
                
                if (customOpts) {
                    for (var p in customOpts) opts[p] = customOpts[p];
                }
                
                var eventType,
                    eventMatchers = {
                        'HTMLEvents': /^(?:load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll)$/,
                        'MouseEvents': /^(?:click|dblclick|mouse(?:down|up|over|move|out))$/
                    };
                for (var name in eventMatchers) {
                    if (eventMatchers[name].test(eventName)) {eventType = name; break;}
                }
                if (!eventType) throw new SyntaxError('Only HTMLEvent and MouseEvent interfaces supported');
                
                var domEvent;
                if (document.createEvent) {
                    domEvent = document.createEvent(eventType);
                    if (eventType === 'HTMLEvents') {
                        domEvent.initEvent(eventName, opts.bubbles, opts.cancelable);
                    } else {
                        domEvent.initMouseEvent(
                            eventName, opts.bubbles, opts.cancelable, document.defaultView,
                            opts.button, opts.pointerX, opts.pointerY, opts.pointerX, opts.pointerY,
                            opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, 
                            opts.button, null
                        );
                    }
                    elem.dispatchEvent(domEvent);
                } else {
                    opts.clientX = opts.pointerX;
                    opts.clientY = opts.pointerY;
                    domEvent = document.createEventObject();
                    for (var key in opts) domEvent[key] = opts[key];
                    elem.fireEvent('on' + eventName, domEvent);
                }
            }
        }
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Sets the dom element to the provided one. */
    setDomElement: function(v) {
        this.domElement = v;
        
        // Store a reference to domElement.style since it is accessed often.
        this.deStyle = v.style;
        
        // Setup a reference from the domElement to this model. This will allow
        // access to the model from code that uses JQuery or some other
        // mechanism to select dom elements.
        v.model = this;
    },
    
    /** Removes this DomElementProxy's dom element from its parent node.
        @returns void */
    removeDomElement: function() {
        var de = this.domElement;
        de.parentNode.removeChild(de);
    },
    
    /** Called when this DomElementProxy is destroyed.
        @returns void */
    disposeOfDomElement: function() {
        delete this.domElement.model;
        delete this.deStyle;
        delete this.domElement;
    },
    
    /** Sets the dom "class" attribute on the dom element.
        @param v:string the dom class name.
        @returns void */
    setDomClass: function(v) {
        this.domElement.className = this.domClass = v;
    },
    
    /** Adds a dom "class" to the existing dom classes on the dom element.
        @param v:string the dom class to add.
        @returns void */
    addDomClass: function(v) {
        var existing = this.domElement.className;
        this.setDomClass((existing ? existing + ' ' : '') + v);
    },
    
    /** Removes a dom "class" from the dom element.
        @param v:string the dom class to remove.
        @returns void */
    removeDomClass: function(v) {
        var existing = this.domElement.className;
        if (existing) {
            var parts = existing.split(' '), i = parts.length;
            while (i) {
                if (parts[--i] === v) parts.splice(i, 1);
            }
            this.setDomClass(parts.join(' '));
        }
    },
    
    /** Clears the dom "class".
        @returns void */
    clearDomClass: function() {
        this.setDomClass('');
    },
    
    /** Sets the dom "id" attribute on the dom element.
        @param v:string the dom id name.
        @returns void */
    setDomId: function(v) {
        this.domElement.id = this.domId = v;
    },
    
    /** Set the z-index of the dom element.
        @param v:number the z-index to set.
        @returns void */
    setZIndex: function(v) {
        this.deStyle.zIndex = v;
    },
    
    /** Set an arbitrary CSS style on the dom element.
        @param propertyName:string the name of the CSS property to set.
        @param v:* the value to set.
        @returns void */
    setStyleProperty: function(propertyName, v) {
        this.deStyle[propertyName] = v;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Gets the x and y position of the underlying dom element relative to
        the page. Transforms are not supported.
        @returns object with 'x' and 'y' keys or null if no dom element exists
            for this proxy. */
    getPagePosition: function() {
        return myt.DomElementProxy.getPagePosition(this.domElement);
    },
    
    /** Gets the x and y position of the underlying dom element relative 
        to the page with support for transforms.
        @returns object with 'x' and 'y' keys or null if no dom element exists
            for this proxy. */
    getTruePagePosition: function() {
        return myt.DomElementProxy.getTruePagePosition(this.domElement);
    },
    
    /** Generates a dom event on this proxy's dom element.
        @param eventName:string the name of the dom event to generate.
        @param customOpts:Object (optional) a map of options that will
            be added onto the dom event object.
        @returns void */
    simulateDomEvent: function(eventName, customOpts) {
        myt.DomElementProxy.simulateDomEvent(this.domElement, eventName, customOpts);
    },
    
    /** Gets the highest z-index of the dom element.
        @returns int */
    getHighestZIndex: function() {
        return myt.DomElementProxy.getHighestZIndex(this.domElement);
    },
    
    /** Gets the highest z-index of any of the descendant dom elements of
        the domElement of this DomElementProxy.
        @param skipChild:domElement (optional) A dom element to skip over
            when determining the z-index.
        @returns number */
    getHighestChildZIndex: function(skipChild) {
        var DEP = myt.DomElementProxy, 
            children = this.domElement.childNodes, i = children.length, child, 
            zIdx = 0;
        while (i) {
            child = children[--i];
            if (child.nodeType === 1 && child !== skipChild) zIdx = Math.max(zIdx, DEP.getHighestZIndex(child));
        }
        return zIdx;
    },
    
    /** Makes this dom element proxy the one with the highest z-index 
        relative to its sibling dom elements.
        @returns void */
    makeHighestZIndex: function() {
        this.setZIndex(this.parent.getHighestChildZIndex(this.domElement) + 1);
    }
});


/** Generates Dom Events and passes them on to one or more event observers.
    Requires myt.DomElementProxy be included when this mixin is included.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __dobsbt:object Stores arrays of myt.DomObservers and method names 
            by event type.
*/
myt.DomObservable = new JS.Module('DomObservable', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Adds the observer to the list of event recipients for the event type.
        @param domObserver:myt.DomObserver The observer that will be notified
            when a dom event occurs.
        @param methodName:string The method name to call on the dom observer.
        @param type:string The type of dom event to register for.
        @param capture:boolean (optional) Indicates if the event registration
            is during capture or bubble phase. Defaults to false, bubble phase.
        @returns boolean True if the observer was successfully registered, 
            false otherwise.*/
    attachDomObserver: function(domObserver, methodName, type, capture) {
        if (domObserver && methodName && type) {
            capture = !!capture;
            
            var methodRef = this.createDomMethodRef(domObserver, methodName, type);
            if (methodRef) {
                var domObserversByType = this.__dobsbt || (this.__dobsbt = {});
                
                // Lazy instantiate dom observers array for type and insert observer.
                var domObservers = domObserversByType[type];
                if (!domObservers) {
                    // Create list with observer
                    domObserversByType[type] = [domObserver, methodName, methodRef, capture];
                } else {
                    // Add dom observer to the end of the list
                    domObservers.push(domObserver, methodName, methodRef, capture);
                }
                
                myt.addEventListener(this.domElement, type, methodRef, capture);
                
                return true;
            }
        }
        return false;
    },
    
    /** Creates a function that will handle the dom event when it is fired
        by the browser. Must be implemented by the object this mixin is 
        applied to.
        @param domObserver:myt.DomObserver the observer that must be notified
            when the dom event fires.
        @param methodName:string the name of the function to pass the event to.
        @param type:string the type of the event to fire.
        @returns a function to handle the dom event or null if the event
            is not supported. */
    createDomMethodRef: function(domObserver, methodName, type) {
        return null;
    },
    
    /** Used by the createDomMethodRef implementations of submixins of 
        myt.DomObservable to implement the standard methodRef.
        @param domObserver:myt.DomObserver the observer that must be notified
            when the dom event fires.
        @param methodName:string the name of the function to pass the event to.
        @param type:string the type of the event to fire.
        @param observableClass:JS.Class The class that has the common event.
        @param preventDefault:boolean (Optional) If true the default behavior
            of the domEvent will be prevented.
        @returns a function to handle the dom event or undefined if the event
            will not be handled. */
    createStandardDomMethodRef: function(domObserver, methodName, type, observableClass, preventDefault) {
        if (observableClass.EVENT_TYPES[type]) {
            var self = this, 
                event = observableClass.EVENT;
            return function(domEvent) {
                if (!domEvent) var domEvent = window.event;
                
                event.source = self;
                event.type = domEvent.type;
                event.value = domEvent;
                
                var allowBubble = domObserver[methodName](event);
                if (!allowBubble) {
                    domEvent.cancelBubble = true;
                    if (domEvent.stopPropagation) domEvent.stopPropagation();
                    
                    if (preventDefault) domEvent.preventDefault();
                }
                
                event.source = undefined;
            };
        }
    },
    
    /** Removes the observer from the list of dom observers for the event type.
        @param domObserver:myt.DomObserver The dom observer to unregister.
        @param methodName:string The method name to unregister for.
        @param type:string The dom event type to unregister for.
        @param capture:boolean (optional) The event phase to unregister for.
            Defaults to false if not provided.
        @returns boolean True if the observer was successfully unregistered, 
            false otherwise.*/
    detachDomObserver: function(domObserver, methodName, type, capture) {
        if (domObserver && methodName && type) {
            capture = !!capture;
            
            var domObserversByType = this.__dobsbt;
            if (domObserversByType) {
                var domObservers = domObserversByType[type];
                if (domObservers) {
                    // Remove dom observer
                    var retval = false, domElement = this.domElement, i = domObservers.length;
                    while (i) {
                        i -= 4;
                        if (domObserver === domObservers[i] && 
                            methodName === domObservers[i + 1] && 
                            capture === domObservers[i + 3]
                        ) {
                            if (domElement) myt.removeEventListener(domElement, type, domObservers[i + 2], capture);
                            domObservers.splice(i, 4);
                            retval = true;
                        }
                    }
                    return retval;
                }
            }
        }
        return false;
    },
    
    /** Detaches all dom observers from this DomObservable.
        @returns void */
    detachAllDomObservers: function() {
        var domElement = this.domElement;
        if (domElement) {
            var domObserversByType = this.__dobsbt;
            if (domObserversByType) {
                var domObservers, methodRef, capture, i, type;
                for (type in domObserversByType) {
                    domObservers = domObserversByType[type];
                    i = domObservers.length;
                    while (i) {
                        capture = domObservers[--i];
                        methodRef = domObservers[--i];
                        i -= 2; // methodName and domObserver
                        myt.removeEventListener(domElement, type, methodRef, capture);
                    }
                    domObservers.length = 0;
                }
            }
        }
    }
});


/** Provides a mechanism to remember which DomObservables this DomObserver has 
    attached itself to. This is useful when the instance is being destroyed
    to automatically cleanup the observer/observable relationships.
    
    When this mixin is used attachment and detachment should be done 
    using the 'attachToDom' and 'detachFromDom' methods of this mixin. If this 
    is not done, it is possible for the relationship between observer and 
    observable to become broken.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __dobt: (Object) Holds arrays of DomObservables by event type.
*/
myt.DomObserver = new JS.Module('DomObserver', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Attaches this DomObserver to the provided DomObservable for the 
        provided type.
        @returns void */
    attachToDom: function(observable, methodName, type, capture) {
        if (observable && methodName && type) {
            capture = !!capture;
            
            // Lazy instantiate __dobt map.
            var observablesByType = this.__dobt || (this.__dobt = {});
            var observables = observablesByType[type] || (observablesByType[type] = []);
            
            // Attach this DomObserver to the DomObservable
            if (observable.attachDomObserver(this, methodName, type, capture)) {
                observables.push(capture, methodName, observable);
            }
        }
    },
    
    /** Detaches this DomObserver from the DomObservable for the event type.
        @returns boolean True if detachment succeeded, false otherwise. */
    detachFromDom: function(observable, methodName, type, capture) {
        if (observable && methodName && type) {
            capture = !!capture;
            
            // No need to detach if observable array doesn't exist.
            var observablesByType = this.__dobt;
            if (observablesByType) {
                var observables = observablesByType[type];
                if (observables) {
                    // Remove all instances of this observer/methodName/type/capture 
                    // from the observable
                    var retval = false, i = observables.length;
                    while (i) {
                        i -= 3;
                        if (observable === observables[i + 2] && 
                            methodName === observables[i + 1] && 
                            capture === observables[i]
                        ) {
                            if (observable.detachDomObserver(this, methodName, type, capture)) {
                                observables.splice(i, 3);
                                retval = true;
                            }
                        }
                    }
                    
                    // Observable wasn't found
                    return retval;
                }
            }
        }
        return false;
    },
    
    /** Detaches this DomObserver from all DomObservables it is attached to.
        @returns void */
    detachFromAllDomSources: function() {
        var observablesByType = this.__dobt;
        if (observablesByType) {
            var observables, i, type;
            for (type in observablesByType) {
                observables = observablesByType[type];
                i = observables.length;
                while (i) observables[--i].detachDomObserver(this, observables[--i], type, observables[--i]);
                observables.length = 0;
            }
        }
    }
});


/** Generates Key Events and passes them on to one or more event observers.
    Requires myt.DomObservable as a super mixin. */
myt.KeyObservable = new JS.Module('KeyObservable', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of supported key event types. */
        EVENT_TYPES:{
            keypress:true,
            keydown:true,
            keyup:true
        },
        
        /** The common key event that gets reused. */
        EVENT:{source:null, type:null, value:null},
        
        /** Gets the key code from the provided key event.
            @param event:event
            @returns number The keycode from the event. */
        getKeyCodeFromEvent: function(event) {
            var domEvent = event.value, 
                keyCode = domEvent.keyCode;
            return keyCode || domEvent.charCode;
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DomObservable */
    createDomMethodRef: function(domObserver, methodName, type) {
        return this.createStandardDomMethodRef(domObserver, methodName, type, myt.KeyObservable) || 
            this.callSuper(domObserver, methodName, type);
    }
});


/** Tracks focus and provides global focus events. Registered with myt.global 
    as 'focus'.
    
    Events:
        focused:View Fired when the focused view changes. The event value is
            the newly focused view.
    
    Attributes:
        lastTraversalWasForward:boolean indicates if the last traversal was
            in the forward direction or not. If false this implies the last
            traversal was in the backward direction. This value is initalized
            to true.
        focusedView:View the view that currently has focus.
        prevFocusedView:View the view that previously had focus.
        focusedDom:DomElement holds the dom element that has focus when the
            focus has traversed into a non myt managed area of the dom.
*/
/* Dom element types reference:
    ELEMENT_NODE                :1
    ATTRIBUTE_NODE              :2
    TEXT_NODE                   :3
    CDATA_SECTION_NODE          :4
    ENTITY_REFERENCE_NODE       :5
    ENTITY_NODE                 :6
    PROCESSING_INSTRUCTION_NODE :7
    COMMENT_NODE                :8
    DOCUMENT_NODE               :9
    DOCUMENT_TYPE_NODE          :10
    DOCUMENT_FRAGMENT_NODE      :11
    NOTATION_NODE               :12 */
new JS.Singleton('GlobalFocus', {
    include: [myt.Observable],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        this.lastTraversalWasForward = true;
        
        myt.global.register('focus', this);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Sets the currently focused view. */
    setFocusedView: function(v) {
        if (this.focusedView !== v) {
            this.prevFocusedView = this.focusedView; // Remember previous focus
            this.focusedView = v;
            if (v) this.focusedDom = null; // Wipe this since we have actual focus now.
            this.fireNewEvent('focused', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called by a FocusObservable when it has received focus.
        @param focusable:FocusObservable the view that received focus.
        @returns void. */
    notifyFocus: function(focusable) {
        if (this.focusedView !== focusable) this.setFocusedView(focusable);
    },
    
    /** Called by a FocusObservable when it has lost focus.
        @param focusable:FocusObservable the view that lost focus.
        @returns void. */
    notifyBlur: function(focusable) {
        if (this.focusedView === focusable) this.setFocusedView(null);
    },
    
    /** Clears the current focus.
        @returns void */
    clear: function() {
        if (this.focusedView) {
            this.focusedView.blur();
        } else if (this.focusedDom) {
            this.focusedDom.blur();
            this.focusedDom = null;
        }
    },
    
    // Focus Traversal //
    /** Move focus to the next focusable element.
        @param ignoreFocusTrap:boolean If true focus traps will be skipped over.
        @returns void */
    next: function(ignoreFocusTrap) {
        var next = this._traverse(true, ignoreFocusTrap);
        if (next) next.focus();
    },
    
    /** Move focus to the previous focusable element.
        @param ignoreFocusTrap:boolean If true focus traps will be skipped over.
        @returns void */
    prev: function(ignoreFocusTrap) {
        var prev = this._traverse(false, ignoreFocusTrap);
        if (prev) prev.focus();
    },
    
    /** Traverse forward or backward from the currently focused view.
        @param isForward:boolean indicates forward or backward dom traversal.
        @param ignoreFocusTrap:boolean indicates if focus traps should be
            skipped over or not.
        @returns the new view to give focus to, or null if there is no view
            to focus on or an unmanaged dom element will receive focus. */
    _traverse: function(isForward, ignoreFocusTrap) {
        this.lastTraversalWasForward = isForward;
        
        // Determine root element and starting element for traversal.
        var activeElem = document.activeElement, 
            rootElem = document.body,
            startElem = rootElem,
            elem = startElem,
            model, progModel,
            focusFuncName = isForward ? 'getNextFocus' : 'getPrevFocus';
        
        if (activeElem) {
            elem = startElem = activeElem;
            model = startElem.model;
            if (!model) model = this.findModelForDomElement(startElem);
            if (model) {
                var focusTrap = model.getFocusTrap(ignoreFocusTrap);
                if (focusTrap) rootElem = focusTrap.domElement;
            }
        }
        
        // Traverse
        while (elem) {
            if (elem.model && elem.model[focusFuncName] &&
                (progModel = elem.model[focusFuncName]())
            ) {
                // Programatic traverse
                elem = progModel.domElement;
            } else if (isForward) {
                // Dom traverse forward
                if (elem.firstChild) {
                    elem = elem.firstChild;
                } else if (elem === rootElem) {
                    return startElem.model; // TODO: why?
                } else if (elem.nextSibling) {
                    elem = elem.nextSibling;
                } else {
                    // Jump up and maybe over since we're at a local
                    // deepest last child.
                    while (elem) {
                        elem = elem.parentNode;
                        
                        if (elem === rootElem) {
                            break; // TODO: why?
                        } else if (elem.nextSibling) {
                            elem = elem.nextSibling;
                            break;
                        }
                    }
                }
            } else {
                // Dom traverse backward
                if (elem === rootElem) {
                    elem = this.__getDeepestDescendant(rootElem);
                } else if (elem.previousSibling) {
                    elem = this.__getDeepestDescendant(elem.previousSibling);
                } else {
                    elem = elem.parentNode;
                }
            }
            
            // If we've looped back around return the starting element.
            if (elem === startElem) return startElem.model;
            
            // Check that the element is focusable and return it if it is.
            if (elem.nodeType === 1) {
                model = elem.model;
                if (model && model instanceof myt.View) {
                    if (model.isFocusable()) return model;
                } else {
                    var nodeName = elem.nodeName;
                    if (nodeName === 'A' || nodeName === 'AREA' || 
                        nodeName === 'INPUT' || nodeName === 'TEXTAREA' || 
                        nodeName === 'SELECT' || nodeName === 'BUTTON'
                    ) {
                        if (!elem.disabled && !isNaN(elem.tabIndex) && 
                            myt.DomElementProxy.isDomElementVisible(elem)
                        ) {
                            // Make sure the dom element isn't inside a maskFocus
                            model = this.findModelForDomElement(elem);
                            if (model && model.searchAncestorsOrSelf(function(n) {return n.maskFocus === true;})) {
                                // Is a masked dom element so ignore.
                            } else {
                                elem.focus();
                                this.focusedDom = elem;
                                return null;
                            }
                        }
                    }
                }
            }
        }
        
        return null;
    },
    
    /** Finds the closest model for the provided dom element.
        @param elem:domElement to element to start looking from.
        @returns myt.View or null if not found.
        @private */
    findModelForDomElement: function(elem) {
        var model;
        while (elem) {
            model = elem.model;
            if (model && model instanceof myt.View) return model;
            elem = elem.parentNode;
        }
        return null;
    },
    
    /** Gets the deepest dom element that is a descendant of the provided
        dom element or the element itself.
        @param elem:domElement The dom element to search downward from.
        @returns a dom element.
        @private */
    __getDeepestDescendant: function(elem) {
        while (elem.lastChild) elem = elem.lastChild;
        return elem;
    }
});


/** Provides global keyboard events. Registered with myt.global as 'keys'.
    
    Also works with GlobalFocus to navigate the focus hierarchy when the 
    focus traversal keys are used.
    
    Events:
        keydown:number fired when a key is pressed down. The value is the
            keycode of the key pressed down.
        keypress:number fired when a key is pressed. The value is the
            keycode of the key pressed.
        keyup:number fired when a key is released up. The value is the
            keycode of the key released up.
    
    Private Attributes:
        __keysDown:object A map of keycodes of the keys currently pressed down.
    
    Keycodes:
        backspace          8
        tab                9
        enter             13
        shift             16
        ctrl              17
        alt               18
        pause/break       19
        caps lock         20
        escape            27
        spacebar          32
        page up           33
        page down         34
        end               35
        home              36
        left arrow        37
        up arrow          38
        right arrow       39
        down arrow        40
        insert            45
        delete            46
        0                 48
        1                 49
        2                 50
        3                 51
        4                 52
        5                 53
        6                 54
        7                 55
        8                 56
        9                 57
        a                 65
        b                 66
        c                 67
        d                 68
        e                 69
        f                 70
        g                 71
        h                 72
        i                 73
        j                 74
        k                 75
        l                 76
        m                 77
        n                 78
        o                 79
        p                 80
        q                 81
        r                 82
        s                 83
        t                 84
        u                 85
        v                 86
        w                 87
        x                 88
        y                 89
        z                 90
        left window key   91
        right window key  92
        select key        93
        numpad 0          96
        numpad 1          97
        numpad 2          98
        numpad 3          99
        numpad 4         100
        numpad 5         101
        numpad 6         102
        numpad 7         103
        numpad 8         104
        numpad 9         105
        multiply         106
        add              107
        subtract         109
        decimal point    110
        divide           111
        f1               112
        f2               113
        f3               114
        f4               115
        f5               116
        f6               117
        f7               118
        f8               119
        f9               120
        f10              121
        f11              122
        f12              123
        num lock         144
        scroll lock      145
        semi-colon       186
        equal sign       187
        comma            188
        dash             189
        period           190
        forward slash    191
        grave accent     192
        open bracket     219
        back slash       220
        close braket     221
        single quote     222
*/
new JS.Singleton('GlobalKeys', {
    include: [
        myt.DomElementProxy, 
        myt.DomObservable,
        myt.DomObserver,
        myt.KeyObservable,
        myt.Observable,
        myt.Observer
    ],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        // Constants
        this.KEYCODE_SHIFT = 16;
        this.KEYCODE_CONTROL = 17;
        this.KEYCODE_ALT = 18;
        var isFirefox = BrowserDetect.browser === 'Firefox';
        this.KEYCODE_COMMAND = isFirefox ? 224 : 91;
        this.KEYCODE_RIGHT_COMMAND = isFirefox ? 224 : 93;
        
        this.setDomElement(document);
        this.attachTo(myt.global.focus, '__handleFocused', 'focused');
        this.__keysDown = {};
        this.__listenToDocument();
        
        myt.global.register('keys', this);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Tests if a key is currently pressed down or not.
        @param keyCode:number the key to test.
        @returns true if the key is down, false otherwise. */
    isKeyDown: function(keyCode) {
        return !!this.__keysDown[keyCode];
    },
    
    /** Tests if the 'shift' key is down. */
    isShiftKeyDown: function() {return this.isKeyDown(this.KEYCODE_SHIFT);},
    
    /** Tests if the 'control' key is down. */
    isControlKeyDown: function() {return this.isKeyDown(this.KEYCODE_CONTROL);},
    
    /** Tests if the 'alt' key is down. */
    isAltKeyDown: function() {return this.isKeyDown(this.KEYCODE_ALT);},
    
    /** Tests if the 'command' key is down. */
    isCommandKeyDown: function() {
        return this.isKeyDown(this.KEYCODE_COMMAND) || this.isKeyDown(this.KEYCODE_RIGHT_COMMAND);
    },
    
    /** @private */
    __handleFocused: function(event) {
        var focused = event.value;
        if (focused) {
            this.__unlistenToDocument();
            
            this.attachToDom(focused, '__handleKeyDown', 'keydown');
            this.attachToDom(focused, '__handleKeyPress', 'keypress');
            this.attachToDom(focused, '__handleKeyUp', 'keyup');
        } else {
            var prevFocused = myt.global.focus.prevFocusedView;
            if (prevFocused) {
                this.detachFromDom(prevFocused, '__handleKeyDown', 'keydown');
                this.detachFromDom(prevFocused, '__handleKeyPress', 'keypress');
                this.detachFromDom(prevFocused, '__handleKeyUp', 'keyup');
            }
            
            this.__listenToDocument();
        }
    },
    
    /** @private */
    __listenToDocument: function() {
        this.attachToDom(this, '__handleKeyDown', 'keydown');
        this.attachToDom(this, '__handleKeyPress', 'keypress');
        this.attachToDom(this, '__handleKeyUp', 'keyup');
    },
    
    /** @private */
    __unlistenToDocument: function() {
        this.detachFromDom(this, '__handleKeyDown', 'keydown');
        this.detachFromDom(this, '__handleKeyPress', 'keypress');
        this.detachFromDom(this, '__handleKeyUp', 'keyup');
    },
    
    /** @private */
    __handleKeyDown: function(event) {
        var keyCode = myt.KeyObservable.getKeyCodeFromEvent(event),
            domEvent = event.value;
        if (this.__shouldPreventDefault(keyCode, domEvent.target)) domEvent.preventDefault();
        
        // Keyup events do not fire when command key is down so fire a keyup
        // event immediately. Not an issue for other meta keys: shift, ctrl 
        // and option.
        if (this.isCommandKeyDown() && keyCode !== 16 && keyCode !== 17 && keyCode !== 18) {
            this.fireNewEvent('keydown', keyCode);
            this.fireNewEvent('keyup', keyCode);
            
            // Assume command key goes back up since it is common for the page
            // to lose focus after the command key is used. Do this for every 
            // key other than 'z' since repeated undo/redo is 
            // nice to have and doesn't typically result in loss of focus 
            // to the page.
            if (keyCode !== 90) {
                this.fireNewEvent('keyup', this.KEYCODE_COMMAND);
                this.__keysDown[this.KEYCODE_COMMAND] = false;
            }
        } else {
            this.__keysDown[keyCode] = true;
            
            // Check for 'tab' key and do focus traversal.
            if (keyCode === 9) {
                var ift = this.ignoreFocusTrap(), gf = myt.global.focus;
                if (this.isShiftKeyDown()) {
                    gf.prev(ift);
                } else {
                    gf.next(ift);
                }
            }
            
            this.fireNewEvent('keydown', keyCode);
        }
    },
    
    ignoreFocusTrap: function() {
        return this.isAltKeyDown();
    },
    
    /** @private */
    __handleKeyPress: function(event) {
        var keyCode = myt.KeyObservable.getKeyCodeFromEvent(event);
        this.fireNewEvent('keypress', keyCode);
    },
    
    /** @private */
    __handleKeyUp: function(event) {
        var keyCode = myt.KeyObservable.getKeyCodeFromEvent(event),
            domEvent = event.value;
        if (this.__shouldPreventDefault(keyCode, domEvent.target)) domEvent.preventDefault();
        this.__keysDown[keyCode] = false;
        this.fireNewEvent('keyup', keyCode);
    },
    
    /** @private */
    __shouldPreventDefault: function(keyCode, targetElem) {
        switch (keyCode) {
            case 8: // Backspace
                // Catch backspace since it navigates the history. Allow it to
                // go through for text input elements though.
                var nodeName = targetElem.nodeName;
                if (nodeName === 'TEXTAREA' || 
                    (nodeName === 'INPUT' && (targetElem.type === 'text' || targetElem.type === 'password')) ||
                    (nodeName === 'DIV' && targetElem.contentEditable === 'true' && targetElem.firstChild)
                ) return false;
                
                return true;
                
            case 9: // Tab
                // Tab navigation is handled by the framework.
                return true;
        }
        return false;
    }
});


/** Generates Touch Events and passes them on to one or more event observers.
    
    Requires: myt.DomObservable super mixin.
*/
myt.TouchObservable = new JS.Module('TouchObservable', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of supported touch event types. */
        EVENT_TYPES:{
            touchstart:true,
            touchend:true,
            touchmove:true
        },
        
        /** The common touch event that gets reused. */
        EVENT:{source:null, type:null, value:null}
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DomObservable */
    createDomMethodRef: function(domObserver, methodName, type) {
        return this.createStandardDomMethodRef(domObserver, methodName, type, myt.TouchObservable, false) || 
            this.callSuper(domObserver, methodName, type);
    }
});


/** Provides global touch events by listening to touch events on the the
    document. Registered with myt.global as 'touch'. */
new JS.Singleton('GlobalTouch', {
    include: [myt.DomElementProxy, myt.DomObservable, myt.TouchObservable],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        this.setDomElement(document);
        
        myt.global.register('touch', this);
    }
});


/** Exposes browser history events generated by history.js.
    
    Events:
        statechange: Fired when the state of the page 
            changes (does not include hash changes)
        anchorchange: Fired when the anchor of the page 
            changes (does not include state hashes)
    
    Private Attributes:
        _notFirstTime:boolean Indicates if this is the first time an attempt
            is made to update the state. This prevents an extra state from
            being inserted when first navigating to the app.
*/
new JS.Singleton('GlobalHistory', {
    include: [myt.Observable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initialize: function() {
        myt.global.register('history', this);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    updateState: function(data, title, url) {
        if (this._notFirstTime) {
            History.pushState(data, title, url);
        } else {
            History.replaceState(data, title, url);
            this._notFirstTime = true;
        }
    },
    
    startMonitoringState: function(monitor) {
        monitor.attachTo(this, 'handleStateChange', 'statechange');
        var state = History.getState();
        monitor.handleStateChange({value:state});
        History.setTitle(state); // Title doesn't get updated for the initial page load.
    },
    
    // Disable History Navigation
    /** Enables or disables the browser forward/back history buttons so that
        they do nothing.
        See http://programmerslate.blogspot.com/2013/06/disable-back-button-of-your-browser.html
        @param enabled:boolean Indicates if history should be enabled or not.
        @returns void */
    enableHistoryNavigation: function(enabled) {
        var location = global.location;
        if (enabled) {
            location.hash = '';
        } else {
            location.hash = "no-back-button";
            location.hash = "Again-no-back-button"; // Again because google chrome don't insert first hash into history
        }
        global.onhashchange = enabled ? null : function() {location.hash = "no-back-button";};
    }
});

if (!global.mytNoHistoryShim) { // FIXME: remove conditional once old code has been updated.
    History.Adapter.bind(window, 'statechange', function(event) {
        myt.global.history.fireNewEvent('statechange', History.getState());
    });
    
    History.Adapter.bind(window, 'anchorchange', function(event) {
        myt.global.history.fireNewEvent('anchorchange', History.getState());
    });
}


/** Provides support for getter and setter functions on an object. */
myt.AccessorSupport = new JS.Module('AccessorSupport', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Generate a setter name for an attribute.
            @returns string */
        generateSetterName: function(attrName) {
            return this.SETTER_NAMES[attrName] || (this.SETTER_NAMES[attrName] = this.generateName(attrName, 'set'));
        },
        
        /** Generate a getter name for an attribute.
            @returns string */
        generateGetterName: function(attrName) {
            return this.GETTER_NAMES[attrName] || (this.GETTER_NAMES[attrName] = this.generateName(attrName, 'get'));
        },
        
        /** Generates a method name by capitalizing the attrName and
            prepending the prefix.
            @returns string */
        generateName: function(attrName, prefix) {
            return prefix + attrName.substring(0,1).toUpperCase() + attrName.substring(1);
        },
        
        /** Creates a standard setter function for the provided attrName on the
            target. This assumes the target is an myt.Observable.
            @returns void */
        createSetterFunction: function(target, attrName) {
            var setterName = this.generateSetterName(attrName);
            if (target[setterName]) console.log("Overwriting setter", setterName);
            target[setterName] = function(v) {
                if (target[attrName] !== v) {
                    target[attrName] = v;
                    if (target.inited) target.fireNewEvent(attrName, v);
                }
            };
        },
        
        /** Creates a standard getter function for the provided attrName on the
            target.
            @returns void */
        createGetterFunction: function(target, attrName) {
            var getterName = this.generateGetterName(attrName);
            if (target[getterName]) console.log("Overwriting getter", getterName);
            target[getterName] = function() {
                return target[attrName];
            };
        },
        
        /** Caches getter names. */
        GETTER_NAMES:{},
        
        /** Caches setter names. */
        SETTER_NAMES:{}
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Calls a setter function for each attribute in the provided map.
        @param attrs:object a map of attributes to set.
        @returns void. */
    callSetters: function(attrs) {
        for (var attrName in attrs) this.set(attrName, attrs[attrName]);
    },
    
    /** A generic getter function that can be called to get a value from this
        object. Will defer to a defined getter if it exists.
        @param attrName:string The name of the attribute to get.
        @returns the attribute value. */
    get: function(attrName) {
        var getterName = myt.AccessorSupport.generateGetterName(attrName);
        return this[getterName] ? this[getterName]() : this[attrName];
    },
    
    /** A generic setter function that can be called to set a value on this
        object. Will defer to a defined setter if it exists. The implementation
        assumes this object is an Observable so it will have a 'fireNewEvent'
        method.
        @param attrName:string The name of the attribute to set.
        @param v:* The value to set.
        @param noSetter:boolean (optional) If true no attempt will be made to
            invoke a setter function. Useful when you want to invoke standard 
            setter behavior. Defaults to undefined which is equivalent to false.
        @returns void */
    set: function(attrName, v, noSetter) {
        if (!noSetter) {
            var setterName = myt.AccessorSupport.generateSetterName(attrName);
            if (this[setterName]) return this[setterName](v);
        }
        
        if (this[attrName] !== v) {
            this[attrName] = v;
            if (this.inited !== false && this.fireNewEvent) this.fireNewEvent(attrName, v); // !== false allows this to work with non-nodes.
        }
    },
    
    /** Checks if an attribute is not null or undefined.
        @param attrName:string The name of the attribute to check.
        @returns true if the attribute value is not null or undefined. */
    has: function(attrName) {
        return this.get(attrName) != null;
    },
    
    /** Checks if an attribute is exactly true.
        @param attrName:string The name of the attribute to check.
        @returns true if the attribute value is === true. */
    is: function(attrName) {
        return this.get(attrName) === true;
    },
    
    /** Checks if an attribute is not exactly true. Note: this is not the same
        as testing exactly false.
        @param attrName:string The name of the attribute to check.
        @returns true if the attribute value is !== true. */
    isNot: function(attrName) {
        return this.get(attrName) !== true;
    }
});


/** Provides a destroy method that can be used as part of an Object creation
    and destruction lifecycle. When an object is "destroyed" it will have
    a 'destroyed' attribute with a value of true.
    
    Events:
        None
    
    Attributes:
        destroyed:boolean Set to true when the object is in the "destroyed"
            state, undefinded otherwise.
*/
myt.Destructible = new JS.Module('Destructible', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Destroys this Object. Subclasses must call super.
        @returns void */
    destroy: function() {
        // See http://perfectionkills.com/understanding-delete/ for details
        // on how delete works. This is why we use Object.keys below since it
        // avoids iterating over many of the properties that are not deletable.
        var keys, i;
        
        // OPTIMIZATION: Improve garbage collection for JS.Class
        var meta = this.__meta__;
        if (meta) {
            keys = Object.keys(meta);
            i = keys.length;
            while (i) delete meta[keys[--i]];
        }
        
        keys = Object.keys(this);
        i = keys.length;
        while (i) delete this[keys[--i]];
        
        this.destroyed = true;
    }
});


/** Objects that can be used in an myt.AbstractPool should use this mixin and 
    implement the "clean" method. */
myt.Reusable = new JS.Module('Reusable', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Puts this object back into a default state suitable for storage in
        an myt.AbstractPool
        @returns void */
    clean: function() {}
});


/** Implements an object pool. Subclasses must at a minimum implement the 
    createInstance method.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __objPool:array The array of objects stored in the pool.
*/
myt.AbstractPool = new JS.Class('AbstractPool', {
    include: [myt.Destructible],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    /** Initialize does nothing. */
    initialize: function() {},
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Destructible */
    destroy: function() {
        var objPool = this.__objPool;
        if (objPool) objPool.length = 0;
        
        this.callSuper();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Get an instance from the pool.
        @param arguments:arguments (optional) arguments to be passed to the
            createInstance method. Note: these have no effect if an object
            already exists in the pool.
        @returns object */
    getInstance: function() {
        var objPool = this.__objPool;
        if (!objPool) objPool = this.__objPool = [];
        
        return objPool.length ? objPool.pop() : this.createInstance.apply(this, arguments);
    },
    
    /** Creates a new object that can be stored in the pool. The default
        implementation does nothing. */
    createInstance: function() {
        return null;
    },
    
    /** Puts the object back in the pool. The object will be "cleaned"
        before it is stored.
        @param obj:object the object to put in the pool.
        @returns void */
    putInstance: function(obj) {
        var objPool = this.__objPool;
        if (!objPool) objPool = this.__objPool = [];
        
        objPool.push(this.cleanInstance(obj));
    },
    
    /** Cleans the object in preparation for putting it back in the pool. The
        default implementation calls the clean method on the object if it is
        a myt.Reusable. Otherwise it does nothing.
        @param obj:object the object to be cleaned.
        @returns object the cleaned object. */
    cleanInstance: function(obj) {
        if (typeof obj.clean === 'function') obj.clean();
        return obj;
    },
    
    /** Calls the destroy method on all object stored in the pool if they
        have a destroy function.
        @returns void */
    destroyPooledInstances: function() {
        var objPool = this.__objPool;
        if (objPool) {
            var i = objPool.length, obj;
            while (i) {
                obj = objPool[--i];
                if (typeof obj.destroy === 'function') obj.destroy();
            }
        }
    }
});


/** An implementation of an myt.AbstractPool.
    
    Events
        None
    
    Attributes:
        instanceClass:JS.Class (initializer only) the class to use for 
            new instances. Defaults to Object.
        instanceParent:myt.Node (initializer only) The node to create new
            instances on.
*/
myt.SimplePool = new JS.Class('SimplePool', myt.AbstractPool, {
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new myt.SimplePool
        @param instanceClass:JS.Class the class to create instances from.
        @param instanceParent:object (optional) The place to create instances 
            on. When instanceClass is an myt.Node this will be the node parent.
        @returns void */
    initialize: function(instanceClass, instanceParent) {
        this.callSuper();
        
        this.instanceClass = instanceClass || Object;
        this.instanceParent = instanceParent;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.AbstractPool
        Creates an instance of this.instanceClass and passes in 
        this.instanceParent as the first argument if it exists.
        @param arguments[0]:object (optional) the attrs to be passed to a
            created myt.Node. */
    createInstance: function() {
        // If we ever need full arguments with new, see:
        // http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible
        var parent = this.instanceParent, instanceClass = this.instanceClass;
        return parent ? new instanceClass(parent, arguments[0]) : new instanceClass();
    }
});


/** An myt.SimplePool that tracks which objects are "active". An "active"
    object is one that has been obtained by the getInstance method.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __actives:array an array of active instances.
*/
myt.TrackActivesPool = new JS.Class('TrackActivesPool', myt.SimplePool, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Destructible */
    destroy: function() {
        var actives = this.__actives;
        if (actives) actives.length = 0;
        
        this.callSuper();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.AbstractPool */
    getInstance: function() {
        var instance = this.callSuper();
        (this.__actives || (this.__actives = [])).push(instance);
        return instance;
    },
    
    /** @overrides myt.AbstractPool */
    putInstance: function(obj) {
        var actives = this.__actives;
        if (actives) {
            var i = actives.length;
            while (i) {
                if (actives[--i] === obj) {
                    actives.splice(i, 1);
                    this.callSuper(obj);
                    return;
                }
            }
            console.warn("Attempt to putInstance for a non-active instance.", obj, this);
        } else {
            console.warn("Attempt to putInstance when no actives exist.", obj, this);
        }
    },
    
    /** Gets an array of the active instances.
        @param filterFunc:function (optional) If provided filters the
            results.
        @returns array */
    getActives: function(filterFunc) {
        var actives = this.__actives;
        if (actives) {
            if (filterFunc) {
                var retval = [], len = actives.length, i = 0, active;
                for (; len > i;) {
                    active = actives[i++];
                    if (filterFunc.call(this, active)) retval.push(active);
                }
                return retval;
            }
            return actives.concat();
        }
        return [];
    },
    
    /** Puts all the active instances back in the pool.
        @returns void */
    putActives: function() {
        var actives = this.__actives;
        if (actives) {
            var i = actives.length;
            while (i) this.putInstance(actives[--i]);
        }
    }
});


/** A single node within a tree data structure. A node has zero or one parent 
    node and zero or more child nodes. If a node has no parent it is a 'root' 
    node. If a node has no child nodes it is a 'leaf' node. Parent nodes and 
    parent of parents, etc. are referred to as ancestors. Child nodes and 
    children of children, etc. are referred to as descendants.
    
    Lifecycle management is also provided via the 'initNode', 'doBeforeAdoption',
    'doAfterAdoption', 'destroy', 'destroyBeforeOrphaning' and
    'destroyAfterOrphaning' methods.
    
    Events:
        parent:myt.Node Fired when the parent is set.
    
    Attributes:
        inited:boolean Set to true after this Node has completed initializing.
        parent:myt.Node The parent of this Node.
        name:string The name of this node. Used to reference this Node from
            its parent Node.
        isBeingDestroyed:boolean Indicates that this node is in the process
            of being destroyed. Set to true at the beginning of the destroy
            lifecycle phase. Undefined before that.
        placement:string The name of the subnode of this Node to add nodes to 
            when setParent is called on the subnode. Placement can be nested 
            using '.' For example 'foo.bar'. The special value of '*' means 
            use the default placement. For example 'foo.*' means place in the 
            foo subnode and then in the default placement for foo.
        defaultPlacement:string The name of the subnode to add nodes to when 
            no placement is specified. Defaults to undefined which means add
            subnodes directly to this node.
        ignorePlacement:boolean If set to true placement will not be processed 
            for this Node when it is added to a parent Node.
    
    Private Attributes:
        __animPool:array An myt.TrackActivesPool used by the 'animate' method.
        subnodes:array The array of child nodes for this node. Should be
            accessed through the getSubnodes method.
*/
myt.Node = new JS.Class('Node', {
    include: [myt.AccessorSupport, myt.Destructible, myt.Observable, myt.Constrainable],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Get the closest ancestor of the provided Node or the Node itself for 
            which the matcher function returns true.
            @param n:myt.Node the Node to start searching from.
            @param matcher:function the function to test for matching Nodes with.
            @returns Node or null if no match is found. */
        getMatchingAncestorOrSelf: function(n, matcherFunc) {
            if (n && matcherFunc) {
                while (n) {
                    if (matcherFunc(n)) return n;
                    n = n.parent;
                }
            }
            return null;
        },
        
        /** Get the youngest ancestor of the provided Node for which the 
            matcher function returns true.
            @param n:myt.Node the Node to start searching from. This Node is not
                tested, but its parent is.
            @param matcher:function the function to test for matching Nodes with.
            @returns Node or null if no match is found. */
        getMatchingAncestor: function(n, matcherFunc) {
            return this.getMatchingAncestorOrSelf(n ? n.parent : null, matcherFunc);
        },
        
        /** A convienence method to execute a method once after a delay.
            @param target:object The object to call the method on.
            @param methodName:string The name of the method on this object
                to execute.
            @param delay:number (optional) The time to wait in millis. Defaults 
                to 0.
            @param arguments Remaining arguments will be passed to the called
                method in the order provided.
            @returns number: The timer ID if the timer is started, othewise
                undefined is returned. */
        doOnceLater: function() {
            var params = Array.prototype.slice.call(arguments),
                target = params.shift(),
                methodName = params.shift(),
                delay = params.shift();
            
            if (target) {
                var method = target[methodName];
                if (method) {
                    params.unshift(target);
                    return setTimeout(method.bind.apply(method, params), delay >= 0 ? delay : 0);
                }
            }
        }
    },
    
    
    // Constructor /////////////////////////////////////////////////////////////
    /** The standard JSClass initializer function. Subclasses should not
        override this function.
        @param parent:Node (or dom element for RootViews) (Optional) the parent 
            of this Node.
        @param attrs:object (Optional) A map of attribute names and values.
        @param mixins:array (Optional) a list of mixins to be added onto
            the new instance.
        @returns void */
    initialize: function(parent, attrs, mixins) {
        if (mixins) {
            var i = 0, len = mixins.length, mixin;
            for (; len > i;) {
                mixin = mixins[i++];
                if (mixin) {
                    this.extend(mixin);
                } else {
                    console.warn("Undefined mixin in initialization of: " + this.klass.__displayName);
                }
            }
        }
        
        this.inited = false;
        this.initNode(parent, attrs || {});
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** Called during initialization. Sets initial state for life cycle attrs,
        calls setter methods, sets parent and lastly, sets inited to true.
        Subclasses must callSuper.
        @param parent:Node (or dom element for RootViews) the parent of 
            this Node.
        @param attrs:object A map of attribute names and values.
        @returns void */
    initNode: function(parent, attrs) {
        this.callSetters(attrs);
        
        this.doBeforeAdoption();
        this.setParent(parent);
        this.doAfterAdoption();
        
        this.inited = true;
    },
    
    /** Provides a hook for subclasses to do things before this Node has its
        parent assigned. This would be the ideal place to create subviews
        so as to avoid unnecessary dom reflows. However, text size can't
        be measured until insertion into the DOM so you may want to use
        doAfterAdoption for creating subviews since it will give you less
        trouble though it will be slower.
        @returns void */
    doBeforeAdoption: function() {},
    
    /** Provides a hook for subclasses to do things after this Node has its
        parent assigned.
        @returns void */
    doAfterAdoption: function() {},
    
    /** @overrides myt.Destructible. */
    destroy: function() {
        // Allows descendants to know destruction is in process
        this.isBeingDestroyed = true;
        
        // Destroy subnodes depth first
        var subs = this.subnodes;
        if (subs) {
            var i = subs.length;
            while (i) subs[--i].destroy();
        }
        
        if (this.__animPool) {
            this.stopActiveAnimators();
            this.__animPool.destroy();
        }
        
        this.destroyBeforeOrphaning();
        if (this.parent) this.setParent(null);
        this.destroyAfterOrphaning();
        
        this.callSuper();
    },
    
    /** Provides a hook for subclasses to do destruction of their internals.
        This method is called after subnodes have been destroyed but before
        the parent has been unset.
        Subclasses should call super.
        @returns void */
    destroyBeforeOrphaning: function() {},
    
    /** Provides a hook for subclasses to do destruction of their internals.
        This method is called after the parent has been unset.
        Subclasses must call super.
        @returns void */
    destroyAfterOrphaning: function() {
        this.releaseAllConstraints();
        this.detachFromAllObservables();
        this.detachAllObservers();
    },
    
    
    // Structural Accessors ////////////////////////////////////////////////////
    setPlacement: function(v) {this.placement = v;},
    setDefaultPlacement: function(v) {this.defaultPlacement = v;},
    setIgnorePlacement: function(v) {this.ignorePlacement = v;},
    
    /** Sets the provided Node as the new parent of this Node. This is the
        most direct method to do reparenting. You can also use the addSubnode
        method but it's just a wrapper around this setter. */
    setParent: function(newParent) {
        // Use placement if indicated
        if (newParent && !this.ignorePlacement) {
            var placement = this.placement || newParent.defaultPlacement;
            if (placement) newParent = newParent.determinePlacement(placement, this);
        }
        
        if (this.parent !== newParent) {
            // Abort if the new parent is in the destroyed life-cycle state.
            if (newParent && newParent.destroyed) return;
            
            // Remove ourselves from our existing parent if we have one.
            var curParent = this.parent;
            if (curParent) {
                var idx = curParent.getSubnodeIndex(this);
                if (idx !== -1) {
                    if (this.name) curParent.__removeNameRef(this);
                    curParent.subnodes.splice(idx, 1);
                    curParent.subnodeRemoved(this);
                }
            }
            
            this.parent = newParent;
            
            // Add ourselves to our new parent
            if (newParent) {
                newParent.getSubnodes().push(this);
                if (this.name) newParent.__addNameRef(this);
                newParent.subnodeAdded(this);
            }
            
            // Fire an event
            if (this.inited) this.fireNewEvent('parent', newParent);
        }
    },
    
    /** The 'name' of a Node allows it to be referenced by name from its
        parent node. For example a Node named 'foo' that is a child of a
        Node stored in the var 'bar' would be referenced like this: bar.foo or
        bar['foo']. */
    setName: function(name) {
        if (this.name !== name) {
            // Remove "name" reference from parent.
            var p = this.parent;
            if (p && this.name) p.__removeNameRef(this);
            
            this.name = name;
            
            // Add "name" reference to parent.
            if (p && name) p.__addNameRef(this);
        }
    },
    
    /** Gets the subnodes for this Node and does lazy instantiation of the 
        subnodes array if no child Nodes exist.
        @returns array of subnodes. */
    getSubnodes: function() {
        return this.subnodes || (this.subnodes = []);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called from setParent to determine where to insert a subnode in the node
        hierarchy. Subclasses will not typically override this method, but if
        they do, they probably won't need to call super.
        @param placement:string the placement path to use.
        @param subnode:myt.Node the subnode being placed.
        @returns the Node to place a subnode into. */
    determinePlacement: function(placement, subnode) {
        // Parse "active" placement and remaining placement.
        var idx = placement.indexOf('.'), remainder, loc;
        if (idx !== -1) {
            remainder = placement.substring(idx + 1);
            placement = placement.substring(0, idx);
        }
        
        // Evaluate placement of '*' as defaultPlacement.
        if (placement === '*') {
            placement = this.defaultPlacement;
            
            // Default placement may be compound and thus require splitting
            if (placement) {
                idx = placement.indexOf('.');
                if (idx !== -1) {
                    remainder = placement.substring(idx + 1) + (remainder ? '.' + remainder : '');
                    placement = placement.substring(0, idx);
                }
            }
            
            // It's possible that a placement of '*' comes out here if a
            // Node has its defaultPlacement set to '*'. This should result
            // in a null loc when the code below runs which will end up
            // returning 'this'.
        }
        
        loc = this[placement];
        return loc ? (remainder ? loc.determinePlacement(remainder, subnode) : loc) : this;
    },
    
    /** Adds a named reference to a subnode.
        @param node:Node the node to add the name reference for.
        @returns void */
    __addNameRef: function(node) {
        var name = node.name;
        if (this[name] === undefined) {
            this[name] = node;
        } else {
            console.log("Name in use:" + name);
        }
    },
    
    /** Removes a named reference to a subnode.
        @param node:Node the node to remove the name reference for.
        @returns void */
    __removeNameRef: function(node) {
        var name = node.name;
        if (this[name] === node) {
            delete this[name];
        } else {
            console.log("Name not in use:" + name);
        }
    },
    
    // Tree Methods //
    /** Gets the root Node for this Node. The root Node is the oldest
        ancestor or self that has no parent.
        @returns Node */
    getRoot: function() {
        return this.parent ? this.parent.getRoot() : this;
    },
    
    /** Checks if this Node is a root Node.
        @returns boolean */
    isRoot: function() {
        return this.parent == null;
    },
    
    /** Tests if this Node is a descendant of the provided Node or is the
        node itself.
        @returns boolean */
    isDescendantOf: function(node) {
        if (node) {
            if (node === this) return true;
            if (this.parent) {
                // Optimization: use the dom element contains function if 
                // both nodes are DomElementProxy instances.
                if (this.domElement && node.domElement) {
                    return node.domElement.contains(this.domElement);
                }
                return this.parent.isDescendantOf(node);
            }
        }
        return false;
    },
    
    /** Tests if this Node is an ancestor of the provided Node or is the
        node itself.
        @param node:Node the node to check for.
        @returns boolean */
    isAncestorOf: function(node) {
        return node ? node.isDescendantOf(this) : false;
    },
    
    /** Gets the youngest common ancestor of this node and the provided node.
        @param node:myt.Node The node to look for a common ancestor with.
        @returns The youngest common Node or null if none exists. */
    getLeastCommonAncestor: function(node) {
        while (node) {
            if (this.isDescendantOf(node)) return node;
            node = node.parent;
        }
        return null;
    },
    
    /** Find the youngest ancestor Node that is an instance of the class.
        @param klass the Class to search for.
        @returns Node or null if no klass is provided or match found. */
    searchAncestorsForClass: function(klass) {
        return klass ? this.searchAncestors(function(n) {return n instanceof klass;}) : null;
    },
    
    /** Get the youngest ancestor of this Node for which the matcher function 
        returns true. This is a simple wrapper around 
        myt.Node.getMatchingAncestor(this, matcherFunc).
        @param matcherFunc:function the function to test for matching 
            Nodes with.
        @returns Node or null if no match is found. */
    searchAncestors: function(matcherFunc) {
        return myt.Node.getMatchingAncestor(this, matcherFunc);
    },
    
    /** Get the youngest ancestor of this Node or the Node itself for which 
        the matcher function returns true. This is a simple wrapper around 
        myt.Node.getMatchingAncestorOrSelf(this, matcherFunc).
        @param matcherFunc:function the function to test for matching 
            Nodes with.
        @returns Node or null if no match is found. */
    searchAncestorsOrSelf: function(matcherFunc) {
        return myt.Node.getMatchingAncestorOrSelf(this, matcherFunc);
    },
    
    /** Gets an array of ancestor nodes including the node itself.
        @returns array: The array of ancestor nodes. */
    getAncestors: function() {
        var ancestors = [], node = this;
        while (node) {
            ancestors.push(node);
            node = node.parent;
        }
        return ancestors;
    },
    
    // Subnode Methods //
    /** Checks if this Node has the provided Node in the subnodes array.
        @param node:Node the subnode to check for.
        @returns true if the subnode is found, false otherwise. */
    hasSubnode: function(node) {
        return this.getSubnodeIndex(node) !== -1;
    },
    
    /** Gets the index of the provided Node in the subnodes array.
        @param node:Node the subnode to get the index for.
        @returns the index of the subnode or -1 if not found. */
    getSubnodeIndex: function(node) {
        return this.getSubnodes().indexOf(node);
    },
    
    /** A convienence method to make a Node a child of this Node. The
        standard way to do this is to call the setParent method on the
        prospective child Node.
        @param node:Node the subnode to add.
        @returns void */
    addSubnode: function(node) {
        node.setParent(this);
    },
    
    /** A convienence method to make a Node no longer a child of this Node. The
        standard way to do this is to call the setParent method with a value
        of null on the child Node.
        @param node:Node the subnode to remove.
        @returns the removed Node or null if removal failed. */
    removeSubnode: function(node) {
        if (node.parent !== this) return null;
        node.setParent(null);
        return node;
    },
    
    /** Called when a subnode is added to this node. Provides a hook for
        subclasses. No need for subclasses to call super. Do not call this
        method to add a subnode. Instead call addSubnode or setParent.
        @param node:Node the subnode that was added.
        @returns void */
    subnodeAdded: function(node) {},
    
    /** Called when a subnode is removed from this node. Provides a hook for
        subclasses. No need for subclasses to call super. Do not call this
        method to remove a subnode. Instead call removeSubnode or setParent.
        @param node:Node the subnode that was removed.
        @returns void */
    subnodeRemoved: function(node) {},
    
    // Animation
    /** A wrapper on Node.animate that will only animate one time and that 
        provides a streamlined list of the most commonly used arguments.
        @param attribute:string/object the name of the attribute to animate. If
            an object is provided it should be the only argument and its keys
            should be the params of this method. This provides a more concise
            way of passing in sparse optional parameters.
        @param to:number the target value to animate to.
        @param from:number the target value to animate from. (optional)
        @param duration:number (optional)
        @param easingFunction:function (optional)
        @returns The Animator being run. */
    animateOnce: function(attribute, to, from, duration, easingFunction) {
        return this.animate(attribute, to, from, false, null, duration, false, 1, easingFunction);
    },
    
    /** Animates an attribute using the provided parameters.
        @param attribute:string/object the name of the attribute to animate. If
            an object is provided it should be the only argument and its keys
            should be the params of this method. This provides a more concise
            way of passing in sparse optional parameters.
        @param to:number the target value to animate to.
        @param from:number the target value to animate from. (optional)
        @param relative:boolean (optional)
        @param callback:function (optional)
        @param duration:number (optional)
        @param reverse:boolean (optional)
        @param repeat:number (optional)
        @param easingFunction:function (optional)
        @returns The Animator being run. */
    animate: function(attribute, to, from, relative, callback, duration, reverse, repeat, easingFunction) {
        var animPool = this.__getAnimPool();
        
        // ignorePlacement ensures the animator is directly attached to this node
        var anim = animPool.getInstance({ignorePlacement:true});
        
        if (typeof attribute === 'object') {
            // Handle a single map argument if provided
            callback = attribute.callback;
            delete attribute.callback;
            anim.callSetters(attribute);
        } else {
            // Handle individual arguments
            anim.attribute = attribute;
            anim.setTo(to);
            anim.setFrom(from);
            if (duration != null) anim.duration = duration;
            if (relative != null) anim.relative = relative;
            if (repeat != null) anim.repeat = repeat;
            if (reverse != null) anim.setReverse(reverse);
            if (easingFunction != null) anim.setEasingFunction(easingFunction);
        }
        
        // Release the animation when it completes.
        anim.next(function(success) {animPool.putInstance(anim);});
        if (callback) anim.next(callback);
        
        anim.setRunning(true);
        return anim;
    },
    
    /** Gets an array of the currently running animators that were created
        by calls to the animate method.
        @param filterFunc:function/string a function that filters which 
            animations get stopped. The filter should return true for 
            functions to be included. If the provided values is a string it will
            be used as a matching attribute name.
        @returns an array of active animators. */
    getActiveAnimators: function(filterFunc) {
        if (typeof filterFunc === 'string') {
            var attrName = filterFunc;
            filterFunc = function(anim) {return anim.attribute === attrName;};
        }
        return this.__getAnimPool(filterFunc).getActives();
    },
    
    /** Stops all active animations.
        @param filterFunc:function/string a function that filters which 
            animations get stopped. The filter should return true for 
            functions to be stopped. If the provided values is a string it will
            be used as a matching attribute name.
        @returns void */
    stopActiveAnimators: function(filterFunc) {
        var activeAnims = this.getActiveAnimators(filterFunc), i = activeAnims.length, anim;
        if (i > 0) {
            var animPool = this.__getAnimPool();
            while (i) {
                anim = activeAnims[--i];
                anim.reset(false);
                animPool.putInstance(anim);
            }
        }
    },
    
    /** Gets the animation pool if it exists, or lazy instantiates it first
        if necessary.
        @private
        @returns myt.TrackActivesPool */
    __getAnimPool: function() {
        return this.__animPool || (this.__animPool = new myt.TrackActivesPool(myt.Animator, this));
    },
    
    // Timing and Delay
    /** A convienence method to execute a method once on idle.
        @param methodName:string The name of the method to execute on
            this object.
        @returns void */
    doOnceOnIdle: function(methodName) {
        this.attachTo(myt.global.idle, methodName, 'idle', true);
    },
    
    /** A convienence method to execute a method once after a delay.
        @param methodName:string The name of the method on this object
            to execute.
        @param delay:number (optional) The time to wait in millis. Defaults 
            to 0.
        @param arguments Remaining arguments will be passed to the called
            method in the order provided.
        @returns number: The timer ID if the timer is started, othewise
            undefined is returned. */
    doOnceLater: function() {
        var params = Array.prototype.slice.call(arguments);
        params.unshift(this);
        return myt.Node.doOnceLater.apply(this, arguments);
    }
});


/** A counter that can be incremented and decremented and will update an
    'exceeded' attribute when a threshold is crossed. */
myt.ThresholdCounter = new JS.Class('ThresholdCounter', {
    include: [myt.AccessorSupport, myt.Destructible, myt.Observable],
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Mixes ThresholdCounter functionality onto the provided scope.
            @param scope:Observable|Class|Module the scope to mix onto.
            @param exceededAttrName:string the name of the boolean attribute
                that will indicate if the threshold is exceeded or not.
            @param counterAttrName:string (Optional) the name of the number
                attribute that will get adjusted up and down. If not provided
                the 'exceeded' attribute name will be used with 'Counter'
                appended to it. For example if the exceeded
                attribute was 'locked' this would be 'lockedCounter'.
            @param thresholdAttrName:string (Optional) the name of the number
                attribute that determines when we are exceeded or not. If not 
                provided the 'exceeded' attribute name will be used with 
                'Threshold' appended to it. For example if the exceeded
                attribute was 'locked' this would be 'lockedThreshold'.
            @returns boolean True if creation succeeded, false otherwise. */
        createThresholdCounter: function(scope, exceededAttrName, counterAttrName, thresholdAttrName) {
            var genNameFunc = myt.AccessorSupport.generateName;
            counterAttrName = counterAttrName || genNameFunc('counter', exceededAttrName);
            thresholdAttrName = thresholdAttrName || genNameFunc('threshold', exceededAttrName);
            
            var incrName = genNameFunc(counterAttrName, 'increment'),
                decrName = genNameFunc(counterAttrName, 'decrement'),
                thresholdSetterName = myt.AccessorSupport.generateSetterName(thresholdAttrName),
                isModuleOrClass = typeof scope === 'function' || scope instanceof JS.Module;
            
            // Prevent clobbering
            if ((isModuleOrClass ? scope.instanceMethod(incrName) : scope[incrName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of ThresholdCounter increment function.", incrName, scope);
                return false;
            }
            if ((isModuleOrClass ? scope.instanceMethod(decrName) : scope[decrName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of ThresholdCounter decrement function.", decrName, scope);
                return false;
            }
            if ((isModuleOrClass ? scope.instanceMethod(thresholdSetterName) : scope[thresholdSetterName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of ThresholdCounter threshold setter function.", thresholdSetterName, scope);
                return false;
            }
            
            // Define the "module".
            var mod = {};
            
            /** Increments the counter attribute on the scope object by the 
                provided value or 1 if no value was provided.
                @param amount:number (Optional) the amount to increment the 
                    counter by. If not provided, 1 will be used.
                @returns void */
            mod[incrName] = function(amount) {
                if (amount == null) amount = 1;
                var curValue = this[counterAttrName],
                    value = curValue + amount;
                
                // Counters must be non-negative.
                if (0 > value) {
                    console.warn("Attempt to decrement a counter below 0.", this, counterAttrName, amount);
                    value = 0;
                }
                
                if (curValue !== value) {
                    this[counterAttrName] = value;
                    this.fireNewEvent(counterAttrName, value);
                    this.set(exceededAttrName, value >= this[thresholdAttrName]); // Check threshold
                }
            };
            
            /** Decrements the counter attribute on the scope object by the 
                provided value or 1 if no value was provided.
                @param amount:number (Optional) the amount to increment the 
                    counter by. If not provided, 1 will be used.
                @returns void */
            mod[decrName] = function(amount) {
                if (amount == null) amount = 1;
                this[incrName](-amount);
            };
            
            /** Sets the threshold attribute and performs a threshold check.
                @returns void */
            mod[thresholdSetterName] = function(v) {
                if (this[thresholdAttrName] === v) return;
                this[thresholdAttrName] = v;
                this.fireNewEvent(thresholdAttrName, v);
                this.set(exceededAttrName, this[counterAttrName] >= v); // Check threshold
            };
            
            // Mixin in the "module"
            if (isModuleOrClass) {
                scope.include(mod);
            } else {
                scope.extend(mod);
            }
            
            return true;
        },
        
        /** Set initial value and threshold on a ThresholdCounter instance.
            This also executes a 'check' so the 'exceeded' attribute will have
            the correct value.
            @returns void */
        initializeThresholdCounter: function(
            scope, initialValue, thresholdValue, exceededAttrName, counterAttrName, thresholdAttrName
        ) {
            var genNameFunc = myt.AccessorSupport.generateName;
            counterAttrName = counterAttrName || genNameFunc('counter', exceededAttrName);
            thresholdAttrName = thresholdAttrName || genNameFunc('threshold', exceededAttrName);
            
            scope[counterAttrName] = initialValue;
            scope[thresholdAttrName] = thresholdValue;
            scope.set(exceededAttrName, initialValue >= thresholdValue); // Check threshold
        },
        
        /** Mixes ThresholdCounter functionality with a fixed threshold onto 
            the provided scope.
            @param scope:Observable|Class|Module the scope to mix onto.
            @param thresholdValue:number the fixed threshold value.
            @param exceededAttrName:string the name of the boolean attribute
                that will indicate if the threshold is exceeded or not.
            @param counterAttrName:string (Optional) the name of the number
                attribute that will get adjusted up and down. If not provided
                the 'exceeded' attribute name will be used with 'Counter'
                appended to it. For example if the exceeded
                attribute was 'locked' this would be 'lockedCounter'.
            @returns boolean True if creation succeeded, false otherwise. */
        createFixedThresholdCounter: function(scope, thresholdValue, exceededAttrName, counterAttrName) {
            var genNameFunc = myt.AccessorSupport.generateName;
            counterAttrName = counterAttrName || genNameFunc('counter', exceededAttrName);
            
            var incrName = genNameFunc(counterAttrName, 'increment'),
                decrName = genNameFunc(counterAttrName, 'decrement'),
                isModuleOrClass = typeof scope === 'function' || scope instanceof JS.Module;
            
            // Prevent clobbering
            if ((isModuleOrClass ? scope.instanceMethod(incrName) : scope[incrName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of ThresholdCounter increment function.", incrName, scope);
                return false;
            }
            if ((isModuleOrClass ? scope.instanceMethod(decrName) : scope[decrName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of ThresholdCounter decrement function.", decrName, scope);
                return false;
            }
            
            // Define the "module".
            var mod = {};
            
            /** Increments the counter attribute on the scope object by 1.
                @returns void */
            mod[incrName] = function() {
                var value = this[counterAttrName] + 1;
                this[counterAttrName] = value;
                this.fireNewEvent(counterAttrName, value);
                if (value === thresholdValue) this.set(exceededAttrName, true);
            };
            
            /** Decrements the counter attribute on the scope object by 1.
                @returns void */
            mod[decrName] = function() {
                var curValue = this[counterAttrName];
                if (curValue === 0) return;
                var value = curValue - 1;
                this[counterAttrName] = value;
                this.fireNewEvent(counterAttrName, value);
                if (curValue === thresholdValue) this.set(exceededAttrName, false);
            };
            
            // Mixin in the "module"
            if (isModuleOrClass) {
                scope.include(mod);
            } else {
                scope.extend(mod);
            }
            
            return true;
        },
        
        /** Set initial value on a ThresholdCounter instance.
            This also executes a 'check' so the 'exceeded' attribute will have
            the correct value.
            @returns void */
        initializeFixedThresholdCounter: function(
            scope, initialValue, thresholdValue, exceededAttrName, counterAttrName
        ) {
            counterAttrName = counterAttrName || myt.AccessorSupport.generateName('counter', exceededAttrName);
            
            scope[counterAttrName] = initialValue;
            scope.set(exceededAttrName, initialValue >= thresholdValue);
        }
    },
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function(initialValue, thresholdValue) {
        myt.ThresholdCounter.initializeThresholdCounter(
            this, initialValue, thresholdValue, 'exceeded', 'counter', 'threshold'
        );
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Destructible */
    destroy: function() {
        this.detachAllObservers();
        this.callSuper();
    }
});

/** Create default counter functions for the ThresholdCounter class. */
myt.ThresholdCounter.createThresholdCounter(
    myt.ThresholdCounter, 'exceeded', 'counter', 'threshold'
);


/** A layout controls the positioning of views within a parent view.
    
    Events:
        None
    
    Attributes:
        locked:boolean When true, the layout will not update.
        lockedCounter:number Counter created by myt.ThresholdCounter.
    
    Private Attributes:
        subviews:array An array of Views managed by this layout.
        __deferredLayout:boolean Marks a layout as deferred if the global
            layout lock, myt.Layout.locked, is true during a call to 
            'canUpdate' on the layout.
*/
myt.Layout = new JS.Class('Layout', myt.Node, {
    // Class Methods ///////////////////////////////////////////////////////////
    extend: {
        deferredLayouts: [],
        
        /** Increments the global lock that prevents all layouts from updating.
            @returns void */
        incrementGlobalLock: function() {
            var L = myt.Layout;
            if (L._lockCount === undefined) L._lockCount = 0;
            
            L._lockCount++;
            if (L._lockCount === 1) L.__setLocked(true);
        },
        
        /** Decrements the global lock that prevents all layouts from updating.
            @returns void */
        decrementGlobalLock: function() {
            var L = myt.Layout;
            if (L._lockCount === undefined) L._lockCount = 0;
            
            if (L._lockCount !== 0) {
                L._lockCount--;
                if (L._lockCount === 0) L.__setLocked(false);
            }
        },
        
        /** Adds a layout to a list of layouts that will get updated when the
            global lock is no longer locked.
            @param layout:myt.Layout the layout to defer an update for.
            @returns void */
        deferLayoutUpdate: function(layout) {
            // Don't add a layout that is already deferred.
            if (!layout.__deferredLayout) {
                myt.Layout.deferredLayouts.push(layout);
                layout.__deferredLayout = true;
            }
        },
        
        /** Called to set/unset the global lock. Updates all the currently 
            deferred layouts.
            @private */
        __setLocked: function(v) {
            var L = myt.Layout;
            if (L.locked === v) return;
            L.locked = v;
            
            if (!v) {
                var layouts = L.deferredLayouts, i = layouts.length, layout;
                while (i) {
                    layout = layouts[--i];
                    layout.__deferredLayout = false;
                    layout.update();
                }
                layouts.length = 0;
            }
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.subviews = [];
        
        // Start the layout in the locked state.
        this.locked = true;
        this.lockedCounter = 1;
        
        // Remember how initial locking state should be set
        var initiallyLocked = attrs.locked === true;
        delete attrs.locked;
        
        this.callSuper(parent, attrs);
        
        // Unlock if initial locking state calls for it.
        if (!initiallyLocked) this.decrementLockedCounter();
        
        this.update();
    },
    
    /** @overrides myt.Node */
    destroyAfterOrphaning: function() {
        this.callSuper();
        this.subviews.length = 0;
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    setParent: function(parent) {
        if (this.parent !== parent) {
            // Lock during parent change so that old parent is not updated by
            // the calls to removeSubview and addSubview.
            var wasNotLocked = !this.locked;
            if (wasNotLocked) this.locked = true;
            
            // Stop monitoring parent
            var svs, i, len;
            if (this.parent) {
                svs = this.subviews;
                i = svs.length;
                while (i) this.removeSubview(svs[--i]);
                
                this.detachFrom(this.parent, '__handleParentSubviewAddedEvent', 'subviewAdded');
                this.detachFrom(this.parent, '__handleParentSubviewRemovedEvent', 'subviewRemoved');
            }
            
            this.callSuper(parent);
            
            // Start monitoring new parent
            if (this.parent) {
                svs = this.parent.getSubviews();
                for (i = 0, len = svs.length; len > i; ++i) this.addSubview(svs[i]);
                
                this.attachTo(this.parent, '__handleParentSubviewAddedEvent', 'subviewAdded');
                this.attachTo(this.parent, '__handleParentSubviewRemovedEvent', 'subviewRemoved');
            }
            
            // Clear temporary lock and update if this happened after initialization.
            if (wasNotLocked) {
                this.locked = false;
                if (this.inited && this.parent) this.update();
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Checks if the layout is locked or not. Should be called by the
        "update" method of each layout to check if it is OK to do the update.
        If myt.Layout.locked is true (the global layout lock) then a deferred
        layout update will be setup for this Layout. Once the global lock is
        unlocked this Layout's 'update' method will be invoked.
        @returns true if not locked, false otherwise. */
    canUpdate: function() {
        if (myt.Layout.locked) {
            myt.Layout.deferLayoutUpdate(this);
            return false;
        }
        return !this.locked;
    },
    
    /** Updates the layout. Subclasses should call super to check lock state.
        @returns void */
    update: function() {},
    
    // Subview Methods //
    /** Checks if this Layout has the provided View in the subviews array.
        @param sv:View the view to check for.
        @returns true if the subview is found, false otherwise. */
    hasSubview: function(sv) {
        return this.getSubviewIndex(sv) !== -1;
    },
    
    /** Gets the index of the provided View in the subviews array.
        @param sv:View the view to check for.
        @returns the index of the subview or -1 if not found. */
    getSubviewIndex: function(sv) {
        return this.subviews.indexOf(sv);
    },
    
    /** Adds the provided View to the subviews array of this Layout.
        @param sv:View the view to add to this layout.
        @returns void */
    addSubview: function(sv) {
        if (this.ignore(sv)) return;
        
        this.subviews.push(sv);
        this.startMonitoringSubview(sv);
        if (!this.locked) this.update();
    },
    
    /** Subclasses should implement this method to start listening to
        events from the subview that should trigger the update method.
        @param sv:View the view to start monitoring for changes.
        @returns void */
    startMonitoringSubview: function(sv) {},
    
    /** Calls startMonitoringSubview for all views. Used by Layout 
        implementations when a change occurs to the layout that requires
        refreshing all the subview monitoring.
        @returns void */
    startMonitoringAllSubviews: function() {
        var svs = this.subviews, i = svs.length;
        while (i) this.startMonitoringSubview(svs[--i]);
    },
    
    /** Removes the provided View from the subviews array of this Layout.
        @param sv:View the view to remove from this layout.
        @returns the index of the removed subview or -1 if not removed. */
    removeSubview: function(sv) {
        if (this.ignore(sv)) return -1;
        
        var idx = this.getSubviewIndex(sv);
        if (idx !== -1) {
            this.stopMonitoringSubview(sv);
            this.subviews.splice(idx, 1);
            if (!this.locked) this.update();
        }
        return idx;
    },
    
    /** Subclasses should implement this method to stop listening to
        events from the subview that would trigger the update method. This
        should remove all listeners that were setup in startMonitoringSubview.
        @param sv:View the view to stop monitoring for changes.
        @returns void */
    stopMonitoringSubview: function(sv) {},
    
    /** Calls stopMonitoringSubview for all views. Used by Layout 
        implementations when a change occurs to the layout that requires
        refreshing all the subview monitoring.
        @returns void */
    stopMonitoringAllSubviews: function() {
        var svs = this.subviews, i = svs.length;
        while (i) this.stopMonitoringSubview(svs[--i]);
    },
    
    /** Checks if a subview can be added to this Layout or not. The default 
        implementation returns the 'ignoreLayout' attributes of the subview.
        @param sv:myt.View the view to check.
        @returns boolean true means the subview will be skipped, false
            otherwise. */
    ignore: function(sv) {
        return sv.ignoreLayout;
    },
    
    /** If our parent adds a new subview we should add it.
        @private */
    __handleParentSubviewAddedEvent: function(event) {
        var v = event.value;
        if (v.parent === this.parent) this.addSubview(v);
    },
    
    /** If our parent removes a subview we should remove it.
        @private */
    __handleParentSubviewRemovedEvent: function(event) {
        var v = event.value;
        if (v.parent === this.parent) this.removeSubview(v);
    },
    
    // Subview ordering //
    /** Sorts the subviews array according to the provided sort function.
        @param sortFunc:function the sort function to sort the subviews with.
        @returns void */
    sortSubviews: function(sortFunc) {
        this.subviews.sort(sortFunc);
    },
    
    /** Moves the subview before the target subview in the order the subviews
        are layed out. If no target subview is provided, or it isn't in the
        layout the subview will be moved to the front of the list.
        @returns void */
    moveSubviewBefore: function(sv, target) {
        this.__moveSubview(sv, target, false);
    },
    
    /** Moves the subview after the target subview in the order the subviews
        are layed out. If no target subview is provided, or it isn't in the
        layout the subview will be moved to the back of the list.
        @returns void */
    moveSubviewAfter: function(sv, target) {
        this.__moveSubview(sv, target, true);
    },
    
    /** Implements moveSubviewBefore and moveSubviewAfter.
        @private */
    __moveSubview: function(sv, target, after) {
        var curIdx = this.getSubviewIndex(sv);
        if (curIdx >= 0) {
            var svs = this.subviews,
                targetIdx = this.getSubviewIndex(target);
            svs.splice(curIdx, 1);
            if (targetIdx >= 0) {
                if (curIdx < targetIdx) --targetIdx;
                svs.splice(targetIdx + after ? 1 : 0, 0, sv);
            } else {
                // Make first or last since target was not found
                if (after) {
                    svs.push(sv);
                } else {
                    svs.unshift(sv);
                }
            }
        }
    }
});

/** Create locked counter functions for the myt.Layout class. */
myt.ThresholdCounter.createFixedThresholdCounter(myt.Layout, 1, 'locked');


/** Generates Mouse Events and passes them on to one or more event observers.
    Also provides the capability to capture contextmenu events and mouse
    wheel events.
    
    Requires: myt.DomObservable super mixin.
*/
myt.MouseObservable = new JS.Module('MouseObservable', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of supported mouse event types. */
        EVENT_TYPES:{
            mouseover:true,
            mouseout:true,
            mousedown:true,
            mouseup:true,
            click:true,
            dblclick:true,
            mousemove:true,
            contextmenu:true,
            wheel:true
        },
        
        /** The common mouse event that gets reused. */
        EVENT:{source:null, type:null, value:null},
        
        /** Gets the mouse coordinates from the provided event.
            @param event
            @returns object: An object with 'x' and 'y' keys containing the
                x and y mouse position. */
        getMouseFromEvent: function(event) {
            var domEvent = event.value;
            return {x:domEvent.pageX, y:domEvent.pageY};
        },
        
        getMouseFromEventRelativeToView: function(event, view) {
            var viewPos = view.getPagePosition(),
                pos = this.getMouseFromEvent(event);
            pos.x -= viewPos.x;
            pos.y -= viewPos.y;
            return pos;
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DomObservable */
    createDomMethodRef: function(domObserver, methodName, type) {
        return this.createStandardDomMethodRef(domObserver, methodName, type, myt.MouseObservable, true) || 
            this.callSuper(domObserver, methodName, type);
    }
});


/** Generates focus and blur events and passes them on to one or more 
    event observers. Also provides focus related events to a view. When a view
    is focused or blurred, myt.global.focus will be notified via the
    'notifyFocus' and 'notifyBlur' methods.
    
    Requires myt.DomObservable as a super mixin.
    
    Events:
        focused:object Fired when this view gets focus. The value is this view.
        focus:object Fired when this view gets focus. The value is a dom
            focus event.
        blur:object Fired when this view loses focus. The value is a dom
            focus event.
    
    Attributes:
        focused:boolean Indicates if this view has focus or not.
        focusable:boolean Indicates if this view can have focus or not.
        focusEmbellishment:boolean Indicates if the focus embellishment should
            be shown for this view or not when it has focus.
    
    Virtual Methods:
        getNextFocus() Implement this method to return the next view that 
            should have focus. If null is returned or the method is not 
            implemented, normal dom traversal will occur.
        getPrevFocus() Implement this method to return the prev view that 
            should have focus. If null is returned or the method is not 
            implemented, normal dom traversal will occur.
*/
// TODO: fire focus and blur events rather than a focused event?
// FIXME: should we give away focus when we become not visible?
myt.FocusObservable = new JS.Module('FocusObservable', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of supported focus event types. */
        EVENT_TYPES:{
            focus:true,
            blur:true
        },
        
        /** The common focus/blur event that gets reused. */
        EVENT:{source:null, type:null, value:null}
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.focusable = false;
        this.focusEmbellishment = true;
        
        this.callSuper(parent, attrs);
    },
    
    /** @overrides myt.View */
    destroyBeforeOrphaning: function() {
        this.giveAwayFocus();
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setFocused: function(v) {
        if (this.focused !== v) {
            this.focused = v;
            if (this.inited) {
                this.fireNewEvent('focused', v);
                var gf = myt.global.focus;
                if (v) {
                    gf.notifyFocus(this);
                } else {
                    gf.notifyBlur(this);
                }
            }
        }
    },
    
    setFocusable: function(v) {
        if (this.focusable !== v) {
            var wasFocusable = this.focusable;
            this.focusable = v;
            
            if (v) {
                this.domElement.tabIndex = 0; // Make focusable. -1 is programtic only
                this.attachToDom(this, '__doFocus', 'focus');
                this.attachToDom(this, '__doBlur', 'blur');
            } else if (wasFocusable) {
                this.domElement.removeAttribute('tabIndex'); // Make unfocusable
                this.detachFromDom(this, '__doFocus', 'focus');
                this.detachFromDom(this, '__doBlur', 'blur');
            }
            
            if (this.inited) this.fireNewEvent('focusable', v);
        }
    },
    
    setFocusEmbellishment: function(v) {
        if (this.focusEmbellishment !== v) {
            this.focusEmbellishment = v;
            if (this.focused) {
                if (v) {
                    this.showFocusEmbellishment();
                } else {
                    this.hideFocusEmbellishment();
                }
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Gives the focus to the next focusable element or, if nothing else
        is focusable, blurs away from this element.
        @returns void */
    giveAwayFocus: function() {
        if (this.focused) {
            // Try to go to next focusable element.
            myt.global.focus.next();
            
            // If focus loops around to ourself make sure we don't keep it.
            if (this.focused) this.blur();
        }
    },
    
    /** Tests if this view is in a state where it can receive focus.
        @returns boolean True if this view is visible, enabled, focusable and
            not focus masked, false otherwise. */
    isFocusable: function() {
        return this.focusable && !this.disabled && this.isVisible() && 
            this.searchAncestorsOrSelf(function(n) {return n.maskFocus === true;}) === null;
    },
    
    /** Calling this method will set focus onto this view if it is focusable.
        @param noScroll:boolean (optional) if true is provided no auto-scrolling
            will occur when focus is set.
        @returns void */
    focus: function(noScroll) {
        if (this.isFocusable()) {
            var de = this.domElement;
            if (noScroll) {
                // Maintain scrollTop/scrollLeft
                var ancestors = myt.DomElementProxy.getAncestorArray(de),
                    len = ancestors.length, i = len, ancestor,
                    scrollPositions = [], scrollPosition;
                while (i) {
                    ancestor = ancestors[--i];
                    scrollPositions.unshift({scrollTop:ancestor.scrollTop, scrollLeft:ancestor.scrollLeft});
                }
                
                de.focus();
                
                // Restore scrollTop/scrollLeft
                i = len;
                while (i) {
                    ancestor = ancestors[--i];
                    scrollPosition = scrollPositions[i];
                    ancestor.scrollTop = scrollPosition.scrollTop;
                    ancestor.scrollLeft = scrollPosition.scrollLeft;
                }
            } else {
                de.focus();
            }
        }
    },
    
    /** Removes the focus from this view. Do not call this method directly.
        @private
        @returns void */
    blur: function() {
        this.domElement.blur();
    },
    
    /** @private */
    __doFocus: function(event) {
        if (!this.focused) {
            this.setFocused(true);
            this.doFocus();
        }
    },
    
    /** @private */
    __doBlur: function(event) {
        if (this.focused) {
            this.doBlur();
            this.setFocused(false);
        }
    },
    
    doFocus: function() {
        if (this.focusEmbellishment) {
            this.showFocusEmbellishment();
        } else {
            this.hideFocusEmbellishment();
        }
    },
    
    doBlur: function() {
        if (this.focusEmbellishment) this.hideFocusEmbellishment();
    },
    
    showFocusEmbellishment: function() {
        // IE
        this.domElement.hideFocus = false;
        
        // Mozilla and Webkit
        var s = this.deStyle;
        s.outlineWidth = 'thin';
        s.outlineColor = '#88bbff';
        s.outlineStyle = 'solid';
        s.outlineOffset = '0px';
    },
    
    hideFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
    },
    
    /** Hides the browser's default focus embellishment. */
    hideDefaultFocusEmbellishment: function() {
        // IE
        this.domElement.hideFocus = true;
        
        // Mozilla and Webkit
        this.deStyle.outlineStyle = 'none';
    },
    
    /** @overrides myt.DomObservable */
    createDomMethodRef: function(domObserver, methodName, type) {
        if (myt.FocusObservable.EVENT_TYPES[type]) {
            var self = this;
            return function(domEvent) {
                if (!domEvent) var domEvent = window.event;
                
                // OPTIMIZATION: prevent extra focus events under special 
                // circumstances. See myt.VariableLayout for more detail.
                if (self._ignoreFocus) {
                    domEvent.cancelBubble = true;
                    if (domEvent.stopPropagation) domEvent.stopPropagation();
                    domEvent.preventDefault();
                    return;
                }
                
                // Configure common focus event.
                var event = myt.FocusObservable.EVENT;
                event.source = self;
                event.type = domEvent.type;
                event.value = domEvent;
                
                var allowBubble = domObserver[methodName](event);
                if (!allowBubble) {
                    domEvent.cancelBubble = true;
                    if (domEvent.stopPropagation) domEvent.stopPropagation();
                }
                
                event.source = undefined;
            };
        }
        
        return this.callSuper(domObserver, methodName, type);
    }
});


/** Generates Scroll Events and passes them on to one or more event observers.
    Requires myt.DomObservable as a super mixin. */
myt.ScrollObservable = new JS.Module('ScrollObservable', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of supported scroll event types. */
        EVENT_TYPES:{
            scroll:true
        },
        
        /** The common scroll event that gets reused. */
        EVENT:{source:null, type:null, value:null},
        
        /** Gets the scrollLeft and scrollTop from the event.
            @param event:event
            @returns object with an x and y key each containing a number. */
        getScrollFromEvent: function(event) {
            var domEvent = event.value,
                target = domEvent.target || domEvent.srcElement;
            return {x: target.scrollLeft, y: target.scrollTop};
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DomObservable */
    createDomMethodRef: function(domObserver, methodName, type) {
        return this.createStandardDomMethodRef(domObserver, methodName, type, myt.ScrollObservable) || 
            this.callSuper(domObserver, methodName, type);
    }
});


/** Provides common geometry related functions. */
myt.Geometry = {
    // Methods /////////////////////////////////////////////////////////////////
    /** Get the closest point on a line to a given point.
        @param Ax:number The x-coordinate of the first point that defines 
            the line.
        @param Ay:number The y-coordinate of the first point that defines 
            the line.
        @param Bx:number The x-coordinate of the second point that defines 
            the line.
        @param By:number The y-coordinate of the second point that defines 
            the line.
        @param Px:number The x-coordinate of the point.
        @param Py:number The y-coordinate of the point.
        @returns object: A position object with x and y properties. */
    getClosestPointOnALineToAPoint: function(Ax, Ay, Bx, By, Px, Py) {
        var APx = Px - Ax,
            APy = Py - Ay,
            ABx = Bx - Ax,
            ABy = By - Ay,
            magAB2 = ABx * ABx + ABy * ABy,
            ABdotAP = ABx * APx + ABy * APy,
            t = ABdotAP / magAB2;
        return {x:Ax + ABx * t, y:Ay + ABy * t};
    },
    
    /** Get the closest point on a segment to a given point.
        @param Ax:number The x-coordinate of the first endpoint that defines 
            the segment.
        @param Ay:number The y-coordinate of the first endpoint that defines 
            the segment.
        @param Bx:number The x-coordinate of the second endpoint that defines 
            the segment.
        @param By:number The y-coordinate of the second endpoint that defines 
            the segment.
        @param Px:number The x-coordinate of the point.
        @param Py:number The y-coordinate of the point.
        @returns object: A position object with x and y properties. */
    getClosestPointOnASegmentToAPoint: function(Ax, Ay, Bx, By, Px, Py) {
        var APx = Px - Ax,
            APy = Py - Ay,
            ABx = Bx - Ax,
            ABy = By - Ay,
            magAB2 = ABx * ABx + ABy * ABy,
            ABdotAP = ABx * APx + ABy * APy,
            t = ABdotAP / magAB2;
        if (t < 0) {
            return {x:Ax, y:Ay};
        } else if (t > 1) {
            return {x:Bx, y:By};
        }
        return {x:Ax + ABx * t, y:Ay + ABy * t};
    },
    
    /** Tests if the provided point is inside this path.
        @param x:number the x coordinate to test.
        @param y:number the y coordinate to test.
        @param boundingBox:object a bounding box object that bounds the path.
        @param path:array an array of points where the index 0,2,4,... are
            the x values and index 1,3,5,... are the y values.
        
        Alternate params:
        @param x:object A point object with x and y properties.
        
        @return true if inside, false otherwise. */
    isPointInPath: function(x, y, boundingBox, path) {
        if (typeof x === 'object') {
            path = boundingBox;
            boundingBox = y;
            y = x.y;
            x = x.x;
        }
        
        // First test bounding box
        if (this.rectContainsPoint(x, y, boundingBox)) {
            // Test using Jordan Curve Theorem
            var len = path.length;
            
            // Must at least be a triangle to have an inside.
            if (len >= 6) {
                var c = false, x1 = path[0], y1 = path[1], x2, y2;
                while (len) {
                    y2 = path[--len];
                    x2 = path[--len];
                    if (((y2 > y) !== (y1 > y)) && (x < (x1 - x2) * (y - y2) / (y1 - y2) + x2)) c = !c;
                    x1 = x2;
                    y1 = y2;
                }
                return c;
            }
        }
        return false;
    },
    
    /** Checks if the provided point is inside or on the edge of the provided 
        rectangle.
        @param pX:number the x coordinate of the point to test.
        @param pY:number the y coordinate of the point to test.
        @param rX:number the x coordinate of the rectangle.
        @param rY:number the y coordinate of the rectangle.
        @param rW:number the width of the rectangle.
        @param rH:number the height of the rectangle.
        
        Alternate Params:
        @param pX:object a point object with properties x and y.
        @param rX:object a rect object with properties x, y, width and height.
        
        @returns boolean True if the point is inside or on the rectangle. */
    rectContainsPoint: function(pX, pY, rX, rY, rW, rH) {
        if (typeof pX === 'object') {
            rH = rW;
            rW = rY;
            rY = rX;
            rX = pY;
            pY = pX.y;
            pX = pX.x;
        }
        
        if (typeof rX === 'object') {
            rH = rX.height;
            rW = rX.width;
            rY = rX.y;
            rX = rX.x;
        }
        
        return pX >= rX && pY >= rY && pX <= rX + rW && pY <= rY + rH;
    },
    
    /** Checks if the provided point lies inside or on the edge of the
        provided circle.
        @param pX:number the x coordinate of the point to test.
        @param pY:number the y coordinate of the point to test.
        @param cX:number the x coordinate of the center of the circle.
        @param cY:number the y coordinate of the center of the circle.
        @param cR:number the radius of the circle.
        @return boolean True if the point is inside or on the circle. */
    circleContainsPoint: function(pX, pY, cX, cY, cR) {
        return this.measureDistance(pX, pY, cX, cY, true) <= cR * cR;
    },
    
    /** Measure the distance between two points.
        @param x1:number the x position of the first point.
        @param y1:number the y position of the first point.
        @param x2:number the x position of the second point.
        @param y2:number the y position of the second point.
        @param squared:boolean (optional) If true, the squared distance will
            be returned.
        @returns number the distance between the two points. */
    measureDistance: function(x1, y1, x2, y2, squared) {
        var diffX = x2 - x1, 
            diffY = y2 - y1, 
            diffSquared = diffX * diffX + diffY * diffY;
        return squared ? diffSquared : Math.sqrt(diffSquared);
    },
    
    /** Convert radians to degrees.
        @param deg:number degrees.
        @returns number: radians. */
    degreesToRadians: function(deg) {
        return deg * Math.PI / 180;
    },
    
    /** Convert degrees to radians.
        @param rad:number radians.
        @returns number: degrees. */
    radiansToDegrees: function(rad) {
        return rad * 180 / Math.PI;
    },
    
    // Geometry on a sphere
    /** Checks if the provided lat/lng point lies inside or on the edge of the
        provided circle.
        @param pLat:number the latitude of the point to test.
        @param pLng:number the longitude of the point to test.
        @param cLat:number the latitude of the center of the circle.
        @param cLng:number the longitude of the center of the circle.
        @param cR:number the radius of the circle in kilometers.
        @param sphereRadius:number (optional) the radius of the sphere the
            measurement is being taken on in kilometers. If not provided the
            radius of the earth is used.
        @return boolean True if the point is inside or on the circle. */
    circleContainsLatLng: function(pLat, pLng, cLat, cLng, cR, sphereRadius) {
        return this.measureLatLngDistance(pLat, pLng, cLat, cLng, sphereRadius) <= cR;
    },
    
    /** Measures the distance between two points on a sphere using latitude
        and longitude.
        @param lat1:number the latitude of the first point.
        @param lng1:number the longitude of the first point.
        @param lat2:number the latitude of the second point.
        @param lng2:number the longitude of the second point.
        @param sphereRadius:number (optional) the radius of the sphere the
            measurement is being taken on in kilometers. If not provided the
            radius of the earth is used.
        @returns number the distance between the points in kilometers. */
    measureLatLngDistance: function(lat1, lng1, lat2, lng2, sphereRadius) {
        // Taken from: http://www.movable-type.co.uk/scripts/latlong.html
        if (sphereRadius === undefined) sphereRadius = 6371; // kilometers for earth
        lat1 = this.degreesToRadians(lat1);
        lng1 = this.degreesToRadians(lng1);
        lat2 = this.degreesToRadians(lat2);
        lng2 = this.degreesToRadians(lng2);
        return sphereRadius * Math.acos(
            Math.sin(lat1) * Math.sin(lat2) + 
            Math.cos(lat1) * Math.cos(lat2) * Math.cos(lng2 - lng1)
        );
    }
};


/** A Node that can be viewed. Instances of view are typically backed by
    an absolutely positioned div element.
    
    Events:
        domClass:string Fired when the domClass setter is called.
        domId:string Fired when the domId setter is called.
        align:string
        alignOffset:number
        valign:string
        valignOffset:number
        x:number
        y:number
        width:number (supressable)
        height:number (supressable)
        boundsWidth:number Fired when the bounds width of the view changes.
        boundsHeight:number Fired when the bounds height of the view changes.
        textColor:string
        bgColor:string
        opacity:number
        overflow:string
        visible:boolean
        cursor:string
        subviewAdded:myt.View Fired when a subview is added to this view.
        subviewRemoved:myt.View Fired when a subview is removed from this view.
        layoutAdded:myt.Layout Fired when a layout is added to this view.
        layoutRemoved:myt.Layout Fired when a layout is removed from this view.
    
    Attributes:
        focusTrap:boolean Determines if focus traversal can move above this view
            or not. The default is undefined which is equivalent to false. Can 
            be ignored using a key modifier. The key modifier is 
            typically 'option'.
        focusCage:boolean Determines if focus traversal can move above this view
            or not. The default is undefined which is equivalent to false. This
            is the same as focusTrap except it can't be ignored using a 
            key modifier.
        maskFocus:boolean Prevents focus from traversing into this view or any
            of its subviews. The default is undefined which is equivalent 
            to false.
        ignoreLayout:boolean Determines if this view should be included in 
            layouts or not. Default is undefined which is equivalent to false.
        layoutHint:* A value that indicates this view is treated as "special" 
            by the layout. The interpretation of this value is up to the 
            layout managing the view.
        align:string Aligns the view horizontally within its parent. 
            Supported values are: 'left', 'center', 'right' and ''. 
            The default is undefined which is equivalent to ''.
        alignOffset:number A pixel offset to use when aligning a view.
        valign:string Aligns the view vertically within its parent. 
            Supported values are: 'top', 'middle', 'bottom' and ''. 
            The default is undefined which is equivalent to ''.
        valignOffset:number A pixel offset to use when valigning a view.
        x:number The x-position of this view in pixels. Defaults to 0.
        y:number The y-position of this view in pixels. Defaults to 0.
        width:number The width of this view in pixels. Defaults to 0.
        height:number the height of this view in pixels. Defaults to 0.
        boundsWidth:number (read only) The actual bounds of the view in the
            x-dimension. This value is in pixels relative to the RootView and
            thus compensates for rotation and scaling.
        boundsHeight:number (read only) The actual bounds of the view in the
            y-dimension. This value is in pixels relative to the RootView and
            thus compensates for rotation and scaling.
        textColor:string The color used for text. Will be inherited by 
            descendant views if they don't themselves set textColor or if 
            they set textColor to 'inherit'. Defaults to undefined which is
            equivalent to 'inherit'.
        bgColor:string The background color of this view. Use a value of 
            'transparent' to make this view transparent. Defaults 
            to 'transparent'.
        opacity:number The opacity of this view. The value should be a number 
            between 0 and 1. Defaults to 1.
        overflow:string Determines how descendant content overflows the bounds.
            Allowed values: 'visible', 'hidden', 'scroll', 'auto', 'inherit'.
            Defaults to undefined which is equivalent to 'visible'.
        visible:boolean Makes this view visible or not. The default value is 
            true which means visbility is inherited from the parent view.
        cursor:string Determines what cursor to show when moused over the view.
            Allowed values: 'auto', 'move', 'no-drop', 'col-resize', 
            'all-scroll', 'pointer', 'not-allowed', 'row-resize', 'crosshair', 
            'progress', 'e-resize', 'ne-resize', 'default', 'text', 'n-resize', 
            'nw-resize', 'help', 'vertical-text', 's-resize', 'se-resize', 
            'inherit', 'wait', 'w-resize', 'sw-resize'. Defaults to undefined 
            which is equivalent to 'auto'.
        pointerEvents:string Determines if this view responds to pointer events
            or not. Supported values: 'none', 'auto' and 'inherit'. Defaults 
            to undefined which is equivalent to 'auto'.
        outlineWidth:number The width of the CSS outline. If a value equivalent
            to false is provided 0 will be used.
        outlineStyle:string The CSS outline style. If null or undefined is 
            provided 'none' will be used. Supported values: 'none', 'dotted', 
            'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 
            'outset', 'inherit'.
        outlineColor:string Sets the color of the CSS outline. If null or 
            undefined is provided '#000000' will be used.
        borderWidth:number The width of the CSS border. If a value equivalent 
            to false is provided 0 will be used.
        borderStyle:string The CSS border style. If null or undefined is 
            provided 'none' will be used. Supported values: 'none', 'dotted', 
            'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 
            'outset', 'inherit'.
        borderColor:string Sets the color of the CSS border. If null or 
            undefined is provided '#000000' will be used.
    
    Private Attributes:
        subviews:array The array of child myt.Views for this view. Should 
            be accessed through the getSubviews method.
        layouts:array The array of child myt.Layouts for this view. Should
            be accessed through the getLayouts method.
*/
myt.View = new JS.Class('View', myt.Node, {
    include: [
        myt.DomElementProxy, 
        myt.DomObservable, 
        myt.DomObserver, 
        myt.ScrollObservable, 
        myt.FocusObservable, 
        myt.KeyObservable, 
        myt.MouseObservable
    ],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Preserves focus and scroll position during dom updates. Focus can 
            get lost in webkit when an element is removed from the dom.
            viewBeingRemoved:myt.View
            wrapperFunc:function a function to execute that manipulates the
                dom in some way, typically a remove followed by an insert.
            @returns void */
        retainFocusDuringDomUpdate: function(viewBeingRemoved, wrappedFunc) {
            var restoreFocus = myt.global.focus.focusedView, 
                elem = viewBeingRemoved.domElement, restoreScrollTop, restoreScrollLeft;
            if (restoreFocus === viewBeingRemoved || (restoreFocus && restoreFocus.isDescendantOf(viewBeingRemoved))) {
                restoreFocus._ignoreFocus = true;
            }
            
            // Also maintain scrollTop/scrollLeft since those also
            // get reset when a dom element is removed. Note: descendant
            // elements with scroll positions won't get maintained.
            restoreScrollTop = elem.scrollTop;
            restoreScrollLeft = elem.scrollLeft;
            
            wrappedFunc.call();
            
            if (restoreFocus) {
                restoreFocus._ignoreFocus = false;
                restoreFocus.focus(true);
            }
            
            // Restore scrollTop/scrollLeft
            elem.scrollTop = restoreScrollTop;
            elem.scrollLeft = restoreScrollLeft;
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.x = this.y = this.width = this.height = 0;
        this.opacity = 1;
        this.visible = true;
        
        this.setDomElement(this.createOurDomElement(parent));
        
        // Necessary since x and y of 0 won't update deStyle so this gets
        // things initialized correctly. Without this RootViews will have
        // an incorrect initial position for x or y of 0.
        this.deStyle.left = this.deStyle.top = '0px';
        
        this.callSuper(parent, attrs);
        
        // Set default bgcolor afterwards if still undefined. This allows 
        // BaseInputText to override the default for input:text via attrs.
        if (this.bgColor === undefined) this.bgColor = 'transparent';
    },
    
    /** Creates the dom element we will be a proxy for. Called during View
        initialization. Gives subclasses a change to change how the view is
        backed.
        @param parent:dom element The dom element that will be the parent
            of the newly created dom element.
        @returns a dom element */
    createOurDomElement: function(parent) {
        var elem = document.createElement('div');
        elem.style.position = 'absolute';
        
        // Make dom elements easier to location via selectors
        var klass = this.klass;
        elem.className = klass.__cssClassName || (klass.__cssClassName = 'myt-' + klass.__displayName.split('.').join('-'));
        
        return elem;
    },
    
    /** @overrides myt.Node 
        Subclasses should call super if they don't call __updateBounds. The call
        to super should probably occur at the end of the overridden method. */
    doAfterAdoption: function() {
        // Must be done after domElement is inserted so that calls to
        // getBoundingClientRect will work.
        this.__updateBounds(this.width, this.height);
    },
    
    /** @overrides myt.Node */
    destroyAfterOrphaning: function() {
        this.callSuper();
        
        this.detachFromAllDomSources();
        this.detachAllDomObservers();
        this.disposeOfDomElement();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    setParent: function(parent) {
        if (this.parent !== parent) {
            if (this.inited) {
                this.__teardownAlignConstraint();
                this.__teardownValignConstraint();
            }
            this.callSuper(parent);
            this.__setupAlignConstraint();
            this.__setupValignConstraint();
        }
    },
    
    /** Does lazy instantiation of the subviews array. */
    getSubviews: function() {
        return this.subviews || (this.subviews = []);
    },
    
    /** Gets the views that are our siblings.
        @returns array of myt.View or null if this view is orphaned. */
    getSiblingViews: function() {
        if (!this.parent) return null;
        
        // Get a copy of the subviews since we will filter it.
        var svs = this.parent.getSubviews().concat();
        
        // Filter out ourself
        myt.filterArray(svs, this);
        
        return svs;
    },
    
    /** Does lazy instantiation of the layouts array. */
    getLayouts: function() {
        return this.layouts || (this.layouts = []);
    },
    
    // Focus Attributes //
    setFocusTrap: function(v) {this.focusTrap = v;},
    setFocusCage: function(v) {this.focusCage = v;},
    setMaskFocus: function(v) {this.maskFocus = v;},
    
    // Layout Attributes //
    setIgnoreLayout: function(v) {this.ignoreLayout = v;},
    setLayoutHint: function(v) {this.layoutHint = v;},
    
    // Dom Selector Attributes //
    /** @overrides myt.DomElementProxy */
    setDomClass: function(v) {
        if (this.domClass !== v) {
            this.callSuper(v);
            if (this.inited) this.fireNewEvent('domClass', v);
        }
    },
    
    /** @overrides myt.DomElementProxy */
    setDomId: function(v) {
        if (this.domId !== v) {
            this.callSuper(v);
            if (this.inited) this.fireNewEvent('domId', v);
        }
    },
    
    // Alignment Attributes //
    setAlignOffset: function(v) {
        if (this.alignOffset !== v) {
            this.alignOffset = v;
            if (this.inited) this.fireNewEvent('alignOffset', v);
            if (this.parent && this.align === 'left') this.setX(v);
        }
    },
    
    setAlign: function(v) {
        if (this.align !== v) {
            if (this.inited) this.__teardownAlignConstraint();
            this.align = v;
            if (this.inited) {
                this.fireNewEvent('align', v);
                this.__setupAlignConstraint();
            }
        }
    },
    
    /** @private */
    __teardownAlignConstraint: function() {
        switch (this.align) {
            case 'center': this.releaseConstraint('__doAlignCenter'); break;
            case 'right': this.releaseConstraint('__doAlignRight'); break;
            case 'left':
            default: // Do nothing
        }
    },
    
    /** @private */
    __setupAlignConstraint: function() {
        var parent = this.parent;
        if (parent) {
            switch (this.align) {
                case 'center':
                    this.applyConstraint('__doAlignCenter', [this, 'width', this, 'alignOffset', parent, 'width']);
                    break;
                case 'right':
                    this.applyConstraint('__doAlignRight', [this, 'width', this, 'alignOffset', parent, 'width']);
                    break;
                case 'left':
                    this.setX(this.alignOffset || 0);
                    break;
                default: // Do nothing
            }
        }
    },
    
    /** @private */
    __doAlignCenter: function(event) {
        this.setX(Math.round((this.parent.width - this.width) / 2) + (this.alignOffset || 0));
    },
    
    /** @private */
    __doAlignRight: function(event) {
        this.setX(this.parent.width - this.width - (this.alignOffset || 0));
    },
    
    setValignOffset: function(v) {
        if (this.valignOffset !== v) {
            this.valignOffset = v;
            if (this.inited) this.fireNewEvent('valignOffset', v);
            if (this.parent && this.valign === 'top') this.setY(v);
        }
    },
    
    setValign: function(v) {
        if (this.valign !== v) {
            if (this.inited) this.__teardownValignConstraint();
            this.valign = v;
            if (this.inited) {
                this.fireNewEvent('valign', v);
                this.__setupValignConstraint();
            }
        }
    },
    
    /** @private */
    __teardownValignConstraint: function() {
        switch (this.valign) {
            case 'middle': this.releaseConstraint('__doValignMiddle'); break;
            case 'bottom': this.releaseConstraint('__doValignBottom'); break;
            case 'top':
            default: // Do nothing
        }
    },
    
    /** @private */
    __setupValignConstraint: function() {
        var parent = this.parent;
        if (parent) {
            switch (this.valign) {
                case 'middle':
                    this.applyConstraint('__doValignMiddle', [this, 'height', this, 'valignOffset', parent, 'height']);
                    break;
                case 'bottom':
                    this.applyConstraint('__doValignBottom', [this, 'height', this, 'valignOffset', parent, 'height']);
                    break;
                case 'top':
                    this.setY(this.valignOffset || 0);
                    break;
                default: // Do nothing
            }
        }
    },
    
    /** @private */
    __doValignMiddle: function(event) {
        this.setY(Math.round((this.parent.height - this.height) / 2) + (this.valignOffset || 0));
    },
    
    /** @private */
    __doValignBottom: function(event) {
        this.setY(this.parent.height - this.height - (this.valignOffset || 0));
    },
    
    // Visual Attributes //
    setX: function(v) {
        if (this.x !== v) {
            this.x = v;
            if (this.visible) this.deStyle.left = v + 'px';
            if (this.inited) this.fireNewEvent('x', v);
        }
    },
    
    setY: function(v) {
        if (this.y !== v) {
            this.y = v;
            if (this.visible) this.deStyle.top = v + 'px';
            if (this.inited) this.fireNewEvent('y', v);
        }
    },
    
    setWidth: function(v, supressEvent) {
        // Dom elements don't support negative width
        if (0 > v) v = 0;
        
        if (this.width !== v) {
            this.width = v;
            this.deStyle.width = v + 'px';
            if (this.inited) {
                this.__updateBounds(v, this.height);
                if (!supressEvent) this.fireNewEvent('width', v);
            }
        }
    },
    
    setHeight: function(v, supressEvent) {
        // Dom elements don't support negative height
        if (0 > v) v = 0;
        
        if (this.height !== v) {
            this.height = v;
            this.deStyle.height = v + 'px';
            if (this.inited) {
                this.__updateBounds(this.width, v);
                if (!supressEvent) this.fireNewEvent('height', v);
            }
        }
    },
    
    setTextColor: function(v) {
        if (this.textColor !== v) {
            this.textColor = v;
            this.deStyle.color = v || 'inherit';
            if (this.inited) this.fireNewEvent('textColor', v);
        }
    },
    
    setBgColor: function(v) {
        if (this.bgColor !== v) {
            this.deStyle.backgroundColor = this.bgColor = v;
            if (this.inited) this.fireNewEvent('bgColor', v);
        }
    },
    
    setOpacity: function(v) {
        if (this.opacity !== v) {
            this.deStyle.opacity = this.opacity = v;
            if (this.inited) this.fireNewEvent('opacity', v);
        }
    },
    
    setOverflow: function(v) {
        if (this.overflow !== v) {
            this.overflow = v;
            this.deStyle.overflow = v || 'visible';
            if (this.inited) this.fireNewEvent('overflow', v);
        }
    },
    
    setVisible: function(v) {
        if (this.visible !== v) {
            this.visible = v;
            
            var s = this.deStyle;
            s.visibility = v ? 'inherit' : 'hidden';
            
            // Move invisible elements to a very negative location so they won't
            // effect scrollable area. Ideally we could use display:none but we
            // can't because that makes measuring bounds not work.
            s.left = v ? this.x + 'px' : '-100000px';
            s.top = v ? this.y + 'px' : '-100000px';
            
            if (this.inited) this.fireNewEvent('visible', v);
        }
    },
    
    setPointerEvents: function(v) {
        if (this.pointerEvents !== v) {
            this.pointerEvents = v;
            this.deStyle.pointerEvents = v || 'auto';
            if (this.inited) this.fireNewEvent('pointerEvents', v);
        }
    },
    
    setCursor: function(v) {
        if (this.cursor !== v) {
            this.cursor = v;
            this.deStyle.cursor = v || 'auto';
            if (this.inited) this.fireNewEvent('cursor', v);
        }
    },
    
    /** Updates the boundsWidth and boundsHeight attributes.
        @private
        @param w:number the boundsWidth to set.
        @param h:number the boundsHeight to set.
        @returns void */
    __updateBounds: function(w, h) {
        if (this.boundsWidth !== w) {
            this.boundsWidth = w;
            this.fireNewEvent('boundsWidth', w);
        }
        
        if (this.boundsHeight !== h) {
            this.boundsHeight = h;
            this.fireNewEvent('boundsHeight', h);
        }
    },
    
    // Outlines
    /** Sets outlineWidth, outlineStyle and outlineColor via a single 
        array. If a value equivalent to false is provided the outline 
        will be supressed.
        @param v:array where index 0 is outlineWidth, index 1 is outline 
            style and index 2 is outlineColor.
        @returns void */
    setOutline: function(v) {
        v = v || [];
        this.setOutlineWidth(v[0]);
        this.setOutlineStyle(v[1]);
        this.setOutlineColor(v[2]);
    },
    
    setOutlineWidth: function(v) {
        this.outlineWidth = v || 0;
        this.deStyle.outlineWidth = this.outlineWidth + 'px';
    },
    
    setOutlineStyle: function(v) {
        this.deStyle.outlineStyle = this.outlineStyle = v || 'none';
    },
    
    setOutlineColor: function(v) {
        this.deStyle.outlineColor = this.outlineColor = v || '#000000';
    },
    
    // Borders
    /** Sets borderWidth, borderStyle and borderColor via a single 
        array. If a value equivalent to false is provided the border 
        will be supressed.
        @param v:array where index 0 is borderWidth, index 1 is border 
            style and index 2 is borderColor.
        @returns void */
    setBorder: function(v) {
        v = v || [];
        this.setBorderWidth(v[0]);
        this.setBorderStyle(v[1]);
        this.setBorderColor(v[2]);
    },
    
    setBorderWidth: function(v) {
        this.borderWidth = v || 0;
        this.deStyle.borderWidth = this.borderWidth + 'px';
    },
    
    setBorderStyle: function(v) {
        this.deStyle.borderStyle = this.borderStyle = v || 'none';
    },
    
    setBorderColor: function(v) {
        this.deStyle.borderColor = this.borderColor = v || '#000000';
    },
    
    // Edge treatements
    /** A convienence method to set rounded corners on an element.
        @param radius:number the radius of the corners.
        @returns void */
    setRoundedCorners: function(radius) {
        this.deStyle.borderRadius = radius + 'px';
    },
    
    /** A convienence method to round the top left corner.
        @param radius:number the radius of the corner.
        @returns void */
    setRoundedTopLeftCorner: function(radius) {
        this.setRoundedCorner(radius, 'TopLeft');
    },
    
    /** A convienence method to round the top right corner.
        @param radius:number the radius of the corner.
        @returns void */
    setRoundedTopRightCorner: function(radius) {
        this.setRoundedCorner(radius, 'TopRight');
    },
    
    /** A convienence method to round the bottom left corner.
        @param radius:number the radius of the corner.
        @returns void */
    setRoundedBottomLeftCorner: function(radius) {
        this.setRoundedCorner(radius, 'BottomLeft');
    },
    
    /** A convienence method to round the bottom right corner.
        @param radius:number the radius of the corner.
        @returns void */
    setRoundedBottomRightCorner: function(radius) {
        this.setRoundedCorner(radius, 'BottomRight');
    },
    
    /** A convienence method to set a single rounded corner on an element.
        @param radius:number the radius of the corner.
        @param corner:string One of 'TopLeft', 'TopRight', 'BottomLeft' or
            'BottomRight'.
        @returns void */
    setRoundedCorner: function(radius, corner) {
        this.deStyle['border' + corner + 'Radius'] = radius + 'px';
    },
    
    /** Sets the CSS boxShadow property.
        @param v:array where index 0 is the horizontal shadow offset,
            index 1 is the vertical shadow offset, index 2 is the blur amount,
            and index 3 is the color.
        @returns void */
    setBoxShadow: function(v) {
        if (v) {
            var hShadow = v[0] || 0,
                vShadow = v[1] || 0,
                blur = v[2] || 7,
                color = v[3] || '#000000';
            v = hShadow + 'px ' + vShadow + 'px ' + blur + 'px ' + color;
        } else {
            v = 'none';
        }
        this.deStyle.boxShadow = v;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Checks if this view is visible and each view in the parent chain to
        the RootView is also visible. Dom elements are not explicitly
        checked. If you need to check that use myt.DomElementProxy.isDomElementVisible.
        @returns true if this view is visible, false otherwise. */
    isVisible: function() {
        return this.searchAncestorsOrSelf(function(v) {return !v.visible;}) === null;
    },
    
    /** Finds the youngest ancestor (or self) that is a focusTrap or focusCage.
        @param ignoreFocusTrap:boolean indicates focusTraps should be
            ignored.
        @returns a View with focusTrap set to true or null if not found. */
    getFocusTrap: function(ignoreFocusTrap) {
        return this.searchAncestorsOrSelf(
            function(v) {
                return v.focusCage || (v.focusTrap && !ignoreFocusTrap);
            }
        );
    },
    
    /** @overrides myt.Node
        Calls this.subviewAdded if the added subnode is a myt.View. 
        @fires subviewAdded event with the provided Node if it's a View. 
        @fires layoutAdded event with the provided node if it's a Layout. */
    subnodeAdded: function(node) {
        if (node instanceof myt.View) {
            this.domElement.appendChild(node.domElement);
            this.getSubviews().push(node);
            this.fireNewEvent('subviewAdded', node);
            this.subviewAdded(node);
        } else if (node instanceof myt.Layout) {
            this.getLayouts().push(node);
            this.fireNewEvent('layoutAdded', node);
            this.layoutAdded(node);
        }
    },
    
    /** @overrides myt.Node
        Calls this.subviewRemoved if the remove subnode is a myt.View.
        @fires subviewRemoved event with the provided Node if it's a View
            and removal succeeds. 
        @fires layoutRemoved event with the provided Node if it's a Layout
            and removal succeeds. */
    subnodeRemoved: function(node) {
        var idx;
        if (node instanceof myt.View) {
            idx = this.getSubviewIndex(node);
            if (idx !== -1) {
                this.fireNewEvent('subviewRemoved', node);
                node.removeDomElement();
                this.subviews.splice(idx, 1);
                this.subviewRemoved(node);
            }
        } else if (node instanceof myt.Layout) {
            idx = this.getLayoutIndex(node);
            if (idx !== -1) {
                this.fireNewEvent('layoutRemoved', node);
                this.layouts.splice(idx, 1);
                this.layoutRemoved(node);
            }
        }
    },
    
    // Subviews //
    /** Checks if this View has the provided View in the subviews array.
        @param sv:View the view to look for.
        @returns true if the subview is found, false otherwise. */
    hasSubview: function(sv) {
        return this.getSubviewIndex(sv) !== -1;
    },
    
    /** Gets the index of the provided View in the subviews array.
        @param sv:View the view to look for.
        @returns the index of the subview or -1 if not found. */
    getSubviewIndex: function(sv) {
        return this.getSubviews().indexOf(sv);
    },
    
    /** Called when a View is added to this View. Do not call this method to 
        add a View. Instead call addSubnode or setParent.
        @param sv:View the view that was added.
        @returns void */
    subviewAdded: function(sv) {},
    
    /** Called when a View is removed from this View. Do not call this method 
        to remove a View. Instead call removeSubnode or setParent.
        @param sv:View the view that was removed.
        @returns void */
    subviewRemoved: function(sv) {},
    
    /** Gets the next sibling view based on lexical ordering of dom elements.
        @returns myt.View: The next sibling view or null if none exists. */
    getNextSibling: function() {
        if (this.parent) {
            var nextDomElement = this.domElement.nextElementSibling;
            if (nextDomElement) return nextDomElement.model;
        }
        return null;
    },
    
    /** Gets the previous sibling view.
        @returns myt.View: The previous sibling view or null if none exists. */
    getPrevSibling: function() {
        if (this.parent) {
            var prevDomElement = this.domElement.previousElementSibling;
            if (prevDomElement) return prevDomElement.model;
        }
        return null;
    },
    
    // Layouts //
    /** Checks if this View has the provided Layout in the layouts array.
        @param layout:Layout the layout to look for.
        @returns true if the layout is found, false otherwise. */
    hasLayout: function(layout) {
        return this.getLayoutIndex(layout) !== -1;
    },
    
    /** Gets the index of the provided Layout in the layouts array.
        @param layout:Layout the layout to look for.
        @returns the index of the layout or -1 if not found. */
    getLayoutIndex: function(layout) {
        return this.getLayouts().indexOf(layout);
    },
    
    /** Called when a Layout is added to this View. Do not call this method to 
        add a Layout. Instead call addSubnode or setParent.
        @param layout:Layout the layout that was added.
        @returns void */
    layoutAdded: function(layout) {},
    
    /** Called when a Layout is removed from this View. Do not call this 
        method to remove a Layout. Instead call removeSubnode or setParent.
        @param layout:Layout the layout that was removed.
        @returns void */
    layoutRemoved: function(layout) {},
    
    // Dom-Ordering //
    /** Test if the provided view is behind this view. The view to test can
        be anywhere in the document.
        @param view:myt.View the view to check.
        @param checkZIndex:boolean (optional) If true z-index will first be
            used to check if the view is behind or not.
        @returns boolean: true if the view is behind this view, 
            false otherwise. */
    isBehind: function(view, checkZIndex) {
        return this.__comparePosition(view, false, checkZIndex);
    },
    
    /** Test if the provided view is front of this view. The view to test can
        be anywhere in the document.
        @param view:myt.View the view to check.
        @param checkZIndex:boolean (optional) If true z-index will first be
            used to check if the view is in front or not.
        @returns boolean: true if the view is in front of this view, 
            false otherwise. */
    isInFrontOf: function(view, checkZIndex) {
        return this.__comparePosition(view, true, checkZIndex);
    },
    
    /** Implements isBehind and isInFrontOf methods.
        @private
        @param front:boolean indicates if this is the isInFrontOf test or not.
        @returns boolean */
    __comparePosition: function(view, front, checkZIndex) {
        if (view) {
            if (checkZIndex) {
                var commonAncestor = this.getLeastCommonAncestor(view);
                if (commonAncestor) {
                    var commonAncestorElem = commonAncestor.domElement,
                        DEP = myt.DomElementProxy,
                        zIdx = DEP.getZIndexRelativeToAncestor(this.domElement, commonAncestorElem),
                        otherZIdx = DEP.getZIndexRelativeToAncestor(view.domElement, commonAncestorElem);
                    
                    // Reverse comparison order
                    if (front) {
                        zIdx *= -1;
                        otherZIdx *= -1;
                    }
                    
                    if (zIdx < otherZIdx) {
                        return true;
                    } else if (otherZIdx < zIdx) {
                        return false;
                    }
                    // Fall through to dom comparison since z-indices are equal.
                }
            }
            
            // DOCUMENT_POSITION_DISCONNECTED 1
            // DOCUMENT_POSITION_PRECEDING 2
            // DOCUMENT_POSITION_FOLLOWING 4
            // DOCUMENT_POSITION_CONTAINS 8
            // DOCUMENT_POSITION_CONTAINED_BY 16
            // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC 32
            var rel = this.domElement.compareDocumentPosition(view.domElement);
            return front ? rel === 2 || rel === 10 : rel === 4 || rel === 20;
        } else {
            return false;
        }
    },
    
    /** Brings this view to the front. */
    bringToFront: function() {
        this.parent.bringSubviewToFront(this);
    },
    
    /** Sends this view to the back. */
    sendToBack: function() {
        this.parent.sendSubviewToBack(this);
    },
    
    /** Sends this view behind the provided sibling view. */
    sendBehind: function(sv) {
        this.parent.sendSubviewBehind(this, sv);
    },
    
    /** Sends this view in front of the provided sibling view. */
    sendInFrontOf: function(sv) {
        this.parent.sendSubviewInFrontOf(this, sv);
    },
    
    /** Sends the provided subview to the back.
        @param sv:View the subview of this view to bring to front.
        @returns void */
    bringSubviewToFront: function(sv) {
        if (sv && sv.parent === this) {
            var de = this.domElement;
            if (sv.domElement !== de.lastChild) {
                myt.View.retainFocusDuringDomUpdate(sv, function() {
                    de.appendChild(sv.domElement);
                });
            }
        }
    },
    
    /** Sends the provided subview to the back.
        @param sv:View the subview of this view to send to back.
        @returns void */
    sendSubviewToBack: function(sv) {
        if (sv && sv.parent === this) {
            var de = this.domElement;
            if (sv.domElement !== de.firstChild) {
                myt.View.retainFocusDuringDomUpdate(sv, function() {
                    de.insertBefore(sv.domElement, de.firstChild);
                });
            }
        }
    },
    
    /** Sends the subview behind the existing subview.
        @param sv:View the subview to send behind the existing view.
        @param existing:View the subview to send the other subview behind.
        @returns void */
    sendSubviewBehind: function(sv, existing) {
        if (sv && existing && sv.parent === this && existing.parent === this) {
            var de = this.domElement;
            myt.View.retainFocusDuringDomUpdate(sv, function() {
                de.insertBefore(sv.domElement, existing.domElement);
            });
        }
    },
    
    /** Sends the subview in front of the existing subview.
        @param sv:View the subview to send in front of the existing view.
        @param existing:View the subview to send the other subview in front of.
        @returns void */
    sendSubviewInFrontOf: function(sv, existing) {
        if (sv && existing && sv.parent === this && existing.parent === this) {
            this.sendSubviewBehind(sv, existing);
            this.sendSubviewBehind(existing, sv);
        }
    },
    
    /** Sorts the subviews array according to the provided sort function.
        Also rearranges the dom elements so that focus navigation and z
        ordering get updated.
        @param sortFunc:function the sort function to sort the subviews with.
        @returns void */
    sortSubviews: function(sortFunc) {
        // Sort subviews
        var svs = this.getSubviews(), i = svs.length;
        svs.sort(sortFunc);
        
        // Rearrange dom to match new sort order.
        while (i) this.sendSubviewToBack(svs[--i]);
    },
    
    // Hit Testing //
    /** Checks if the provided location is inside this view or not.
        @param locX:number the x position to test.
        @param locY:number the y position to test.
        @param referenceFrameDomElem:dom_element (optional) The dom element
            the locX and locY are relative to. If not provided the page is
            assumed.
        @returns boolean True if the location is inside this view, false 
            if not. */
    containsPoint: function(locX, locY, referenceFrameDomElem) {
        var de = this.domElement;
        if (!de) return false;
        
        var pos = myt.DomElementProxy.getPagePosition(de, referenceFrameDomElem);
        return myt.Geometry.rectContainsPoint(locX, locY, pos.x, pos.y, this.width, this.height);
    },
    
    /** Checks if the provided location is visible on this view and is not
        masked by the bounding box of the view or any of its ancestor views.
        @returns boolean: true if visible, false otherwise. */
    isPointVisible: function(locX, locY) {
        var pos = this.getTruePagePosition();
        this.calculateEffectiveScale();
        return this.__isPointVisible(locX - pos.x, locY - pos.y);
    },
    
    /** @private */
    __isPointVisible: function(x, y) {
        var effectiveScale = this.__effectiveScale;
        
        if (myt.Geometry.rectContainsPoint(x, y, 0, 0, this.width * effectiveScale, this.height * effectiveScale)) {
            var p = this.parent;
            if (p) {
                var de = p.domElement, pScale = p.__effectiveScale;
                return p.__isPointVisible(x + (this.x - de.scrollLeft) * pScale, y + (this.y - de.scrollTop) * pScale);
            }
            return true;
        }
        return false;
    },
    
    calculateEffectiveScale: function() {
        var ancestors = this.getAncestors(), i = ancestors.length, ancestor,
            effectiveScale = 1;
        while (i) {
            ancestor = ancestors[--i];
            effectiveScale *= ancestor.scaleX || 1;
            ancestor.__effectiveScale = effectiveScale;
        }
    },
    
    getEffectiveScale: function() {
        this.calculateEffectiveScale();
        return this.__effectiveScale;
    }
});


/** Adds CSS3 transform support to a View.
    
    Events:
        transformOrigin:string
        rotation:number
        scaleX:number
        scaleY:number
        skewX:number
        skewY:number
    
    Attributes:
        transformOrigin:string The origin point for transforms.
        rotation:number The rotation in degrees.
        scale:number (write only) Sets the scale for the view in both the x 
            and y dimension to the same value. A value of 1 is no scaling, 
            0.5 is 50%, 2 is 200%, etc. Note: The setters for scaleX and 
            scaleY are not called.
        scaleX:number The scale for the view in the x-dimension. A value of 1 
            is no scaling, 0.5 is 50%, 2 is 200%, etc.
        scaleY:number The scale for the view in the y-dimension. A value of 1 
            is no scaling, 0.5 is 50%, 2 is 200%, etc.
        skewX:number Sets the horizontal skew in degrees.
        skewY:number Sets the vertical skew in degrees.
*/
myt.TransformSupport = new JS.Module('TransformSupport', {
    // Class Methods ///////////////////////////////////////////////////////////
    extend: {
        /** Sets the 'transformOrigin' style property of the provided
            style property map.
            @param s:Object the style map to modify.
            @param v:string the transformOrigin to set.
            @returns void */
        setTransformOrigin: function(s, v) {
            s[this._styleOriginKey] = v || '50% 50% 0';
        },
        
        /** Adds an entry to the 'transform' style property of the provided
            style property map.
            @param s:Object the style map to modify.
            @param type:string the type of transform: 'rotate', 'scaleX', 
                'scaleY', 'skewX', 'skewY'.
            @param v:string the style value to set.
            @returns void */
        addTransform: function(s, type, v) {
            var cur = this.removeTransform(s, type);
            s[this._styleKey] = cur + (cur.length === 0 ? '' : ' ') + type + '(' + v + ')';
        },
        
        /** Removes an entry from the 'transform' style property of the provided
            style property map.
            @param s:Object the style map to modify.
            @param type:string the type of transform: 'rotate', 'scaleX', 
                'scaleY', 'skewX', 'skewY'.
            @returns string: the new transform value after the removal has been
                applied. */
        removeTransform: function(s, type) {
            var key = this._styleKey, value = s[key];
            
            if (!value || value.length === 0) return '';
            
            var parts = value.split(' '), i = parts.length;
            while (i) {
                if (parts[--i].indexOf(type) === 0) {
                    parts.splice(i, 1);
                    break;
                }
            }
            
            return s[key] = parts.join(' ');
        },
        
        /** Gets the total scaling being applied to an element. Walks up the
            ancestor chain multiplying the scaleX and scaleY.
            @param elem:myt.View the view to calculate scaling for.
            @returns object containing 'scaleX' and 'scaleY' numbers. */
        getEffectiveScale: function(elem) {
            var scaleX = 1, scaleY = 1;
            while (elem) {
                if (elem.scaleX != null) scaleX *= elem.scaleX;
                if (elem.scaleY != null) scaleY *= elem.scaleY;
                elem = elem.parent;
            }
            return {scaleX:scaleX, scaleY:scaleY};
        }
    },
    
    // Accessors ///////////////////////////////////////////////////////////////
    setTransformOrigin: function(v) {
        if (this.transformOrigin !== v) {
            this.transformOrigin = v;
            myt.TransformSupport.setTransformOrigin(this.deStyle, v);
            if (this.inited) {
                this.__updateBounds(this.width, this.height);
                this.fireNewEvent('transformOrigin', v);
            }
        }
    },
    
    setRotation: function(v) {
        if (this.rotation !== v) {
            this.rotation = v;
            myt.TransformSupport.addTransform(this.deStyle, 'rotate', (v || 0) + 'deg');
            if (this.inited) {
                this.__updateBounds(this.width, this.height);
                this.fireNewEvent('rotation', v);
            }
        }
    },
    
    setScale: function(v) {
        var doUpdateX = this.scaleX !== v;
        if (doUpdateX) this.__applyScale('scaleX', this.scaleX = v);
        
        var doUpdateY = this.scaleY !== v;
        if (doUpdateY) this.__applyScale('scaleY', this.scaleY = v);
        
        if (this.inited) {
            if (doUpdateX || doUpdateY) this.__updateBounds(this.width, this.height);
            if (doUpdateX) this.fireNewEvent('scaleX', v);
            if (doUpdateY) this.fireNewEvent('scaleY', v);
        }
    },
    
    setScaleX: function(v) {
        if (this.scaleX !== v) {
            this.__applyScale('scaleX', this.scaleX = v);
            if (this.inited) {
                this.__updateBounds(this.width, this.height);
                this.fireNewEvent('scaleX', v);
            }
        }
    },
    
    setScaleY: function(v) {
        if (this.scaleY !== v) {
            this.__applyScale('scaleY', this.scaleY = v);
            if (this.inited) {
                this.__updateBounds(this.width, this.height);
                this.fireNewEvent('scaleY', v);
            }
        }
    },
    
    /** @private */
    __applyScale: function(axis, v) {
        if (v == null) {
            myt.TransformSupport.removeTransform(this.deStyle, axis);
        } else {
            myt.TransformSupport.addTransform(this.deStyle, axis, v || 1); // Also converts 0 to 1.
        }
    },
    
    setSkewX: function(v) {
        if (this.skewX !== v) {
            this.skewX = v;
            myt.TransformSupport.addTransform(this.deStyle, 'skewX', v || 0);
            if (this.inited) {
                this.__updateBounds(this.width, this.height);
                this.fireNewEvent('skewX', v);
            }
        }
    },
    
    setSkewY: function(v) {
        if (this.skewY !== v) {
            this.skewY = v;
            myt.TransformSupport.addTransform(this.deStyle, 'skewY', v || 0);
            if (this.inited) {
                this.__updateBounds(this.width, this.height);
                this.fireNewEvent('skewY', v);
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.View
        @private */
    __updateBounds: function(w, h) {
        var r = this.rotation, sx = this.scaleX, sy = this.scaleY, notScaled = false;
        if ((sx === undefined || sx === 1) && (sy === undefined || sy === 1)) notScaled = true;
        
        if (notScaled && (r === undefined || r === 0 || r === 180)) {
            // Do nothing
        } else if (notScaled && (r === 90 || r === 270)) {
            w = this.height;
            h = this.width;
        } else {
            var b = this.domElement.getBoundingClientRect();
            w = b.width;
            h = b.height;
        }
        
        this.callSuper(w, h);
    }
});

/** Setup style keys for myt.TransformSupport one time only based on the
    browser being used. */
(function() {
    var prefix;
    switch (BrowserDetect.browser) {
        case 'Chrome': case 'Safari': case 'OmniWeb': 
            prefix = 'webkit';
            break;
        case 'MSIE': 
            prefix = 'ms';
            break;
        case 'Opera': 
            prefix = 'o';
            break;
        case 'Firefox': default: 
            prefix = '';
    }
    
    this._styleKey = prefix ? prefix + 'Transform' : 'transform';
    this._styleOriginKey = this._styleKey + 'Origin';
}).call(myt.TransformSupport);


/** A mixin that sizes the view to the width and height of the dom element.
    
    Events:
        None
    
    Attributes:
        width:number:string If a number the behavior is defined by the
            superclass. If a string value of 'auto' is provided sizing to
            the dom will occur. Using 'auto' allows the original SizeToDom
            behavior to be restored after an explicit width has been set.
        height:number:string If a number the behavior is defined by the
            superclass. If a string value of 'auto' is provided sizing to
            the dom will occur. Using 'auto' allows the original SizeToDom
            behavior to be restored after an explicit height has been set.
    
    Private Attributes:
        __hasSetWidth:boolean Indicates the an explicit width has been set
            so that should be used rather than sizing to the dom element.
        __hasSetHeight:boolean Indicates the an explicit height has been set
            so that should be used rather than sizing to the dom element.
*/
myt.SizeToDom = new JS.Module('SizeToDom', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View 
        Subclasses should call super. */
    doAfterAdoption: function() {
        this.sizeViewToDom();
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    setWidth: function(v, supressEvent) {
        if (v === 'auto') {
            this.__hasSetWidth = false;
            this.deStyle.width = 'auto';
            this.sizeViewToDom();
        } else {
            this.__hasSetWidth = true;
            this.callSuper(v, supressEvent);
        }
    },
    
    /** @overrides myt.View */
    setHeight: function(v, supressEvent) {
        if (v === 'auto') {
            this.__hasSetHeight = false;
            this.deStyle.height = 'auto';
            this.sizeViewToDom();
        } else {
            this.__hasSetHeight = true;
            this.callSuper(v, supressEvent);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Call this method after any change to the width or height of the dom
        element would have occurred.
        @returns void */
    sizeViewToDom: function() {
        var bounds, scaling;
        
        if (!this.__hasSetWidth) {
            bounds = this.domElement.getBoundingClientRect();
            var w = bounds.width;
            
            // Bounding rect doesn't factor in scaling so we need to calculate
            // this ourselves.
            scaling = myt.TransformSupport.getEffectiveScale(this);
            w /= scaling.scaleX;
            
            // Circumvent setter
            if (this.width !== w) {
                this.width = w;
                if (this.inited) this.__updateBounds(w, this.height);
                this.fireNewEvent('width', w);
            }
        }
        
        if (!this.__hasSetHeight) {
            if (!bounds) bounds = this.domElement.getBoundingClientRect();
            var h = bounds.height;
            
            // Bounding rect doesn't factor in scaling so we need to calculate
            // this ourselves.
            if (!scaling) scaling = myt.TransformSupport.getEffectiveScale(this);
            h /= scaling.scaleY;
            
            // Circumvent setter
            if (this.height !== h) {
                this.height = h;
                if (this.inited) this.__updateBounds(this.width, h);
                this.fireNewEvent('height', h);
            }
        }
    }
});


/** Adds support for text display to a View.
    
    Requires:
        myt.SizeToDom super mixin.
    
    Events:
        text:string
        textOverflow:string
        textAlign:string
        whiteSpace:string
        wordWrap:string
        textIndent:string
        textTransform:string
        textDecoration:string
        lineHeight:string
        letterSpacing:string
        wordSpacing:string
        fontFamily:string
        fontStyle:string
        fontVariant:string
        fontWeight:string
        fontSize:string
    
    Attributes:
        text:string|event(string) The text to be displayed. The value will 
            be assigned to the inner html of the div.
        textOverflow:string How text will be treated when it overflows the
            bounds. Supported values: 'ellipsis', 'clip', 'inherit'.
        textAlign:string How text will be aligned within the bounds. Supported 
            values: 'left', 'right', 'center', 'justify', 'inherit'.
        whiteSpace:string How white space is handled. Supported values: 
            'normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'inherit'.
        wordWrap:string How line wrapping is done. Supported 
            values: 'break-word', 'normal'.
        textIndent:string How text gets indented. Supported values: '20px', 
            '10%', 'inherit'.
        textTransform:string Transformation performed on the text during
            display. Supported values: 'none', 'capitalize', 'uppercase', 
            'lowercase', 'inherit'.
        textDecoration:string Visual decoration to the text. Supported 
            values: 'none', 'underline', 'overline', 'line-through', 
            'blink', 'inherit'.
        lineHeight:string The height of individual lines of text. Supported 
            values: 'normal', '1.5', '22px', '150%', 'inherit'.
        letterSpacing:string Spacing between letters. Supported values: 
            'normal', '3px', 'inherit'.
        wordSpacing:string Spacing between words. Supported values: 
            'normal', '3px', 'inherit'.
        fontFamily:string The name of a font to use. The value will be 
            assigned to the font family CSS parameter.
        fontStyle:string Styling applied to the text. Supported values: 
            'normal', 'italic', 'oblique', 'inherit'.
        fontVariant:string The font variant. Supported values: 'normal', 
            'small-caps', 'inherit'.
        fontWeight:string The font weight. Supported values: 'normal', 'bold', 
            'bolder', 'lighter', '100-900', 'inherit'.
        fontSize:string The size of the font. Supported values: 'normal, 
            '14px', '14pt', 'xx-small', 'x-small', 'small', 'medium', 'large', 
            'x-large', 'xx-large', 'smaller', 'larger', '75%', 'inherit'.
        userUnselectable:boolean If set to true the CSS property user-select 
            will be set to 'none' thus making text selection not work.
            Furthermore, the cursor will be set to the default so it no longer
            appears as an i-beam.
*/
myt.TextSupport = new JS.Module('TextSupport', {
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    setWidth: function(v, supressEvent) {
        this.callSuper(v, supressEvent);
        
        // Height can change with width change when wrapping occurs.
        if (v !== 'auto') {
            var ws = this.whiteSpace;
            if (ws === 'normal' || ws === 'pre-line' || ws === 'pre-wrap') {
                this.sizeViewToDom();
            }
        }
    },
    
    setText: function(v) {
        if (!v) v = '';
        if (typeof v === 'object') v = v.value;
        
        if (this.text !== v) {
            // Use innerHTML rather than textContent since this allows us to
            // embed formatting markup.
            this.domElement.innerHTML = this.text = v;
            if (this.inited) {
                this.fireNewEvent('text', v);
                this.sizeViewToDom();
            }
        }
    },
    
    // Text Attributes
    setTextOverflow: function(v) {
        if (this.textOverflow !== v) {
            this.textOverflow = v;
            this.deStyle.textOverflow = v || 'inherit';
            if (this.inited) this.fireNewEvent('textOverflow', v);
        }
    },
    
    setTextAlign: function(v) {
        if (this.textAlign !== v) {
            this.textAlign = v;
            this.deStyle.textAlign = v || 'inherit';
            if (this.inited) this.fireNewEvent('textAlign', v);
        }
    },
    
    setWhiteSpace: function(v) {this.__s(v, 'whiteSpace');},
    setWordWrap: function(v) {this.__s(v, 'wordWrap', 'normal');},
    setTextIndent: function(v) {this.__s(v, 'textIndent');},
    setTextTransform: function(v) {this.__s(v, 'textTransform');},
    setTextDecoration: function(v) {this.__s(v, 'textDecoration');},
    setLineHeight: function(v) {this.__s(v, 'lineHeight');},
    setLetterSpacing: function(v) {this.__s(v, 'letterSpacing');},
    setWordSpacing: function(v) {this.__s(v, 'wordSpacing');},
    
    // Font Attributes
    setFontFamily: function(v) {this.__s(v, 'fontFamily');},
    setFontStyle: function(v) {this.__s(v, 'fontStyle');},
    setFontVariant: function(v) {this.__s(v, 'fontVariant');},
    setFontWeight: function(v) {this.__s(v, 'fontWeight');},
    setFontSize: function(v) {this.__s(v, 'fontSize');},
    
    /** A private setter function that provides a common implementation for
        most of this setters in this mixin.
        @private */
    __s: function(v, attrName, defaultValue) {
        if (this[attrName] !== v) {
            this[attrName] = v;
            this.deStyle[attrName] = v || defaultValue || 'inherit';
            if (this.inited) {
                this.fireNewEvent(attrName, v);
                this.sizeViewToDom();
            }
        }
    },
    
    setUserUnselectable: function(v) {
        if (this.userUnselectable !== v) {
            this.userUnselectable = v;
            this[v ? 'addDomClass' : 'removeDomClass']('mytUnselectable');
            this.setCursor(v ? 'default' : 'text');
            if (this.inited) this.fireNewEvent('userUnselectable', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Configures the attributes for this Text so that an ellipsis will be
        displayed. To actually see an ellipsis, an explicit width should be
        set on the Text so that overflow will occur.
        @returns void */
    enableEllipsis: function() {
        this.setWhiteSpace('nowrap');
        this.setOverflow('hidden');
        this.setTextOverflow('ellipsis');
    },
    
    /** Turns ellipsis off by setting overflow to 'visible'. Other CSS
        related changes for ellipsis are not undone such as whiteSpace and
        textOverflow.
        @returns void */
    disableEllipsis: function() {
        this.setOverflow('visible');
    },
    
    /** Turns on a text shadow.
        @param x:number (optional) The x offset in pixels of the shadow.
            Defaults to 0 if not provided.
        @param y:number (optional) The y offset in pixels of the shadow.
            Defaults to 0 if not provided.
        @param blur:number (optional) The bluriness in pixels of the shadow.
            Defaults to 2 if not provided.
        @param color:color_string (optional) The color of the shadow. Defaults
            to '#000000' if not provided.
        @param extraStrength:number (optional) The number of times to render 
            the shadow to give the shadow extra opacity.
        @returns void */
    showTextShadow: function(x, y, blur, color, extraStrength) {
        var shadow = (x || 0) + 'px ' + 
            (y || 0) + 'px ' + 
            (blur != null ? blur : 2) + 'px ' + 
            (color || '#000000');
            
        if (extraStrength > 0) {
            var value = [shadow];
            while (extraStrength--) value.push(shadow);
            shadow = value.join(',');
        }
        
        this.deStyle.textShadow = shadow;
    },
    
    /** Turns off a text shadow.
        @returns void */
    hideTextShadow: function() {
        this.deStyle.textShadow = 'none';
    }
});


/** Displays text content.
    
    Performance Note: If you set the bgColor of a text element it will render
    about 10% faster than if the background is set to 'transparent'. */
myt.Text = new JS.Class('Text', myt.View, {
    include: [myt.SizeToDom, myt.TextSupport],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        if (attrs.whiteSpace === undefined) attrs.whiteSpace = 'nowrap';
        
        this.callSuper(parent, attrs);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Measures the width of this element as if the wrapping was set 
        to 'nowrap'. The dom element is manipulated directly so that no 
        events get fired.
        @returns number the unwrapped width of this text view. */
    measureNoWrapWidth: function() {
        if (this.whiteSpace === 'nowrap') return this.width;
        
        // Temporarily set wrapping to 'nowrap', take measurement and
        // then restore wrapping.
        var s = this.deStyle, oldValue = s.whiteSpace;
        s.whiteSpace = 'nowrap';
        var measuredWidth = this.domElement.getBoundingClientRect().width;
        s.whiteSpace = oldValue;
        return measuredWidth;
    }
});


/** Displays HTML markup and resizes the view to fit the markup.
    
    Attributes:
        html:string The HTML to insert into the view.
*/
myt.Markup = new JS.Class('Markup', myt.View, {
    include: [myt.SizeToDom],
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setHtml: function(v) {
        if (this.html !== v) {
            this.domElement.innerHTML = this.html = v;
            if (this.inited) {
                this.fireNewEvent('html', v);
                this.sizeViewToDom();
            }
        }
    }
});


/** A view for an iframe. This component also listens to global mousedown/up
    events and turns off point-events so that the iframe will interfere
    less with mouse behavior in the parent document.
    
    Events:
        src:string
    
    Attributes:
        src:string The URL to an HTML document to load into the iframe.
    
    Private Attributes:
        __restorePointerEvents:string The value of pointerEvents before a
            mousedown occurs. Used as part of turning off pointer-events
            so that the iframe messes less with mouse behavior in the 
            parent document.
*/
myt.Frame = new JS.Class('Frame', myt.View, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        var gm = myt.global.mouse;
        this.attachToDom(gm, '__doMouseDown', 'mousedown', true);
        this.attachToDom(gm, '__doMouseUp', 'mouseup', true);
    },
    
    /** @overrides myt.View */
    createOurDomElement: function(parent) {
        var elem = document.createElement('iframe'),
            s = elem.style;
        s.position = 'absolute';
        s.border = '0px';
        return elem;
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSrc: function(v) {
        if (this.src !== v) {
            this.src = this.domElement.src = v;
            if (this.inited) this.fireNewEvent('src', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __doMouseDown: function(event) {
        this.__restorePointerEvents = this.pointerEvents;
        this.setPointerEvents('none');
        return true;
    },
    
    /** @private */
    __doMouseUp: function(event) {
        this.setPointerEvents(this.__restorePointerEvents);
        return true;
    }
});


/** A variation of myt.SizeToDom that sizes the view to the width of the 
    dom element only.
    
    Events:
        None
    
    Attributes:
        width:number:string If a number the behavior is defined by the
            superclass. If a string value of 'auto' is provided sizing to
            the dom will occur. Using 'auto' allows the original SizeToDom
            behavior to be restored after an explicit width has been set.
    
    Private Attributes:
        __hasSetWidth:boolean Indicates the an explicit width has been set
            so that should be used rather than sizing to the dom element.
*/
myt.SizeWidthToDom = new JS.Module('SizeWidthToDom', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View 
        Subclasses should call super. */
    doAfterAdoption: function() {
        this.sizeViewToDom();
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    setWidth: function(v, supressEvent) {
        if (v === 'auto') {
            this.__hasSetWidth = false;
            this.deStyle.width = 'auto';
            this.sizeViewToDom();
        } else {
            this.__hasSetWidth = true;
            this.callSuper(v, supressEvent);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Call this method after any change to the width of the dom
        element would have occurred.
        @returns void */
    sizeViewToDom: function() {
        if (!this.__hasSetWidth) {
            // Bounding rect doesn't factor in scaling so we need to calculate
            // this ourselves.
            var scaling = myt.TransformSupport.getEffectiveScale(this);
            
            var w = this.domElement.getBoundingClientRect().width / scaling.scaleX;
            
            // Circumvent setter
            if (this.width !== w) {
                this.width = w;
                if (this.inited) this.__updateBounds(w, this.height);
                this.fireNewEvent('width', w);
            }
        }
    }
});


/** A variation of myt.SizeToDom that sizes the view to the height of the 
    dom element only.
    
    Events:
        None
    
    Attributes:
        height:number:string If a number the behavior is defined by the
            superclass. If a string value of 'auto' is provided sizing to
            the dom will occur. Using 'auto' allows the original SizeToDom
            behavior to be restored after an explicit height has been set.
    
    Private Attributes:
        __hasSetHeight:boolean Indicates the an explicit height has been set
            so that should be used rather than sizing to the dom element.
*/
myt.SizeHeightToDom = new JS.Module('SizeHeightToDom', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View 
        Subclasses should call super. */
    doAfterAdoption: function() {
        this.sizeViewToDom();
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    setHeight: function(v, supressEvent) {
        if (v === 'auto') {
            this.__hasSetHeight = false;
            this.deStyle.height = 'auto';
            this.sizeViewToDom();
        } else {
            this.__hasSetHeight = true;
            this.callSuper(v, supressEvent);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Call this method after any change to the height of the dom
        element would have occurred.
        @returns void */
    sizeViewToDom: function() {
        if (!this.__hasSetHeight) {
            // Bounding rect doesn't factor in scaling so we need to calculate
            // this ourselves.
            var scaling = myt.TransformSupport.getEffectiveScale(this);
            
            var h = this.domElement.getBoundingClientRect().height / scaling.scaleY;
            
            // Circumvent setter
            if (this.height !== h) {
                this.height = h;
                if (this.inited) this.__updateBounds(this.width, h);
                this.fireNewEvent('height', h);
            }
        }
    }
});


/** A mixin that sizes a view to a percentage of its parent view.
    
    This is the inverse of a layout since the child is responsible for sizing
    itself to the parent rather than in a layout where the layout positions
    and sizes the children.
    
    Events:
        percentOfParentWidthOffset:number
        percentOfParentHeightOffset:number
        percentOfParentWidth:number
        percentOfParentHeight:number
        
    Attributes:
        percentOfParentWidthOffset:number An additional offset used to adjust
            the width of the parent. Defaults to undefined which is
            equivalent to 0.
        percentOfParentHeightOffset:number An additional offset used to adjust
            the height of the parent. Defaults to undefined which is
            equivalent to 0.
        percentOfParentWidth:number The percent of the parent views width
            to size this views width to. Should be a number between 0 and 100 
            or a negative value which means don't do resizing. Defaults to 
            undefined which is equivalent to a negative value.
        percentOfParentHeight:number The percent of the parent views height
            to size this views height to. Should be a number between 0 and 100 
            or a negative value which means don't do resizing. Defaults to 
            undefined which is equivalent to a negative value.
*/
myt.SizeToParent = new JS.Module('SizeToParent', {
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    setParent: function(parent) {
        if (this.parent !== parent) {
            if (this.inited) {
                this.__teardownPercentOfParentWidthConstraint();
                this.__teardownPercentOfParentHeightConstraint();
            }
            this.callSuper(parent);
            this.__setupPercentOfParentWidthConstraint();
            this.__setupPercentOfParentHeightConstraint();
        }
    },
    
    setPercentOfParentWidthOffset: function(v) {
        if (this.percentOfParentWidthOffset !== v) {
            this.percentOfParentWidthOffset = v;
            if (this.inited) {
                this.fireNewEvent('percentOfParentWidthOffset', v);
                this.__doPercentOfParentWidth();
            }
        }
    },
    
    setPercentOfParentWidth: function(v) {
        if (this.percentOfParentWidth !== v) {
            if (this.inited) this.__teardownPercentOfParentWidthConstraint();
            this.percentOfParentWidth = v;
            if (this.inited) this.fireNewEvent('percentOfParentWidth', v);
            this.__setupPercentOfParentWidthConstraint();
        }
    },
    
    setPercentOfParentHeightOffset: function(v) {
        if (this.percentOfParentHeightOffset !== v) {
            this.percentOfParentHeightOffset = v;
            if (this.inited) {
                this.fireNewEvent('percentOfParentHeightOffset', v);
                this.__doPercentOfParentHeight();
            }
        }
    },
    
    setPercentOfParentHeight: function(v) {
        if (this.percentOfParentHeight !== v) {
            if (this.inited) this.__teardownPercentOfParentHeightConstraint();
            this.percentOfParentHeight = v;
            if (this.inited) this.fireNewEvent('percentOfParentHeight', v);
            this.__setupPercentOfParentHeightConstraint();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __teardownPercentOfParentWidthConstraint: function() {
        if (this.percentOfParentWidth >= 0) this.detachFrom(this.parent, '__doPercentOfParentWidth', 'width');
    },
    
    /** @private */
    __setupPercentOfParentWidthConstraint: function() {
        var p = this.parent;
        if (p && this.percentOfParentWidth >= 0) this.syncTo(p, '__doPercentOfParentWidth', 'width');
    },
    
    /** @private */
    __doPercentOfParentWidth: function(event) {
        this.setWidth((this.percentOfParentWidthOffset || 0) + Math.round(this.parent.width * (this.percentOfParentWidth / 100)));
        // Force width event if not inited yet so that align constraint
        // in myt.View will work.
        if (!this.inited) this.fireNewEvent('width', this.width);
    },
    
    /** @private */
    __teardownPercentOfParentHeightConstraint: function() {
        if (this.percentOfParentHeight >= 0) this.detachFrom(this.parent, '__doPercentOfParentHeight', 'height');
    },
    
    /** @private */
    __setupPercentOfParentHeightConstraint: function() {
        var p = this.parent;
        if (p && this.percentOfParentHeight >= 0) this.syncTo(p, '__doPercentOfParentHeight', 'height');
    },
    
    /** @private */
    __doPercentOfParentHeight: function(event) {
        this.setHeight((this.percentOfParentHeightOffset || 0) + Math.round(this.parent.height * (this.percentOfParentHeight / 100)));
        // Force height event if not inited yet so that valign constraint
        // in myt.View will work.
        if (!this.inited) this.fireNewEvent('height', this.height);
    }
});


/** Provides events when a new myt.RootView is created or destroyed.
    Registered in myt.global as 'roots'.
    
    Events:
        rootAdded:RootView Fired when a RootView is added. The value is the 
            RootView added.
        rootRemoved:RootView Fired when a RootView is removed. The value is the 
            RootView removed.
    
    Attributes:
        None
    
    Private Attributes:
        __roots:array Holds an array of RootViews.
*/
new JS.Singleton('GlobalRootViewRegistry', {
    include: [myt.Observable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initialize: function() {
        this.__roots = [];
        myt.global.register('roots', this);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Gets the list of global root views.
        @returns array of RootViews. */
    getRoots: function() {
        return this.__roots;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Add a rootable to the global list of root views.
        @param r:RootView the RootView to add.
        @returns void */
    addRoot: function(r) {
        this.__roots.push(r);
        this.fireNewEvent('rootAdded', r);
    },
    
    /** Remove a rootable from the global list of root views.
        @param r:RootView the RootView to remove.
        @returns void */
    removeRoot: function(r) {
        var roots = this.__roots, i = roots.length, root;
        while(i) {
            root = roots[--i];
            if (root === r) {
                roots.splice(i, 1);
                this.fireNewEvent('rootRemoved', root);
                break;
            }
        }
    }
});


/** Allows a view to act as a "root" for a view hierarchy. A "root" view is 
    backed by a dom element from the page rather than a dom element created 
    by the view.
    
    Events:
        None
    
    Attributes:
        keepDomElementWhenDestroyed:boolean Indicates the dom element backing 
            this view must not be destroyed when this view is destroyed. 
            Defaults to undefined which is equivalent to false.
*/
myt.RootView = new JS.Module('RootView', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Prevents default drag/drop behavior.
            @param v:myt.View the view to supress default dragover and drop on.
            @returns void */
        setupCaptureDrop: function(v) {
            var cdf = v.__captureDrop = function(event) {event.preventDefault();},
                de = v.domElement;
            myt.addEventListener(de, 'drop', cdf);
            myt.addEventListener(de, 'dragover', cdf);
        },
        
        /** Cleanup dom listeners for drag/drop.
            @param v:myt.View the view that had supressed default dragover 
                and drop on.
            @returns void */
        teardownCaptureDrop: function(v) {
            var de = v.domElement, cdf = v.__captureDrop;
            myt.removeEventListener(de, 'drop', cdf);
            myt.removeEventListener(de, 'dragover', cdf);
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        // Establish a stacking context
        this.setZIndex(0);
        
        // Set a css class to allow scoping of CSS rules
        this.addDomClass('myt');
        
        myt.global.roots.addRoot(this);
        
        myt.RootView.setupCaptureDrop(this);
    },
    
    /** @overrides myt.View */
    createOurDomElement: function(parent) {
        // If no parent is provided create a new dom element
        if (!parent) {
            parent = this.callSuper(parent);
            myt.getElement().appendChild(parent);
        }
        
        // A root view has a dom element provided as the parent. We use
        // that dom element as our domElement.
        return parent;
    },
    
    /** @overrides myt.View */
    destroyAfterOrphaning: function() {
        myt.RootView.teardownCaptureDrop(this);
        
        myt.global.roots.removeRoot(this);
        if (!this.keepDomElementWhenDestroyed) this.removeDomElement();
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setKeepDomElementWhenDestroyed: function(keepDomElementWhenDestroyed) {
        this.keepDomElementWhenDestroyed = keepDomElementWhenDestroyed;
    },
    
    /** @overrides myt.Node */
    setParent: function(parent) {
        // A root view doesn't have a parent view.
        this.callSuper(undefined);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    bringToFront: function() {
        // Attempt to manipulate dom above root node.
        var de = this.domElement, parentNode = de.parentNode;
        if (de !== parentNode.lastChild) {
            var removedElem = parentNode.removeChild(de);
            if (removedElem) parentNode.appendChild(removedElem);
        }
    },
    
    /** @overrides myt.View */
    sendToBack: function() {
        // Attempt to manipulate dom above root node.
        var de = this.domElement, parentNode = de.parentNode;
        if (de !== parentNode.firstChild) {
            var removedElem = parentNode.removeChild(de);
            if (removedElem) parentNode.insertBefore(removedElem, parentNode.firstChild);
        }
    },
    
    /** @overrides myt.View */
    sendBehind: function(otherRootView) {
        // Attempt to manipulate dom above root node.
        var de = this.domElement,
            otherDe = otherRootView.domElement,
            parentNode = de.parentNode;
        if (otherDe.parentNode === parentNode) {
            var removedElem = parentNode.removeChild(de);
            if (removedElem) parentNode.insertBefore(removedElem, otherDe);
        }
    },
    
    /** @overrides myt.View */
    sendInFrontOf: function(otherRootView) {
        // Attempt to manipulate dom above root node.
        if (otherRootView.domElement.parentNode === this.domElement.parentNode) {
            this.sendBehind(otherRootView);
            otherRootView.sendBehind(this);
        }
    }
});


/** Provides events when the window is resized. Registered with myt.global
    as 'windowResize'.
    
    Events:
        resize:object Fired when the browser window is resized. This is a
            reused event stored at myt.global.windowResize.EVENT. The type
            is 'resize' and the value is an object containing:
                w:number the new window width.
                h:number the new window height.
    
    Attributes:
        EVENT:object The common resize event that gets fired.
    
    Private Attributes:
        __windowInnerWidth:number The inner width of the browser window.
        __windowInnerHeight:number The inner height of the browser window.
*/
new JS.Singleton('GlobalWindowResize', {
    include: [myt.Observable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initialize: function() {
        // The common browser resize event that gets reused.
        this.EVENT = {
            source:this, type:'resize', 
            value:{w:this.getWidth(), h:this.getHeight()}
        };
        
        var self = this;
        myt.addEventListener(window, 'resize', function(domEvent) {self.__handleEvent(domEvent);});
        
        myt.global.register('windowResize', this);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Gets the window's innerWidth.
        @returns the current width of the window. */
    getWidth: function() {
        return this.__windowInnerWidth || (this.__windowInnerWidth = window.innerWidth);
    },
    
    /** Gets the window's innerHeight.
        @returns the current height of the window. */
    getHeight: function() {
        return this.__windowInnerHeight || (this.__windowInnerHeight = window.innerHeight);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Handles the window resize event and broadcasts it to the observers.
        @private
        @param domEvent:object the window resize dom event.
        @returns void */
    __handleEvent: function(domEvent) {
        if (!domEvent) domEvent = window.event;
        
        var event = this.EVENT,
            value = event.value,
            isChanged = false,
            target = domEvent.target,
            w = target.innerWidth,
            h = target.innerHeight;
        if (w !== value.w) {
            value.w = this.__windowInnerWidth = w;
            isChanged = true;
        }
        if (h !== value.h) {
            value.h = this.__windowInnerHeight = h;
            isChanged = true;
        }
        
        if (isChanged) this.fireEvent(event);
    }
});


/** A mixin that sizes a RootView to the window width, height or both.
    
    Events:
        None
    
    Attributes:
        resizeDimension:string The dimension to resize in. Supported values
            are 'width', 'height' and 'both'. Defaults to 'both'.
        minWidth:number the minimum width below which this view will not 
            resize its width. Defaults to 0.
        minWidth:number the minimum height below which this view will not
            resize its height. Defaults to 0.
*/
myt.SizeToWindow = new JS.Module('SizeToWindow', {
    include: [myt.RootView],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.minWidth = this.minHeight = 0;
        if (attrs.resizeDimension === undefined) attrs.resizeDimension = 'both';
        
        this.attachTo(myt.global.windowResize, '__handleResize', 'resize');
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setResizeDimension: function(v) {
        if (this.resizeDimension !== v) {
            this.resizeDimension = v;
            this.__handleResize();
        }
    },
    
    setMinWidth: function(v) {
        if (this.minWidth !== v) {
            this.minWidth = v;
            this.__handleResize();
        }
    },
    
    setMinHeight: function(v) {
        if (this.minHeight !== v) {
            this.minHeight = v;
            this.__handleResize();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __handleResize: function(event) {
        var v = myt.global.windowResize.EVENT.value, // Ignore the provided event.
            dim = this.resizeDimension;
        if (dim === 'width' || dim === 'both') this.setWidth(Math.max(this.minWidth, v.w));
        if (dim === 'height' || dim === 'both') this.setHeight(Math.max(this.minHeight, v.h));
    }
});


/** A mixin that sizes a RootView to the window width. */
myt.SizeToWindowWidth = new JS.Module('SizeToWindowWidth', {
    include: [myt.SizeToWindow],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.SizeToWindow */
    initNode: function(parent, attrs) {
        if (attrs.resizeDimension === undefined) attrs.resizeDimension = 'width';
        
        this.callSuper(parent, attrs);
    }
});


/** A mixin that sizes a RootView to the window height. */
myt.SizeToWindowHeight = new JS.Module('SizeToWindowHeight', {
    include: [myt.SizeToWindow],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.SizeToWindow */
    initNode: function(parent, attrs) {
        if (attrs.resizeDimension === undefined) attrs.resizeDimension = 'height';
        
        this.callSuper(parent, attrs);
    }
});


/** Provides idle events. Registered with myt.global as 'idle'.
    
    Events:
        idle:object Fired when a browser idle event occurs. The event value is
            an object containing:
                delta: The time in millis since the last idle evnet.
                time: The time in millis of this idle event.
    
    Attributes:
        running:boolean Indicates if idle events are currently being fired
            or not.
        lastTime:number The millis of the last idle event fired.
    
    Private Attributes:
        __timerId:number The ID of the last idle event in the browser.
        __doIdle:function The function that gets executed on idle.
        __event:object The idle event object that gets reused.
*/
new JS.Singleton('GlobalIdle', {
    include: [myt.Observable],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        this.running = false;
        
        var vendor, vendors = ['webkit','moz','ms','o'], win = window;
        for (var i = 0; i < vendors.length && !win.requestAnimationFrame; ++i) {
            vendor = vendors[i];
            win.requestAnimationFrame = win[vendor + 'RequestAnimationFrame'];
            win.cancelAnimationFrame = win[vendor + 'CancelAnimationFrame'] || win[vendor + 'CancelRequestAnimationFrame'];
        }
        
        // Setup callback function
        var self = this;
        this.__event = {};
        this.__doIdle = function doIdle(time) {
            self.__timerId = win.requestAnimationFrame(doIdle);
            var lastTime = self.lastTime;
            if (lastTime !== -1) {
                time = Math.round(time);
                var event = self.__event;
                event.delta = time - lastTime;
                event.time = time;
                self.fireNewEvent('idle', event);
            }
            self.lastTime = time;
        };
        
        myt.global.register('idle', this);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Observable */
    attachObserver: function(observer, methodName, type) {
        var retval = this.callSuper(observer, methodName, type);
        
        // Start firing idle events
        if (!this.running && this.hasObservers('idle')) {
            this.running = true;
            this.lastTime = -1;
            this.__timerId = window.requestAnimationFrame(this.__doIdle);
        }
        
        return retval;
    },
    
    /** @overrides myt.Observable */
    detachObserver: function(observer, methodName, type) {
        var retval = this.callSuper(observer, methodName, type);
        
        // Stop firing idle events
        if (this.running && !this.hasObservers('idle')) {
            window.cancelAnimationFrame(this.__timerId);
            this.running = false;
        }
        
        return retval;
    }
});


/** Changes the value of an attribute on a target over time.
    
    Events:
        running:boolean Fired when the animation starts or stops.
        paused:boolean Fired when the animation is paused or unpaused.
        reverse:boolean
        easingFunction:function
        from:number
        to:number
        repeat:Fired when the animation repeats. The value is the current
            loop count.
        
    Attributes:
        attribute:string The attribute to animate.
        target:object The object to animate the attribute on. The default is 
            the parent of this node.
        from:number The starting value of the attribute. If not specified the 
            current value on the target will be used.
        to:number The ending value of the attribute.
        duration:number The length of time the animation will run in millis.
            The default value is 1000.
        easingFunction:string/function Controls the rate of animation.
            string: See http://easings.net/ for more info. One of the following:
                linear, 
                easeInQuad, easeOutQuad, easeInOutQuad(default), 
                easeInCubic, easeOutCubic, easeInOutCubic, 
                easeInQuart, easeOutQuart, easeInOutQuart, 
                easeInQuint, easeOutQuint, easeInOutQuint, 
                easeInSine, easeOutSine, easeInOutSine,
                easeInExpo ,easeOutExpo, easeInOutExpo, 
                easeInCirc, easeOutCirc, easeInOutCirc,
                easeInElastic ,easeOutElastic, easeInOutElastic, 
                easeInBack, easeOutBack, easeInOutBack, 
                easeInBounce, easeOutBounce, easeInOutBounce
            
            function: A function that determines the rate of change of the 
                attribute. The arguments to the easing function are:
                t: Animation progress in millis
                c: Value change (to - from)
                d: Animation duration in millis
        relative:boolean Determines if the animated value is set on the target 
            (false), or added to the exiting value on the target (true). Note
            that this means the difference between the from and to values
            will be "added" to the existing value on the target. The default 
            value is false.
        repeat:number The number of times to repeat the animation. If negative 
            the animation will repeat forever. The default value is 1.
        reverse:boolean If true, the animation is run in reverse.
        running:boolean Indicates if the animation is currently running. The 
            default value is false.
        paused:boolean Indicates if the animation is temporarily paused. The 
            default value is false.
        callback:function A function that gets called when the animation
            completes. A boolean value is passed into the function and will be
            true if the animation completed successfully or false if not.
    
    Private Attributes:
        __loopCount:number the loop currently being run.
        __progress:number the number of millis currently used during the
            current animation loop.
        __temporaryFrom:boolean Indicates no "from" was set on the animator so 
            we will have to generate one when needed. We want to reset back to 
            undefined after the animation completes so that subsequent calls 
            to start the animation will behave the same.
*/
myt.Animator = new JS.Class('Animator', myt.Node, {
    include: [myt.Reusable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.duration = 1000;
        this.relative = this.reverse = this.running = this.paused = false;
        this.repeat = 1;
        this.easingFunction = myt.Animator.DEFAULT_EASING_FUNCTION;
        
        this.callSuper(parent, attrs);
        
        this.__reset();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setRunning: function(v) {
        if (this.running !== v) {
            this.running = v;
            if (this.inited) this.fireNewEvent('running', v);
            
            if (!this.paused) {
                if (v) {
                    this.attachTo(myt.global.idle, '__update', 'idle');
                } else {
                    if (this.__temporaryFrom) this.from = undefined;
                    this.__reset();
                    this.detachFrom(myt.global.idle, '__update', 'idle');
                }
            }
        }
    },
    
    setPaused: function(v) {
        if (this.paused !== v) {
            this.paused = v;
            if (this.inited) this.fireNewEvent('paused', v);
            
            if (this.running) {
                if (v) {
                    this.detachFrom(myt.global.idle, '__update', 'idle');
                } else {
                    this.attachTo(myt.global.idle, '__update', 'idle');
                }
            }
        }
    },
    
    setReverse: function(v) {
        if (this.reverse !== v) {
            this.reverse = v;
            if (this.inited) this.fireNewEvent('reverse', v);
            
            if (!this.running) this.__reset();
        }
    },
    
    setEasingFunction: function(v) {
        // Lookup easing function if a string is provided.
        if (typeof v === 'string') v = myt.Animator.easingFunctions[v];
        
        // Use default if invalid
        if (!v) v = myt.Animator.DEFAULT_EASING_FUNCTION;
        
        if (this.easingFunction !== v) {
            this.easingFunction = v;
            if (this.inited) this.fireNewEvent('easingFunction', v);
        }
    },
    
    setFrom: function(v) {
        if (this.from !== v) {
            this.from = v;
            if (this.inited) this.fireNewEvent('from', v);
        }
    },
    
    setTo: function(v) {
        if (this.to !== v) {
            this.to = v;
            if (this.inited) this.fireNewEvent('to', v);
        }
    },
    
    setCallback: function(v) {this.callback = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** A convienence method to set the callback to run when the animator
        stops running. If a callback already exists the provided callback
        will be executed after the existing one.
        @param callback:function the function to run.
        @param replace:boolean (optional) if true the existing callback will 
            be replaced with the new callback.
        @returns void */
    next: function(callback, replace) {
        var existingCallback = this.callback;
        if (existingCallback && !replace) {
            var anim = this;
            this.setCallback(function(success) {
                existingCallback.call(anim, success);
                callback.call(anim, success);
            });
        } else {
            this.setCallback(callback);
        }
    },
    
    /** Puts the animator back to an initial configured state.
        @param executeCallback:boolean (optional) if true the callback, if
            it exists, will be executed.
        @returns void */
    reset: function(executeCallback) {
        this.__reset();
        
        this.setRunning(false);
        this.setPaused(false);
        
        if (executeCallback && this.callback) this.callback.call(this, false);
    },
    
    /** @overrides myt.Reusable */
    clean: function() {
        this.to = this.from = this.attribute = this.callback = undefined;
        this.duration = 1000;
        this.relative = this.reverse = false;
        this.repeat = 1;
        this.easingFunction = myt.Animator.DEFAULT_EASING_FUNCTION;
        
        this.reset(false);
    },
    
    /** @private */
    __reset: function() {
        this.__temporaryFrom = false;
        this.__loopCount = this.reverse ? this.repeat - 1 : 0;
        this.__progress = this.reverse ? this.duration : 0;
    },
    
    /** @private */
    __update: function(idleEvent) {
        this.__advance(idleEvent.value.delta);
    },
    
    /** @private */
    __advance: function(timeDiff) {
        if (this.running && !this.paused) {
            var reverse = this.reverse, 
                duration = this.duration, 
                repeat = this.repeat, 
                attr = this.attribute;
            
            // An animation in reverse is like time going backward.
            if (reverse) timeDiff = timeDiff * -1;
            
            // Determine how much time to move forward by.
            var oldProgress = this.__progress;
            this.__progress += timeDiff;
            
            // Check for overage
            var remainderTime = 0;
            if (this.__progress > duration) {
                remainderTime = this.__progress - duration;
                this.__progress = duration;
                
                // Increment loop count and halt looping if necessary
                if (++this.__loopCount === repeat) remainderTime = 0;
            } else if (0 > this.__progress) {
                // Reverse case
                remainderTime = -this.__progress; // Flip reverse time back to forward time
                this.__progress = 0;
                
                // Decrement loop count and halt looping if necessary
                if (0 > --this.__loopCount && repeat > 0) remainderTime = 0;
            }
            
            var target = this.target || this.parent;
            if (target) {
                // Apply to attribute
                if (this.from == null) {
                    this.__temporaryFrom = true;
                    this.from = this.relative ? 0 : target.get(attr);
                }
                var from = this.from,
                    attrDiff = this.to - from,
                    newValue = this.easingFunction(this.__progress, attrDiff, duration);
                if (this.relative) {
                    // Need to calculate old value since it's possible for
                    // multiple animators to be animating the same attribute
                    // at one time.
                    var oldValue = this.easingFunction(oldProgress, attrDiff, duration),
                        curValue = target.get(attr);
                    target.set(attr, curValue + newValue - oldValue);
                } else {
                    target.set(attr, from + newValue);
                }
                
                if (
                    (!reverse && this.__loopCount === repeat) || // Forward check
                    (reverse && 0 > this.__loopCount && repeat > 0) // Reverse check
                ) {
                    // Stop animation since loop count exceeded repeat count.
                    this.setRunning(false);
                    if (this.callback) this.callback.call(this, true);
                } else if (remainderTime > 0) {
                    // Advance again if time is remaining. This occurs when
                    // the timeDiff provided was greater than the animation
                    // duration and the animation loops.
                    this.fireNewEvent('repeat', this.__loopCount);
                    this.__progress = reverse ? duration : 0;
                    this.__advance(remainderTime);
                }
            } else {
                console.log("No target found for animator.", this);
                this.setRunning(false);
                if (this.callback) this.callback.call(this, false);
            }
        }
    }
});


/*
 * TERMS OF USE - EASING EQUATIONS
 * 
 * Open source under the BSD License. 
 * 
 * Copyright  2001 Robert Penner
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
 * ============================================================
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Open source under the BSD License.
 *
 * Copyright  2008 George McGinley Smith
 * All rights reserved.
 * https://raw.github.com/danro/jquery-easing/master/LICENSE
 * ============================================================
 */
myt.Animator.easingFunctions = {
    linear:function(t, c, d) {
        return c*(t/d);
    },
    easeInQuad:function(t, c, d) {
        return c*(t/=d)*t;
    },
    easeOutQuad:function(t, c, d) {
        return -c *(t/=d)*(t-2);
    },
    easeInOutQuad:function(t, c, d) {
        if ((t/=d/2) < 1) return c/2*t*t;
        return -c/2 * ((--t)*(t-2) - 1);
    },
    easeInCubic:function(t, c, d) {
        return c*(t/=d)*t*t;
    },
    easeOutCubic:function(t, c, d) {
        return c*((t=t/d-1)*t*t + 1);
    },
    easeInOutCubic:function(t, c, d) {
        if ((t/=d/2) < 1) return c/2*t*t*t;
        return c/2*((t-=2)*t*t + 2);
    },
    easeInQuart:function(t, c, d) {
        return c*(t/=d)*t*t*t;
    },
    easeOutQuart:function(t, c, d) {
        return -c * ((t=t/d-1)*t*t*t - 1);
    },
    easeInOutQuart:function(t, c, d) {
        if ((t/=d/2) < 1) return c/2*t*t*t*t;
        return -c/2 * ((t-=2)*t*t*t - 2);
    },
    easeInQuint:function(t, c, d) {
        return c*(t/=d)*t*t*t*t;
    },
    easeOutQuint:function(t, c, d) {
        return c*((t=t/d-1)*t*t*t*t + 1);
    },
    easeInOutQuint:function(t, c, d) {
        if ((t/=d/2) < 1) return c/2*t*t*t*t*t;
        return c/2*((t-=2)*t*t*t*t + 2);
    },
    easeInSine: function (t, c, d) {
        return -c * Math.cos(t/d * (Math.PI/2)) + c;
    },
    easeOutSine: function (t, c, d) {
        return c * Math.sin(t/d * (Math.PI/2));
    },
    easeInOutSine: function (t, c, d) {
        return -c/2 * (Math.cos(Math.PI*t/d) - 1);
    },
    easeInExpo: function (t, c, d) {
        return (t===0) ? 0 : c * Math.pow(2, 10 * (t/d - 1));
    },
    easeOutExpo: function (t, c, d) {
        return (t===d) ? c : c * (-Math.pow(2, -10 * t/d) + 1);
    },
    easeInOutExpo: function (t, c, d) {
        if (t===0) return 0;
        if (t===d) return c;
        if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1));
        return c/2 * (-Math.pow(2, -10 * --t) + 2);
    },
    easeInCirc: function (t, c, d) {
        return -c * (Math.sqrt(1 - (t/=d)*t) - 1);
    },
    easeOutCirc: function (t, c, d) {
        return c * Math.sqrt(1 - (t=t/d-1)*t);
    },
    easeInOutCirc: function (t, c, d) {
        if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1);
        return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },
    easeInElastic: function (t, c, d) {
        var s = 1.70158, p = 0, a = c;
        if (t===0) return 0;
        if ((t/=d)===1) return c;
        if (!p) p = d*.3;
        if (a < Math.abs(c)) {
            //a = c;
            s = p/4;
        } else {
            s = p/(2*Math.PI) * Math.asin(c/a);
        }
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p));
    },
    easeOutElastic: function (t, c, d) {
        var s = 1.70158, p = 0, a = c;
        if (t===0) return 0;
        if ((t/=d)===1) return c;
        if (!p) p = d*.3;
        if (a < Math.abs(c)) {
            //a = c;
            s = p/4;
        } else {
            s = p/(2*Math.PI) * Math.asin(c/a);
        }
        return a*Math.pow(2,-10*t) * Math.sin((t*d-s)*(2*Math.PI)/p) + c;
    },
    easeInOutElastic: function (t, c, d) {
        var s = 1.70158, p = 0, a = c;
        if (t===0) return 0;
        if ((t/=d/2)===2) return c;
        if (!p) p = d*(.3*1.5);
        if (a < Math.abs(c)) {
            //a = c;
            s = p/4;
        } else {
            s = p/(2*Math.PI) * Math.asin(c/a);
        }
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p)*.5 + c;
    },
    easeInBack: function (t, c, d, s) {
        if (s === undefined) s = 1.70158;
        return c*(t/=d)*t*((s+1)*t - s);
    },
    easeOutBack: function (t, c, d, s) {
        if (s === undefined) s = 1.70158;
        return c*((t=t/d-1)*t*((s+1)*t + s) + 1);
    },
    easeInOutBack: function (t, c, d, s) {
        if (s === undefined) s = 1.70158; 
        if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s));
        return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },
    easeInBounce: function (t, c, d) {
        return c - myt.Animator.easingFunctions.easeOutBounce(d-t, c, d);
    },
    easeOutBounce: function (t, c, d) {
        if ((t/=d) < (1/2.75)) {
            return c*(7.5625*t*t);
        } else if (t < (2/2.75)) {
            return c*(7.5625*(t-=(1.5/2.75))*t + .75);
        } else if (t < (2.5/2.75)) {
            return c*(7.5625*(t-=(2.25/2.75))*t + .9375);
        } else {
            return c*(7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },
    easeInOutBounce: function (t, c, d) {
        if (t < d/2) return myt.Animator.easingFunctions.easeInBounce(t*2, c, d) * .5;
        return myt.Animator.easingFunctions.easeOutBounce(t*2-d, c, d) * .5 + c*.5;
    }
};

/** Setup the default easing function. */
myt.Animator.DEFAULT_EASING_FUNCTION = myt.Animator.easingFunctions.easeInOutQuad;


/** Stores a function name and a context to call that function on along with 
    zero or more callback parameters.
    
    Events:
        None
    
    Attributes:
        context:object The context to call the method/function on.
        methodName:string The name of the function to call on the context.
        extraArgs:array An array of additional args to pass to the function. 
            These are appended to the args passed into the 'execute' method.
*/
myt.Callback = new JS.Class('Callback', {
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new Callback.
        @param methodName:String the name of the method to call.
        @param context:Object the object to call the method on.
        @param extraArgs:Array (Optional) args to be passed to the method. */
    initialize: function(methodName, context, extraArgs) {
        this.setContext(context);
        this.setMethodName(methodName);
        this.setExtraArgs(extraArgs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setContext: function(context) {this.context = context;},
    setMethodName: function(methodName) {this.methodName = methodName;},
    setExtraArgs: function(extraArgs) {this.extraArgs = extraArgs;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Calls the callback method using the provided arguments 
        "array" and any extraArgs.
        @param arguments:arguments The arguments passed to the callback
            function when it is executed.
        @returns void */
    execute: function() {
        var args = Array.prototype.slice.call(arguments),
            ctx = this.context,
            ea = this.extraArgs;
        
        // Concat extraArgs if they exist.
        if (ea && ea.length > 0) args = args.concat(ea);
        
        // Call the method
        ctx[this.methodName].apply(ctx, args);
    }
});


/** A utility class that will call a myt.Callback or function after a 
    specified time.
    
    Events:
        None
    
    Attributes:
        callback:myt.Callback|function The callback to get executed when the
            timer completes.
        timerId:number The "timer" ID returned by setTimeout. The initial value 
            is undefined.
*/
myt.Timer = new JS.Class('Timer', {
    // Constructor /////////////////////////////////////////////////////////////
    /** Creates a new Timer. If a callback and delay are provided
        the timer is started.
        @param callback:myt.Callback/function the callback to execute when the
            timer completes.
        @param delayInMillis:Number the length of time to delay for. */
    initialize: function(callback, delayInMillis) {
        this.reset(callback, delayInMillis);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setCallback: function(callback) {this.callback = callback;},
    setTimerId: function(timerId) {this.timerId = timerId;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Stops the timer and clears the callback.
        @returns void */
    clear: function() {
        if (this.isRunning()) {
            clearTimeout(this.timerId);
            this.setTimerId();
        }
        this.setCallback();
    },
    
    /** Stops the Timer and restarts it with the callback and delay if
        they are provided.
        @returns void */
    reset: function(callback, delayInMillis) {
        this.clear();
        this.setCallback(callback);
        this.run(delayInMillis);
    },
    
    /** Start the timer.
        @returns void */
    run: function(delayInMillis) {
        if (this.callback && delayInMillis >= 0) {
            var self = this;
            var func = function() {
                self.setTimerId();
                if (self.callback.execute) {
                    self.callback.execute();
                } else {
                    self.callback.call(this);
                }
            };
            
            this.setTimerId(
                BrowserDetect.browser === 'Firefox' ? this.__setTimeout(func, delayInMillis) : setTimeout(func, delayInMillis)
            );
        }
    },
    
    /** Indicates if the Timer is currently running or not.
        @returns boolean */
    isRunning: function() {
        return this.timerId !== undefined;
    },
    
    /** Fix for firefox since that browser often executes setTimeout early.
        @private */
    __setTimeout: function(f, t) {
        var self = this,
            endTime = Date.now() + t;
        return setTimeout(function() {
            var now = Date.now();
            if (now < endTime) {
                self.setTimerId(self.__setTimeout(f, endTime - now));
            } else {
                f();
            }
        }, t);
    }
});


/** A Timer that can be repeated as well as provide a value to execute.
    
    Events:
        None
    
    Attributes:
        value:* An optional value to be passed to the callbacks execute method.
        repeatDelayInMillis:number If this value is greater than zero the 
            timer will repeat using this value as the delay.
*/
myt.RepeatableTimer = new JS.Class('RepeatableTimer', myt.Timer, {
    // Constructor /////////////////////////////////////////////////////////////
    /** Creates a new Timer. If a callback and delay are provided
        the timer is started.
        @overrides
        @param callback:Callback the Callback to execute when the timer
            completes.
        @param delayInMillis:Number the length of time to delay for.
        @param value:* (Optional) value to be passed to the callback when
            the timer fires.
        @param repeatDelayInMillis:Number (Optional) the length of time in
            millis between repeated calls of this timer. If less than zero the
            timer will not be repeated. */
    initialize: function(callback, delayInMillis, value, repeatDelayInMillis) {
        this.reset(callback, delayInMillis, value, repeatDelayInMillis);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setValue: function(value) {this.value = value;},
    setRepeatDelayInMillis: function(repeatDelayInMillis) {this.repeatDelayInMillis = repeatDelayInMillis;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Stops the timer and clears the callback, value and repeat delay.
        @overrides
        @returns void */
    clear: function() {
        this.callSuper();
        this.setValue();
        this.setRepeatDelayInMillis();
    },
    
    /** Stops the Timer and restarts it with the callback and delay if
        they are provided.
        @overrides
        @returns void */
    reset: function(callback, delayInMillis, value, repeatDelayInMillis) {
        this.clear();
        this.setCallback(callback);
        this.setValue(value);
        this.setRepeatDelayInMillis(repeatDelayInMillis);
        this.run(delayInMillis);
    },
    
    /** @overrides myt.Timer */
    run: function(delayInMillis) {
        if (this.callback && delayInMillis >= 0) {
            var self = this;
            this.setTimerId(setTimeout(function() {
                var repeatDelay = self.repeatDelayInMillis,
                    isRepeating = repeatDelay !== undefined && repeatDelay >= 0;
                if (!isRepeating) self.setTimerId();
                
                if (self.value === undefined) {
                    self.callback.execute();
                } else {
                    self.callback.execute(self.value);
                }
                
                if (isRepeating) self.run(repeatDelay);
            }, delayInMillis));
        }
    }
});


/** An implementation of a finite state machine.
    
    Events:
        start + transition name: Fired when a transition starts.
        start: Fired when a transition starts after the named start event.
        leave + state name: Fired when a state is left.
        leave: Fired when a state is left after the named leave event.
        enter + state name: Fired when a state is entered.
        enter: Fired when a state is entered after the named enter event.
        end + transition name: Fired when a transition ends.
        end: Fired when a transition ends after the named end event.
        finished: Fired when the state machine has transitioned into the
            terminal state if one is defined.
    
    Attributes:
        map:object A map of state names to transition maps.
        current:string The name of the current state.
        initial:string The name of the state to start with.
        terminal:string The name of the final state from which no other
            transitions are allowed.
    
    Private Attributes:
        __transitionInProgress:boolean Indicates that a transition is 
            currently under way.
        __pendingTransition:string The name of the transition that is currently
            under way.
        __additionalArgs:array An array of additional args passed into the
            doTransition or doAsyncTransition methods.
        __transitionDestinationState: The state the currently running 
            transition is transitioning to
        __transitionStage:string The stage of the current transition. Allowed
            values are 'leaveState' and 'enterState'.
        __deferredTransitions:array An array of transitions that will be
            performed after the current one completes.
*/
myt.StateMachine = new JS.Class('StateMachine', myt.Node, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** The transition was successfull. */
        SUCCEEDED:1,
        /** The transition was cancelled before the state change occurred. */
        CANCELLED:2,
        /** An asynchronous transition is in progress. */
        PENDING:3,
        /** The transition was invalid in some way. */
        INVALID:4,
        /** No transition exists for the current state. */
        NO_TRANSITION:5,
        
        /** Indicates a synchronous transition. */
        SYNC:'sync',
        /** Indicates an asynchronous transition. */
        ASYNC:'async',
        /** Special state name that holds transitions for all states. */
        WILDCARD:'*'
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.map = {};
        this.map[myt.StateMachine.WILDCARD] = {};
        
        this.current = this.initial = this.terminal = '';
        this.__resetTransitionProgress();
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setInitialState: function(v) {
        if (this.current === '') {
            // Get optional args if v is an array
            var args;
            if (Array.isArray(v)) {
                args = v;
                v = args.shift();
            } else {
                args = [];
            }
            
            this.current = this.initial = v;
            this.doEnterState('', '', v, args);
            var eventValue = {name:'', from:'', to:v, args:args};
            this.fireNewEvent('enter' + v, eventValue);
            this.fireNewEvent('enter', eventValue);
            if (this.isFinished()) this.fireNewEvent('finished', eventValue);
        }
    },
    
    setTerminalState: function(v) {
        this.terminal = v;
    },
    
    setTransitions: function(v) {
        var i = v.length, data;
        while (i) {
            data = v[--i];
            this.addTransition(data.name, data.from, data.to);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    addTransition: function(transition, from, to) {
        var map = this.map;
        
        if (!from) {
            from = [myt.StateMachine.WILDCARD];
        } else {
            from = Array.isArray(from) ? from : [from];
        }
        
        var i = from.length, mapEntry;
        while (i) {
            mapEntry = map[from[--i]];
            if (!mapEntry) mapEntry = map[from[i]] = {};
            mapEntry[transition] = to;
        }
    },
    
    doTransition: function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(myt.StateMachine.SYNC);
        return this.__doTransition.apply(this, args);
    },
    
    doAsyncTransition: function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(myt.StateMachine.ASYNC);
        return this.__doTransition.apply(this, args);
    },
    
    /** @private */
    __doTransition: function() {
        var args = Array.prototype.slice.call(arguments);
        
        // Don't allow another transition if one is already in progress.
        // Instead, defer them until after the current transition completes.
        if (this.__transitionInProgress) {
            var deferredTransitions = this.__deferredTransitions;
            if (!deferredTransitions) deferredTransitions = this.__deferredTransitions = [];
            deferredTransitions.unshift(args);
            return;
        } else {
            this.__transitionInProgress = true;
        }
        
        var async = args.shift(),
            transition = args.shift();
        
        // Invalid to start a transition if one is still pending.
        var SM = myt.StateMachine;
        if (this.__pendingTransition) return SM.PENDING;
        
        // Do not allow transition from the terminal states
        if (this.isFinished()) {
            this.__transitionInProgress = false;
            return SM.NO_TRANSITION;
        }
        
        var to = this.map[this.current][transition];
        if (!to) to = this.map[SM.WILDCARD][transition];
        if (to) {
            this.__pendingTransition = transition;
            this.__transitionDestinationState = to;
            this.__additionalArgs = args;
            return this.resumeTransition(async);
        } else {
            this.__transitionInProgress = false;
            return SM.NO_TRANSITION;
        }
    },
    
    resumeTransition: function(async) {
        var transition = this.__pendingTransition;
        
        // Invalid to resume a transition if none is pending.
        var SM = myt.StateMachine;
        if (!transition) return SM.INVALID;
        
        var current = this.current,
            to = this.__transitionDestinationState,
            args = this.__additionalArgs,
            eventValue = {name:transition, from:current, to:to, args:args};
        
        switch (this.__transitionStage) {
            case 'leaveState':
                var result = this.doLeaveState(transition, current, to, args);
                if (result === false) {
                    this.__resetTransitionProgress();
                    this.__doDeferredTransitions();
                    return SM.CANCELLED;
                } else if (result === SM.ASYNC || async === SM.ASYNC) {
                    this.__transitionStage = 'enterState';
                    this.fireNewEvent('start' + transition, eventValue);
                    this.fireNewEvent('start', eventValue);
                    this.fireNewEvent('leave' + current, eventValue);
                    this.fireNewEvent('leave', eventValue);
                    this.__doDeferredTransitions(); // FIXME: Is there a bug here if a transition starts in the middle of an async transition?
                    return SM.PENDING;
                } else {
                    this.fireNewEvent('start' + transition, eventValue);
                    this.fireNewEvent('start', eventValue);
                    this.fireNewEvent('leave' + current, eventValue);
                    this.fireNewEvent('leave', eventValue);
                    // Synchronous so fall through to 'enterState' case.
                }
            case 'enterState':
                this.current = to;
                this.__resetTransitionProgress();
                this.doEnterState(transition, current, to, args);
                this.fireNewEvent('enter' + to, eventValue);
                this.fireNewEvent('enter', eventValue);
                this.fireNewEvent('end' + transition, eventValue);
                this.fireNewEvent('end', eventValue);
                if (this.isFinished()) this.fireNewEvent('finished', eventValue);
        }
        
        this.__doDeferredTransitions();
        return SM.SUCCEEDED;
    },
    
    /** @private */
    __doDeferredTransitions: function() {
        this.__transitionInProgress = false;
        
        var deferredTransitions = this.__deferredTransitions;
        if (deferredTransitions) {
            while(deferredTransitions.length > 0) {
                this.__doTransition.apply(this, deferredTransitions.pop());
            }
        }
    },
    
    doLeaveState: function(transition, from, to, args) {
        // Subclasses to implement as needed.
    },
    
    doEnterState: function(transition, from, to, args) {
        // Subclasses to implement as needed.
    },
    
    /** @private */
    __resetTransitionProgress: function() {
        this.__additionalArgs = [];
        this.__pendingTransition = '';
        this.__transitionDestinationState = '';
        this.__transitionStage = 'leaveState';
    },
    
    isFinished: function() {
        return this.is(this.terminal);
    },
    
    isStarting: function() {
        return this.is(this.initial);
    },
    
    is: function(stateName) {
        if (Array.isArray(stateName)) {
            return stateName.indexOf(this.current) >= 0;
        } else {
            return this.current === stateName;
        }
    },
    
    can: function(transition) {
        if (this.map[this.current][transition] !== undefined) {
            return true;
        } else {
            return this.map[myt.StateMachine.WILDCARD][transition] !== undefined;
        }
    }
});


/** Objects that can be replicated should include this mixin and implemment
    the replicate method. The myt.Reusable mixin is also included and the
    clean method should also be implemented. The methods replicate and clean
    should perform setup and teardown of the object respectively.
    
    Events:
        None
    
    Attributes:
        replicationData:* The data provided during replication.
        replicationIndex:number The replication index provided 
            during replication.
*/
myt.Replicable = new JS.Module('Replicable', {
    include: [myt.Reusable],
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called to configure the replicable object with data. Subclasses should
        call super.
        @param data:object the data being replicated for this instance.
        @param idx:number the index of the data in the replicated list.
        @returns void */
    replicate: function(data, idx) {
        this.replicationData = data;
        this.replicationIndex = idx;
    },
    
    // FIXME: Make this a mixin?
    /** Notifies this object that something happened.
        @param key:string the name of the message
        @param value:* the value of the message.
        @returns void */
    notify: function(key, value) {},
    
    /** @overrides myt.Reusable
        Subclasses should call super. */
    clean: function() {
        this.replicationData = null;
        this.replicationIndex = -1;
    },
    
    /** Called by an myt.Replicator to check if this replicable needs to be
        updated or not.
        @param data:object the data being replicated for this instance.
        @param idx:number the index of the data in the replicated list.
        @returns boolean true if the provided data is already set on this
            replicable, false otherwise. */
    alreadyHasReplicationData: function(data, idx) {
        // FIXME: Use deepEquals on replicationData?
        return idx === this.replicationIndex && data === this.replicationData;
    }
});


/** Creates instances using a template class and an array of data items.
    
    Events:
        None
    
    Attributes:
        template:JS.Class The template to replicate for each entry in the
            data set.
        data:array The data to replicate the template for.
    
    Private Attributes:
        __pool:myt.TrackActivesPool The pool that holds the myt.Replicable
            instances.
*/
myt.Replicator = new JS.Class('Replicator', myt.Node, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        SORT_FUNCTION: function(a, b) {
            return a.replicationIndex - b.replicationIndex;
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        this.__setupPool();
        this.doReplication();
    },
    
    /** @overrides myt.Node */
    destroyAfterOrphaning: function() {
        this.__destroyOldPool();
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setTemplate: function(v) {
        // Make sure template class is an myt.Replicable
        this.template = v.includes(myt.Replicable) ? v : null;
        if (!this.template) myt.dumpStack("Template not an myt.Replicable");
        
        if (this.inited) {
            this.__setupPool();
            this.doReplication();
        }
    },
    
    setData: function(v) {
        this.data = v;
        if (this.inited) this.doReplication();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __setupPool: function() {
        this.__destroyOldPool();
        
        // Create new pool
        var template = this.template;
        if (template) this.__pool = new myt.TrackActivesPool(template, this.parent);
    },
    
    /** @private */
    __destroyOldPool: function() {
        // Destroy old pool and instances.
        var pool = this.__pool;
        if (pool) {
            // Lock layouts before modifying instances
            var layouts = this.parent.getLayouts();
            this.__lockLayouts(layouts);
            
            pool.putActives();
            pool.destroyPooledInstances();
            
            this.__unlockLayouts(layouts, false);
            
            pool.destroy();
        }
    },
    
    /** Performs replication.
        @returns void */
    doReplication: function() {
        var pool = this.__pool;
        if (pool) {
            // Lock layouts before modifying instances
            var layouts = this.parent.getLayouts();
            this.__lockLayouts(layouts);
            
            // Walk actives comparing against data
            var data = this.data, dataLen = data ? data.length : 0,
                actives = pool.getActives(), activesLen = actives.length,
                i = activesLen, active,
                replicationIndex, unused = [],
                sortFunc = myt.Replicator.SORT_FUNCTION;
            
            actives.sort(sortFunc);
            
            while (i) {
                active = actives[--i];
                replicationIndex = active.replicationIndex;
                if (replicationIndex >= dataLen ||
                    !active.alreadyHasReplicationData(data[replicationIndex], replicationIndex)
                ) {
                    unused[replicationIndex] = active;
                }
            }
            
            // Put away all unused actives
            i = unused.length;
            while (i) {
                active = unused[--i];
                if (active) pool.putInstance(active);
            }
            
            // Replicate on unused data and data that was beyond the length
            // of the actives list
            for (i = 0; dataLen > i; ++i) {
                if (i >= activesLen || unused[i] != null) pool.getInstance().replicate(data[i], i);
            }
            
            // Sort layout subviews so the layout reflects the data list order.
            i = layouts.length;
            while (i) layouts[--i].sortSubviews(sortFunc);
            
            this.__unlockLayouts(layouts, true);
        }
    },
    
    // FIXME: Make this a mixin?
    /** Sends a message to each active myt.Replicable.
        @param key:string the name of the message
        @param value:* the value of the message.
        @returns void */
    notify: function(key, value) {
        var pool = this.__pool;
        if (pool) {
            var actives = pool.getActives(), i = actives.length;
            while (i) actives[--i].notify(key, value);
        }
    },
    
    /** @private */
    __lockLayouts: function(layouts) {
        var i = layouts.length;
        while (i) layouts[--i].incrementLockedCounter();
    },
    
    /** @private */
    __unlockLayouts: function(layouts, update) {
        var i = layouts.length, layout;
        while (i) {
            layout = layouts[--i];
            layout.decrementLockedCounter();
            if (update) layout.update();
        }
    }
});


/** A layout that sets the target attribute name to the target value for 
    each subview.
    
    Events:
        targetAttrName:string
        targetValue:*
    
    Attributes:
        targetAttrName:string the name of the attribute to set on each subview.
        targetValue:* the value to set the attribute to.
        setterName:string the name of the setter method to call on the subview
            for the targetAttrName. This value is updated when
            setTargetAttrName is called.
*/
myt.ConstantLayout = new JS.Class('ConstantLayout', myt.Layout, {
    // Accessors ///////////////////////////////////////////////////////////////
    setTargetAttrName: function(v) {
        if (this.targetAttrName !== v) {
            this.targetAttrName = v;
            this.setterName = myt.AccessorSupport.generateSetterName(v);
            if (this.inited) {
                this.fireNewEvent('targetAttrName', v);
                this.update();
            }
        }
    },
    
    setTargetValue: function(v) {
        if (this.targetValue !== v) {
            this.targetValue = v;
            if (this.inited) {
                this.fireNewEvent('targetValue', v);
                this.update();
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Layout */
    update: function() {
        if (this.canUpdate()) {
            var setterName = this.setterName, 
                value = this.targetValue, 
                svs = this.subviews, len = svs.length, sv,
                setter, i = 0;
            for (; len > i;) {
                sv = svs[i++];
                setter = sv[setterName];
                if (setter) setter.call(sv, value);
            }
        }
    }
});


/** An extension of ConstantLayout that allows for variation based on the
    index and subview. An updateSubview method is provided that can be
    overriden to provide variable behavior.
    
    Events:
        collapseParent:boolean
        reverse:boolean
    
    Attributes:
        collapseParent:boolean If true the updateParent method will be called.
            The updateParent method will typically resize the parent to fit
            the newly layed out child views. Defaults to false.
        reverse:boolean If true the layout will position the items in the
            opposite order. For example, right to left instead of left to right.
            Defaults to false.
*/
myt.VariableLayout = new JS.Class('VariableLayout', myt.ConstantLayout, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.collapseParent = this.reverse = false;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setCollapseParent: function(v) {
        if (this.collapseParent !== v) {
            this.collapseParent = v;
            if (this.inited) {
                this.fireNewEvent('collapseParent', v);
                this.update();
            }
        }
    },
    
    setReverse: function(v) {
        if (this.reverse !== v) {
            this.reverse = v;
            if (this.inited) {
                this.fireNewEvent('reverse', v);
                this.update();
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ConstantLayout */
    update: function() {
        if (this.canUpdate()) {
            // Prevent inadvertent loops
            this.incrementLockedCounter();
            
            this.doBeforeUpdate();
            
            var setterName = this.setterName, value = this.targetValue,
                svs = this.subviews, len = svs.length, i, sv, count = 0;
            
            if (this.reverse) {
                i = len;
                while(i) {
                    sv = svs[--i];
                    if (this.skipSubview(sv)) continue;
                    value = this.updateSubview(++count, sv, setterName, value);
                }
            } else {
                for (i = 0; len > i;) {
                    sv = svs[i++];
                    if (this.skipSubview(sv)) continue;
                    value = this.updateSubview(++count, sv, setterName, value);
                }
            }
            
            this.doAfterUpdate();
            
            if (this.collapseParent && !this.parent.isBeingDestroyed) {
                this.updateParent(setterName, value);
            }
            
            this.decrementLockedCounter();
        }
    },
    
    /** Called by update before any processing is done. Gives subviews a
        chance to do any special setup before update is processed.
        @returns void */
    doBeforeUpdate: function() {
        // Subclasses to implement as needed.
    },
    
    /** Called by update after any processing is done but before the optional
        collapsing of parent is done. Gives subviews a chance to do any 
        special teardown after update is processed.
        @returns void */
    doAfterUpdate: function() {
        // Subclasses to implement as needed.
    },
    
    /** @overrides myt.Layout
        Provides a default implementation that calls update when the
        visibility of a subview changes. */
    startMonitoringSubview: function(sv) {
        this.attachTo(sv, 'update', 'visible');
    },
    
    /** @overrides myt.Layout
        Provides a default implementation that calls update when the
        visibility of a subview changes. */
    stopMonitoringSubview: function(sv) {
        this.detachFrom(sv, 'update', 'visible');
    },
    
    /** Called for each subview in the layout.
        @param count:int the number of subviews that have been layed out
            including the current one. i.e. count will be 1 for the first
            subview layed out.
        @param sv:View the subview being layed out.
        @param setterName:string the name of the setter method to call.
        @param value:* the layout value.
        @returns the value to use for the next subview. */
    updateSubview: function(count, sv, setterName, value) {
        sv[setterName](value);
        return value;
    },
    
    /** Called for each subview in the layout to determine if the view should
        be positioned or not. The default implementation returns true if the 
        subview is not visible.
        @returns true if the subview should be skipped during layout updates.*/
    skipSubview: function(sv) {
        return !sv.visible;
    },
    
    /** Called if the collapseParent attribute is true. Subclasses should 
        implement this if they want to modify the parent view.
        @returns void */
    updateParent: function(setterName, value) {
        // Subclasses to implement as needed.
    }
});


/** An extension of VariableLayout that positions views along an axis using
    an inset, outset and spacing value. Views will be wrapped when they
    overflow the available space.
    
    Supported Layout Hints:
        break:string Will force the subview to start a new line/column.
*/
myt.WrappingLayout = new JS.Class('WrappingLayout', myt.VariableLayout, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.VariableLayout */
    initNode: function(parent, attrs) {
        this.targetAttrName = this.axis = 'x';
        this.setterName = 'setX';
        this.otherSetterName = 'setY';
        this.measureAttrName = 'boundsWidth';
        this.measureAttrBaseName = 'width';
        this.otherMeasureAttrName = 'boundsHeight';
        this.otherMeasureAttrBaseName = 'height';
        this.parentSetterName = 'setHeight';
        this.targetValue = this.spacing = this.inset = this.outset = this.lineSpacing = this.lineInset = this.lineOutset = 0;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.ConstantLayout */
    setTargetAttrName: function(v) {
        if (this.targetAttrName !== v) {
            if (v === 'x') {
                if (this.inited) this.stopMonitoringAllSubviews();
                this.measureAttrName = 'boundsWidth';
                this.measureAttrBaseName = 'width';
                this.otherMeasureAttrName = 'boundsHeight';
                this.otherMeasureAttrBaseName = 'height';
                this.parentSetterName = 'setHeight';
                this.otherSetterName = 'setY';
                if (this.inited) {
                    this.startMonitoringAllSubviews();
                    this.stopMonitoringParent('height');
                    this.startMonitoringParent('width');
                }
                this.callSuper(v);
            } else if (v === 'y') {
                if (this.inited) this.stopMonitoringAllSubviews();
                this.measureAttrName = 'boundsHeight';
                this.measureAttrBaseName = 'height';
                this.otherMeasureAttrName = 'boundsWidth';
                this.otherMeasureAttrBaseName = 'width';
                this.parentSetterName = 'setWidth';
                this.otherSetterName = 'setX';
                if (this.inited) {
                    this.startMonitoringAllSubviews();
                    this.stopMonitoringParent('width');
                    this.startMonitoringParent('height');
                }
                this.callSuper(v);
            }
        }
    },
    
    /** @overrides myt.Layout */
    setParent: function(v) {
        if (this.parent !== parent) {
            if (this.parent) {
                if (this.targetAttrName === 'x') {
                    this.stopMonitoringParent('width');
                } else if (this.targetAttrName === 'y') {
                    this.stopMonitoringParent('height');
                }
            }
            
            this.callSuper(v);
            
            if (this.parent) {
                if (this.targetAttrName === 'x') {
                    this.startMonitoringParent('width');
                } else if (this.targetAttrName === 'y') {
                    this.startMonitoringParent('height');
                }
            }
        }
    },
    
    setSpacing: function(v) {
        if (this.spacing !== v) {
            this.spacing = v;
            if (this.inited) {
                this.fireNewEvent('spacing', v);
                this.update();
            }
        }
    },
    
    setOutset: function(v) {
        if (this.outset !== v) {
            this.outset = v;
            if (this.inited) {
                this.fireNewEvent('outset', v);
                this.update();
            }
        }
    },
    
    setLineSpacing: function(v) {
        if (this.lineSpacing !== v) {
            this.lineSpacing = v;
            if (this.inited) {
                this.fireNewEvent('lineSpacing', v);
                this.update();
            }
        }
    },
    
    setLineInset: function(v) {
        if (this.lineInset !== v) {
            this.lineInset = v;
            if (this.inited) {
                this.fireNewEvent('lineInset', v);
                this.update();
            }
        }
    },
    
    setLineOutset: function(v) {
        if (this.lineOutset !== v) {
            this.lineOutset = v;
            if (this.inited) {
                this.fireNewEvent('lineOutset', v);
                this.update();
            }
        }
    },
    
    // Aliases: We use a wrapper rather than .alias since .alias doesn't
    // appear to carry over to subclasses.
    setAxis: function(v) {
        this.setTargetAttrName(v);
        this.axis = this.targetAttrName;
    },
    
    setInset: function(v) {
        this.setTargetValue(v);
        this.inset = this.targetValue;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called when monitoring of width/height should start on our parent. */
    startMonitoringParent: function(measureAttrName) {
        this.attachTo(this.parent, 'update', measureAttrName);
    },
    
    /** Called when monitoring of width/height should stop on our parent. */
    stopMonitoringParent: function(measureAttrName) {
        this.detachFrom(this.parent, 'update', measureAttrName);
    },
    
    /** @overrides myt.Layout */
    startMonitoringSubview: function(sv) {
        this.attachTo(sv, 'update', this.measureAttrName);
        this.attachTo(sv, 'update', this.otherMeasureAttrName);
        this.attachTo(sv, 'update', 'visible');
    },
    
    /** @overrides myt.Layout */
    stopMonitoringSubview: function(sv) {
        this.detachFrom(sv, 'update', this.measureAttrName);
        this.detachFrom(sv, 'update', this.otherMeasureAttrName);
        this.detachFrom(sv, 'update', 'visible');
    },
    
    
    /** @overrides myt.VariableLayout */
    doBeforeUpdate: function() {
        // The number of lines layed out.
        this.lineCount = 1;
        
        // The maximum size achieved by any line.
        this.maxSize = 0;
        
        // Track the maximum size of a line. Used to determine how much to
        // update linePos by when wrapping occurs.
        this.lineSize = 0;
        
        // The position for each subview in a line. Gets updated for each new
        // line of subviews.
        this.linePos = this.lineInset;
        
        // The size of the parent view. Needed to determine when to wrap. The
        // outset is already subtracted as a performance optimization.
        this.parentSizeLessOutset = this.parent[this.measureAttrName] - this.outset;
    },
    
    /** @overrides myt.ConstantLayout */
    updateSubview: function(count, sv, setterName, value) {
        var size = sv[this.measureAttrName],
            otherSize = sv[this.otherMeasureAttrName];
        
        if (value + size > this.parentSizeLessOutset || sv.layoutHint === 'break') {
            // Check for overflow
            value = this.targetValue; // Reset to inset.
            this.linePos += this.lineSize + this.lineSpacing;
            this.lineSize = otherSize;
            
            ++this.lineCount;
        } else if (otherSize > this.lineSize) {
            // Update line size if this subview is larger
            this.lineSize = otherSize;
        }
        
        sv[this.otherSetterName](this.linePos + (otherSize - sv[this.otherMeasureAttrBaseName])/2.0); // adj is for transform
        sv[setterName](value + (size - sv[this.measureAttrBaseName])/2.0); // adj is for transform
        
        // Track max size achieved during layout.
        this.maxSize = Math.max(this.maxSize, value + size + this.outset);
        
        return value + size + this.spacing;
    },
    
    /** @overrides myt.VariableLayout */
    updateParent: function(setterName, value) {
        // Collapse in the other direction
        value = this.linePos + this.lineSize + this.lineOutset;
        this.parent[this.parentSetterName](value);
    }
});


/** An extension of VariableLayout that positions views along an axis using
    an inset, outset and spacing value.
    
    Events:
        None
    
    Attributes:
        noAddSubviewOptimization:boolean Turns the optimization to supress
            layout updates when a subview is added off/on. Defaults to 
            undefined which is equivalent to false and thus leaves the
            optimization on.
*/
myt.SpacedLayout = new JS.Class('SpacedLayout', myt.VariableLayout, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.VariableLayout */
    initNode: function(parent, attrs) {
        this.targetAttrName = this.axis = 'x';
        this.setterName = 'setX';
        this.measureAttrName = 'boundsWidth';
        this.measureAttrBaseName = 'width';
        this.parentSetterName = 'setWidth';
        this.targetValue = this.spacing = this.inset = this.outset = 0;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setNoAddSubviewOptimization: function(v) {this.noAddSubviewOptimization = v;},
    
    /** @overrides myt.ConstantLayout */
    setTargetAttrName: function(v) {
        if (this.targetAttrName !== v) {
            if (v === 'x') {
                if (this.inited) this.stopMonitoringAllSubviews();
                this.measureAttrName = 'boundsWidth';
                this.measureAttrBaseName = 'width';
                this.parentSetterName = 'setWidth';
                if (this.inited) this.startMonitoringAllSubviews();
                this.callSuper(v);
            } else if (v === 'y') {
                if (this.inited) this.stopMonitoringAllSubviews();
                this.measureAttrName = 'boundsHeight';
                this.measureAttrBaseName = 'height';
                this.parentSetterName = 'setHeight';
                if (this.inited) this.startMonitoringAllSubviews();
                this.callSuper(v);
            }
        }
    },
    
    setSpacing: function(v) {
        if (this.spacing !== v) {
            this.spacing = v;
            if (this.inited) {
                this.fireNewEvent('spacing', v);
                this.update();
            }
        }
    },
    
    setOutset: function(v) {
        if (this.outset !== v) {
            this.outset = v;
            if (this.inited) {
                this.fireNewEvent('outset', v);
                this.update();
            }
        }
    },
    
    // Aliases: We use a wrapper rather than .alias since .alias doesn't
    // appear to carry over to subclasses.
    setAxis: function(v) {
        this.setTargetAttrName(v);
        this.axis = this.targetAttrName;
    },
    
    setInset: function(v) {
        this.setTargetValue(v);
        this.inset = this.targetValue;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Layout */
    addSubview: function(sv) {
        // OPTIMIZATION: Skip the update call that happens during subview add.
        // The boundsWidth/boundsHeight events will be fired immediately 
        // after and are a more appropriate time to do the update.
        var isLocked = this.locked; // Remember original locked state.
        if (!this.noAddSubviewOptimization) this.locked = true; // Lock the layout so no updates occur.
        this.callSuper(sv);
        this.locked = isLocked; // Restore original locked state.
    },
    
    /** @overrides myt.VariableLayout */
    startMonitoringSubview: function(sv) {
        this.attachTo(sv, 'update', this.measureAttrName);
        this.attachTo(sv, 'update', 'visible');
    },
    
    /** @overrides myt.VariableLayout */
    stopMonitoringSubview: function(sv) {
        this.detachFrom(sv, 'update', this.measureAttrName);
        this.detachFrom(sv, 'update', 'visible');
    },
    
    /** @overrides myt.ConstantLayout */
    updateSubview: function(count, sv, setterName, value) {
        var size = sv[this.measureAttrName];
        sv[setterName](value + (size - sv[this.measureAttrBaseName])/2.0); // Adj for transform
        return value + size + this.spacing;
    },
    
    /** @overrides myt.VariableLayout */
    updateParent: function(setterName, value) {
        var diff = this.outset - this.spacing;
        this.parent[this.parentSetterName](value + diff);
    }
});


/** An extension of SpacedLayout that resizes one or more views to fill in
    any remaining space. The resizable subviews should not have a transform
    applied to it. The non-resized views may have transforms applied to them. */
myt.ResizeLayout = new JS.Class('SpacedLayout', myt.SpacedLayout, {
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.VariableLayout */
    setCollapseParent: function(v) {
        // collapseParent attribute is unused in ResizeLayout.
    },
    
    /** @overrides myt.SpacedLayout */
    setTargetAttrName: function(v) {
        if (this.targetAttrName !== v) {
            if (this.inited) {
                var isX = v === 'x';
                this.stopMonitoringParent(isX ? 'height' : 'width');
                this.startMonitoringParent(isX ? 'width' : 'height');
            }
            
            this.callSuper(v);
        }
    },
    
    /** @overrides myt.Layout */
    setParent: function(parent) {
        if (this.parent !== parent) {
            var dim = this.targetAttrName === 'x' ? 'width' : 'height';
            if (this.parent) this.stopMonitoringParent(dim);
            
            this.callSuper(parent);
            
            if (this.parent) this.startMonitoringParent(dim);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called when monitoring of width/height should start on our parent.
        @param attrName:string the name of the attribute to start monitoring.
        @returns void */
    startMonitoringParent: function(attrName) {
        this.attachTo(this.parent, 'update', attrName);
    },
    
    /** Called when monitoring of width/height should stop on our parent.
        @param attrName:string the name of the attribute to stop monitoring.
        @returns void */
    stopMonitoringParent: function(attrName) {
        this.detachFrom(this.parent, 'update', attrName);
    },
    
    /** @overrides myt.VariableLayout */
    doBeforeUpdate: function() {
        // Get size to fill
        var measureAttrName = this.measureAttrName,
            measureAttrBaseName = this.measureAttrBaseName,
            remainder = this.parent[measureAttrBaseName];
        
        // Calculate minimum required size
        remainder -= this.targetValue + this.outset;
        
        var svs = this.subviews, i = svs.length, sv,
            count = 0, resizeSum = 0;
        
        while(i) {
            sv = svs[--i];
            if (this.skipSubview(sv)) continue;
            ++count;
            if (sv.layoutHint > 0) {
                resizeSum += sv.layoutHint;
            } else {
                remainder -= sv[measureAttrName];
            }
        }
        
        if (count !== 0) {
            remainder -= (count - 1) * this.spacing;
            
            // Store for update
            this.remainder = remainder;
            this.resizeSum = resizeSum;
            this.scalingFactor = remainder / resizeSum;
            this.resizeSumUsed = this.remainderUsed = 0;
            this.measureSetter = measureAttrName === 'boundsWidth' ? 'setWidth' : 'setHeight';
        }
    },
    
    /** @overrides myt.SpacedLayout */
    updateSubview: function(count, sv, setterName, value) {
        var hint = sv.layoutHint;
        if (hint > 0) {
            this.resizeSumUsed += hint;
            
            var size = this.resizeSum === this.resizeSumUsed ? 
                this.remainder - this.remainderUsed : 
                Math.round(hint * this.scalingFactor);
            
            this.remainderUsed += size;
            sv[this.measureSetter](size);
        }
        return this.callSuper(count, sv, setterName, value);
    },
    
    /** @overrides myt.SpacedLayout */
    startMonitoringSubview: function(sv) {
        // Don't monitor width/height of the "stretchy" subviews since this
        // layout changes them.
        if (!(sv.layoutHint > 0)) this.attachTo(sv, 'update', this.measureAttrName);
        this.attachTo(sv, 'update', 'visible');
    },
    
    /** @overrides myt.SpacedLayout */
    stopMonitoringSubview: function(sv) {
        // Don't monitor width/height of the "stretchy" subviews since this
        // layout changes them.
        if (!(sv.layoutHint > 0)) this.detachFrom(sv, 'update', this.measureAttrName);
        this.detachFrom(sv, 'update', 'visible');
    },
    
    /** @overrides myt.SpacedLayout */
    updateParent: function(setterName, value) {
        // No resizing of parent since this view expands to fill the parent.
    }
});


/** An extension of VariableLayout that also aligns each view vertically
    or horizontally.
    
    Events:
        align:string
    
    Attributes:
        align:string Determines which way the views are aligned. Allowed
            values are 'left', 'center', 'right' and 'top', 'middle', 'bottom'.
*/
myt.AlignedLayout = new JS.Class('AlignedLayout', myt.VariableLayout, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.VariableLayout */
    initNode: function(parent, attrs) {
        this.targetAttrName = this.axis = 'x';
        this.align = 'middle';
        this.setterName = 'setX';
        this.measureAttrName = 'boundsWidth';
        this.measureAttrBaseName = 'width';
        this.parentSetterName = 'setWidth';
        this.targetValue = 0;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.ConstantLayout */
    setTargetAttrName: function(v) {
        if (this.targetAttrName !== v) {
            if (v === 'x') {
                if (this.inited) this.stopMonitoringAllSubviews();
                this.measureAttrName = 'boundsWidth';
                this.measureAttrBaseName = 'width';
                this.parentSetterName = 'setWidth';
                if (this.inited) this.startMonitoringAllSubviews();
                this.callSuper(v);
            } else if (v === 'y') {
                if (this.inited) this.stopMonitoringAllSubviews();
                this.measureAttrName = 'boundsHeight';
                this.measureAttrBaseName = 'height';
                this.parentSetterName = 'setHeight';
                if (this.inited) this.startMonitoringAllSubviews();
                this.callSuper(v);
            }
        }
    },
    
    setAlign: function(v) {
        if (this.align !== v) {
            this.align = v;
            if (this.inited) {
                this.fireNewEvent('align', v);
                this.update();
            }
        }
    },
    
    // Aliases: We use a wrapper rather than .alias since .alias doesn't
    // appear to carry over to subclasses.
    setAxis: function(v) {
        this.setTargetAttrName(v);
        this.axis = this.targetAttrName;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.VariableLayout */
    startMonitoringSubview: function(sv) {
        this.attachTo(sv, 'update', this.measureAttrName);
        this.attachTo(sv, 'update', 'visible');
    },
    
    /** @overrides myt.VariableLayout */
    stopMonitoringSubview: function(sv) {
        this.detachFrom(sv, 'update', this.measureAttrName);
        this.detachFrom(sv, 'update', 'visible');
    },
    
    /** Determine the maximum subview width/height according to the axis.
        @overrides myt.VariableLayout */
    doBeforeUpdate: function() {
        var measureAttrName = this.measureAttrName,
            value = 0,
            svs = this.subviews, sv, i = svs.length;
        while(i) {
            sv = svs[--i];
            if (this.skipSubview(sv)) continue;
            value = Math.max(value, sv[measureAttrName]);
        }
        
        if (isNaN(value) || 0 >= value) value = 0;
        
        this.setTargetValue(value);
    },
    
    /** @overrides myt.VariableLayout */
    updateSubview: function(count, sv, setterName, value) {
        switch (this.align) {
            case 'center': case 'middle':
                sv[setterName]((value - sv[this.measureAttrName]) / 2);
                break;
            case 'right': case 'bottom':
                sv[setterName](value - sv[this.measureAttrName]);
                break;
            default:
                sv[setterName](0);
                break;
        }
        return value;
    },
    
    /** @overrides myt.VariableLayout */
    updateParent: function(setterName, value) {
        this.parent[this.parentSetterName](value);
    }
});


/** Adds support for image display to a View.
    
    Events:
        imageUrl:string
        imageSize:string
        imageRepeat:string
        imagePosition:string
        imageAttachment:string
        calculateNaturalSize:boolean
        naturalWidth:number
        naturalHeight:number
        useNaturalSize:boolean
    
    Attributes:
        imageUrl:string The URL to load the image data from.
        imageSize:string Determines the size of the image. Allowed values
            are: 'auto', 'cover', 'contain', absolute ('20px 10px') and 
            percentage ('100% 50%').
        imageRepeat:string Determines if an image is repeated or not.
            Allowed values: 'repeat', 'repeat-x', 'repeat-y', 'no-repeat', 
            'inherit'. Defaults to 'no-repeat'.
        imagePosition:string Determines where an image is positioned.
        imageAttachment:string Determines how an image is attached to the view.
            Allowed values are: 'scroll', 'fixed', 'inherit'. The default
            value is 'scroll'.
        calculateNaturalSize:boolean Determines if the natural size should be 
            automatically calculated or not. Defaults to undefined which is
            equivalent to false.
        naturalWidth:number The natural width of the image. Only set if
            calculateNaturalWidth is true.
        naturalHeight:number The natural height of the image. Only set if
            calculateNaturalWidth is true.
        useNaturalSize:boolean If true this image view will be sized to the
            naturalWidth and naturalHeight and calculateNaturalSize will be
            set to true.
*/
myt.ImageSupport = new JS.Module('ImageSupport', {
    // Class Methods ///////////////////////////////////////////////////////////
    extend: {
        /** Stores widths and heights of images by URL so we don't have to
            reload them to get sizes. */
        SIZE_CACHE:{},
        
        /** Tracks requests to get the width and height of an image. Used to
            prevent multiple requests being made for the same image URL. */
        OPEN_SIZE_QUERIES:{}
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        if (attrs.imageRepeat === undefined) attrs.imageRepeat = 'no-repeat';
        if (attrs.imageAttachment === undefined) attrs.imageAttachment = 'scroll';
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setImageUrl: function(v) {
        if (this.imageUrl !== v) {
            this.imageUrl = v;
            this.deStyle.backgroundImage = v ? 'url("' + v + '")' : 'none';
            if (this.inited) {
                this.fireNewEvent('imageUrl', v);
                this.setNaturalWidth(undefined);
                this.setNaturalHeight(undefined);
                
                // Collapse size if no url and we are using natural size
                if (!v && this.useNaturalSize) {
                    this.setWidth(0);
                    this.setHeight(0);
                }
            }
            this.__calculateNaturalSize();
        }
    },
    
    setImageSize: function(v) {
        if (this.imageSize !== v) {
            this.imageSize = v;
            this.deStyle.backgroundSize = v || 'auto';
            if (this.inited) this.fireNewEvent('imageSize', v);
        }
    },
    
    setImageRepeat: function(v) {
        if (this.imageRepeat !== v) {
            this.deStyle.backgroundRepeat = this.imageRepeat = v;
            if (this.inited) this.fireNewEvent('imageRepeat', v);
        }
    },
    
    setImagePosition: function(v) {
        if (this.imagePosition !== v) {
            this.deStyle.backgroundPosition = this.imagePosition = v;
            if (this.inited) this.fireNewEvent('imagePosition', v);
        }
    },
    
    setImageAttachment: function(v) {
        if (this.imageAttachment !== v) {
            this.deStyle.backgroundAttachment = this.imageAttachment = v;
            if (this.inited) this.fireNewEvent('imageAttachment', v);
        }
    },
    
    setCalculateNaturalSize: function(v) {
        if (this.calculateNaturalSize !== v) {
            this.calculateNaturalSize = v;
            if (this.inited) this.fireNewEvent('calculateNaturalSize', v);
            this.__calculateNaturalSize();
        }
    },
    
    setNaturalWidth: function(v) {
        if (this.naturalWidth !== v) {
            this.naturalWidth = v;
            if (this.inited) this.fireNewEvent('naturalWidth', v);
            if (this.useNaturalSize && v) this.setWidth(v);
        }
    },
    
    setNaturalHeight: function(v) {
        if (this.naturalHeight !== v) {
            this.naturalHeight = v;
            if (this.inited) this.fireNewEvent('naturalHeight', v);
            if (this.useNaturalSize && v) this.setHeight(v);
        }
    },
    
    setUseNaturalSize: function(v) {
        if (this.useNaturalSize !== v) {
            this.useNaturalSize = v;
            if (this.inited) this.fireNewEvent('useNaturalSize', v);
            
            // Sync width and height
            if (v) {
                if (this.naturalWidth) this.setWidth(this.naturalWidth);
                if (this.naturalHeight) this.setHeight(this.naturalHeight);
            }
            
            // Turn on calculation of natural size if we're going to use
            // natural size.
            if (v && !this.calculateNaturalSize) this.setCalculateNaturalSize(true);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Loads an image to measure its size.
        @private
        @returns void */
    __calculateNaturalSize: function() {
        var imgUrl = this.imageUrl;
        if (this.calculateNaturalSize && imgUrl) {
            var sizeCache = myt.ImageSupport.SIZE_CACHE,
                cachedSize = sizeCache[imgUrl];
            if (cachedSize) {
                // Cache hit
                this.setNaturalWidth(cachedSize.width);
                this.setNaturalHeight(cachedSize.height);
            } else {
                // Cache miss
                var openQueryCache = myt.ImageSupport.OPEN_SIZE_QUERIES,
                    openQuery = openQueryCache[imgUrl];
                if (!openQuery) {
                    // Lazy instantiate the open query array.
                    openQueryCache[imgUrl] = openQuery = [];
                    
                    // Start a size query
                    var img = new Image();
                    img.onload = function() {
                        var w = this.width, h = this.height;
                        
                        // Notify all ImageSupport instances that are waiting
                        // for a natural size.
                        var openQueries = openQueryCache[imgUrl];
                        if (openQueries) {
                            var i = openQueries.length, imageSupportInstance;
                            while (i) {
                                imageSupportInstance = openQueries[--i];
                                imageSupportInstance.setNaturalWidth(w);
                                imageSupportInstance.setNaturalHeight(h);
                            }
                            
                            // Cleanup
                            openQueries.length = 0;
                            delete openQueryCache[imgUrl];
                        }
                        
                        // Store size in cache.
                        sizeCache[imgUrl] = {width:w, height:h};
                    };
                    img.src = imgUrl;
                }
                
                openQuery.push(this);
            }
        }
    }
});


/** A view that displays an image. By default useNaturalSize is set to true
    so the Image will take on the size of the image data. */
myt.Image = new JS.Class('Image', myt.View, {
    include: [myt.ImageSupport],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        if (attrs.useNaturalSize === undefined) attrs.useNaturalSize = true;
        
        this.callSuper(parent, attrs);
    }
});


/** A special "layout" that resizes the parent to fit the children rather than
    laying out the children.
    
    Events:
        axis:string
        paddingX:number
        paddingY:number
    
    Attributes:
        axis:string The axis along which to resize this view to fit its
            children. Supported values are 'x', 'y' and 'both'. Defaults to 'x'.
        paddingX:number Additional space added on the child extent along the
            x-axis. Defaults to 0.
        paddingY:number Additional space added on the child extent along the
            y-axis. Defaults to 0.
*/
myt.SizeToChildren = new JS.Class('SizeToChildren', myt.Layout, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.axis = 'x';
        this.paddingX = this.paddingY = 0;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Acessors ////////////////////////////////////////////////////////////////
    setAxis: function(v) {
        if (this.axis !== v) {
            if (this.inited) {
                this.stopMonitoringAllSubviews();
                this.axis = v;
                this.startMonitoringAllSubviews();
                this.fireNewEvent('axis', v);
                this.update();
            } else {
                this.axis = v;
            }
        }
    },
    
    setPaddingX: function(v) {
        if (this.paddingX !== v) {
            this.paddingX = v;
            if (this.inited) {
                this.fireNewEvent('paddingX', v);
                this.update();
            }
        }
    },
    
    setPaddingY: function(v) {
        if (this.paddingY !== v) {
            this.paddingY = v;
            if (this.inited) {
                this.fireNewEvent('paddingY', v);
                this.update();
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ConstantLayout */
    update: function() {
        if (this.canUpdate()) {
            // Prevent inadvertent loops
            this.incrementLockedCounter();
            
            var svs = this.subviews, i = svs.length, sv,
                xMax, yMax,
                p = this.parent,
                axis = this.axis,
                maxFunc = Math.max,
                bw, bh;
            
            if (!p.isBeingDestroyed) {
                if (axis === 'x') {
                    xMax = 0;
                    while(i) {
                        sv = svs[--i];
                        bw = sv.boundsWidth;
                        bw = bw > 0 ? bw : 0;
                        if (sv.visible) xMax = maxFunc(xMax, sv.x + bw);
                    }
                    p.setWidth(xMax + this.paddingX);
                } else if (axis === 'y') {
                    yMax = 0;
                    while(i) {
                        sv = svs[--i];
                        bh = sv.boundsHeight;
                        bh = bh > 0 ? bh : 0;
                        if (sv.visible) yMax = maxFunc(yMax, sv.y + bh);
                    }
                    p.setHeight(yMax + this.paddingY);
                } else {
                    xMax = yMax = 0;
                    while(i) {
                        sv = svs[--i];
                        if (sv.visible) {
                            bw = sv.boundsWidth;
                            bw = bw > 0 ? bw : 0;
                            xMax = maxFunc(xMax, sv.x + bw);
                            bh = sv.boundsHeight;
                            bh = bh > 0 ? bh : 0;
                            yMax = maxFunc(yMax, sv.y + bh);
                        }
                    }
                    p.setWidth(xMax + this.paddingX);
                    p.setHeight(yMax + this.paddingY);
                }
            }
            
            this.decrementLockedCounter();
        }
    },
    
    /** @overrides myt.Layout
        Provides a default implementation that calls update when the
        visibility of a subview changes. */
    startMonitoringSubview: function(sv) {
        this.__updateMonitoringSubview(sv, this.attachTo);
    },
    
    /** @overrides myt.Layout
        Provides a default implementation that calls update when the
        visibility of a subview changes. */
    stopMonitoringSubview: function(sv) {
        this.__updateMonitoringSubview(sv, this.detachFrom);
    },
    
    /** Wrapped by startMonitoringSubview and stopMonitoringSubview.
        @private */
    __updateMonitoringSubview: function(sv, func) {
        var axis = this.axis, func = func.bind(this);
        if (axis === 'x') {
            func(sv, 'update', 'x');
            func(sv, 'update', 'boundsWidth');
        } else if (axis === 'y') {
            func(sv, 'update', 'y');
            func(sv, 'update', 'boundsHeight');
        } else {
            func(sv, 'update', 'x');
            func(sv, 'update', 'boundsWidth');
            func(sv, 'update', 'y');
            func(sv, 'update', 'boundsHeight');
        }
        func(sv, 'update', 'visible');
    }
});


/** Must be mixed onto a View.
    
    A set of three images where the middle images resizes to fill the
    available space. If you only need support for a single axis you should
    instead use HorizontalThreePanel or VerticalThreePanel since they are
    a bit more optimized.
    
    Events:
        axis:string
        repeat:boolean
    
    Attributes:
        firstImageUrl:string
        secondImageUrl:string
        thirdImageUrl:string
        axis:string Determines if the views are layed out along the x-axis or 
            y-axis. This value can be changed at runtime and the component 
            will update itself. You will need to setWidth/setHeight 
            appropriately for the new axis. The default axis is 'x'.
        repeat:boolean If true the image on the middle view will be repeated 
            rather than stretched. The default is stretched(false).
*/
myt.ThreePanel = new JS.Module('ThreePanel', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** The common ignore function used in the myt.ResizeLayout and 
            myt.SizeToChildren in all myt.ThreePanel, myt.HorizontalThreePanel 
            and myt.VerticalThreePanel instances. */
        IGNORE_FUNCTION_MIXIN: {
            ignore: function(sv) {
                switch (sv.name) {
                    case 'first': case 'second': case 'third': return false;
                    default: return true;
                }
            }
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.axis = 'x';
        this.repeat = false;
        
        this.callSuper(parent, attrs);
    },
    
    doBeforeAdoption: function() {
        this.callSuper();
        
        var m = myt;
        new m.Image(this, {
            name:'first', imageUrl:this.firstImageUrl, ignoreLayout:true
        });
        
        var second = new m.Image(this, {
            name:'second', layoutHint:1, imageUrl:this.secondImageUrl, 
            ignoreLayout:true, useNaturalSize:false, calculateNaturalSize:true,
        });
        this.attachTo(second, '__updateSize', 'naturalWidth');
        this.attachTo(second, '__updateSize', 'naturalHeight');
        this.attachTo(second, '__updateImageSize', 'width');
        this.attachTo(second, '__updateImageSize', 'height');
        
        new m.Image(this, {
            name:'third', imageUrl:this.thirdImageUrl, ignoreLayout:true
        });
        
        var axis = this.axis,
            otherAxis = axis === 'x' ? 'y' : 'x',
            ignoreMixin = [m.ThreePanel.IGNORE_FUNCTION_MIXIN];
        new m.ResizeLayout(this, {name:'resizeLayout', axis:axis}, ignoreMixin);
        new m.SizeToChildren(this, {name:'sizeToChildren', axis:otherAxis}, ignoreMixin);
        
        this.__updateRepeat();
        this.__updateSize();
        this.__updateImageSize();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setFirstImageUrl: function(v) {
        if (this.firstImageUrl !== v) {
            this.firstImageUrl = v;
            if (this.inited) this.first.setImageUrl(v);
        }
    },
    
    setSecondImageUrl: function(v) {
        if (this.secondImageUrl !== v) {
            this.secondImageUrl = v;
            if (this.inited) this.second.setImageUrl(v);
        }
    },
    
    setThirdImageUrl: function(v) {
        if (this.thirdImageUrl !== v) {
            this.thirdImageUrl = v;
            if (this.inited) this.third.setImageUrl(v);
        }
    },
    
    setRepeat: function(v) {
        if (this.repeat !== v) {
            this.repeat = v;
            if (this.inited) {
                this.fireNewEvent('repeat', v);
                this.__updateRepeat();
            }
        }
    },
    
    setAxis: function(v) {
        if (this.axis !== v) {
            this.axis = v;
            
            if (this.inited) {
                this.__updateRepeat();
                if (v === 'x') {
                    this.first.setY(0);
                    this.second.setY(0);
                    this.third.setY(0);
                } else {
                    this.first.setX(0);
                    this.second.setX(0);
                    this.third.setX(0);
                }
                this.__updateSize();
                this.resizeLayout.setAxis(v);
                this.sizeToChildren.setAxis(v === 'x' ? 'y' : 'x');
                this.fireNewEvent('axis', v);
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __updateSize: function(event) {
        var v = this.second;
        if (this.axis === 'x') {
            v.setHeight(v.naturalHeight);
        } else {
            v.setWidth(v.naturalWidth);
        }
    },
    
    /** @private */
    __updateImageSize: function(event) {
        var v = this.second;
        v.setImageSize(this.repeat ? undefined : v.width + 'px ' + v.height + 'px');
    },
    
    /** @private */
    __updateRepeat: function(event) {
        this.second.setImageRepeat(
            this.repeat ? (this.axis === 'x' ? 'repeat-x' : 'repeat-y') : 'no-repeat'
        );
    }
});


/** A view for programatic drawing. This view is backed by an html 
    canvas element.
    
    Events:
        None
    
    Attributes:
        Same as HTML canvas element.
    
    Private Attributes:
        __canvas: A reference to the canvas dom element.
        __ctx: A reference to the 2D drawing context.
*/
myt.Canvas = new JS.Class('Canvas', myt.View, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    createOurDomElement: function(parent) {
        var e = this.callSuper(parent);
        
        var canvas = this.__canvas = document.createElement('canvas');
        e.appendChild(canvas);
        canvas.style.position = 'absolute';
        
        this.__ctx = canvas.getContext('2d');
        return e;
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.View
        Needed because canvas must also set width/height attribute.
        See: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#attr-canvas-width */
    setWidth: function(v, supressEvent) {
        if (0 > v) v = 0;
        this.__canvas.setAttribute('width', v);
        this.callSuper(v, supressEvent);
    },
    
    /** @overrides myt.View
        Needed because canvas must also set width/height attribute.
        See: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#attr-canvas-width */
    setHeight: function(v, supressEvent) {
        if (0 > v) v = 0;
        this.__canvas.setAttribute('height', v);
        this.callSuper(v, supressEvent);
    },
    
    setFillStyle: function(v) {this.__ctx.fillStyle = v;},
    getFillStyle: function() {return this.__ctx.fillStyle;},
    
    setStrokeStyle: function(v) {this.__ctx.strokeStyle = v;},
    getStrokeStyle: function() {return this.__ctx.strokeStyle;},
    
    setShadowColor: function(v) {this.__ctx.shadowColor = v;},
    getShadowColor: function() {return this.__ctx.shadowColor;},
    
    setShadowBlur: function(v) {this.__ctx.shadowBlur = v;},
    getShadowBlur: function() {return this.__ctx.shadowBlur;},
    
    setShadowOffsetX: function(v) {this.__ctx.shadowOffsetX = v;},
    getShadowOffsetX: function() {return this.__ctx.shadowOffsetX;},
    
    setShadowOffsetY: function(v) {this.__ctx.shadowOffsetY = v;},
    getShadowOffsetY: function() {return this.__ctx.shadowOffsetY;},
    
    setLineWidth: function(v) {this.__ctx.lineWidth = v;},
    getLineWidth: function() {return this.__ctx.lineWidth;},
    
    setLineCap: function(v) {this.__ctx.lineCap = v;},
    getLineCap: function() {return this.__ctx.lineCap;},
    
    setLineJoin: function(v) {this.__ctx.lineJoin = v;},
    getLineJoin: function() {return this.__ctx.lineJoin;},
    
    setMiterLimit: function(v) {this.__ctx.miterLimit = v;},
    getMiterLimit: function() {return this.__ctx.miterLimit;},
    
    setFont: function(v) {this.__ctx.font = v;},
    getFont: function() {return this.__ctx.font;},
    
    setTextAlign: function(v) {this.__ctx.textAlign = v;},
    getTextAlign: function() {return this.__ctx.textAlign;},
    
    setTextBaseline: function(v) {this.__ctx.textBaseline = v;},
    getTextBaseline: function() {return this.__ctx.textBaseline;},
    
    setGlobalAlpha: function(v) {this.__ctx.globalAlpha = v;},
    getGlobalAlpha: function() {return this.__ctx.globalAlpha;},
    
    setGlobalCompositeOperation: function(v) {this.__ctx.globalCompositeOperation = v;},
    getGlobalCompositeOperation: function() {return this.__ctx.globalCompositeOperation;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Prevent views from being sent behind the __canvas. This allows us to
        add child views to a Canvas which is not directly supported in HTML.
        @overrides myt.View */
    sendSubviewToBack: function(sv) {
        if (sv.parent === this) {
            var de = this.domElement,
                firstChild = de.childNodes[1];
            if (sv.domElement !== firstChild) {
                var removedElem = de.removeChild(sv.domElement);
                if (removedElem) de.insertBefore(removedElem, firstChild);
            }
        }
    },
    
    /** Clears the drawing context. Anything currently drawn will be erased. */
    clear: function() {
        // Store the current transform matrix, then apply the identity matrix
        // to make clearing simpler then restore the transform.
        var ctx = this.__ctx;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, this.width, this.height);
        ctx.restore();
    },
    
    /** Draws a circle
        @param x:number the x location of the center of the circle.
        @param y:number the y location of the center of the circle.
        @param radius:number the radius of the circle.
        @returns void */
    circle: function(x, y, radius) {
        this.__ctx.arc(x, y, radius, 0, 2 * Math.PI);
    },
    
    save: function() {var ctx = this.__ctx; ctx.save.apply(ctx, arguments);},
    restore: function() {var ctx = this.__ctx; ctx.restore.apply(ctx, arguments);},
    
    scale: function() {var ctx = this.__ctx; ctx.scale.apply(ctx, arguments);},
    rotate: function() {var ctx = this.__ctx; ctx.rotate.apply(ctx, arguments);},
    translate: function() {var ctx = this.__ctx; ctx.translate.apply(ctx, arguments);},
    transform: function() {var ctx = this.__ctx; ctx.transform.apply(ctx, arguments);},
    setTransform: function() {var ctx = this.__ctx; ctx.setTransform.apply(ctx, arguments);},
    
    createLinearGradient: function() {var ctx = this.__ctx; return ctx.createLinearGradient.apply(ctx, arguments);},
    createRadialGradient: function() {var ctx = this.__ctx; return ctx.createRadialGradient.apply(ctx, arguments);},
    createPattern: function() {var ctx = this.__ctx; return ctx.createPattern.apply(ctx, arguments);},
    
    clearRect: function() {var ctx = this.__ctx; ctx.clearRect.apply(ctx, arguments);},
    fillRect: function() {var ctx = this.__ctx; ctx.fillRect.apply(ctx, arguments);},
    strokeRect: function() {var ctx = this.__ctx; ctx.strokeRect.apply(ctx, arguments);},
    
    beginPath: function() {var ctx = this.__ctx; ctx.beginPath.apply(ctx, arguments);},
    closePath: function() {var ctx = this.__ctx; ctx.closePath.apply(ctx, arguments);},
    moveTo: function() {var ctx = this.__ctx; ctx.moveTo.apply(ctx, arguments);},
    lineTo: function() {var ctx = this.__ctx; ctx.lineTo.apply(ctx, arguments);},
    
    quadraticCurveTo: function() {var ctx = this.__ctx; ctx.quadraticCurveTo.apply(ctx, arguments);},
    bezierCurveTo: function() {var ctx = this.__ctx; ctx.bezierCurveTo.apply(ctx, arguments);},
    arcTo: function() {var ctx = this.__ctx; ctx.arcTo.apply(ctx, arguments);},
    rect: function() {var ctx = this.__ctx; ctx.rect.apply(ctx, arguments);},
    arc: function() {var ctx = this.__ctx; ctx.arc.apply(ctx, arguments);},
    
    fill: function() {var ctx = this.__ctx; ctx.fill.apply(ctx, arguments);},
    stroke: function() {var ctx = this.__ctx; ctx.stroke.apply(ctx, arguments);},
    clip: function() {var ctx = this.__ctx; ctx.clip.apply(ctx, arguments);},
    isPointInPath: function() {var ctx = this.__ctx; ctx.isPointInPath.apply(ctx, arguments);},
    
    fillText: function() {var ctx = this.__ctx; ctx.fillText.apply(ctx, arguments);},
    strokeText: function() {var ctx = this.__ctx; ctx.strokeText.apply(ctx, arguments);},
    measureText: function() {var ctx = this.__ctx; ctx.measureText.apply(ctx, arguments);},
    
    drawImage: function() {var ctx = this.__ctx; ctx.drawImage.apply(ctx, arguments);},
    createImageData: function() {var ctx = this.__ctx; ctx.createImageData.apply(ctx, arguments);},
    getImageData: function() {var ctx = this.__ctx; return ctx.getImageData.apply(ctx, arguments);},
    putImageData: function() {var ctx = this.__ctx; ctx.putImageData.apply(ctx, arguments)}
});



/** Adds an udpateUI method that should be called to update the UI. Various
    mixins will rely on the updateUI method to trigger visual updates.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.UpdateableUI = new JS.Module('UpdateableUI', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        // Call updateUI one time after initialization is complete to give
        // this View a chance to update itself.
        this.updateUI();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Updates the UI whenever a change occurs that requires a visual update.
        Subclasses should implement this as needed.
        @returns void */
    updateUI: function() {
        // Subclasses to implement as needed.
    }
});


/** Adds the capability to be "disabled" to an myt.Node. When an myt.Node is 
    disabled the user should typically not be able to interact with it.
    
    When disabled becomes true an attempt will be made to give away the focus
    using myt.FocusObservable's giveAwayFocus method.
    
    Events:
        disabled:boolean Fired when the disabled attribute is modified
            via setDisabled.
    
    Attributes:
        disabled:boolean Indicates that this component is disabled.
*/
myt.Disableable = new JS.Module('Disableable', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.disabled === undefined) attrs.disabled = false;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setDisabled: function(v) {
        if (this.disabled !== v) {
            this.disabled = v;
            if (this.inited) this.fireNewEvent('disabled', v);
            
            this.doDisabled();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called after the disabled attribute is set. Default behavior attempts
        to give away focus and calls the updateUI method of myt.UpdateableUI if 
        it is defined.
        @returns void */
    doDisabled: function() {
        if (this.inited) {
            // Give away focus if we become disabled and this instance is
            // a FocusObservable
            if (this.disabled && this.giveAwayFocus) this.giveAwayFocus();
            
            if (this.updateUI) this.updateUI();
        }
    }
});


/** Provides global mouse events by listening to mouse events on the the
    document. Registered with myt.global as 'mouse'. */
new JS.Singleton('GlobalMouse', {
    include: [myt.DomElementProxy, myt.DomObservable, myt.MouseObservable],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        this.setDomElement(document);
        
        myt.global.register('mouse', this);
    }
});


/** Provides a 'mouseOver' attribute that tracks mouse over/out state. Also
    provides a mechanism to smoothe over/out events so only one call to
    'doSmoothMouseOver' occurs per idle event.
    
    Requires myt.Disableable and myt.MouseObservable super mixins.
    
    Events:
        None
    
    Attributes:
        mouseOver:boolean Indicates if the mouse is over this view or not.
    
    Private Attributes:
        __attachedToOverIdle:boolean Used by the code that smoothes out
            mouseover events. Indicates that we are registered with the
            idle event.
        __lastOverIdleValue:boolean Used by the code that smoothes out
            mouseover events. Stores the last mouseOver value.
*/
myt.MouseOver = new JS.Module('MouseOver', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.mouseOver === undefined) attrs.mouseOver = false;
        
        this.callSuper(parent, attrs);
        
        this.attachToDom(this, 'doMouseOver', 'mouseover');
        this.attachToDom(this, 'doMouseOut', 'mouseout');
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setMouseOver: function(v) {
        if (this.mouseOver !== v) {
            this.mouseOver = v;
            // No event needed
            
            // Smooth out over/out events by delaying until the next idle event.
            if (this.inited && !this.__attachedToOverIdle) {
                this.__attachedToOverIdle = true;
                this.attachTo(myt.global.idle, '__doMouseOverOnIdle', 'idle');
            }
        }
    },
    
    /** @overrides myt.Disableable */
    setDisabled: function(v) {
        // When about to disable make sure mouseOver is not true. This 
        // helps prevent unwanted behavior of a disabled view.
        if (v && this.mouseOver) this.setMouseOver(false);
        
        this.callSuper(v);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __doMouseOverOnIdle: function() {
        this.detachFrom(myt.global.idle, '__doMouseOverOnIdle', 'idle');
        this.__attachedToOverIdle = false;
        
        // Only call doSmoothOver if the over/out state has changed since the
        // last time it was called.
        var isOver = this.mouseOver;
        if (this.__lastOverIdleValue !== isOver) {
            this.__lastOverIdleValue = isOver;
            this.doSmoothMouseOver(isOver);
        }
    },
    
    /** Called when mouseOver state changes. This method is called after
        an event filtering process has reduced frequent over/out events
        originating from the dom.
        @returns void */
    doSmoothMouseOver: function(v) {
        if (this.inited && this.updateUI) this.updateUI();
    },
    
    /** Called when the mouse is over this view. Subclasses must call super.
        @returns void */
    doMouseOver: function(event) {
        if (!this.disabled) this.setMouseOver(true);
    },
    
    /** Called when the mouse leaves this view. Subclasses must call super.
        @returns void */
    doMouseOut: function(event) {
        if (!this.disabled) this.setMouseOver(false);
    }
});


/** Provides a 'mouseDown' attribute that tracks mouse up/down state.
    
    Requires: myt.MouseOver, myt.Disableable, myt.MouseObservable super mixins.
    
    Suggested: myt.UpdateableUI and myt.Activateable super mixins.
    
    Events:
        None
    
    Attributes:
        mouseDown:boolean Indicates if the mouse is down or not. */
myt.MouseDown = new JS.Module('MouseDown', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.mouseDown === undefined) attrs.mouseDown = false;
        
        this.callSuper(parent, attrs);
        
        this.attachToDom(this, 'doMouseDown', 'mousedown');
        this.attachToDom(this, 'doMouseUp', 'mouseup');
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setMouseDown: function(v) {
        if (this.mouseDown !== v) {
            this.mouseDown = v;
            // No event needed
            if (this.inited) {
                if (v && this.isFocusable()) this.focus(true);
                if (this.updateUI) this.updateUI();
            }
        }
    },
    
    /** @overrides myt.Disableable */
    setDisabled: function(v) {
        // When about to disable the view make sure mouseDown is not true. This 
        // helps prevent unwanted activation of a disabled view.
        if (v && this.mouseDown) this.setMouseDown(false);
        
        this.callSuper(v);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.MouseOver */
    doMouseOver: function(event) {
        this.callSuper(event);
        if (this.mouseDown) this.detachFromDom(myt.global.mouse, 'doMouseUp', 'mouseup', true);
    },
    
    /** @overrides myt.MouseOver */
    doMouseOut: function(event) {
        this.callSuper(event);
        
        // Wait for a mouse up anywhere if the user moves the mouse out of the
        // view while the mouse is still down. This allows the user to move
        // the mouse in and out of the view with the view still behaving 
        // as moused down.
        if (!this.disabled && this.mouseDown) this.attachToDom(myt.global.mouse, 'doMouseUp', 'mouseup', true);
    },
    
    /** Called when the mouse is down on this view. Subclasses must call super.
        @returns void */
    doMouseDown: function(event) {
        if (!this.disabled) this.setMouseDown(true);
    },
    
    /** Called when the mouse is up on this view. Subclasses must call super.
        @returns void */
    doMouseUp: function(event) {
        // Cleanup global mouse listener since the mouseUp occurred outside
        // the view.
        if (!this.mouseOver) this.detachFromDom(myt.global.mouse, 'doMouseUp', 'mouseup', true);
        
        if (!this.disabled && this.mouseDown) {
            this.setMouseDown(false);
            
            // Only do mouseUpInside if the mouse is actually over the view.
            // This means the user can mouse down on a view, move the mouse
            // out and then mouse up and not "activate" the view.
            if (this.mouseOver) this.doMouseUpInside(event);
        }
    },
    
    /** Called when the mouse is up and we are still over the view. Executes
        the 'doActivated' method by default.
        @returns void */
    doMouseUpInside: function(event) {
        if (this.doActivated) this.doActivated();
    }
});


/** Provides both MouseOver and MouseDown mixins as a single mixin. */
myt.MouseOverAndDown = new JS.Module('MouseOverAndDown', {
    include: [myt.MouseOver, myt.MouseDown]
});


/** Adds the capability for an myt.View to be "activated". A doActivated method
    is added that gets called when the view is "activated". */
myt.Activateable = new JS.Module('Activateable', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Called when this view should be activated.
        @returns void */
    doActivated: function() {
        // Subclasses to implement as needed.
    }
});


/** Provides keyboard handling to "activate" the component when a key is 
    pressed down or released up. By default, when a keyup event occurs for
    an activation key and this view is not disabled, the 'doActivated' method
    will get called.
    
    Requires: myt.Activateable, myt.Disableable, myt.KeyObservable and 
        myt.FocusObservable super mixins.
    
    Events:
        None
    
    Attributes:
        activationKeys:array of chars The keys that when keyed down will
            activate this component. Note: The value is not copied so
            modification of the array outside the scope of this object will
            effect behavior.
        activateKeyDown:number the keycode of the activation key that is
            currently down. This will be -1 when no key is down.
        repeatKeyDown:boolean Indicates if doActivationKeyDown will be called
            for repeated keydown events or not. Defaults to false.
*/
myt.KeyActivation = new JS.Module('KeyActivation', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** The default activation keys are enter (13) and spacebar (32). */
        DEFAULT_ACTIVATION_KEYS: [13,32]
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.activateKeyDown = -1;
        
        if (attrs.activationKeys === undefined) {
            attrs.activationKeys = myt.KeyActivation.DEFAULT_ACTIVATION_KEYS;
        }
        
        this.callSuper(parent, attrs);
        
        this.attachToDom(this, '__handleKeyDown', 'keydown');
        this.attachToDom(this, '__handleKeyPress', 'keypress');
        this.attachToDom(this, '__handleKeyUp', 'keyup');
        this.attachToDom(this, '__doDomBlur', 'blur');
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setActivationKeys: function(v) {this.activationKeys = v;},
    setRepeatKeyDown: function(v) {this.repeatKeyDown = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __handleKeyDown: function(event) {
        if (!this.disabled) {
            if (this.activateKeyDown === -1 || this.repeatKeyDown) {
                var keyCode = myt.KeyObservable.getKeyCodeFromEvent(event),
                    keys = this.activationKeys, i = keys.length;
                while (i) {
                    if (keyCode === keys[--i]) {
                        if (this.activateKeyDown === keyCode) {
                            this.doActivationKeyDown(keyCode, true);
                        } else {
                            this.activateKeyDown = keyCode;
                            this.doActivationKeyDown(keyCode, false);
                        }
                        event.value.preventDefault();
                        return;
                    }
                }
            }
        }
    },
    
    /** @private */
    __handleKeyPress: function(event) {
        if (!this.disabled) {
            var keyCode = myt.KeyObservable.getKeyCodeFromEvent(event);
            if (this.activateKeyDown === keyCode) {
                var keys = this.activationKeys, i = keys.length;
                while (i) {
                    if (keyCode === keys[--i]) {
                        event.value.preventDefault();
                        return;
                    }
                }
            }
        }
    },
    
    /** @private */
    __handleKeyUp: function(event) {
        if (!this.disabled) {
            var keyCode = myt.KeyObservable.getKeyCodeFromEvent(event);
            if (this.activateKeyDown === keyCode) {
                var keys = this.activationKeys, i = keys.length;
                while (i) {
                    if (keyCode === keys[--i]) {
                        this.activateKeyDown = -1;
                        this.doActivationKeyUp(keyCode);
                        event.value.preventDefault();
                        return;
                    }
                }
            }
        }
    },
    
    /** @private */
    __doDomBlur: function(event) {
        if (!this.disabled) {
            var keyThatWasDown = this.activateKeyDown;
            if (keyThatWasDown !== -1) {
                this.activateKeyDown = -1;
                this.doActivationKeyAborted(keyThatWasDown);
            }
        }
    },
    
    /** Called when an activation key is pressed down. Default implementation
        does nothing.
        @param key:number the keycode that is down.
        @param isRepeat:boolean Indicates if this is a key repeat event or not.
        @returns void */
    doActivationKeyDown: function(key, isRepeat) {
        // Subclasses to implement as needed.
    },
    
    /** Called when an activation key is release up. This executes the
        'doActivated' method by default. 
        @param key:number the keycode that is up.
        @returns void */
    doActivationKeyUp: function(key) {
        this.doActivated();
    },
    
    /** Called when focus is lost while an activation key is down. Default 
        implementation does nothing.
        @param key:number the keycode that is down.
        @returns void */
    doActivationKeyAborted: function(key) {
        // Subclasses to implement as needed.
    }
});


/** Provides button functionality to an myt.View. Most of the functionality 
    comes from the mixins included by this mixin. This mixin resolves issues 
    that arise when the various mixins are used together.
    
    By default myt.Button instances are focusable.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __restoreCursor:string The cursor to restore to when the button is
            no longer disabled.
*/
myt.Button = new JS.Module('Button', {
    include: [
        myt.Activateable, 
        myt.UpdateableUI, 
        myt.Disableable, 
        myt.MouseOverAndDown, 
        myt.KeyActivation
    ],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_FOCUS_SHADOW_PROPERTY_VALUE: [0, 0, 7, '#666666'],
        DEFAULT_DISABLED_OPACITY: 0.5
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.focusable === undefined) attrs.focusable = true;
        if (attrs.cursor === undefined) attrs.cursor = 'pointer';
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.FocusObservable */
    setFocused: function(v) {
        var existing = this.focused;
        this.callSuper(v);
        if (this.inited && this.focused !== existing) this.updateUI();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.KeyActivation. */
    doActivationKeyDown: function(key, isRepeat) {
        // Prevent unnecessary UI updates when the activation key is repeating.
        if (!isRepeat) this.updateUI();
    },
    
    /** @overrides myt.KeyActivation. */
    doActivationKeyUp: function(key) {
        this.callSuper(key);
        this.updateUI();
    },
    
    /** @overrides myt.KeyActivation. */
    doActivationKeyAborted: function(key) {
        this.callSuper(key);
        this.updateUI();
    },
    
    /** @overrides myt.UpdateableUI. */
    updateUI: function() {
        if (this.disabled) {
            // Remember the cursor to change back to, but don't re-remember
            // if we're already remembering one.
            if (this.__restoreCursor == null) this.__restoreCursor = this.cursor;
            this.setCursor('not-allowed');
            this.drawDisabledState();
        } else {
            var rc = this.__restoreCursor;
            if (rc) {
                this.setCursor(rc);
                this.__restoreCursor = null;
            }
            
            if (this.activateKeyDown !== -1 || this.mouseDown) {
                this.drawActiveState();
            } else if (this.focused) {
                this.drawFocusedState();
            } else if (this.mouseOver) {
                this.drawHoverState();
            } else {
                this.drawReadyState();
            }
        }
    },
    
    /** Draw the UI when the component is in the disabled state.
        @returns void */
    drawDisabledState: function() {
        // Subclasses to implement as needed.
    },
    
    /** Draw the UI when the component has focus. The default implementation
        calls drawHoverState.
        @returns void */
    drawFocusedState: function() {
        this.drawHoverState();
    },
    
    /** Draw the UI when the component is on the verge of being interacted 
        with. For mouse interactions this corresponds to the over state.
        @returns void */
    drawHoverState: function() {
        // Subclasses to implement as needed.
    },
    
    /** Draw the UI when the component has a pending activation. For mouse
        interactions this corresponds to the down state.
        @returns void */
    drawActiveState: function() {
        // Subclasses to implement as needed.
    },
    
    /** Draw the UI when the component is ready to be interacted with. For
        mouse interactions this corresponds to the enabled state when the
        mouse is not over the component.
        @returns void */
    drawReadyState: function() {
        // Subclasses to implement as needed.
    },
    
    /** @overrides myt.FocusObservable */
    showFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow(myt.Button.DEFAULT_FOCUS_SHADOW_PROPERTY_VALUE);
    },
    
    /** @overrides myt.FocusObservable */
    hideFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow();
    }
});


/** Models a color as individual color channels.
    
    Events:
        None
   
    Attributes:
        red:int The red channel. Will be an integer between 0 and 255.
        green:int The green channel. Will be an integer between 0 and 255.
        blue:int The blue channel. Will be an integer between 0 and 255.
*/
myt.Color = new JS.Class('Color', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Converts a number or string representation of a number to a 
            two character hex string.
            @param value:number/string The number or string to convert.
            @returns string: A two character hex string such as: '0c' or 'c9'. */
        toHex: function(value) {
            value = Math.round(Number(value)).toString(16);
            return value.length === 1 ? '0' + value : value;
        },
        
        /** Converts red, green, and blue color channel numbers to a six 
            character hex string.
            @param red:number The red color channel.
            @param green:number The green color channel.
            @param blue:number The blue color channel.
            @param prependHash:boolean (optional) If true a '#' character
                will be prepended to the return value.
            @returns string: Something like: '#ff9c02' or 'ff9c02' */
        rgbToHex: function(red, green, blue, prependHash) {
            var toHex = this.toHex;
            return [prependHash ? '#' : '', toHex(red), toHex(green), toHex(blue)].join('');
        },
        
        /** Limits a channel value to integers between 0 and 255.
            @param value:number the channel value to clean up.
            @returns number */
        cleanChannelValue: function(value) {
            value = Math.round(value);
            
            if (value > 255) return 255;
            if (value < 0) return 0;
            return value;
        },
        
        /** Gets the red channel from a "color" number.
            @return number */
        getRedChannel: function(value) {
            return (0xff0000 & value) >> 16;
        },
        
        /** Gets the green channel from a "color" number.
            @returns number */
        getGreenChannel: function(value) {
            return (0x00ff00 & value) >> 8;
        },
        
        /** Gets the blue channel from a "color" number.
            @returns number */
        getBlueChannel: function(value) {
            return (0x0000ff & value);
        },
        
        /** Creates an myt.Color from a "color" number.
            @returns myt.Color */
        makeColorFromNumber: function(value) {
            return new myt.Color(
                this.getRedChannel(value),
                this.getGreenChannel(value),
                this.getBlueChannel(value)
            );
        },
        
        /** Creates an myt.Color from an html color string.
            @param value:string A hex string representation of a color, such
                as '#ff339b'.
            @returns myt.Color or null if no color could be parsed. */
        makeColorFromHexString: function(value) {
            if (value && value.indexOf('#') === 0) {
                return this.makeColorFromNumber(parseInt(value.substring(1), 16));
            } else {
                return null;
            }
        },
        
        /** Returns the lighter of the two provided colors.
            @param a:number A color number.
            @param b:number A color number.
            @returns The number that represents the lighter color. */
        getLighterColor: function(a, b) {
            var cA = this.makeColorFromNumber(a),
                cB = this.makeColorFromNumber(b);
            return cA.isLighterThan(cB) ? a : b;
        },
        
        /** Creates a "color" number from the provided color channels.
            @param red:number the red channel
            @param green:number the green channel
            @param blue:number the blue channel
            @returns number */
        makeColorNumberFromChannels: function(red, green, blue) {
            red = this.cleanChannelValue(red);
            green = this.cleanChannelValue(green);
            blue = this.cleanChannelValue(blue);
            return (red << 16) + (green << 8) + blue;
        }
    },
    
    
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new Color.
        @param red:number the red channel
        @param green:number the green channel
        @param blue:number the blue channel */
    initialize: function(red, green, blue) {
        this.setRed(red);
        this.setGreen(green);
        this.setBlue(blue);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Sets the red channel value. */
    setRed: function(red) {
        this.red = myt.Color.cleanChannelValue(red);
    },
    
    /** Sets the green channel value. */
    setGreen: function(green) {
        this.green = myt.Color.cleanChannelValue(green);
    },
    
    /** Sets the blue channel value. */
    setBlue: function(blue) {
        this.blue = myt.Color.cleanChannelValue(blue);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Gets the numerical representation of this color.
        @returns number: The number that represents this color. */
    getColorNumber: function() {
        return (this.red << 16) + (this.green << 8) + this.blue;
    },
    
    /** Gets the hex string representation of this color.
        @returns string: A hex color such as '#a0bbcc'. */
    getHtmlHexString: function() {
        return myt.Color.rgbToHex(this.red, this.green, this.blue, true);
    },
    
    /** Tests if this color is lighter than the provided color.
        @param c:myt.Color the color to compare to.
        @returns boolean: True if this color is lighter, false otherwise. */
    isLighterThan: function(c) {
        var diff = this.getDiffFrom(c);
        
        // Sum channel diffs to determine lightest color. A negative diff
        // means a lighter color.
        return 0 > (diff.red + diff.green + diff.blue);
    },
    
    /** Gets an object holding color channel diffs.
        @param c:myt.Color the color to diff from.
        @returns object containing the diffs for the red, green and blue
            channels. */
    getDiffFrom: function(c) {
        return {
            red: c.red - this.red,
            green: c.green - this.green,
            blue: c.blue - this.blue
        };
    },
    
    /** Applies the provided diff object to this color.
        @param diff:object the color diff to apply.
        @returns this myt.Color to facilitate method chaining. */
    applyDiff: function(diff) {
        this.setRed(this.red + diff.red);
        this.setGreen(this.green + diff.green);
        this.setBlue(this.blue + diff.blue);
        return this;
    },
    
    /** Adds the provided color to this color.
        @param c:myt.Color the color to add.
        @returns this myt.Color to facilitate method chaining. */
    add: function(c) {
        this.setRed(this.red + c.red);
        this.setGreen(this.green + c.green);
        this.setBlue(this.blue + c.blue);
        return this;
    },
    
    /** Subtracts the provided color from this color.
        @param c:myt.Color the color to subtract.
        @returns this myt.Color to facilitate method chaining. */
    subtract: function(c) {
        this.setRed(this.red - c.red);
        this.setGreen(this.green - c.green);
        this.setBlue(this.blue - c.blue);
        return this;
    },
    
    /** Multiplys this color by the provided scalar.
        @param s:number the scaler to multiply by.
        @returns this myt.Color to facilitate method chaining. */
    multiply: function(s) {
        this.setRed(this.red * s);
        this.setGreen(this.green * s);
        this.setBlue(this.blue * s);
        return this;
    },
    
    /** Divides this color by the provided scalar.
        @param s:number the scaler to divide by.
        @returns this myt.Color to facilitate method chaining. */
    divide: function(s) {
        this.setRed(this.red / s);
        this.setGreen(this.green / s);
        this.setBlue(this.blue / s);
        return this;
    },
    
    /** Clones this Color.
        @returns myt.Color A copy of this myt.Color. */
    clone: function() {
        return new myt.Color(this.red, this.green, this.blue);
    }
});


/** An ordered collection of points that can be applied to a canvas.
    
    Attributes:
        vectors:array The data is stored in a single array with the x coordinate
            first and the y coordinate second.
        _boundingBox:object the cached bounding box if it has been calculated.
*/
myt.Path = new JS.Class('Path', {
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new Path. */
    initialize: function(vectors) {
        this.setVectors(vectors || []);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setVectors: function(v) {
        this._boundingBox = null;
        this.vectors = v;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Copy the data from the provided Path into this one.
        @param path:myt.Path
        @returns void */
    copyFrom: function(path) {
        this.vectors = path.vectors.slice();
        this._boundingBox = null;
    },
    
    /** Draws this path into the provided drawview. */
    drawInto: function(canvas) {
        canvas.beginPath();
        var vecs = this.vectors, len = vecs.length, i = 0;
        canvas.moveTo(vecs[i++], vecs[i++]);
        for (; len > i;) canvas.lineTo(vecs[i++], vecs[i++]);
        canvas.closePath();
    },
    
    /** Shift this path by the provided x and y amount. */
    translate: function(dx, dy) {
        var vecs = this.vectors, i = vecs.length;
        while (i) {
            vecs[--i] += dy;
            vecs[--i] += dx;
        }
        this._boundingBox = null;
    },
    
    /** Rotates this path around 0,0 by the provided angle in radians. */
    rotate: function(a) {
        var cosA = Math.cos(a), sinA = Math.sin(a),
            vecs = this.vectors, len = vecs.length,
            xNew, yNew, i = 0;
        for (; len > i;) {
            xNew = vecs[i] * cosA - vecs[i + 1] * sinA;
            yNew = vecs[i] * sinA + vecs[i + 1] * cosA;
            
            vecs[i++] = xNew;
            vecs[i++] = yNew;
        }
        this._boundingBox = null;
    },
    
    /** Rotates this path around the provided origin by the provided angle 
        in radians.
        @param angle:number the angle in radians
        @param xOrigin:number the x coordinate to rotate around.
        @param yOrigin:number the y coordinate to rotate around.
        @returns void */
    rotateAroundOrigin: function(angle, xOrigin, yOrigin) {
        this.translate(-xOrigin, -yOrigin);
        this.rotate(angle);
        this.translate(xOrigin, yOrigin);
    },
    
    /** Gets the bounding box for this path.
        @return object with properties x, y, width and height or null
            if no bounding box could be calculated. */
    getBoundingBox: function() {
        if (this._boundingBox) return this._boundingBox;
        
        var vecs = this.vectors, i = vecs.length, x, y, minX, maxX, minY, maxY;
        if (i >= 2) {
            minY = maxY = vecs[--i];
            minX = maxX = vecs[--i];
            while (i) {
                y = vecs[--i];
                x = vecs[--i];
                minY = Math.min(y, minY);
                maxY = Math.max(y, maxY);
                minX = Math.min(x, minX);
                maxX = Math.max(x, maxX);
            }
            return this._boundingBox = {x:minX, y:minY, width:maxX - minX, height:maxY - minY};
        }
        
        return this._boundingBox = null;
    },
    
    /** Gets the center point of the bounding box for the path.
        @returns object with properties x and y or null if no bounding box
            could be calculated. */
    getCenter: function() {
        var box = this.getBoundingBox();
        return box ? {
            x:box.x + (box.width - box.x) / 2,
            y:box.y + (box.height - box.y) / 2
        } : null;
    },
    
    /** Tests if the provided point is inside this path.
        @param x:number the x coordinate to test.
        @param y:number the y coordinate to test.
        
        Alternate params:
        @param x:object A point object with x and y properties.
        
        @return true if inside, false otherwise. */
    isPointInPath: function(x, y) {
        if (typeof x === 'object') {
            y = x.y;
            x = x.x;
        }
        return myt.Geometry.isPointInPath(x, y, this.getBoundingBox(), this.vectors);
    }
});


/** A collection of common drawing routines. */
myt.DrawingUtil = {
    // Methods /////////////////////////////////////////////////////////////////
    /** Draws a rounded rect into the provided drawview.
        @param r:Number the radius of the corners.
        @param thickness:Number the thickness of the line. If thickness is
            zero or less a fill will be done rather than an outline. */
    drawRoundedRect: function(canvas, r, thickness, left, top, w, h) {
        var bottom = top + h, right = left + w;
        
        // We create a single path for both an outer and inner rounded rect.
        // The reason for this is that filling looks much better than stroking.
        canvas.beginPath();
        
        canvas.moveTo(left, top + r);
        
        canvas.lineTo(left, bottom - r);
        canvas.quadraticCurveTo(left, bottom, left + r, bottom);
        
        canvas.lineTo(right - r, bottom);
        canvas.quadraticCurveTo(right, bottom, right, bottom - r);
        
        canvas.lineTo(right, top + r);
        canvas.quadraticCurveTo(right, top, right - r, top);
        
        canvas.lineTo(left + r, top);
        canvas.quadraticCurveTo(left, top, left, top + r);
        
        if (thickness > 0) {
            var ir = r - thickness,
                ileft = left + thickness,
                iright = right - thickness,
                itop = top + thickness,
                ibottom = bottom - thickness;
            
            canvas.lineTo(ileft, itop + ir);
            
            canvas.quadraticCurveTo(ileft, itop, ileft + ir, itop);
            
            canvas.lineTo(iright - ir, itop);
            canvas.quadraticCurveTo(iright, itop, iright, itop + ir);
            
            canvas.lineTo(iright, ibottom - ir);
            canvas.quadraticCurveTo(iright, ibottom, iright - ir, ibottom);
            
            canvas.lineTo(ileft + ir, ibottom);
            canvas.quadraticCurveTo(ileft, ibottom, ileft, ibottom - ir);
            
            canvas.lineTo(ileft, itop + ir);
        }
        
        canvas.closePath();
    },
    
    /** Draws a rect outline into the provided drawview.
        @param thickness:Number the thickness of the line. */
    drawRectOutline: function(canvas, thickness, left, top, w, h) {
        var bottom = top + h, 
            right = left + w,
            ileft = left + thickness,
            iright = right - thickness,
            itop = top + thickness,
            ibottom = bottom - thickness;
        
        canvas.beginPath();
        
        canvas.moveTo(left, top);
        canvas.lineTo(left, bottom);
        canvas.lineTo(right, bottom);
        canvas.lineTo(right, top);
        canvas.lineTo(left, top);
        
        canvas.lineTo(ileft, itop);
        canvas.lineTo(iright, itop);
        canvas.lineTo(iright, ibottom);
        canvas.lineTo(ileft, ibottom);
        canvas.lineTo(ileft, itop);
        
        canvas.closePath();
    },
    
    /** Draws a rounded rect with one or more flat corners.
        @param rTL:Number the radius for the top left corner.
        @param rTR:Number the radius for the top right corner.
        @param rBL:Number the radius for the bottom left corner.
        @param rBR:Number the radius for the bottom right corner. */
    drawPartiallyRoundedRect: function(canvas, rTL, rTR, rBL, rBR, left, top, w, h) {
        var bottom = top + h, right = left + w;
        
        canvas.beginPath();
        
        canvas.moveTo(left, top + rTL);
        
        canvas.lineTo(left, bottom - rBL);
        if (rBL > 0) canvas.quadraticCurveTo(left, bottom, left + rBL, bottom);
        
        canvas.lineTo(right - rBR, bottom);
        if (rBR > 0) canvas.quadraticCurveTo(right, bottom, right, bottom - rBR);
        
        canvas.lineTo(right, top + rTR);
        if (rTR > 0) canvas.quadraticCurveTo(right, top, right - rTR, top);
        
        canvas.lineTo(left + rTL, top);
        if (rTL > 0) canvas.quadraticCurveTo(left, top, left, top + rTL);
        
        canvas.closePath();
    },
    
    drawGradientArc: function(canvas, centerX, centerY, r, ir, startAngle, endAngle, colors, segments) {
        if (segments == null) segments = 60;
        
        var angleDelta = Math.PI / segments,
        
        // Antialiasing issues means we need to draw each polygon with a small 
        // overlap to fill the gap.
            angleOverlap =  Math.PI / 360,
        
        // Calculate Colors
            len = colors.length, i = 0, angleDiff, slices, diff;
        for (; len > i + 1; i++) {
            angleDiff = colors[i + 1].angle - colors[i].angle;
            slices = Math.round(angleDiff / angleDelta);
            diff = colors[i].color.getDiffFrom(colors[i + 1].color);
            colors[i].colorDelta = {red:diff.red / slices, green:diff.green / slices, blue:diff.blue / slices};
        }
        
        var path = new myt.Path([centerX + r, centerY, centerX + ir, centerY]),
            prevAngle, ix1, iy1, x1, y1,
            angle = startAngle;
        
        path.rotateAroundOrigin(angle, centerX, centerY);
        var vectors = path.vectors,
            x2 = vectors[0], y2 = vectors[1],
            ix2 = vectors[2], iy2 = vectors[3],
            diffCount = 0;
        
        i = 0;
        
        while (endAngle > angle) {
            // Shift angle and points
            x1 = x2;
            y1 = y2;
            ix1 = ix2;
            iy1 = iy2;
            prevAngle = angle;
            
            // Calculate new angle and points
            angle += angleDelta;
            if (angle > endAngle) {
                angleDelta += endAngle - angle;
                angleOverlap = 0;
                angle = endAngle;
            }
            path.rotateAroundOrigin(angleDelta + angleOverlap, centerX, centerY);
            x2 = vectors[0];
            y2 = vectors[1];
            ix2 = vectors[2];
            iy2 = vectors[3];
            
            // Draw part
            canvas.beginPath();
            canvas.moveTo(x1, y1);
            canvas.lineTo(ix1, iy1);
            canvas.lineTo(ix2, iy2);
            canvas.lineTo(x2, y2);
            canvas.closePath();
            
            var c = colors[i].color;
            var colorDelta = colors[i].colorDelta
            canvas.fillStyle = myt.Color.makeColorNumberFromChannels(
                c.red + (diffCount * colorDelta.red),
                c.green + (diffCount * colorDelta.green),
                c.blue + (diffCount * colorDelta.blue)
            );
            canvas.fill();
            
            if (angleOverlap > 0) {
                path.rotateAroundOrigin(-angleOverlap, centerX, centerY);
                x2 = vectors[0];
                y2 = vectors[1];
                ix2 = vectors[2];
                iy2 = vectors[3];
            }
            
            // Increment color
            diffCount++;
            if (angle >= colors[i + 1].angle) {
                diffCount = 0;
                i++;
            }
        }
    }
};


/** Encapsulates drawing into a myt.Canvas object. Contains a repository
    of DrawingMethod instances that can be accessed by class name. */
myt.DrawingMethod = new JS.Class('DrawingMethod', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of DrawingMethod by class name. */
        _drawingMethods: {},
        
        /** Gets a DrawingMethod for the classname.
            @returns myt.DrawingMethod. */
        get: function(classname) {
            var drawingMethods = this._drawingMethods,
                drawingMethod = drawingMethods[classname];
            
            // Create the DrawingMethod if it wasn't found in the cache.
            if (!drawingMethod) {
                var drawingMethodClass = myt.resolveName(classname);
                if (drawingMethodClass) {
                    drawingMethods[classname] = drawingMethod = new drawingMethodClass();
                }
            }
            
            return drawingMethod;
        },
        
        /** Gets a DrawingMethod and uses it to draw into the Canvas.
            @param classname:String the name of the class to draw with.
            @param canvas:myt.Canvas the canvas to draw into.
            @param config:Object (Optional) a map of configuration parameters 
                that control how the DrawingMethod draws. */
        draw: function(classname, canvas, config) {
            var drawingMethod = this.get(classname);
            if (drawingMethod) {
                drawingMethod.draw(canvas, config);
            } else {
                console.log("Unknown DrawingMethod", classname);
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Draw into the Canvas.
        @param canvas:myt.Canvas the canvas to draw into.
        @param config:Object (Optional) a map of configuration parameters 
            that control how the DrawingMethod draws. */
    draw: function(canvas, config) {}
});


/** An myt.Button that makes use of an myt.DrawingMethod to display itself.
    
    Events:
        None
    
    Attributes:
        drawingMethodClassname:string the name of the class to draw with.
        drawingMethod:myt.DrawingMethod the instance to draw with. Obtained
            by resolving the drawingMethodClassname. This attribute should be
            treated as read only.
        drawBounds:object the bounds for drawing within.
    
    Private Attributes:
        __lastState:string The last draw state drawn.
*/
myt.DrawButton = new JS.Class('DrawButton', myt.Canvas, {
    include: [myt.Button],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.drawBounds = {x:0, y:0, w:0, h:0};
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setDrawingMethodClassname: function(v) {
        if (this.drawingMethodClassname !== v) {
            this.drawingMethodClassname = v;
            this.setDrawingMethod(myt.DrawingMethod.get(v));
        }
    },
    
    setDrawingMethod: function(v) {
        if (this.drawingMethod !== v) {
            this.drawingMethod = v;
            if (this.inited) this.updateUI();
        }
    },
    
    /** Gets the bounds used by the DrawingMethod to draw within. By default
        this returns the bounds of this view.
        @returns an object with x, y, w and h properties. */
    getDrawBounds: function() {
        var bounds = this.drawBounds;
        bounds.w = this.width;
        bounds.h = this.height;
        return bounds;
    },
    
    getDrawConfig: function(state) {
        return {state:state, focused:this.focused, bounds:this.getDrawBounds()};
    },
    
    /** @overrides myt.View */
    setWidth: function(v, supressEvent) {
        this.callSuper(v, supressEvent);
        if (this.inited) this.redraw();
    },
    
    /** @overrides myt.View */
    setHeight: function(v, supressEvent) {
        this.callSuper(v, supressEvent);
        if (this.inited) this.redraw();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Button */
    drawDisabledState: function() {
        this.setOpacity(myt.Button.DEFAULT_DISABLED_OPACITY);
        this.redraw('disabled');
    },
    
    /** @overrides myt.Button */
    drawHoverState: function() {
        this.setOpacity(1);
        this.redraw('hover');
    },
    
    /** @overrides myt.Button */
    drawActiveState: function() {
        this.setOpacity(1);
        this.redraw('active');
    },
    
    /** @overrides myt.Button */
    drawReadyState: function() {
        this.setOpacity(1);
        this.redraw('ready');
    },
    
    redraw: function(state) {
        // Used if redrawing for focus changes
        if (state === undefined) state = this.__lastState;
        this.__lastState = state;
        
        var dm = this.drawingMethod || this;
        dm.draw(this, this.getDrawConfig(state));
    },
    
    /** Used if no drawing method is found. */
    draw: function(canvas, config) {
        myt.dumpStack("No drawing method found");
    }
});


/** An myt.Button that makes use of activeColor, hoverColor and readyColor
    attributes to fill the button.
    
    Events:
        None
    
    Attributes:
        activeColor:string A color string such as '#ff0000' or 'transparent'.
            Used when the button is in the active state. The default value 
            is transparent.
        hoverColor:string A color string such as '#ff0000' or 'transparent'.
            Used when the button is in the hover state. The default value 
            is transparent.
        readyColor:string A color string such as '#ff0000' or 'transparent'.
            Used when the button is in the ready or disabled state. The 
            default value is transparent.
*/
myt.SimpleButton = new JS.Class('SimpleButton', myt.View, {
    include: [myt.Button],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.activeColor = this.hoverColor = this.readyColor = 'transparent';
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setActiveColor: function(v) {
        if (this.activeColor !== v) {
            this.activeColor = v;
            // No event needed
            if (this.inited) this.updateUI();
        }
    },
    
    setHoverColor: function(v) {
        if (this.hoverColor !== v) {
            this.hoverColor = v;
            // No event needed
            if (this.inited) this.updateUI();
        }
    },
    
    setReadyColor: function(v) {
        if (this.readyColor !== v) {
            this.readyColor = v;
            // No event needed
            if (this.inited) this.updateUI();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Button */
    drawDisabledState: function() {
        this.setOpacity(myt.Button.DEFAULT_DISABLED_OPACITY);
        this.setBgColor(this.readyColor);
    },
    
    /** @overrides myt.Button */
    drawHoverState: function() {
        this.setOpacity(1);
        this.setBgColor(this.hoverColor);
    },
    
    /** @overrides myt.Button */
    drawActiveState: function() {
        this.setOpacity(1);
        this.setBgColor(this.activeColor);
    },
    
    /** @overrides myt.Button */
    drawReadyState: function() {
        this.setOpacity(1);
        this.setBgColor(this.readyColor);
    }
});


/** A mixin that adds an icon and text to the inside of a button.
    
    Events:
        inset:number
        outset:number
        text:string
        shrinkToFit:boolean
        contentAlign:string
        iconUrl:string
        iconY:number|string
        iconSpacing:number
        textY:number|string
    
    Attributes:
        text:string The text to display on the button.
        iconUrl:string The url for an image to display in the button.
        inset:number The left padding before the icon. Defaults to 0.
        outset:number The right padding after the text/icon. Defaults to 0.
        textY:number|string The y offset for the text. If a string it must be
            a valign value: 'top', 'middle' or 'bottom'.
        iconY:number|string The y offset for the icon. If a string it must be
            a valign value: 'top', 'middle' or 'bottom'.
        iconSpacing:number The spacing between the iconView and the textView. 
            Defaults to 2.
        shrinkToFit:boolean When true the button will be as narrow as possible
            to fit the text, icon, inset and outset. When false the button 
            will be as wide as the set width. Defaults to false.
        contentAlign:string Determines how the icon and text will be 
            positioned when not in shrinkToFit mode. Allowed values are: 
            'left', 'center' and 'right'. Defaults to 'center'.
        textView:myt.Text A reference to the child text view.
        iconView:myt.Image A reference to the child image view.
        
    Private Attributes:
        __updateContentPositionLoopBlock:boolean Used in __updateContentPosition
            to prevent infinite loops.
*/
myt.IconTextButtonContent = new JS.Module('IconTextButtonContent', {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.textY = this.iconY = 'middle';
        this.iconSpacing = 2;
        this.inset = this.outset = 0;
        
        if (attrs.shrinkToFit === undefined) attrs.shrinkToFit = false;
        if (attrs.contentAlign === undefined) attrs.contentAlign = 'center';
        
        this.callSuper(parent, attrs);
        
        // Setup the constraint after inited since the textView won't have
        // been sized to the dom until it's added in.
        var iconView = this.iconView, textView = this.textView;
        this.applyConstraint('__updateContentPosition', [
            this, 'inset', this, 'outset',
            this, 'width', this, 'shrinkToFit', this, 'iconSpacing',
            this, 'contentAlign',
            iconView, 'width', iconView, 'visible',
            textView, 'visible', textView, 'width'
        ]);
    },
    
    doAfterAdoption: function() {
        var attrs, iconY = this.iconY, textY = this.textY;
        
        // Setup iconView
        attrs = {
            name:'iconView', imageUrl:this.iconUrl
        };
        if (typeof iconY === 'string') {
            attrs.valign = iconY;
        } else {
            attrs.y = iconY;
        }
        new myt.Image(this, attrs);
        
        // Setup textView
        attrs = {
            name:'textView', whiteSpace:'nowrap', text:this.text, 
            domClass:'mytButtonText mytUnselectable'
        };
        if (typeof textY === 'string') {
            attrs.valign = textY;
        } else {
            attrs.y = textY;
        }
        new myt.Text(this, attrs);
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setInset: function(v) {
        // Adapt to event from syncTo
        if (v !== null && typeof v === 'object') v = v.value;
        
        if (this.inset !== v) {
            this.inset = v;
            if (this.inited) this.fireNewEvent('inset', v);
        }
    },
    
    setOutset: function(v) {
        // Adapt to event from syncTo
        if (v !== null && typeof v === 'object') v = v.value;
        
        if (this.outset !== v) {
            this.outset = v;
            if (this.inited) this.fireNewEvent('outset', v);
        }
    },
    
    setText: function(v) {
        if (this.text !== v) {
            this.text = v;
            if (this.inited) {
                this.textView.setText(v);
                this.fireNewEvent('text', v);
            }
        }
    },
    
    setShrinkToFit: function(v) {
        if (this.shrinkToFit !== v) {
            this.shrinkToFit = v;
            if (this.inited) this.fireNewEvent('shrinkToFit', v);
        }
    },
    
    setContentAlign: function(v) {
        if (this.contentAlign !== v) {
            this.contentAlign = v;
            if (this.inited) this.fireNewEvent('contentAlign', v);
        }
    },
    
    setIconUrl: function(v) {
        if (this.iconUrl !== v) {
            this.iconUrl = v;
            if (this.inited) {
                this.fireNewEvent('iconUrl', v);
                this.iconView.setImageUrl(v);
            }
        }
    },
    
    setIconY: function(v) {
        if (this.iconY !== v) {
            this.iconY = v;
            if (this.inited) {
                this.fireNewEvent('iconY', v);
                if (typeof v === 'string') {
                    this.iconView.setValign(v);
                } else {
                   this.iconView.setY(v);
                }
            }
        }
    },
    
    setIconSpacing: function(v) {
        if (this.iconSpacing !== v) {
            this.iconSpacing = v;
            if (this.inited) this.fireNewEvent('iconSpacing', v);
        }
    },
    
    setTextY: function(v) {
        if (this.textY !== v) {
            this.textY = v;
            if (this.inited) {
                this.fireNewEvent('textY', v);
                if (typeof v === 'string') {
                    this.textView.setValign(v);
                } else {
                    this.textView.setValign('');
                    this.textView.setY(v);
                }
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __updateContentPosition: function(v) {
        if (this.__updateContentPositionLoopBlock || this.destroyed) return;
        
        var inset = this.inset,
            outset = this.outset,
            iconView = this.iconView,
            textView = this.textView,
            textViewVisible = textView.visible && this.text,
            iconWidth = iconView.visible ? iconView.width : 0,
            iconExtent = iconWidth + (textViewVisible && iconWidth > 0 ? this.iconSpacing : 0),
            textWidth = textViewVisible ? textView.width : 0;
        
        if (this.shrinkToFit) {
            var totalWidth = inset;
            iconView.setX(totalWidth);
            totalWidth += iconExtent;
            textView.setX(totalWidth);
            totalWidth += textWidth + outset;
            
            this.__updateContentPositionLoopBlock = true;
            this.setWidth(totalWidth);
            this.__updateContentPositionLoopBlock = false;
        } else {
            var leftPos;
            if (this.contentAlign === 'left') {
                leftPos = inset;
            } else if (this.contentAlign === 'center') {
                var extraWidth = this.width - inset - iconExtent - textWidth - outset;
                leftPos = inset + (extraWidth / 2);
            } else {
                leftPos = this.width - iconExtent - textWidth - outset;
            }
            
            iconView.setX(leftPos);
            textView.setX(leftPos + iconExtent);
        }
    }
});


/** A base class for tooltip classes.
    
    Events:
        None
    
    Attributes:
        tooltip:object The tooltip configuration assigned to this tooltip
            when the mouse has moved over a view with TooltipMixin.
        tipDelay:number The time in millis to wait before showing the tooltip.
        tipHideDelay:number The time in millis to wait before hiding 
            the tooltip.
    
    Private Attributes:
        __checkTipCallback:myt.Callback The callback invoked by 
            the __checkTipTimer.
        __checkTipTimer:myt.Timer The timer that shows the tooltip if the
            mouse is still over the TooltipMixin view when the delay time
            has passed.
*/
myt.BaseTooltip = new JS.Class('BaseTooltip', myt.View, {
    include: [myt.RootView],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** The length of time in millis before the tip is shown. */
        DEFAULT_TIP_DELAY:500,
        /** The length of time in millis before the tip is hidden. */
        DEFAULT_TIP_HIDE_DELAY:100
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        var BTT = myt.BaseTooltip;
        this.tipDelay = this.nextTipDelay = BTT.DEFAULT_TIP_DELAY;
        this.tipHideDelay = BTT.DEFAULT_TIP_HIDE_DELAY;
        
        if (attrs.visible === undefined) attrs.visible = false;
        
        this.callSuper(parent, attrs);
        
        this.__checkTipCallback = new myt.Callback('__checkTip', this);
        this.__checkTipTimer = new myt.Timer();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Sets the tooltip info that will be displayed. 
        @param v:object with the following keys:
            parent:myt.View The view to show the tip for.
            text:string The tip text.
            tipalign:string Tip alignment, 'left' or 'right'.
            tipvalign:string Tip vertical alignment, 'above' or 'below'. */
    setTooltip: function(v) {
        if (this.inited) {
            this.tooltip = v;
            if (v) {
                this.attachToDom(myt.global.mouse, '__checkMouseMovement', 'mousemove', true);
                
                var ttp = v.parent;
                this.attachToDom(ttp, 'hideTip', 'mousedown', true);
                this.attachToDom(ttp, 'hideTip', 'mouseup', true);
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __checkMouseMovement: function(event) {
        this._lastPos = myt.MouseObservable.getMouseFromEvent(event);
        if (this.__checkIn()) this.__checkTipTimer.reset(this.__checkTipCallback, this.nextTipDelay);
    },
    
    /** If the mouse rests in the tip's parent, show the tip.
        @private
        @returns void */
    __checkTip: function() {
        if (this.__checkIn()) this.showTip();
    },
    
    /** Checks if the last mouse position is inside the tip's parent.
        If not inside the tip will also get hidden.
        @private
        @returns boolean: false if the tip got hidden, true otherwise. */
    __checkIn: function() {
        var tt = this.tooltip;
        if (tt) {
            var pos = this._lastPos;
            if (tt.parent.containsPoint(pos.x, pos.y)) return true;
        }
        this.hideTip();
        return false;
    },
    
    /** Called when the tip will be hidden.
        @returns boolean */
    hideTip: function(event) {
        this.__checkTipTimer.clear();
        
        var ttp = this.tooltip.parent;
        this.detachFromDom(ttp, 'hideTip', 'mousedown', true);
        this.detachFromDom(ttp, 'hideTip', 'mouseup', true);
        this.detachFromDom(myt.global.mouse, '__checkMouseMovement', 'mousemove', true);
        
        this.nextTipDelay = this.tipDelay;
        this.setVisible(false);
        
        // Don't consume mouse event since we just want to close the tip
        // as a side effect of the user action. The typical case for this is
        // the user clicking on a button while the tooltip for that button
        // is shown.
        return true;
    },
    
    /** Called when the tip will be shown.
        @returns void */
    showTip: function() {
        // Don't show tooltips while doing drag and drop since they're
        // distracting while this is going on.
        if (!myt.global.dragManager.dragView) {
            this.nextTipDelay = this.tipHideDelay;
            this.bringToFront();
            this.setVisible(true);
        }
    }
});


/** An implementation of a tooltip.
    
    Events:
        None
    
    Attributes:
        edgeWidth:number the width of the "edge" of the tip background.
        pointerInset:number The inset of the "pointer" from the left/right 
            edge of the tip.
        insetH:number The horizontal inset of the text from the edge.
        insetTop:number The top inset of the text from the edge.
        insetBottom:number The bottom inset of the text from the edge.
        shadowWidth:number The width of the shadow.
        maxTextWidth:number The maximum width for the text view in the tooltip.
        tipBgColor:string The color to use for the tip background.
        edgeColor:string The color used for the edge.
        shadowColor:string The color of the shadow.
    
    Private Attributes:
        __tipWidth:number The width of the tip text view.
*/
myt.Tooltip = new JS.Class('Tooltip', myt.BaseTooltip, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_POINTER_WIDTH:7,
        DEFAULT_POINTER_HEIGHT:4,
        DEFAULT_EDGE_WIDTH:1,
        DEFAULT_POINTER_INSET:2,
        DEFAULT_HORIZONTAL_INSET:4,
        DEFAULT_TOP_INSET:2,
        DEFAULT_BOTTOM_INSET:3,
        DEFAULT_SHADOW_WIDTH:2,
        DEFAULT_MAX_TEXT_WIDTH:280,
        DEFAULT_TIP_BG_COLOR:'#dddddd',
        DEFAULT_EDGE_COLOR:'#666666',
        DEFAULT_SHADOW_COLOR:'#000000'
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        var T = myt.Tooltip;
        if (attrs.pointerWidth === undefined) attrs.pointerWidth = T.DEFAULT_POINTER_WIDTH;
        if (attrs.pointerHeight === undefined) attrs.pointerHeight = T.DEFAULT_POINTER_HEIGHT;
        if (attrs.edgeWidth === undefined) attrs.edgeWidth = T.DEFAULT_EDGE_WIDTH;
        if (attrs.pointerInset === undefined) attrs.pointerInset = T.DEFAULT_POINTER_INSET;
        if (attrs.insetH === undefined) attrs.insetH = T.DEFAULT_HORIZONTAL_INSET;
        if (attrs.insetTop === undefined) attrs.insetTop = T.DEFAULT_TOP_INSET;
        if (attrs.insetBottom === undefined) attrs.insetBottom = T.DEFAULT_BOTTOM_INSET;
        if (attrs.shadowWidth === undefined) attrs.shadowWidth = T.DEFAULT_SHADOW_WIDTH;
        if (attrs.maxTextWidth === undefined) attrs.maxTextWidth = T.DEFAULT_MAX_TEXT_WIDTH;
        if (attrs.tipBgColor === undefined) attrs.tipBgColor = T.DEFAULT_TIP_BG_COLOR;
        if (attrs.edgeColor === undefined) attrs.edgeColor = T.DEFAULT_EDGE_COLOR;
        if (attrs.shadowColor === undefined) attrs.shadowColor = T.DEFAULT_SHADOW_COLOR;
        
        this.__tipWidth = 0;
        
        this.callSuper(parent, attrs);
        
        new myt.Canvas(this, {
            name:'_bg', percentOfParentWidth:100, percentOfParentHeight:100
        }, [myt.SizeToParent]);
        new myt.Text(this, {
            name:'_tipText', fontSize:'12px',
            x:this.edgeWidth + this.insetH, whiteSpace:'inherit'
        });
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setPointerWidth: function(v) {this.pointerWidth = v;},
    setPointerHeight: function(v) {this.pointerHeight = v;},
    setEdgeWidth: function(v) {this.edgeWidth = v;},
    setPointerInset: function(v) {this.pointerInset = v;},
    setInsetH: function(v) {this.insetH = v;},
    setInsetTop: function(v) {this.insetTop = v;},
    setInsetBottom: function(v) {this.insetBottom = v;},
    setShadowWidth: function(v) {this.shadowWidth = v;},
    setMaxTextWidth: function(v) {this.maxTextWidth = v;},
    setTipBgColor: function(v) {this.tipBgColor = v;},
    setEdgeColor: function(v) {this.edgeColor = v;},
    setShadowColor: function(v) {this.shadowColor = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.BaseTooltip. */
    showTip: function() {
        var tt = this.tooltip,
            txt = tt.text,
            ttp = tt.parent,
            tipText = this._tipText,
            insetTop = this.insetTop,
            shadowWidth = this.shadowWidth;
        
        // Set tip text
        if (tipText.text !== txt) tipText.setText(txt);
        
        // Get floating boundary
        var gwr = myt.global.windowResize,
            bounds = {x:0, y:0, width:gwr.getWidth(), height:gwr.getHeight()},
            boundsXOffset = 0, boundsYOffset = 0;
        
        // Get position of parent
        var parentPos = ttp.getPagePosition(),
            tipX = parentPos.x,
            tipParentY = parentPos.y;
        
        // Determine X position
        tipText.setWidth('auto');
        var tipTextWidth = Math.min(tipText.measureNoWrapWidth(), this.maxTextWidth),
            pointerX = tipText.x;
        this.__tipWidth = 2 * pointerX + tipTextWidth;
        tipText.setWidth(tipTextWidth);
        tipText.sizeViewToDom();
        
        if (tt.tipalign === 'right') {
            tipX += ttp.width - this.__tipWidth;
            pointerX += tipText.width - this.pointerInset - this.pointerWidth;
        } else {
            pointerX += this.pointerInset;
        }
        
        // Prevent out-of-bounds to the left
        var diff;
        if (boundsXOffset > tipX) {
            diff = boundsXOffset - tipX;
            tipX += diff;
            pointerX -= diff;
        }
        
        // Prevent out-of-bounds to the right
        if (tipX + this.__tipWidth > boundsXOffset + bounds.width) {
            diff = (tipX + this.__tipWidth) - (boundsXOffset + bounds.width);
            tipX -= diff;
            pointerX += diff;
        }
        
        // Determine Y position
        var tipHeight = 2*this.edgeWidth + insetTop + this.insetBottom + tipText.height + this.pointerHeight,
            tipParentHeight = ttp.height,
            pointerOnTop, tipY;
        switch (tt.tipvalign) {
            case "below":
                tipY = tipParentY + tipParentHeight;
                pointerOnTop = true;
                
                if (tipY + tipHeight > boundsYOffset + bounds.height) {
                    tipY = tipParentY - tipHeight;
                    pointerOnTop = false;
                }
                break;
            
            case "above":
            default:
                tipY = tipParentY - tipHeight;
                pointerOnTop = false;
                
                if (boundsYOffset > tipY) {
                    tipY = tipParentY + tipParentHeight;
                    pointerOnTop = true;
                }
                break;
        }
        
        // Apply values
        this.setX(Math.round(tipX));
        this.setY(Math.round(tipY));
        tipText.setY(insetTop + this.edgeWidth + (pointerOnTop ? this.pointerHeight : 0));
        
        this.setWidth(this.__tipWidth + shadowWidth);
        this.setHeight(tipHeight + shadowWidth);
        
        this.__redraw(pointerX, pointerOnTop);
        
        this.callSuper();
    },
    
    /** @private */
    __redraw: function(pointerX, pointerOnTop) {
        var canvas = this._bg,
            right = this.__tipWidth,
            top = pointerOnTop ? this.pointerHeight : 0,
            bottom = 2*this.edgeWidth + this.insetTop + this.insetBottom + this._tipText.height + top,
            pointerWidth = this.pointerWidth,
            pointerXCtr = pointerX + pointerWidth / 2,
            pointerXRt = pointerX + pointerWidth,
            pointerHeight = this.pointerHeight,
            shadowWidth = this.shadowWidth,
            edgeWidth = this.edgeWidth,
            lineTo = canvas.lineTo.bind(canvas);
        
        canvas.clear();
        
        // Draw Shadow
        canvas.beginPath();
        canvas.moveTo(shadowWidth, top + shadowWidth);
        lineTo(right + shadowWidth, top + shadowWidth);
        lineTo(right + shadowWidth, bottom + shadowWidth);
        lineTo(shadowWidth, bottom + shadowWidth);
        canvas.closePath();
        canvas.setGlobalAlpha(0.3);
        canvas.setFillStyle(this.shadowColor);
        canvas.fill();
        
        canvas.setGlobalAlpha(1);
        
        // Draw Edge
        canvas.beginPath();
        canvas.moveTo(0, top);
        
        if (pointerOnTop) {
            lineTo(pointerX, top);
            lineTo(pointerXCtr, top - pointerHeight);
            lineTo(pointerXRt, top);
        }
        
        lineTo(right, top);
        lineTo(right, bottom);
        
        if (!pointerOnTop) {
            lineTo(pointerXRt, bottom);
            lineTo(pointerXCtr, bottom + pointerHeight);
            lineTo(pointerX, bottom);
        }
        
        lineTo(0, bottom);
        canvas.closePath();
        canvas.setFillStyle(this.edgeColor);
        canvas.fill();
        
        // Draw Fill
        right -= edgeWidth;
        top += edgeWidth;
        bottom -= edgeWidth;
        
        canvas.beginPath();
        canvas.moveTo(edgeWidth, top);
        
        if (pointerOnTop) {
            lineTo(pointerX, top);
            lineTo(pointerXCtr, top - pointerHeight);
            lineTo(pointerXRt, top);
        }
        
        lineTo(right, top);
        lineTo(right, bottom);
        
        if (!pointerOnTop) {
            lineTo(pointerXRt, bottom);
            lineTo(pointerXCtr, bottom + pointerHeight);
            lineTo(pointerX, bottom);
        }
        
        lineTo(edgeWidth, bottom);
        canvas.closePath();
        canvas.setFillStyle(this.tipBgColor);
        canvas.fill();
    }
});


/** A mixin that adds tooltip support to a view.
    
    Requires:
        myt.MouseOver
    
    Events:
        tooltip:string
        tipAlign:string
        tipValign:string
        tipClass:JS.Class
    
    Attributes:
        tooltip:string The tip text to display.
        tipAlign:string The horizontal alignment of the tooltip relative to
            the view the tip is being shown for. Supported values are 'left'
            and 'right'. Defaults to 'left'.
        tipValign:string The vertical alignment of the tooltip relative to
            the view the tip is being shown for. Supported values are 'above'
            and 'below'. Defaults to 'above'.
        tipClass:JS.Class The class to use to instantiate the tooltip.
*/
myt.TooltipMixin = new JS.Module('TooltipMixin', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** The default class to use for tooltip views. If a project wants to use
            a special tip class everywhere it should override this. */
        DEFAULT_TIP_CLASS:myt.Tooltip
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setTooltip: function(v) {
        if (this.tooltip !== v) {
            this.tooltip = v;
            if (this.inited) this.fireNewEvent('tooltip', v);
        }
    },
    
    setTipAlign: function(v) {
        if (this.tipAlign !== v) {
            this.tipAlign = v;
            if (this.inited) this.fireNewEvent('tipAlign', v);
        }
    },
    
    setTipValign: function(v) {
        if (this.tipValign !== v) {
            this.tipValign = v;
            if (this.inited) this.fireNewEvent('tipValign', v);
        }
    },
    
    setTipClass: function(v) {
        if (this.tipClass !== v) {
            this.tipClass = v;
            if (this.inited) this.fireNewEvent('tipClass', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.MouseOver. */
    doSmoothMouseOver: function(isOver) {
        this.callSuper(isOver);
        
        if (isOver && this.tooltip) {
            // Use configured class or default if none defined.
            var tipClass = this.tipClass || myt.TooltipMixin.DEFAULT_TIP_CLASS,
                g = myt.global, 
                ttv = g.tooltipView;
            
            // Destroy tip if it's not the correct class.
            if (ttv && !(ttv instanceof tipClass)) {
                g.unregister('tooltipView');
                ttv.destroy();
                ttv = null;
            }
            
            // Create new instance.
            if (!ttv) {
                // Create tooltip div if necessary
                var elem = document.getElementById("tooltipDiv");
                if (!elem) {
                    elem = myt.DomElementProxy.createDomElement('div', {position:'absolute'});
                    myt.getElement().appendChild(elem);
                }
                
                ttv = new tipClass(elem, {domId:'tooltipDiv'});
                g.register('tooltipView', ttv);
            }
            
            ttv.setTooltip({
                parent:this, 
                text:this.tooltip, 
                tipalign:this.tipAlign || 'left', 
                tipvalign:this.tipValign || 'above'
            });
        }
    }
});


/** A simple button with support for an icon and text and tooltip support. */
myt.SimpleIconTextButton = new JS.Class('SimpleIconTextButton', myt.SimpleButton, {
    include: [myt.IconTextButtonContent, myt.TooltipMixin]
});


/** A base class for MouseableH3Panel and MouseableV3Panel.
    Includes the myt.Button mixin.
    
    Events:
        None
    
    Attributes:
        imageRoot:string The path to the directory with the images.
        extension:string The file extension for the images.
        firstPrefix:string The filename for the top/left panel image.
        secondPrefix:string The filename for the middle/center panel image.
        thirdPrefix:string The filename for the bottom/right panel image.
*/
myt.BaseMouseablePanel = new JS.Module('BaseMouseablePanel', {
    include: [myt.Button],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.extension = 'png';
        
        // @overrides behavior from HorizontalThreePanel and VerticalThreePanel
        // mixins which will be used with this mixin in MouseableH3Panel
        // and MouseableV3Panel respectively.
        if (attrs.repeat === undefined) attrs.repeat = false;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setImageRoot: function(v) {
        if (this.imageRoot !== v) {
            this.imageRoot = v;
            if (this.inited) updateUI();
        }
    },
    
    setExtension: function(v) {
        if (this.extension !== v) {
            this.extension = v;
            if (this.inited) updateUI();
        }
    },
    
    setFirstPrefix: function(v) {
        if (this.firstPrefix !== v) {
            this.firstPrefix = v;
            if (this.inited) updateUI();
        }
    },
    
    setSecondPrefix: function(v) {
        if (this.secondPrefix !== v) {
            this.secondPrefix = v;
            if (this.inited) updateUI();
        }
    },
    
    setThirdPrefix: function(v) {
        if (this.thirdPrefix !== v) {
            this.thirdPrefix = v;
            if (this.inited) updateUI();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Button */
    drawDisabledState: function() {
        this.setOpacity(myt.Button.DEFAULT_DISABLED_OPACITY);
        this.__updateImageUrls('up');
    },
    
    /** @overrides myt.Button */
    drawHoverState: function() {
        this.setOpacity(1);
        this.__updateImageUrls('mo');
    },
    
    /** @overrides myt.Button */
    drawActiveState: function() {
        this.setOpacity(1);
        this.__updateImageUrls('dn');
    },
    
    /** @overrides myt.Button */
    drawReadyState: function() {
        this.setOpacity(1);
        this.__updateImageUrls('up');
    },
    
    /** @private */
    __updateImageUrls: function(mouseState) {
        var suffix = '_' + mouseState + '.' + this.extension,
            imageRoot = this.imageRoot;
        
        this.first.setImageUrl(imageRoot + this.firstPrefix + suffix);
        this.second.setImageUrl(imageRoot + this.secondPrefix + suffix);
        this.third.setImageUrl(imageRoot + this.thirdPrefix + suffix);
    }
});


/** Must be mixed onto a View.
    
    A set of three images where the middle images resizes to fill the
    available space. This component lays out the views horizontally.
    
    Events:
        repeat:boolean
    
    Attributes:
        firstImageUrl:string
        secondImageUrl:string
        thirdImageUrl:string
        repeat:boolean Determines if the second image is stretched(false) or 
            repeated(true). Defaults to true.
*/
myt.HorizontalThreePanel = new JS.Module('HorizontalThreePanel', {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.repeat = true;
        
        this.callSuper(parent, attrs);
    },
    
    doBeforeAdoption: function() {
        this.callSuper();
        
        var m = myt;
        new m.Image(this, {
            name:'first', imageUrl:this.firstImageUrl, ignoreLayout:true
        });
        
        var second = new m.Image(this, {
            name:'second', layoutHint:1, imageUrl:this.secondImageUrl, 
            ignoreLayout:true, useNaturalSize:false, calculateNaturalSize:true
        });
        this.attachTo(second, '__updateSize', 'naturalHeight');
        this.attachTo(second, '__updateImageSize', 'width');
        
        new m.Image(this, {
            name:'third', imageUrl:this.thirdImageUrl, ignoreLayout:true
        });
        
        var ignoreMixin = [m.ThreePanel.IGNORE_FUNCTION_MIXIN];
        new m.ResizeLayout(this, {name:'resizeLayout'}, ignoreMixin);
        new m.SizeToChildren(this, {axis:'y'}, ignoreMixin);
        
        this.__updateRepeat();
        this.__updateSize();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setFirstImageUrl: function(v) {
        if (this.firstImageUrl !== v) {
            this.firstImageUrl = v;
            if (this.inited) this.first.setImageUrl(v);
        }
    },
    
    setSecondImageUrl: function(v) {
        if (this.secondImageUrl !== v) {
            this.secondImageUrl = v;
            if (this.inited) this.second.setImageUrl(v);
        }
    },
    
    setThirdImageUrl: function(v) {
        if (this.thirdImageUrl !== v) {
            this.thirdImageUrl = v;
            if (this.inited) this.third.setImageUrl(v);
        }
    },
    
    setRepeat: function(v) {
        if (this.repeat !== v) {
            this.repeat = v;
            if (this.inited) {
                this.fireNewEvent('repeat', v);
                this.__updateRepeat();
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __updateSize: function(event) {
        var v = this.second;
        v.setHeight(v.naturalHeight);
        this.__updateImageSize();
    },
    
    /** @private */
    __updateImageSize: function(event) {
        var v = this.second;
        v.setImageSize(this.repeat ? undefined : v.width + 'px ' + v.height + 'px');
    },
    
    /** @private */
    __updateRepeat: function() {
        this.second.setImageRepeat(this.repeat ? 'repeat-x' : 'no-repeat');
    }
});


/** A mixin that includes HorizontalThreePanel and BaseMouseablePanel. */
myt.MouseableH3Panel = new JS.Module('MouseableH3Panel', {
    include: [myt.BaseMouseablePanel, myt.HorizontalThreePanel],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.firstPrefix = 'lft';
        this.secondPrefix = 'ctr';
        this.thirdPrefix = 'rt';
        
        this.callSuper(parent, attrs);
    }
});


/** A button that uses an myt.MouseableH3Panel. */
myt.PanelButton = new JS.Class('PanelButton', myt.View, {
    include: [myt.MouseableH3Panel],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.imageRoot = myt.IMAGE_ROOT + 'component/panelbutton/rsrc/';
        
        this.callSuper(parent, attrs);
    }
});


/** An myt.PanelButton with contents that consist of an icon and text. */
myt.IconTextPanelButton = new JS.Class('IconTextPanelButton', myt.PanelButton, {
    include: [myt.IconTextButtonContent, myt.TooltipMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    doAfterAdoption: function() {
        this.syncTo(this.first, 'setInset', 'width');
        this.syncTo(this.third, 'setOutset', 'width');
        
        this.callSuper();
    }
});


/** A method that gets called a provided number of millis later. Multiple
    method calls will get collapsed into a single call if they occur before
    the method is executed. */
myt.DelayedMethodCall = new JS.Class('DelayedMethodCall', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Mixes DelayedMethodCall functionality onto the provided scope.
            @param scope:Observable|Class|Module the scope to mix onto.
            @param millis:number the time to delay the call by.
            @param methodName:string the name of the method to call after the
                delay.
            @returns boolean True if creation succeeded, false otherwise. */
        createDelayedMethodCall: function(scope, millis, methodName) {
            var genNameFunc = myt.AccessorSupport.generateName,
                delayedMethodName = genNameFunc('delayed', methodName),
                timerName = genNameFunc('timer', methodName),
                callbackName = genNameFunc('callback', methodName),
                isModuleOrClass = typeof scope === 'function' || scope instanceof JS.Module;
            
            // Prevent clobbering
            if ((isModuleOrClass ? scope.instanceMethod(delayedMethodName) : scope[delayedMethodName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of delayed method function.", delayedMethodName, scope);
                return false;
            }
            if ((isModuleOrClass ? scope.instanceMethod(timerName) : scope[timerName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of delayed method timer reference.", timerName, scope);
                return false;
            }
            if ((isModuleOrClass ? scope.instanceMethod(callbackName) : scope[callbackName]) !== undefined) {
                console.warn("Can't clobber existing property during setup of delayed method callback reference.", callbackName, scope);
                return false;
            }
            
            // Define the "module".
            var mod = {};
            
            /** Calls the method after a delay. Resets the delay timer if
                this method is called again before the timer has finished.
                @returns void */
            mod[delayedMethodName] = function() {
                var callback = this[callbackName];
                if (!callback) callback = this[callbackName] = new myt.Callback(methodName, this);
                
                var timer = this[timerName];
                if (timer) {
                    timer.reset(callback, millis);
                } else {
                    this[timerName] = new myt.Timer(callback, millis);
                }
            };
            
            // Mixin in the "module"
            if (isModuleOrClass) {
                scope.include(mod);
            } else {
                scope.extend(mod);
            }
            
            return true;
        }
    }
});

/** Create default functions for the DelayedMethodCall class. By default
    the method is 'execute' and the delay is 0 millis. */
myt.DelayedMethodCall.createDelayedMethodCall(
    myt.DelayedMethodCall, 0, 'execute'
);


/** A panel that floats above everything else.
    
    Events:
        None
    
    Attributes:
        owner:myt.FloatingPanelAnchor The anchor that currently "owns" 
            this panel.
        panelId:string The unique ID for this panel instance.
        hideOnMouseDown:boolean If true this panel will be hidden when a
            mousedown occurs outside the panel. True by default.
        ignoreOwnerForHideOnMouseDown:boolean If true the owner view for this
            panel will also be ignored for mousedown events. True by default.
        ignoreOwnerForHideOnBlur:boolean If true the owner view for this
            panel will also be ignored for blur events. True by default.
        hideOnBlur:boolean If true this panel will be hidden when a
            focus traverses outside the panel. True by default.
*/
myt.FloatingPanel = new JS.Class('FloatingPanel', myt.View, {
    include: [myt.RootView],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        // Create a dom element for the panel and insert it at the end of
        // the body.
        var elem = document.createElement('div');
        elem.style.position = 'absolute';
        myt.getElement().appendChild(elem);
        
        this.ignoreOwnerForHideOnMouseDown = this.ignoreOwnerForHideOnBlur = this.hideOnBlur = this.hideOnMouseDown = true;
        
        attrs.visible = attrs.focusEmbellishment = false;
        
        // Ensure the focus starts and ends with the panel
        attrs.focusable = attrs.focusCage = true;
        
        this.callSuper(elem, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setOwner: function(v) {this.owner = v;},
    setPanelId: function(v) {this.panelId = v;},
    setIgnoreOwnerForHideOnMouseDown: function(v) {this.ignoreOwnerForHideOnMouseDown = v;},
    setHideOnBlur: function(v) {this.hideOnBlur = v;},
    setHideOnMouseDown: function(v) {this.hideOnMouseDown = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __doMouseDown: function(event) {
        var v = event.value, px = v.pageX, py = v.pageY;
        if (!this.containsPoint(px, py) && 
            (this.ignoreOwnerForHideOnMouseDown ? !this.owner.containsPoint(px, py) : true)
        ) {
            this.doMouseDownOutside();
        }
        return true;
    },
    
    /** Called when a mousedown occurs outside the floating panel. The default
        behavior is to hide the panel. This gives subclasses a chance to 
        provide different behavior.
        @returns void */
    doMouseDownOutside: function() {
        if (this.hideOnMouseDown) this.hide();
    },
    
    /** @overrides myt.FocusObservable
        Intercepts focus on this panel and refocuses to the "best" view.
        When focus enters the panel we give focus to the first focusable
        descendant of the panel. When leaving we ask the panel anchor
        where to give focus. */
    focus: function(noScroll) {
        var gf = myt.global.focus;
        if (this.owner && this.isAncestorOf(gf.focusedView)) {
            this.owner[gf.lastTraversalWasForward ? 'getNextFocusAfterPanel' : 'getPrevFocusAfterPanel'](this.panelId).focus(noScroll);
        } else {
            var ffv = this.getFirstFocusableDescendant();
            if (ffv === this) {
                // Process normally since focus is actually being set
                // on the panel.
                this.callSuper(noScroll);
            } else {
                ffv.focus(noScroll);
            }
        }
    },
    
    /** Gets the view to give focus to when this panel gets focus. Should be
        a descendant of the floating panel or the panel itself. Returns this 
        floating panel by default.
        @returns myt.View: The view to give focus to. */
    getFirstFocusableDescendant: function() {
        return this;
    },
    
    /** @private */
    __doFocusChange: function(event) {
        var v = event.value;
        if (v && !this.isAncestorOf(v)) this.doLostFocus();
    },
    
    /** Called when focus moves out of the floating panel. Hides the
        floating panel by default.
        @returns void */
    doLostFocus: function() {
        if (this.hideOnBlur) {
            if (this.ignoreOwnerForHideOnBlur && myt.global.focus.focusedView === this.owner) return;
            
            this.hide(true);
        }
    },
    
    /** Determines if this floating panel is being "shown" or not. Typically
        this means the floating panel is visible.
        @returns boolean: True if this panel is shown, otherwise false. */
    isShown: function() {
        return this.visible;
    },
    
    /** Shows the floating panel for the provided myt.FloatingPanelAnchor.
        @param panelAnchor:myt.FloatingPanelAnchor The floating panel anchor 
            to show the panel for.
        @returns void */
    show: function(panelAnchor) {
        if (!this.isShown()) {
            this.bringToFront();
            this.updateLocation(panelAnchor);
            this.setVisible(true);
            
            this.owner.notifyPanelShown(this);
            
            var g = myt.global;
            this.attachToDom(g.mouse, '__doMouseDown', 'mousedown', true);
            this.attachTo(g.focus, '__doFocusChange', 'focused');
        }
    },
    
    /** Hides the floating panel for the provided myt.FloatingPanelAnchor.
        @param ignoreRestoreFocus:boolean (Optional) If true the restoreFocus
            method will not be called. Defaults to undefined which is
            equivalent to false.
        @returns void */
    hide: function(ignoreRestoreFocus) {
        if (this.isShown()) {
            var g = myt.global;
            this.detachFromDom(g.mouse, '__doMouseDown', 'mousedown', true);
            this.detachFrom(g.focus, '__doFocusChange', 'focused');
            
            this.setVisible(false);
            this.owner.notifyPanelHidden(this);
            if (!ignoreRestoreFocus) this.restoreFocus();
            this.setOwner();
        }
    },
    
    /** Sends the focus back to the owner. Can be overridden to
        send the focus elsewhere.
        @returns void */
    restoreFocus: function() {
        if (this.owner) this.owner.focus();
    },
    
    /** Updates the x and y position of the floating panel for the provided 
        floating panel anchor.
        @param panelAnchor:myt.FloatingPanelAnchor The anchor to update the
            location for.
        @returns void */
    updateLocation: function(panelAnchor) {
        this.setOwner(panelAnchor);
        
        var panelId = this.panelId,
            align = panelAnchor.getFloatingAlignForPanelId(panelId),
            valign = panelAnchor.getFloatingValignForPanelId(panelId),
            anchorLocation = panelAnchor.getPagePosition(),
            x = 0, y = 0,
            type = typeof align;
        
        if (type === 'string') {
            x = anchorLocation.x + panelAnchor.getFloatingAlignOffsetForPanelId(panelId);
            switch(align) {
                case 'outsideRight': x += panelAnchor.width; break;
                case 'insideRight': x += panelAnchor.width - this.width; break;
                case 'outsideLeft': x -= this.width; break;
                case 'insideLeft': break;
                default: console.warn("Unexpected align value", type, align);
            }
        } else if (type === 'number') {
            // Absolute position
            x = align;
        } else {
            console.warn("Unexpected align type", type, align);
        }
        this.setX(x);
        
        // Vertical positioning
        type = typeof valign;
        
        if (type === 'string') {
            y = anchorLocation.y + panelAnchor.getFloatingValignOffsetForPanelId(panelId);
            switch(valign) {
                case 'outsideBottom': y += panelAnchor.height; break;
                case 'insideBottom': y += panelAnchor.height - this.height; break;
                case 'outsideTop': y -= this.height; break;
                case 'insideTop': break;
                default: console.warn("Unexpected valign value", type, valign);
            }
        } else if (type === 'number') {
            // Absolute position
            y = valign;
        } else {
            console.warn("Unexpected valign type", type, valign);
        }
        this.setY(y);
    }
});


/** Enables a view to act as the anchor point for a FloatingPanel.
    
    Events:
        floatingAlign:string
        floatingValign:string
        floatingAlignOffset:number
        floatingValignOffset:number
    
    Attributes:
        floatingPanelId:string If defined this is the panel ID that will be
            used by default in the various methods that require a panel ID.
        floatingAlign:string:number The horizontal alignment for panels shown 
            by this anchor. If the value is a string it is an alignment 
            identifier relative to this anchor. If the value is a number it is 
            an absolute position in pixels. Allowed values: 'outsideLeft', 
            'insideLeft', 'insideRight', 'outsideRight' or a number.
        floatingValign:string:number The vertical alignment for panels shown 
            by this anchor. If the value is a string it is an alignment 
            identifier relative to this anchor. If the value is a number it is 
            an absolute position in pixels. Allowed values: 'outsideTop', 
            'insideTop', 'insideBottom', 'outsideBottom' or a number.
        floatingAlignOffset:number The number of pixels to offset the panel
            position by horizontally.
        floatingValignOffset:number The number of pixels to offset the panel
            position by vertically.
        lastFloatingPanelShown:myt.FloatingPanel A reference to the last
            floating panel shown by this anchor.
*/
myt.FloatingPanelAnchor = new JS.Module('FloatingPanelAnchor', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of FloatingPanel classes by panel ID. */
        classesByPanelId: {},
        
        /** A map of FloatingPanel instances by panel ID. */
        panelsByPanelId: {}
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.floatingAlign = 'insideLeft';
        this.floatingValign = 'outsideBottom';
        this.floatingAlignOffset = this.floatingValignOffset = 0;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setLastFloatingPanelShown: function(v) {this.lastFloatingPanelShown = v;},
    setLastFloatingPanelId: function(v) {this.floatingPanelId = v;},
    
    setFloatingAlign: function(v) {this.set('floatingAlign', v, true);},
    setFloatingValign: function(v) {this.set('floatingValign', v, true);},
    setFloatingAlignOffset: function(v) {this.set('floatingAlignOffset', v, true);},
    setFloatingValignOffset: function(v) {this.set('floatingValignOffset', v, true);},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    createFloatingPanel: function(panelId, panelClass, panelInitAttrs) {
        panelId = panelId || this.floatingPanelId;
        
        var FPA = myt.FloatingPanelAnchor;
        panelClass = panelClass || FPA.classesByPanelId[panelId];
        if (!panelClass) {
            console.log("No panel class found for panelId:", panelId);
            return null;
        }
        
        panelInitAttrs = panelInitAttrs || {};
        panelInitAttrs.panelId = panelId;
        return FPA.panelsByPanelId[panelId] = new panelClass(null, panelInitAttrs);
    },
    
    getFloatingPanel: function(panelId) {
        return myt.FloatingPanelAnchor.panelsByPanelId[panelId || this.floatingPanelId];
    },
    
    toggleFloatingPanel: function(panelId) {
        var fp = this.getFloatingPanel(panelId = panelId || this.floatingPanelId);
        if (fp && fp.isShown()) {
            this.hideFloatingPanel(panelId);
        } else {
            this.showFloatingPanel(panelId);
        }
    },
    
    showFloatingPanel: function(panelId) {
        var fp = this.getFloatingPanel(panelId || this.floatingPanelId);
        if (fp) {
            fp.show(this);
            this.setLastFloatingPanelShown(fp);
        }
    },
    
    hideFloatingPanel: function(panelId) {
        var fp = this.getFloatingPanel(panelId || this.floatingPanelId);
        if (fp) {
            fp.hide();
            this.setLastFloatingPanelShown();
        }
    },
    
    /** Called when a floating panel has been shown for this anchor.
        @param panel:myt.FloatingPanel The panel that is now shown.
        @returns void */
    notifyPanelShown: function(panel) {
        // Subclasses to implement as needed.
    },
    
    /** Called when a floating panel has been hidden for this anchor.
        @param panel:myt.FloatingPanel The panel that is now hidden.
        @returns void */
    notifyPanelHidden: function(panel) {
        // Subclasses to implement as needed.
    },
    
    /** Called by the FloatingPanel to determine where to position itself
        horizontally. By default this returns the floatingAlign attribute. 
        Subclasses and instances should override this if panel specific 
        behavior is needed.
        @param panelId:string the ID of the panel being positioned.
        @returns:string|number an alignment identifer or absolute position. */
    getFloatingAlignForPanelId: function(panelId) {
        return this.floatingAlign;
    },
    
    /** Called by the FloatingPanel to determine where to position itself
        vertically. By default this returns the floatingAlign attribute. 
        Subclasses and instances should override this if panel specific 
        behavior is needed.
        @param panelId:string the ID of the panel being positioned.
        @returns:string|number an alignment identifer or absolute position. */
    getFloatingValignForPanelId: function(panelId) {
        return this.floatingValign;
    },
    
    /** Called by the FloatingPanel to determine where to position itself
        horizontally. By default this returns the floatingAlignOffset attribute. 
        Subclasses and instances should override this if panel specific 
        behavior is needed.
        @param panelId:string the ID of the panel being positioned.
        @returns:number the offset to use. */
    getFloatingAlignOffsetForPanelId: function(panelId) {
        return this.floatingAlignOffset;
    },
    
    /** Called by the FloatingPanel to determine where to position itself
        vertically. By default this returns the floatingValignOffset attribute. 
        Subclasses and instances should override this if panel specific 
        behavior is needed.
        @param panelId:string the ID of the panel being positioned.
        @returns:number the offset to use. */
    getFloatingValignOffsetForPanelId: function(panelId) {
        return this.floatingValignOffset;
    },
    
    /** @overrides myt.FocusObservable
        @returns the last floating panel shown if it exists and can be shown.
        Otherwise it returns the default. */
    getNextFocus: function() {
        var last = this.lastFloatingPanelShown;
        if (last && last.isShown()) return last;
        return this.callSuper ? this.callSuper() : null;
    },
    
    /** Called by the floating panel owned by this anchor to determine where
        to go to next after leaving the panel in the forward direction. */
    getNextFocusAfterPanel: function(panelId) {
        return this;
    },
    
    /** Called by the floating panel owned by this anchor to determine where
        to go to next after leaving the panel in the backward direction. */
    getPrevFocusAfterPanel: function(panelId) {
        return this;
    }
});


/** Defines the interface list view items must support.
    
    Events:
        None
    
    Attributes:
        listView:myt.ListView The list view this item is managed by.
*/
myt.ListViewItemMixin = new JS.Module('ListViewItemMixin', {
    // Accessors ///////////////////////////////////////////////////////////////
    setListView: function(v) {this.listView = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Subclasses and/or implementations must implement this method. Should
        return the minimum width the list item needs to display itself.
        @returns number */
    getMinimumWidth: function() {
        return 0;
    }
});


/** An item in an myt.ListView
    
    Events:
        None
    
    Attributes:
        None
*/
myt.ListViewItem = new JS.Class('ListViewItem', myt.SimpleIconTextButton, {
    include: [myt.ListViewItemMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (attrs.height === undefined) attrs.height = 24;
        
        if (attrs.activeColor === undefined) attrs.activeColor = '#bbbbbb';
        if (attrs.hoverColor === undefined) attrs.hoverColor = '#ffffff';
        if (attrs.readyColor === undefined) attrs.readyColor = '#eeeeee';
        
        if (attrs.contentAlign === undefined) attrs.contentAlign = 'left';
        if (attrs.inset === undefined) attrs.inset = 8;
        if (attrs.outset === undefined) attrs.outset = 8;
        
        if (attrs.activationKeys === undefined) attrs.activationKeys = [13,27,32,37,38,39,40];
        
        this.callSuper(parent, attrs);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ListViewItemMixin */
    getMinimumWidth: function() {
        var iconView = this.iconView,
            textView = this.textView,
            textViewVisible = textView.visible && this.text,
            iconWidth = iconView.visible ? iconView.width : 0,
            iconExtent = iconWidth + (textViewVisible && iconWidth > 0 ? this.iconSpacing : 0),
            textWidth = textViewVisible ? Math.ceil(textView.width) : 0;
        return this.inset + iconExtent + textWidth + this.outset;
    },
    
    /** @overrides myt.Button */
    doActivated: function() {
        this.listView.doItemActivated(this);
    },
    
    /** @overrides myt.Button */
    showFocusEmbellishment: function() {this.hideDefaultFocusEmbellishment();},
    
    /** @overrides myt.Button */
    hideFocusEmbellishment: function() {this.hideDefaultFocusEmbellishment();},
    
    /** @overrides myt.KeyActivation. */
    doActivationKeyDown: function(key, isRepeat) {
        switch (key) {
            case 27: // Escape
                this.listView.owner.hideFloatingPanel();
                return;
            case 37: // Left
            case 38: // Up
                myt.global.focus.prev();
                break;
            case 39: // Right
            case 40: // Down
                myt.global.focus.next();
                break;
        }
        
        this.callSuper(key, isRepeat);
    }
});


/** A separator item in an myt.ListView
    
    Events:
        None
    
    Attributes:
        None
*/
myt.ListViewSeparator = new JS.Class('ListViewSeparator', myt.View, {
    include: [myt.ListViewItemMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (attrs.height === undefined) attrs.height = 1;
        if (attrs.bgColor === undefined) attrs.bgColor = '#666666';
        
        this.callSuper(parent, attrs);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ListViewItemMixin */
    getMinimumWidth: function() {
        return 0;
    }
});


/** A floating panel that contains a list of items.
    
    Events:
        maxHeight:number
    
    Attributes:
        minWidth:number The minimum width for the list. The list will size
            itself to fit the maximum width of the items in the list or this
            value whichever is larger. Defaults to 0.
        maxHeight:number The maximum height of the list view in pixels. If set 
            to -1 no max height will be used.
        defaultItemClass:JS.Class The class to use for list items if one is
            not provided in the config. Defaults to myt.ListViewItem.
        itemConfig:array An array of configuration information for the items
            in the list.
        items:array The array of items in the list.
*/
myt.ListView = new JS.Class('ListView', myt.FloatingPanel, {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.items = [];
        this.maxHeight = -1;
        this.minWidth = 0;
        
        if (attrs.defaultItemClass === undefined) attrs.defaultItemClass = myt.ListViewItem;
        if (attrs.overflow === undefined) attrs.overflow = 'auto';
        if (attrs.bgColor === undefined) attrs.bgColor = '#cccccc';
        if (attrs.boxShadow === undefined) attrs.boxShadow = myt.Button.DEFAULT_FOCUS_SHADOW_PROPERTY_VALUE;
        
        this.callSuper(parent, attrs);
        
        this.__updateItems();
        new myt.SpacedLayout(this.getContentView(), {
            axis:'y', spacing:1, collapseParent:true
        });
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setMinWidth: function(v) {this.minWidth = v;},
    setDefaultItemClass: function(v) {this.defaultItemClass = v;},
    setItemConfig: function(v) {
        this.itemConfig = v;
        if (this.inited) this.__updateItems();
    },
    
    /** Get the view that will contain list content.
        @returns myt.View */
    getContentView: function(v) {
        return this;
    },
    
    setMaxHeight: function(v) {
        if (this.maxHeight !== v) {
            this.maxHeight = v;
            if (this.inited) {
                this.fireNewEvent('maxHeight', v);
                this.setHeight(this.height);
            }
        }
    },
    
    /** @overrides myt.View */
    setHeight: function(v, supressEvent) {
        // Limit height if necessary
        if (this.maxHeight >= 0) v = Math.min(this.maxHeight, v);
        
        this.callSuper(v, supressEvent);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** ListViewItems should call this method when they are activated. The
        default implementation invokes doItemActivated on the ListViewAnchor.
        @returns void */
    doItemActivated: function(itemView) {
        var owner = this.owner;
        if (owner) owner.doItemActivated(itemView);
    },
    
    /** @overrides myt.FloatingPanel */
    getFirstFocusableDescendant: function() {
        return this.getFirstFocusableItem() || this.callSuper();
    },
    
    getFirstFocusableItem: function() {
        var items = this.items, item, len = items.length, i = 0;
        for (; len > i; ++i) {
            item = items[i];
            if (item.isFocusable()) return item;
        }
        return null;
    },
    
    getLastFocusableItem: function() {
        var items = this.items, item, i = items.length;
        while (i) {
            item = items[--i];
            if (item.isFocusable()) return item;
        }
        return null;
    },
    
    /** @private */
    __updateItems: function() {
        var cfg = this.itemConfig || [],
            cfgLen = cfg.length, cfgItem, cfgClass, cfgAttrs,
            items = this.items, itemsLen = items.length, item,
            defaultItemClass = this.defaultItemClass,
            contentView = this.getContentView(), 
            layouts = contentView.getLayouts(), layout,
            layoutLen = layouts.length, i,
            minItemWidth, minWidth = this.minWidth;
        
        // Lock layouts during reconfiguration
        i = layoutLen;
        while (i) layouts[--i].incrementLockedCounter();
        
        // Reconfigure list
        for (i = 0; cfgLen > i; ++i) {
            cfgItem = cfg[i];
            cfgClass = cfgItem.klass || defaultItemClass;
            cfgAttrs = cfgItem.attrs || {};
            
            item = items[i];
            
            // Destroy existing item if it's the wrong class
            if (item && !item.isA(cfgClass)) {
                item.destroy();
                item = null;
            }
            
            // Create a new item if no item exists
            if (!item) item = items[i] = new cfgClass(contentView, {listView:this});
            
            // Apply config to item and measure width
            if (item) {
                item.callSetters(cfgAttrs);
                minItemWidth = item.getMinimumWidth();
                if (minItemWidth > minWidth) minWidth = minItemWidth;
            }
        }
        
        // Delete any remaining items
        for (; itemsLen > i; ++i) items[i].destroy();
        items.length = cfgLen;
        
        // Resize items and contentView
        for (i = 0; cfgLen > i; ++i) items[i].setWidth(minWidth);
        contentView.setWidth(minWidth);
        
        // Unlock layouts and update
        i = layoutLen;
        while (i) {
            layout = layouts[--i];
            layout.decrementLockedCounter();
            layout.update();
        }
    }
});


/** The anchor for an myt.ListView.
    
    Events:
        None
    
    Attributes:
        listViewClass:JS.Class The class of list view to create. Defaults
            to myt.ListView.
        listViewAttrs:object The initialization attributes for the 
            listViewClass.
        itemConfig:array An array of configuration parameters for the items
            in the list.
*/
myt.ListViewAnchor = new JS.Module('ListViewAnchor', {
    include: [myt.FloatingPanelAnchor],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (attrs.listViewClass === undefined) attrs.listViewClass = myt.ListView;
        if (attrs.listViewAttrs === undefined) attrs.listViewAttrs = {};
        if (attrs.itemConfig === undefined) attrs.itemConfig = [];
        
        // Assume this will be mixed onto something that implements 
        // myt.KeyActivation since it probably will.
        if (attrs.activationKeys === undefined) {
            attrs.activationKeys = [13,27,32,37,38,39,40];
        }
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setListViewClass: function(v) {this.listViewClass = v;},
    setListViewAttrs: function(v) {this.listViewAttrs = v;},
    setItemConfig: function(v) {this.itemConfig = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called by the list view when an item is activated. By default it
        hides the list view.
        @returns void */
    doItemActivated: function(itemView) {
        this.hideFloatingPanel();
    },
    
    /** @overrides myt.FloatingPanelAnchor */
    getFloatingPanel: function(panelId) {
        return this.callSuper(panelId) || this.createFloatingPanel(panelId, this.listViewClass, this.listViewAttrs);
    },
    
    /** @overrides myt.FloatingPanelAnchor */
    showFloatingPanel: function(panelId) {
        var fp = this.getFloatingPanel(panelId);
        if (fp) {
            fp.setItemConfig(this.itemConfig);
            this.callSuper(panelId);
        }
    },
    
    /** @overrides myt.KeyActivation. */
    doActivationKeyDown: function(key, isRepeat) {
        // Close for escape key.
        if (key === 27) {
            this.hideFloatingPanel();
            return;
        }
        
        // Select first/last if the list view is already open
        switch (key) {
            case 37: // Left
            case 38: // Up
                this.selectLastItem();
                break;
            case 39: // Right
            case 40: // Down
                this.selectFirstItem();
                break;
        }
        
        this.callSuper(key, isRepeat);
    },
    
    /** @overrides myt.KeyActivation. */
    doActivationKeyUp: function(key) {
        // Abort for escape key.
        if (key === 27) return;
        
        this.callSuper(key);
        
        // Select first/last after list view is open.
        switch (key) {
            case 37: // Left
            case 38: // Up
                this.selectLastItem();
                break;
            case 39: // Right
            case 40: // Down
                this.selectFirstItem();
                break;
        }
    },
    
    selectLastItem: function() {
        var fp = this.getFloatingPanel();
        if (fp && fp.isShown()) {
            var item = fp.getLastFocusableItem();
            if (item) item.focus();
        }
    },
    
    selectFirstItem: function() {
        var fp = this.getFloatingPanel();
        if (fp && fp.isShown()) {
            var item = fp.getFirstFocusableItem();
            if (item) item.focus();
        }
    }
});


/** Provides styling functionality for a Checkbox and other similar components.
    
    Requires:
        Should be used on: myt.DrawButton or subclass thereof.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.CheckboxStyleMixin = new JS.Module('CheckboxStyleMixin', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** The x location of the "icon". */
        DEFAULT_PAD_X:3,
        /** The y location of the "icon". */
        DEFAULT_PAD_Y:4,
        /** The width of the "icon". */
        DEFAULT_WIDTH:14,
        /** The height of the "icon" */
        DEFAULT_HEIGHT:14,
        DEFAULT_FILL_COLOR_CHECKED: '#666666',
        DEFAULT_FILL_COLOR_HOVER: '#eeeeee',
        DEFAULT_FILL_COLOR_ACTIVE: '#cccccc',
        DEFAULT_FILL_COLOR_READY: '#ffffff',
        DEFAULT_EDGE_COLOR: '#333333',
        DEFAULT_EDGE_SIZE: 0.5
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (attrs.width === undefined) attrs.width = this.getIconExtentX();
        if (attrs.height === undefined) attrs.height = this.getIconExtentY();
        if (attrs.focusEmbellishment === undefined) attrs.focusEmbellishment = false;
        
        var CSM = myt.CheckboxStyleMixin;
        if (attrs.fillColorChecked === undefined) attrs.fillColorChecked = CSM.DEFAULT_FILL_COLOR_CHECKED;
        if (attrs.fillColorHover === undefined) attrs.fillColorHover = CSM.DEFAULT_FILL_COLOR_HOVER;
        if (attrs.fillColorActive === undefined) attrs.fillColorActive = CSM.DEFAULT_FILL_COLOR_ACTIVE;
        if (attrs.fillColorReady === undefined) attrs.fillColorReady = CSM.DEFAULT_FILL_COLOR_READY;
        if (attrs.edgeColor === undefined) attrs.edgeColor = CSM.DEFAULT_EDGE_COLOR;
        if (attrs.edgeSize === undefined) attrs.edgeSize = CSM.DEFAULT_EDGE_SIZE;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setFillColorChecked: function(v) {this.fillColorChecked = v;},
    setFillColorHover: function(v) {this.fillColorHover = v;},
    setFillColorActive: function(v) {this.fillColorActive = v;},
    setFillColorReady: function(v) {this.fillColorReady = v;},
    setEdgeColor: function(v) {this.edgeColor = v;},
    setEdgeSize: function(v) {this.edgeSize = v;},
    
    /** @overrides myt.DrawButton */
    setFocused: function(v) {
        this.callSuper(v);
        
        if (this.inited) this.redraw();
    },
    
    /** @overrides myt.DrawButton */
    getDrawBounds: function() {
        var bounds = this.drawBounds, CSM = myt.CheckboxStyleMixin;
        bounds.x = CSM.DEFAULT_PAD_X;
        bounds.y = CSM.DEFAULT_PAD_Y;
        bounds.w = CSM.DEFAULT_WIDTH;
        bounds.h = CSM.DEFAULT_HEIGHT;
        return bounds;
    },
    
    /** @overrides myt.DrawButton */
    getDrawConfig: function(state) {
        var config = this.callSuper(state);
        config.checkedColor = this.fillColorChecked;
        config.edgeColor = this.edgeColor;
        config.edgeSize = this.edgeSize;
        
        switch (state) {
            case 'hover':
                config.fillColor = this.fillColorHover;
                break;
            case 'active':
                config.fillColor = this.fillColorActive;
                break;
            case 'disabled':
            case 'ready':
                config.fillColor = this.fillColorReady;
                break;
            default:
        }
        return config;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Gets the horizontal size of the "icon" plus the padding
        needed around it to display a shadow. */
    getIconExtentX: function() {
        var CSM = myt.CheckboxStyleMixin;
        return CSM.DEFAULT_WIDTH + 2 * CSM.DEFAULT_PAD_X;
    },
    
    /** Gets the vertical size of the "icon" plus the padding
        needed around it to display a shadow. */
    getIconExtentY: function() {
        var CSM = myt.CheckboxStyleMixin;
        return CSM.DEFAULT_HEIGHT + 2 * CSM.DEFAULT_PAD_Y;
    }
});


/** Provides a setValue and getValue method.
    
    Events:
        value:*
    
    Attributes:
        value:* The stored value.
        valueFilter:function If it exists, values will be run through this
            filter function before being set on the component. By default
            no valueFilter exists. A value filter function must take a 
            single value as an argument and return a value.
*/
myt.ValueComponent = new JS.Module('ValueComponent', {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        // Attempt to setValue again since the valueFilter may not have been
        // set when setValue was originally called.
        if (this.valueFilter) this.setValue(this.value);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setValueFilter: function(v) {
        this.valueFilter = v;
        
        if (this.inited && v) this.setValue(this.value);
    },
    
    setValue: function(v) {
        if (this.valueFilter) v = this.valueFilter(v);
        
        if (this.value !== v) {
            this.value = v;
            if (this.inited) this.fireNewEvent('value', this.getValue());
        }
    },
    
    getValue: function() {
        return this.value;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Combines a value filter with any existing value filter.
        @param filter:function the value filter to add.
        @param where:string (optional) Determines where to add the filter.
            Supported values are 'first' and 'last'. Defaults to 'first'.
        @returns void */
    chainValueFilter: function(filter, where) {
        var existingFilter = this.valueFilter, chainedFilter = filter;
        if (existingFilter) {
            if (where === 'last') {
                chainedFilter = function(v) {return filter(existingFilter(v));};
            } else if (where === 'first' || where === undefined) {
                chainedFilter = function(v) {return existingFilter(filter(v));};
            }
        }
        this.setValueFilter(chainedFilter);
    }
});


/** Draws a checkbox into an myt.Canvas. */
myt.CheckboxDrawingMethod = new JS.Class('CheckboxDrawingMethod', myt.DrawingMethod, {
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        this.__getTemplate = myt.memoize(this.__getTemplate);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawingMethod */
    draw: function(canvas, config) {
        canvas.clear();
        canvas.drawImage(this.__getTemplate(config), 0, 0);
    },
    
    /** @private */
    __getTemplate: function(config) {
        var m = myt, 
            b = config.bounds, x = b.x, y = b.y, w = b.w, h = b.h,
            shadowBlur         = config.shadowBlur == null ? 2 : config.shadowBlur,
            shadowOffsetX      = config.shadowOffsetX == null ? 0 : config.shadowOffsetX,
            shadowOffsetY      = config.shadowOffsetY == null ? 1 : config.shadowOffsetY,
            radius             = config.radius == null ? 4 : config.radius,
            shadowColor        = config.shadowColor == null ? 'rgba(0, 0, 0, 0.3)' : config.shadowColor,
            focusedShadowColor = config.focusedShadowColor == null ? 'rgba(0, 0, 0, 0.5)' : config.focusedShadowColor,
            fillColor          = config.fillColor,
            focused            = config.focused,
            inset              = config.edgeSize,
            x2 = x + inset, 
            y2 = y + inset,
            w2 = w - 2*inset,
            h2 = h - 2*inset,
            darkColor = (m.Color.makeColorFromHexString(fillColor)).multiply(5/6),
            DU = m.DrawingUtil;
        
        var canvas = new m.Canvas(m.global.roots.getRoots()[0], {
            width:x + w + shadowOffsetX + shadowBlur, 
            height:y + h + shadowOffsetY + shadowBlur, 
            visible:false, 
            ignoreLayout:true, 
            ignorePlacement:true
        });
        var grd = canvas.createLinearGradient(x2, y2, x2, y2 + h2);
        
        // Border and shadow
        canvas.save();
        canvas.setShadowOffsetX(shadowOffsetX);
        canvas.setShadowOffsetY(shadowOffsetY);
        canvas.setShadowBlur(shadowBlur * (focused ? 2 : 1));
        canvas.setShadowColor(focused ? focusedShadowColor : shadowColor);
        
        DU.drawRoundedRect(canvas, radius, 0, x, y, w, h);
        canvas.setFillStyle(config.edgeColor);
        canvas.fill();
        canvas.restore();
        
        // Fill
        DU.drawRoundedRect(canvas, radius - inset, 0, x2, y2, w2, h2);
        grd.addColorStop(0, fillColor);
        grd.addColorStop(1, darkColor.getHtmlHexString());
        canvas.setFillStyle(grd);
        canvas.fill();
        
        // Checkmark
        if (config.checked) {
            var path = new m.Path([
                x2 + 2, y2 + 1/2 * h2,
                x2 + 1/2 * w2, y2 + h2 - 2,
                x + w + 3, y,
                x2 + 1/2 * w2, y2 + h2 - 6,
                x2 + 5, y2 + 1/2 * h2 - 2
            ]);
            path.drawInto(canvas);
            canvas.setFillStyle(config.checkedColor);
            canvas.fill();
        }
        
        var retval = canvas.__canvas;
        canvas.destroy();
        return retval;
    }
});


/** Mix onto a view to make it behave as a checkbox button. Use setValue to 
    set the checked state of the checkbox.
    
    Requires:
        Should be used on: myt.DrawButton or subclass thereof.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.CheckboxMixin = new JS.Module('CheckboxMixin', {
    include: [myt.ValueComponent, myt.CheckboxStyleMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (attrs.value === undefined) attrs.value = false;
        if (attrs.drawingMethodClassname === undefined) attrs.drawingMethodClassname = 'myt.CheckboxDrawingMethod';
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.ValueComponent */
    setValue: function(v) {
        if (this.value !== v) {
            this.callSuper(v);
            
            if (this.inited) this.redraw();
        }
    },
    
    /** @overrides myt.CheckboxStyleMixin */
    getDrawConfig: function(state) {
        var config = this.callSuper(state);
        config.checked = this.value;
        return config;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawButton
        Toggle the value attribute when activated. */
    doActivated: function() {
        this.setValue(!this.value);
    }
});


/** A checkbox component. */
myt.Checkbox = new JS.Class('Checkbox', myt.DrawButton, {
    include: [myt.CheckboxMixin]
});


/** A mixin that adds a text element to the inside of a button.
    
    Events:
        inset:number
        outset:number
        text:string
        shrinkToFit:boolean
        textY:number|string
    
    Attributes:
        inset:number The left padding before the text. Defaults to 0.
        outset:number The right padding after the text. Defaults to 0.
        text:string The text to display on the button.
        shrinkToFit:boolean When true the button will be as narrow as possible
            to fit the text, inset and outset. When false the button 
            will be as wide as the set width. Defaults to false.
        textY:number|string The y offset for the text. If a string it must be
            a valign value: 'top', 'middle' or 'bottom'.
        textView:myt.Text A reference to the child text view.
    
    Private Attributes:
        __updateContentPositionLoopBlock:boolean Used in __updateContentPosition
            to prevent infinite loops.
        __origHeight:number The height the button has after adoption. Used to
            keep a positive height for the button even when the textView is
            not shown.
*/
myt.TextButtonContent = new JS.Module('TextButtonContent', {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.inset = this.outset = 0;
        
        if (attrs.shrinkToFit === undefined) attrs.shrinkToFit = false;
        
        // Use appropriate default based on mutliline text or not.
        this.textY = attrs.shrinkToFit ? 'middle' : 0;
        
        this.callSuper(parent, attrs);
        
        // Setup the constraint after adoption since the textView won't have
        // been sized to the dom until it's added in.
        var textView = this.textView;
        this.applyConstraint('__updateContentPosition', [
            this, 'inset', this, 'outset',
            this, 'width', this, 'shrinkToFit',
            textView, 'visible', textView, 'width',
            textView, 'height', textView, 'y'
        ]);
    },
    
    doAfterAdoption: function() {
        var textY = this.textY, 
            attrs = {
                name:'textView', 
                whiteSpace: this.shrinkToFit ? 'nowrap' : 'normal', 
                text:this.text, domClass:'mytButtonText mytUnselectable'
            };
        if (typeof textY === 'string') {
            attrs.valign = textY;
        } else {
            attrs.y = textY;
        }
        new myt.Text(this, attrs);
        
        // Record original height
        this.__origHeight = this.height;
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setInset: function(v) {
        // Adapt to event from syncTo
        if (v !== null && typeof v === 'object') v = v.value;
        
        if (this.inset !== v) {
            this.inset = v;
            if (this.inited) this.fireNewEvent('inset', v);
        }
    },
    
    setOutset: function(v) {
        // Adapt to event from syncTo
        if (v !== null && typeof v === 'object') v = v.value;
        
        if (this.outset !== v) {
            this.outset = v;
            if (this.inited) this.fireNewEvent('outset', v);
        }
    },
    
    setText: function(v) {
        if (this.text !== v) {
            this.text = v;
            if (this.inited) {
                this.textView.setText(v);
                this.fireNewEvent('text', v);
            }
        }
    },
    
    setShrinkToFit: function(v) {
        if (this.shrinkToFit !== v) {
            this.shrinkToFit = v;
            if (this.inited) {
                if (this.textView) this.textView.setWhiteSpace(v ? 'nowrap' : 'normal');
                this.fireNewEvent('shrinkToFit', v);
            }
        }
    },
    
    setTextY: function(v) {
        if (this.textY !== v) {
            this.textY = v;
            if (this.inited) {
                this.fireNewEvent('textY', v);
                if (typeof v === 'string') {
                    this.textView.setValign(v);
                } else {
                    this.textView.setValign('');
                    this.textView.setY(v);
                }
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    __updateContentPosition: function(v) {
        if (this.__updateContentPositionLoopBlock || this.destroyed) return;
        
        var inset = this.inset, 
            outset = this.outset, 
            textView = this.textView,
            textViewVisible = textView.visible && this.text;
        
        if (this.shrinkToFit) {
            textView.setX(inset);
            
            this.__updateContentPositionLoopBlock = true;
            this.setWidth(inset + (textViewVisible ? textView.width : 0) + outset);
            this.__updateContentPositionLoopBlock = false;
            
            this.setHeight(this.__origHeight);
        } else {
            textView.setHeight('auto');
            textView.setWidth(this.width - inset - outset);
            textView.setX(inset);
            
            this.__updateContentPositionLoopBlock = true;
            this.setHeight(textViewVisible ? textView.y + textView.height : this.__origHeight);
            this.__updateContentPositionLoopBlock = false;
        }
    }
});


/** A checkbox component with a text label. */
myt.TextCheckbox = new JS.Class('TextCheckbox', myt.Checkbox, {
    include: [myt.TextButtonContent, myt.TooltipMixin],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Padding on the left and right side of the text. */
        DEFAULT_PAD_X:2,
        /** Padding above the text when in multiline mode (shrinkToFit == false) */
        DEFAULT_MULTILINE_PAD_Y:4,
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    doAfterAdoption: function() {
        var TC = myt.TextCheckbox, padX = TC.DEFAULT_PAD_X;
        this.setInset(this.getIconExtentX() + padX);
        this.setOutset(padX);
        
        if (!this.shrinkToFit) this.setTextY(TC.DEFAULT_MULTILINE_PAD_Y);
        
        this.callSuper();
    }
});


/** Draws a radio button into an myt.Canvas. */
myt.RadioDrawingMethod = new JS.Class('RadioDrawingMethod', myt.DrawingMethod, {
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        this.__getTemplate = myt.memoize(this.__getTemplate);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawingMethod */
    draw: function(canvas, config) {
        canvas.clear();
        canvas.drawImage(this.__getTemplate(config), 0, 0);
    },
    
    /** @private */
    __getTemplate: function(config) {
        var m = myt,
            b = config.bounds, x = b.x, y = b.y, w = b.w, h = b.h,
            shadowBlur         = config.shadowBlur == null ? 2 : config.shadowBlur,
            shadowOffsetX      = config.shadowOffsetX == null ? 0 : config.shadowOffsetX,
            shadowOffsetY      = config.shadowOffsetY == null ? 1 : config.shadowOffsetY,
            shadowColor        = config.shadowColor == null ? 'rgba(0, 0, 0, 0.3)' : config.shadowColor,
            focusedShadowColor = config.focusedShadowColor == null ? 'rgba(0, 0, 0, 0.5)' : config.focusedShadowColor,
            fillColor          = config.fillColor,
            focused            = config.focused,
            inset              = config.edgeSize,
            radius = w / 2,
            radius2 = radius - inset,
            dotRadius = (radius2 / 2) - 1,
            centerX = x + radius,
            centerY = y + radius,
            darkColor = (m.Color.makeColorFromHexString(fillColor)).multiply(5/6);
        
        var canvas = new m.Canvas(m.global.roots.getRoots()[0], {
            width:x + w + shadowOffsetX + shadowBlur, 
            height:y + h + shadowOffsetY + shadowBlur, 
            visible:false, 
            ignoreLayout:true, 
            ignorePlacement:true
        });
        var grd = canvas.createLinearGradient(x, y, x, y + w);
        
        // Border and shadow
        canvas.save();
        canvas.setShadowOffsetX(shadowOffsetX);
        canvas.setShadowOffsetY(shadowOffsetY);
        canvas.setShadowBlur(shadowBlur * (focused ? 2 : 1));
        canvas.setShadowColor(focused ? focusedShadowColor : shadowColor);
        
        canvas.beginPath();
        canvas.circle(centerX, centerY, radius);
        canvas.closePath();
        canvas.setFillStyle(config.edgeColor);
        canvas.fill();
        canvas.restore();
        
        // Fill
        canvas.beginPath();
        canvas.circle(centerX, centerY, radius2);
        canvas.closePath();
        grd.addColorStop(0, fillColor);
        grd.addColorStop(1, darkColor.getHtmlHexString());
        canvas.setFillStyle(grd);
        canvas.fill();
        
        // Checkmark
        if (config.checked) {
            canvas.beginPath();
            canvas.circle(centerX, centerY, dotRadius);
            canvas.closePath();
            canvas.setFillStyle(config.checkedColor);
            canvas.fill();
        }
        
        var retval = canvas.__canvas;
        canvas.destroy();
        return retval;
    }
});


/** Provides the capability for a Node to participate in a BAG.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __bags:array A list of BAGs this node is a member of.
*/
myt.BAGMembership = new JS.Module('BAGMembership', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Node */
    initNode: function(parent, attrs) {
        this.__bags = [];
        
        this.callSuper(parent, attrs);
    },
    
    /** @overrides myt.Node */
    destroyAfterOrphaning: function() {
        this.callSuper();
        
        var groups = this.__bags, i = groups.length, group;
        while (i) {
            group = groups[--i];
            this.removeFromBAG(group.attrName, group.groupId);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    isRegisteredWithBAG: function(group) {
        var groups = this.__bags, i = groups.length;
        while (i) {
            if (groups[--i] === group) return true;
        }
        return false;
    },
    
    getBAG: function(attrName, groupId) {
        return myt.BAG.getGroup(attrName, groupId);
    },
    
    /** Adds this node to the BAG for the groupId and
        attribute name.
        @param attrName:string
        @param groupId:string
        @returns void */
    addToBAG: function(attrName, groupId) {
        var group = this.getBAG(attrName, groupId);
        if (!this.isRegisteredWithBAG(group)) {
            this.__bags.push(group);
            group.register(this);
            
            // Monitor attribute
            if (!this.isAttachedTo(this, '__updateForBAG', attrName)) {
                this.attachTo(this, '__updateForBAG', attrName);
            }
        }
    },
    
    /** Removes this node from the BAG for the groupId and
        attribute name.
        @param attrName:string
        @param groupId:string
        @returns void */
    removeFromBAG: function(attrName, groupId) {
        var group = this.getBAG(attrName, groupId);
        if (this.isRegisteredWithBAG(group)) {
            var groups = this.__bags, i = groups.length, g, detach = true;
            while (i) {
                g = groups[--i];
                if (g === group) {
                    groups.splice(i, 1);
                    group.unregister(this);
                } else if (g.attrName === attrName) {
                    // Don't detach if another group is listening to the same attr.
                    detach = false;
                }
            }
            
            if (detach) this.detachFrom(this, '__updateForBAG', attrName);
        }
    },
    
    /** Called whenever an event for the attrName is fired.
        @private 
        @returns void */
    __updateForBAG: function(event) {
        var type = event.type,
            value = event.value,
            groups = this.__bags, i = groups.length, group;
        while (i) {
            group = groups[--i];
            if (group.attrName === type) {
                if (value) {
                    group.setTrue(this);
                } else {
                    group.setFalse(this);
                }
            }
        }
    }
});


/** Manages a boolean attribute on a collection of Nodes. Ensures that no more
    than one of the Nodes has the attribute set to true at one time.
    
    Events:
        attrName:string
        groupId:string
        trueNode:myt.Node
    
    Attributes:
        attrName:string The name of the boolean attribute to monitor and update.
        groupId:string The unqiue ID of the group.
        trueNode:myt.Node The node that is currently true. Will be null if no
            node is true.
    
    Private Attributes:
        __nodes:array A list of the currently registered nodes.
*/
myt.BAG = new JS.Class('BAG', {
    include: [myt.AccessorSupport, myt.Destructible, myt.Observable],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A data structure of groups stored as a map of maps. First level 
            is attribute name second level is group ID.
            @private */
        __groups: {},
        
        /** Generates a unique group id
            @return number */
        generateUniqueGroupId: function() {
            return myt.generateGuid();
        },
        
        /** Creates a new BAG.
            @param attrName:string
            @returns a new BAG. */
        createGroup: function(attrName) {
            return new BAG(attrName, this.generateUniqueGroupId());
        },
        
        /** Gets a BAG for the attribute name and group ID.
            @param attrName:string the name of the attribute to monitor.
            @param groupId:string the unique ID of the group.
            @returns the BAG */
        getGroup: function(attrName, groupId) {
            if (attrName && groupId) {
                var groups = this.__groups,
                    groupIdMap = groups[attrName] || (groups[attrName] = {});
                return groupIdMap[groupId] || (groupIdMap[groupId] = new myt.BAG(attrName, groupId));
            }
            return null;
        },
        
        /** Removes a BAG for the attribute name and group id.
            @param attrName:string the name of the attribute to monitor.
            @param groupId:string the unique ID of the group.
            @returns the removed BAG */
        removeGroup: function(attrName, groupId) {
            if (attrName && groupId) {
                var groups = this.__groups;
                if (groups) {
                    var groupIdMap = groups[attrName];
                    if (groupIdMap) {
                        var group = groupIdMap[groupId];
                        if (group) delete groupIdMap[groupId];
                        return group;
                    }
                }
            }
            return null;
        }
    },
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function(attrName, groupId) {
        this.__nodes = [];
        this.trueNode = null;
        
        this.attrName = attrName;
        this.groupId = groupId;
    },

    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Destructible */
    destroy: function() {
        if (this.trueNode) this.setTrueNode(null);
        
        if (this.__nodes.length === 0) myt.BAG.removeGroup(this.attrName, this.groupId);
        
        this.__nodes.length = 0;
        this.detachAllObservers();
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setGroupId: function(v) {this.set('groupId', v, true);},
    setAttrName: function(v) {this.set('attrName', v, true);},
    setTrueNode: function(v) {this.set('trueNode', v, true);},
    getNodes: function() {return this.__nodes;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Registeres a node with this group.
        @param node:myt.Node the node to register with this group.
        @returns void */
    register: function(node) {
        if (node && !this.isRegistered(node)) {
            this.__nodes.push(node);
            
            // If node is true then update for this.
            if (node[this.attrName]) this.setTrue(node);
        }
    },
    
    /** Unregisteres a node from this group.
        @param node:myt.Node the node to unregister from this group.
        @returns void */
    unregister: function(node) {
        if (node) {
            var nodes = this.__nodes, i = nodes.length;
            while (i) {
                if (node === nodes[--i]) {
                    nodes.splice(i, 1);
                    break;
                }
            }
            
            if (this.trueNode === node) this.setTrueNode(null);
            
            if (nodes.length === 0) this.destroy();
        }
    },
    
    /** Sets the attribute to true on the provided registered node and sets 
        it to false on all other registered nodes.
        @param node:myt.Node the node to set the attribute to true on.
        @returns void */
    setTrue: function(node) {
        if (node && this.trueNode !== node && this.isRegistered(node)) {
            var attrName = this.attrName,
                setterName = myt.AccessorSupport.generateSetterName(attrName),
                nodes = this.__nodes, i = nodes.length, n;
            
            this.setTrueNode(node);
            
            while (i) {
                n = nodes[--i];
                if (node === n) {
                    if (!n[attrName]) n[setterName](true);
                } else {
                    if (n[attrName]) n[setterName](false);
                }
            }
            
        }
    },
    
    /** Sets the attribute to false on the provided registered node.
        @param node:myt.Node the node to set the attribute to false on.
        @returns void */
    setFalse: function(node) {
        if (node && this.trueNode === node) {
            var setterName = myt.AccessorSupport.generateSetterName(this.attrName);
            node[setterName](false);
            this.setTrueNode(null);
        }
    },
    
    /** Checks if a node is already registered or not.
        @param node:myt.Node the node to test.
        @returns void */
    isRegistered: function(node) {
        var nodes = this.__nodes, i = nodes.length;
        while (i) {
            if (node === nodes[--i]) return true;
        }
        return false;
    }
});


/** Mix onto a view to make it behave as a radio button. Should be used
    on an myt.DrawButton or subclass thereof.
    
    Events:
        optionValue:* Fired when the optionValue changes.
        selected:boolean Fired when a radio is selected/deselected.
        groupId:string Fired when the groupId is changed.
    
    Attributes:
        optionValue:* The value of this radio button within the radio group.
        selected:boolean Indicates if this radio is selected or not.
        groupId:string The radio group ID this radio is a member of.
    
    Private Attributes:
        __initValue:* Holds the value if it is set during initialization until
            the end of initialization so the group value can be updated.
*/
myt.RadioMixin = new JS.Module('RadioMixin', {
    include: [myt.BAGMembership, myt.CheckboxStyleMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.selected === undefined) attrs.selected = false;
        if (attrs.groupId === undefined) attrs.groupId = myt.generateGuid();
        if (attrs.drawingMethodClassname === undefined) attrs.drawingMethodClassname = 'myt.RadioDrawingMethod';
        
        this.callSuper(parent, attrs);
        
        if (this.__initValue !== undefined) {
            this.__updateGroupValue(this.__initValue);
            delete this.__initValue;
        }
        
        if (this.selected) {
            var bag = this.__getBAG();
            if (bag) bag.setTrue(this);
        }
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setOptionValue: function(v) {this.set('optionValue', v, true);},
    
    /** Sets the value of the radio group. Calling this method on any
        radio button in the group should have the same effect. */
    setValue: function(v) {
        if (this.inited) {
            this.__updateGroupValue(v);
        } else {
            this.__initValue = v;
        }
    },
    
    /** Gets the value of the 'selected' radio button in the group.
        @returns *: The value of the selected radio button. */
    getValue: function() {
        // Get selected radio
        var bag = this.__getBAG(),
            selectedRadio = bag ? bag.trueNode : null;
        return selectedRadio ? selectedRadio.optionValue : null;
    },
    
    setSelected: function(v) {
        if (this.selected !== v) {
            this.selected = v;
            if (this.inited) {
                this.fireNewEvent('selected', v);
                this.redraw();
            }
        }
    },
    
    setGroupId: function(v) {
        if (this.groupId !== v) {
            var oldGroupId = this.groupId;
            this.groupId = v;
            if (oldGroupId) this.removeFromBAG('selected', oldGroupId);
            if (v) this.addToBAG('selected', v);
            if (this.inited) this.fireNewEvent('groupId', v);
        }
    },
    
    /** @overrides myt.CheckboxStyleMixin */
    getDrawConfig: function(state) {
        var config = this.callSuper(state);
        config.checked = this.selected;
        return config;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawButton */
    doActivated: function() {
        if (!this.selected) this.setValue(this.optionValue);
    },
    
    /** @private */
    __getBAG: function() {
        return this.getBAG('selected', this.groupId);
    },
    
    /** Search the radio group for a matching node and make that one the
        true node.
        @private */
    __updateGroupValue: function(v) {
        var bag = this.__getBAG();
        if (bag) {
            var nodes = bag.getNodes(), i = nodes.length, node;
            while (i) {
                node = nodes[--i];
                if (node.optionValue === v) {
                    bag.setTrue(node);
                    break;
                }
            }
        }
    }
});


/** A radio button component. */
myt.Radio = new JS.Class('Radio', myt.DrawButton, {
    include: [myt.RadioMixin]
});


/** A radio button component with a text label. */
myt.TextRadio = new JS.Class('TextRadio', myt.Radio, {
    include: [myt.TextButtonContent, myt.TooltipMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    doAfterAdoption: function() {
        var TC = myt.TextCheckbox, padX = TC.DEFAULT_PAD_X;
        this.setInset(this.getIconExtentX() + padX);
        this.setOutset(padX);
        
        if (!this.shrinkToFit) this.setTextY(TC.DEFAULT_MULTILINE_PAD_Y);
        
        this.callSuper();
    }
});


/** Draws a tab slider into an myt.Canvas.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.TabSliderDrawingMethod = new JS.Class('TabSliderDrawingMethod', myt.DrawingMethod, {
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawingMethod */
    draw: function(canvas, config) {
        var b = config.bounds, x = b.x, y = b.y, w = b.w, h = b.h;
        
        canvas.clear();
        
        if (w == 0 || h == 0) return;
        
        var inset = config.edgeSize, twiceInset = 2 * inset;
        
        // Border
        if (inset > 0) {
            canvas.beginPath();
            canvas.rect(x, y, w, h);
            canvas.closePath();
            canvas.setFillStyle(config.edgeColor);
            canvas.fill();
        }
        
        // Fill
        canvas.beginPath();
        canvas.rect(x + inset, y + inset, w - twiceInset, h - twiceInset);
        canvas.closePath();
        canvas.setFillStyle(config.fillColor);
        canvas.fill();
    }
});


/** Makes an object selectable.
    
    Events:
        selected:boolean
    
    Attributes:
        selected:boolean Indicates the object is selected.
*/
myt.Selectable = new JS.Module('Selectable', {
    // Accessors ///////////////////////////////////////////////////////////////
    setSelected: function(v) {
        // Adapt to event from syncTo
        if (v !== null && typeof v === 'object') v = v.value;
        
        if (this.selected !== v) {
            this.selected = v;
            if (this.inited && this.fireNewEvent) this.fireNewEvent('selected', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Checks if this object is selected. */
    isSelected: function() {
        return this.selected ? true : false;
    },
    
    /** Checks if the provided myt.SelectionManager can select this object.
        Returns true by default.
        @returns boolean */
    canSelect: function(selectionManager) {
        return true;
    },
    
    /** Checks if the provided myt.SelectionManager can deselect this object.
        Returns true by default.
        @returns boolean */
    canDeselect: function(selectionManager) {
        return true;
    }
});


/** Manages the selection of one or more items.
    
    Events:
        itemSelected:object Fired when an item is selected. The event value is 
            the selected item.
        itemDeselected:object Fired when an item is deselected. The event 
            value is the deselected item.
        selectedCount:number Fired when the number of selected items changes.
    
    Attributes:
        itemSelectionId:string The name of the property on items that is used
            to differentiate them from each other for selection. The default
            value is 'id'.
        maxSelected:number The maximum number of items that can be selected.
            If -1 is provided the count is unlimited. If 1 is provided attempts
            to select when an item is already selected will result in the
            existing selection being cleared and the the new item being
            selected. Defaults to -1.
        selectedCount:number The number of selected items.
    
    Private Attributes:
        __selected:object A map of selected items by itemSelectionId.
        __lastSelectedItem:object A reference to the last item that was
            selected. If this item is deselected this will get set to null.
*/
myt.SelectionManager = new JS.Module('SelectionManager', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** Determines if we are in "add" mode for selection such that
            selections will only be increased not reduced. Typically this
            means the shift key is down.
            @returns boolean true if in add mode, false otherwise. */
        isAddMode: function() {
            return myt.global.keys.isShiftKeyDown();
        },
        
        /** Determines if we are in "toggle" mode for selection such that
            selections can be added to or removed from incrementally. Typically 
            this means the control or command key is down.
            @returns boolean true if in add mode, false otherwise. */
        isToggleMode: function() {
            var gk = myt.global.keys;
            return gk.isControlKeyDown() || gk.isCommandKeyDown();
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.__selected = {};
        this.__lastSelectedItem = null;
        
        attrs.selectedCount = 0;
        
        if (attrs.itemSelectionId === undefined) attrs.itemSelectionId = 'id';
        if (attrs.maxSelected === undefined) attrs.maxSelected = -1;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setItemSelectionId: function(v) {this.itemSelectionId = v;},
    setMaxSelected: function(v) {this.maxSelected = v;},
    
    setSelectedCount: function(v) {
        if (this.selectedCount !== v) {
            this.selectedCount = v;
            if (this.inited) this.fireNewEvent('selectedCount', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** A wrapper around myt.SelectionManager.isAddMode. */
    isAddMode: function() {
        return myt.SelectionManager.isAddMode();
    },
    
    /** A wrapper around myt.SelectionManager.isToggleMode. */
    isToggleMode: function() {
        return myt.SelectionManager.isToggleMode();
    },
    
    /** Gets the currently selected items.
        @returns array: The selected items. */
    getSelected: function() {
        var retval = [], items = this.__selected, key;
        for (key in items) retval.push(items[key]);
        return retval;
    },
    
    /** Selects the provided item.
        @param item:object The item to select.
        @returns void */
    select: function(item) {
        if (!this.isSelected(item) && this.canSelect(item)) {
            item.setSelected(true);
            this.__selected[item[this.itemSelectionId]] = item;
            this.setSelectedCount(this.selectedCount + 1);
            
            this.__lastSelectedItem = item;
            
            this.doSelected(item);
            this.fireNewEvent('itemSelected', item);
        }
    },
    
    /** Called when an item is selected.
        @param item:myt.Selectable The newly selected item.
        @returns void */
    doSelected: function(item) {},
    
    /** Selects the item with the provided item selection ID.
        @param itemSelectionId:string
        @returns void */
    selectById: function(itemSelectionId) {
        this.select(this.getSelectableItem(itemSelectionId));
    },
    
    /** Checks if the item can be selected.
        @param item:object The item to test.
        @returns boolean: True if selection is allowed, false otherwise. */
    canSelect: function(item) {
        var ms = this.maxSelected, sc = this.selectedCount;
        
        if (ms === 0) {
            return false;
        } else if (ms === 1) {
            // Deselect current selection if necessary
            if (sc > 0) {
                this.deselectAll();
                if (this.selectedCount > 0) return false;
            }
        } else if (ms > 1) {
            if (sc >= ms) return false;
        }
        
        return item.canSelect(this);
    },
    
    /** Selects all items that can be selected.
        @returns void */
    selectAll: function() {
        var items = this.getSelectableItems(), i = items.length;
        while (i) this.select(items[--i]);
    },
    
    /** Deselects the provided item.
        @param item:object The item to deselect.
        @returns void */
    deselect: function(item) {
        if (this.isSelected(item) && this.canDeselect(item)) {
            item.setSelected(false);
            delete this.__selected[item[this.itemSelectionId]];
            this.setSelectedCount(this.selectedCount - 1);
            
            if (this.__lastSelectedItem === item) this.__lastSelectedItem = null;
            
            this.doDeselected(item);
            this.fireNewEvent('itemDeselected', item);
        }
    },
    
    /** Called when an item is deselected.
        @param item:myt.Selectable The newly deselected item.
        @returns void */
    doDeselected: function(item) {},
    
    /** Deselects the item with the provided item selection ID.
        @param itemSelectionId:string
        @returns void */
    deselectById: function(itemSelectionId) {
        this.deselect(this.getSelectableItem(itemSelectionId));
    },
    
    /** Checks if the item can be deselected.
        @returns true if deselection is allowed, false otherwise. */
    canDeselect: function(item) {
        return item.canDeselect(this);
    },
    
    /** Deselects all selected items.
        @returns void */
    deselectAll: function() {
        var items = this.__selected, key;
        for (key in items) this.deselect(items[key]);
    },
    
    /** Checks if the item is selected.
        @param item:object The item to test.
        @returns boolean */
    isSelected: function(item) {
        return item ? item.isSelected() : false;
    },
    
    /** Checks if all selectable items are selected.
        @returns boolean */
    areAllSelected: function() {
        return this.selectedCount === this.getSelectableItems().length;
    },
    
    /** Gets a list of items that are potentially selectable by this manager.
        By default assumes this is an myt.View and returns all 
        myt.Selectable subviews.
        @returns array */
    getManagedItems: function() {
        var retval = [], svs = this.getSubviews(), i = svs.length, sv;
        while (i) {
            sv = svs[--i];
            if (sv.isA(myt.Selectable)) retval.push(sv);
        }
        return retval;
    },
    
    /** Gets a list of items that can currently be selected by this manager.
        @returns array */
    getSelectableItems: function() {
        var items = this.getManagedItems(), i = items.length;
        while (i) {
            if (!items[--i].canSelect(this)) items.splice(i, 1);
        }
        return items;
    },
    
    /** Gets a selectable item with the the provided selection item ID.
        @param itemSelectionId:string
        @returns myt.Selectable: The item or null if not found. */
    getSelectableItem: function(itemSelectionId) {
        var items = this.getSelectableItems(), i = items.length, item,
            selectionAttr = this.itemSelectionId;
        while (i) {
            item = items[--i];
            if (item[selectionAttr] === itemSelectionId) return item;
        }
        return null;
    }
});


/** A mixin that allows myt.TabSliders to be added to a view.
    
    Events:
        None
    
    Attributes:
        spacing:number The spacing between tab sliders. Defaults to
            myt.TabSliderContainer.DEFAULT_SPACING which is 1.
*/
myt.TabSliderContainer = new JS.Module('TabSliderContainer', {
    include: [myt.SelectionManager],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_SPACING:1
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this._tabSliders = [];
        
        attrs.defaultPlacement = 'container';
        
        if (attrs.spacing === undefined) attrs.spacing = myt.TabSliderContainer.DEFAULT_SPACING;
        if (attrs.overflow === undefined) attrs.overflow = 'auto';
        if (attrs.itemSelectionId === undefined) attrs.itemSelectionId = 'tabId';
        if (attrs.maxSelected === undefined) attrs.maxSelected = 1;
        
        myt.DelayedMethodCall.createDelayedMethodCall(this, 0, '__updateLayout');
        
        this.callSuper(parent, attrs);
    },
    
    doAfterAdoption: function() {
        var self = this;
        var container = new myt.View(this, {
            name:'container', ignorePlacement:true, percentOfParentWidth:100
        }, [myt.SizeToParent, {
            /** @overrides myt.View */
            subnodeAdded: function(node) {
                this.callSuper(node);
                if (node instanceof myt.TabSlider) {
                    self._tabSliders.push(node);
                    self.attachTo(node, 'updateLayout', 'selected');
                }
            },
            
            /** @overrides myt.View */
            subnodeRemoved: function(node) {
                if (node instanceof myt.TabSlider) {
                    var tabSliders = self._tabSliders, i = tabSliders.length;
                    while (i) {
                        if (tabSliders[--i] === node) {
                            self.detachFrom(node, 'updateLayout', 'selected');
                            tabSliders.splice(i, 1);
                            break;
                        }
                    }
                }
                this.callSuper(node);
            }
        }]);
        new myt.SpacedLayout(container, {name:'layout', axis:'y', spacing:this.spacing, collapseParent:true});
        
        this.attachTo(this, 'updateLayout', 'height');
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSpacing: function(v) {
        if (this.spacing !== v) {
            this.spacing = v;
            if (this.layout) this.layout.setSpacing(v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    updateLayout: function(event) {
        this.__updateLayoutDelayed();
    },
    
    /** @private */
    __updateLayout: function() {
        var tabSliders = this._tabSliders, i = tabSliders.length, tabSlider,
            min = 0, preferred = 0, visCount = 0;
        
        while (i) {
            tabSlider = tabSliders[--i];
            
            if (tabSlider.visible) {
                ++visCount;
                if (tabSlider.selected) {
                    min += tabSlider.getMinimumExpandedHeight();
                    preferred += tabSlider.getPreferredExpandedHeight();
                } else {
                    min += tabSlider.getCollapsedHeight();
                    preferred += tabSlider.getCollapsedHeight();
                }
            }
        }
        
        var layout = this.container.layout,
            layoutOverage = layout.inset + layout.outset + layout.spacing * (visCount - 1);
        min += layoutOverage;
        preferred += layoutOverage;
        
        var h = this.height,
            minIsOver = min > h,
            preferredIsOver = preferred > h,
            overage = preferred - h,
            tabPreferred, tabMin, newVal;
        
        i = tabSliders.length;
        while (i) {
            tabSlider = tabSliders[--i];
            
            if (tabSlider.visible) {
                if (tabSlider.selected) {
                    if (minIsOver) {
                        tabSlider.expand(tabSlider.getMinimumExpandedHeight());
                    } else if (preferredIsOver) {
                        tabPreferred = tabSlider.getPreferredExpandedHeight();
                        tabMin = tabSlider.getMinimumExpandedHeight();
                        
                        newVal = tabPreferred - overage;
                        if (tabMin > newVal) {
                            overage -= tabPreferred - tabMin;
                            newVal = tabMin;
                        } else {
                            overage = 0;
                        }
                        
                        tabSlider.expand(newVal);
                    } else {
                        tabSlider.expand(tabSlider.getPreferredExpandedHeight());
                    }
                } else {
                    tabSlider.collapse(tabSlider.getCollapsedHeight());
                }
            }
        }
    }
});


/** A tab slider component.
    
    Events:
        expansionState:string Fired when the tab slider changes expansion state.
    
    Attributes:
        tabId:string The unique ID for this tab slider relative to the
            tab slider container that manages this tab slider.
        tabContainer:myt.TabSliderContainer The tab slider container that 
            manages this tab.
        buttonClass:JS.Class The class to use for the button portion of the
            tab slider. Defaults to myt.DrawButton.
        drawingMethodClassname:string The name of the class to draw the button
            with.
        edgeColor:color The color of the edge of the tab slider button.
        edgeSize:number The size of the edge of the tab slider button.
        fillColorSelected:color The color of the button when selected.
        fillColorHover:color The color of the button when moused over.
        fillColorActive:color The color of the button while active.
        fillColorReady:color The color of the button when ready for interaction.
        buttonHeight:number The height of the button portion of the tab slider.
            Defaults to myt.TabSlider.DEFAULT_BUTTON_HEIGHT which is 30.
        minContainerHeight:number The minimum height of the content container
            inside this tab slider. Defaults to 
            myt.TabSlider.DEFAULT_MINIMUM_CONTAINER_HEIGHT which is 100.
        expansionState:string Indicates the expansion state of the tab slider.
            Supported values are: 'expanded', 'expanding', 'collapsed' and
            'collapsing'. Defaults to 'collapsed'.
*/
myt.TabSlider = new JS.Class('TabSlider', myt.View, {
    include: [myt.Selectable, myt.Disableable, myt.SizeToParent],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_BUTTON_HEIGHT: 30,
        /** The minimum height of the container when expanded. */
        DEFAULT_MINIMUM_CONTAINER_HEIGHT:100,
        DEFAULT_FILL_COLOR_SELECTED: '#666666',
        DEFAULT_FILL_COLOR_HOVER: '#eeeeee',
        DEFAULT_FILL_COLOR_ACTIVE: '#cccccc',
        DEFAULT_FILL_COLOR_READY: '#ffffff',
        DEFAULT_EDGE_COLOR: '#333333',
        DEFAULT_EDGE_SIZE: 0.5,
        DEFAULT_ANIMATION_MILLIS: 500
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Checkbox */
    initNode: function(parent, attrs) {
        attrs.defaultPlacement = 'wrapper.container';
        attrs.percentOfParentWidth = 100;
        attrs.expansionState = 'collapsed';
        
        if (attrs.tabId === undefined) attrs.tabId = myt.generateGuid();
        if (attrs.tabContainer === undefined) attrs.tabContainer = parent;
        
        if (attrs.selected === undefined) attrs.selected = false;
        if (attrs.buttonClass === undefined) attrs.buttonClass = myt.DrawButton;
        if (attrs.drawingMethodClassname === undefined) attrs.drawingMethodClassname = 'myt.TabSliderDrawingMethod';
        if (attrs.zIndex === undefined) attrs.zIndex = 0;
        
        var TS = myt.TabSlider;
        if (attrs.edgeColor === undefined) attrs.edgeColor = TS.DEFAULT_EDGE_COLOR;
        if (attrs.edgeSize === undefined) attrs.edgeSize = TS.DEFAULT_EDGE_SIZE;
        if (attrs.buttonHeight === undefined) attrs.buttonHeight = TS.DEFAULT_BUTTON_HEIGHT;
        if (attrs.fillColorSelected === undefined) attrs.fillColorSelected = TS.DEFAULT_FILL_COLOR_SELECTED;
        if (attrs.fillColorHover === undefined) attrs.fillColorHover = TS.DEFAULT_FILL_COLOR_HOVER;
        if (attrs.fillColorActive === undefined) attrs.fillColorActive = TS.DEFAULT_FILL_COLOR_ACTIVE;
        if (attrs.fillColorReady === undefined) attrs.fillColorReady = TS.DEFAULT_FILL_COLOR_READY;
        if (attrs.minContainerHeight === undefined) attrs.minContainerHeight = TS.DEFAULT_MINIMUM_CONTAINER_HEIGHT;
        
        // Selection must be done via the select method on the tabContainer
        if (attrs.selected) {
            var initiallySelected = true;
            delete attrs.selected;
        }
        
        this.callSuper(parent, attrs);
        
        if (initiallySelected) this.tabContainer.select(this);
        if (attrs.disabled === true) this.setDisabled(true);
        
        this.setHeight(this.getCollapsedHeight());
    },
    
    doAfterAdoption: function() {
        var self = this, btnClass = this.buttonClass;
        new btnClass(this, {
            name:'button', ignorePlacement:true, zIndex:1,
            height:this.buttonHeight,
            focusEmbellishment:true,
            drawingMethodClassname:this.drawingMethodClassname,
            groupId:this.parent.parent.groupId,
            percentOfParentWidth:100,
            fillColorChecked:this.fillColorChecked,
            fillColorHover:this.fillColorHover,
            fillColorActive:this.fillColorActive,
            fillColorReady:this.fillColorReady,
            fillBorderColor:this.fillBorderColor,
            edgeSize:this.edgeSize
        }, [myt.SizeToParent, {
            setFocused: function(v) {
                this.callSuper(v);
                if (this.inited) this.redraw();
            },
            
            /** @overrides myt.DrawButton */
            doActivated: function() {
                var tc = self.tabContainer;
                if (self.isSelected() && tc.maxSelected !== 1) {
                    tc.deselect(self);
                } else {
                    tc.select(self);
                }
            },
            
            /** @overrides myt.DrawButton */
            getDrawConfig: function(state) {
                var config = this.callSuper(state);
                
                config.selected = self.selected;
                config.edgeColor = self.edgeColor;
                config.edgeSize = self.edgeSize;
                
                if (self.selected && self.tabContainer.maxSelected !== -1) {
                    config.fillColor = self.fillColorSelected;
                } else {
                    switch (state) {
                        case 'hover':
                            config.fillColor = self.fillColorHover;
                            break;
                        case 'active':
                            config.fillColor = self.fillColorActive;
                            break;
                        case 'disabled':
                        case 'ready':
                            config.fillColor = this.focused ? self.fillColorHover : self.fillColorReady;
                            break;
                        default:
                    }
                }
                
                return config;
            },
            
            /** @overrides myt.DrawButton */
            getDrawBounds: function() {
                var bounds = this.drawBounds;
                bounds.w = this.width;
                bounds.h = this.height;
                return bounds;
            },
            
            /** @overrides myt.DrawButton */
            redraw: function(state) {
                this.callSuper(state);
                self.notifyButtonRedraw(state);
            }
        }]);
        
        var wrapper = new myt.View(this, {
            name:'wrapper', ignorePlacement:true,
            y:this.buttonHeight, height:0,
            visible:false, maskFocus:true,
            overflow:'hidden', percentOfParentWidth:100
        }, [myt.SizeToParent, {
            setHeight: function(v, supressEvent) {
                this.callSuper(Math.round(v), supressEvent);
            },
            setWidth: function(v, supressEvent) {
                this.callSuper(v, supressEvent);
                if (this.inited) this.container.setWidth(v);
            }
        }]);
        
        var container = new myt.View(wrapper, {name:'container'});
        new myt.SizeToChildren(container, {axis:'y'});
        
        this.applyConstraint('__updateHeight', [wrapper, 'y', wrapper, 'height']);
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.Selectable */
    setSelected: function(v) {
        this.callSuper(v);
        if (this.button) this.button.redraw();
    },
    
    setTabId: function(v) {this.tabId = v;},
    setTabContainer: function(v) {this.tabContainer = v;},
    
    setMinContainerHeight: function(v) {this.minContainerHeight = v;},
    setButtonClass: function(v) {this.buttonClass = v;},
    setDrawingMethodClassname: function(v) {this.drawingMethodClassname = v;},
    setEdgeColor: function(v) {this.edgeColor = v;},
    setEdgeSize: function(v) {this.edgeSize = v;},
    setFillColorSelected: function(v) {this.fillColorSelected = v;},
    setFillColorHover: function(v) {this.fillColorHover = v;},
    setFillColorActive: function(v) {this.fillColorActive = v;},
    setFillColorReady: function(v) {this.fillColorReady = v;},
    
    setButtonHeight: function(v) {
        if (this.buttonHeight !== v) {
            this.buttonHeight = v;
            if (this.button) {
                this.button.setHeight(v);
                this.wrapper.setY(v);
            }
        }
    },
    
    setExpansionState: function(v) {
        if (this.expansionState !== v) {
            this.expansionState = v;
            if (this.inited) this.fireNewEvent('expansionState', v);
            
            var wrapper = this.wrapper;
            if (wrapper) {
                if (v === 'expanded') {
                    wrapper.setMaskFocus(false);
                    wrapper.setOverflow('auto');
                } else if (v === 'expanding') {
                    wrapper.setVisible(true);
                } else if (v === 'collapsed') {
                    wrapper.setVisible(false);
                } else if (v === 'collapsing') {
                    wrapper.setMaskFocus(true);
                    wrapper.setOverflow('hidden');
                }
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Disableable */
    doDisabled: function() {
        var btn = this.button;
        if (btn) btn.setDisabled(this.disabled);
    },
    
    /** Called whenever the button is redrawn. Gives subclasses/instances
        a chance to do additional things when the button is redrawn.
        @param state:string The state the button is in.
        @returns void */
    notifyButtonRedraw: function(state) {},
    
    /** @private */
    __updateHeight: function(event) {
        this.setHeight(this.wrapper.y + this.wrapper.height);
    },
    
    /** Should only be called from the TabSliderContainer.
        @private */
    expand: function(targetHeight) {
        this.setExpansionState('expanding');
        
        var wrapper = this.wrapper,
            to = targetHeight - this.getCollapsedHeight();
        
        wrapper.stopActiveAnimators();
        
        if (wrapper.height !== to) {
            var self = this;
            wrapper.animate({
                attribute:'height', to:to, 
                duration:myt.TabSlider.DEFAULT_ANIMATION_MILLIS
            }).next(function(success) {self.setExpansionState('expanded');});
        } else {
            this.setExpansionState('expanded');
        }
    },
    
    /** Should only be called from the TabSliderContainer.
        @private */
    collapse: function(targetHeight) {
        this.setExpansionState('collapsing');
        
        var wrapper = this.wrapper,
            to = targetHeight - this.getCollapsedHeight();
        
        wrapper.stopActiveAnimators();
        
        if (wrapper.height !== to) {
            var self = this;
            wrapper.animate({
                attribute:'height', to:to, 
                duration:myt.TabSlider.DEFAULT_ANIMATION_MILLIS
            }).next(function(success) {self.setExpansionState('collapsed');});
        } else {
            this.setExpansionState('collapsed');
        }
    },
    
    /** Gets the height of the tab slider when it is collapsed. Will be the
        height of the button portion of the tab slider.
        @returns number */
    getCollapsedHeight: function() {
        return this.buttonHeight;
    },
    
    /** Gets the minimum height. Will be the smaller of the preferred height
        or the buttonHeight + minContainerHeight. Thus, if the content is
        smaller than the minContainerHeight extra space will not be shown.
        @returns number */
    getMinimumExpandedHeight: function() {
        return Math.min(this.getPreferredExpandedHeight(), this.buttonHeight + this.minContainerHeight);
    },
    
    /** Gets the preferred height that would allow the container to be shown
        without vertical scrollbars.
        @returns number */
    getPreferredExpandedHeight: function() {
        return this.buttonHeight + this.wrapper.container.height;
    }
});


/** A tab slider with a text label.
    
    Events:
        None
    
    Attributes:
        labelTextColorChecked:color
        labelTextColor:color
        text:string The text for the tab slider.
*/
myt.TextTabSlider = new JS.Class('TextTabSlider', myt.TabSlider, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_LABEL_TEXT_COLOR_CHECKED: '#ffffff',
        DEFAULT_LABEL_TEXT_COLOR: '#333333'
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        var TTS = myt.TextTabSlider;
        if (attrs.labelTextColorChecked === undefined) attrs.labelTextColorChecked = TTS.DEFAULT_LABEL_TEXT_COLOR_CHECKED;
        if (attrs.labelTextColor === undefined) attrs.labelTextColor = TTS.DEFAULT_LABEL_TEXT_COLOR;
        
        this.callSuper(parent, attrs);
        
        new myt.Text(this.button, {
            name:'label', domClass:'mytTextTabSliderLabel', ignorePlacement:true,
            text:this.text, align:'center', valign:'middle', 
            textColor:this.__getTextColor()
        });
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setLabelTextColorChecked: function(v) {this.labelTextColorChecked = v;},
    setLabelTextColor: function(v) {this.labelTextColor = v;},
    
    setText: function(v) {
        if (this.text !== v) {
            this.text = v;
            var button = this.button;
            if (button && button.label) button.label.setText(v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.TabSlider */
    notifyButtonRedraw: function(state) {
        var label = this.button.label;
        if (label) label.setTextColor(this.__getTextColor());
    },
    
    /** @private */
    __getTextColor: function() {
        return (this.selected && this.tabContainer.maxSelected !== -1) ? this.labelTextColorChecked : this.labelTextColor;
    }
});


/** Draws a tab into an myt.Canvas.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.TabDrawingMethod = new JS.Class('TabDrawingMethod', myt.DrawingMethod, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_RADIUS:6
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawingMethod */
    draw: function(canvas, config) {
        var b = config.bounds, x = b.x, y = b.y, w = b.w, h = b.h;
        
        canvas.clear();
        
        if (w == 0 || h == 0) return;
        
        var inset = config.edgeSize, twiceInset = 2 * inset,
            rTL = 0, rTR = 0, rBL = 0, rBR = 0,
            irTL = 0, irTR = 0, irBL = 0, irBR = 0,
            r = config.cornerRadius === undefined ? myt.TabDrawingMethod.DEFAULT_RADIUS : config.cornerRadius,
            ir = r - inset,
            x2 = x + inset, y2 = y + inset, 
            w2 = w - twiceInset, h2 = h - twiceInset,
            selected = config.selected;
        
        switch (config.location) {
            case 'top':
                rTL = rTR = r;
                irTL = irTR = r;
                if (selected) h2 += inset;
                break;
            case 'right':
                rBR = rTR = r;
                irBR = irTR = r;
                if (selected) {
                    x2 -= inset;
                    w2 += inset;
                }
                break;
            case 'bottom':
                rBL = rBR = r;
                irBL = irBR = r;
                if (selected) {
                    y2 -= inset;
                    h2 += inset;
                }
                break;
            case 'left':
                rTL = rBL = r;
                irTL = irBL = r;
                if (selected) w2 += inset;
                break;
        }
        
        // Border
        if (inset > 0) {
            canvas.beginPath();
            myt.DrawingUtil.drawPartiallyRoundedRect(canvas, rTL, rTR, rBL, rBR, x, y, w, h);
            canvas.closePath();
            canvas.setFillStyle(config.edgeColor);
            canvas.fill();
        }
        
        // Fill
        canvas.beginPath();
        myt.DrawingUtil.drawPartiallyRoundedRect(canvas, irTL, irTR, irBL, irBR, x2, y2, w2, h2);
        canvas.closePath();
        canvas.setFillStyle(config.fillColor);
        canvas.fill();
    }
});


/** A mixin that allows myt.Tabs to be added to a view.
    
    Events:
        None
    
    Attributes:
        layout:myt.SpacedLayout The layout for the tabs.
        location:string The location of the tabs relative to the container.
            Supported values are: 'top', 'bottom', 'left' and 'right'. Defaults
            to 'top'.
        spacing:number The spacing between tabs. Defaults to 1.
        inset:number The inset for the layout. Defaults to 0.
*/
myt.TabContainer = new JS.Module('TabContainer', {
    include: [myt.SelectionManager],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_SPACING:1,
        DEFAULT_INSET:0
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.__tabs = [];
        
        var TC = myt.TabContainer;
        if (attrs.spacing === undefined) attrs.spacing = TC.DEFAULT_SPACING;
        if (attrs.inset === undefined) attrs.inset = TC.DEFAULT_INSET;
        
        if (attrs.location === undefined) attrs.location = 'top';
        
        if (attrs.itemSelectionId === undefined) attrs.itemSelectionId = 'tabId';
        if (attrs.maxSelected === undefined) attrs.maxSelected = 1;
        
        this.callSuper(parent, attrs);
        
        var axis;
        switch (this.location) {
            case 'top':
            case 'bottom':
                axis = 'x';
                break;
            case 'left':
            case 'right':
                axis = 'y';
                break;
        }
        
        new myt.SpacedLayout(this, {
            name:'layout', axis:axis, spacing:this.spacing, inset:this.inset,
            collapseParent:true
        });
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setLocation: function(v) {this.location = v;},
    
    setSpacing: function(v) {
        if (this.spacing !== v) {
            this.spacing = v;
            if (this.layout) this.layout.setSpacing(v);
        }
    },
    
    setInset: function(v) {
        if (this.inset !== v) {
            this.inset = v;
            if (this.layout) this.layout.setInset(v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    getFirstTab: function() {
        return this.__tabs[0];
    },
    
    /** Gets the currently selected tab.
        @returns myt.Tab or undefined if no tab is selected. */
    getSelectedTab: function() {
        return this.getSelected()[0];
    },
    
    /** @overrides myt.View */
    subnodeAdded: function(node) {
        this.callSuper(node);
        if (node.isA(myt.TabMixin)) {
            this.__tabs.push(node);
            
            switch (this.location) {
                case 'top':
                    node.setValign('bottom');
                    break;
                case 'bottom':
                    node.setValign('top');
                    break;
                case 'left':
                    node.setAlign('right');
                    break;
                case 'right':
                    node.setAlign('left');
                    break;
            }
        }
    },
    
    /** @overrides myt.View */
    subnodeRemoved: function(node) {
        if (node.isA(myt.TabMixin)) {
            var tabs = this.__tabs, i = tabs.length;
            while (i) {
                if (tabs[--i] === node) {
                    tabs.splice(i, 1);
                    break;
                }
            }
        }
        this.callSuper(node);
    }
});


/** A tab component.
    
    Requires:
        myt.Activateable
    
    Events:
        None
    
    Attributes:
        tabId:string The unique ID of this tab relative to its tab container.
        tabContainer:myt.TabContainer The tab container that manages this tab.
*/
myt.TabMixin = new JS.Module('TabMixin', {
    include: [myt.Selectable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.tabId === undefined) attrs.tabId = myt.generateGuid();
        if (attrs.tabContainer === undefined) attrs.tabContainer = parent;
        
        // Selection must be done via the select method on the tabContainer
        var initiallySelected;
        if (attrs.selected) {
            initiallySelected = true;
            delete attrs.selected;
        }
        
        this.callSuper(parent, attrs);
        
        if (initiallySelected) this.tabContainer.select(this);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setTabId: function(v) {this.tabId = v;},
    setTabContainer: function(v) {this.tabContainer = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Activateable */
    doActivated: function() {
        if (!this.selected) this.tabContainer.select(this);
    }
});


/** A tab component.
    
    Events:
        None
    
    Attributes:
        tabId:string The unique ID of this tab relative to its tab container.
        tabContainer:myt.TabContainer The tab container that manages this tab.
        edgeColor:color
        edgeSize:number
        fillColorSelected:color
        fillColorHover:color
        fillColorActive:color
        fillColorReady:color
        labelTextColorSelected:color The color to use for the label text when
            this tab is selected.
        cornerRadius:number Passed into the drawing config to determine if
            a rounded corner is drawn or not. Defaults to undefined which
            causes myt.TabDrawingMethod.DEFAULT_RADIUS to be used.
*/
myt.Tab = new JS.Class('Tab', myt.DrawButton, {
    include: [myt.TabMixin, myt.IconTextButtonContent],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_HEIGHT: 24,
        DEFAULT_INSET: 8,
        DEFAULT_OUTSET: 8,
        DEFAULT_FILL_COLOR_SELECTED: '#ffffff',
        DEFAULT_FILL_COLOR_HOVER: '#eeeeee',
        DEFAULT_FILL_COLOR_ACTIVE: '#aaaaaa',
        DEFAULT_FILL_COLOR_READY: '#cccccc',
        DEFAULT_LABEL_TEXT_COLOR_SELECTED:'#333333',
        DEFAULT_EDGE_COLOR: '#333333',
        DEFAULT_EDGE_SIZE: 0.5
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.DrawButton */
    initNode: function(parent, attrs) {
        var T = myt.Tab;
        
        // myt.DrawButton
        if (attrs.drawingMethodClassname === undefined) attrs.drawingMethodClassname = 'myt.TabDrawingMethod';
        
        // myt.IconTextButtonContent
        if (attrs.inset === undefined) attrs.inset = T.DEFAULT_INSET;
        if (attrs.outset === undefined) attrs.outset = T.DEFAULT_OUTSET;
        
        // myt.Tab
        if (attrs.edgeColor === undefined) attrs.edgeColor = T.DEFAULT_EDGE_COLOR;
        if (attrs.edgeSize === undefined) attrs.edgeSize = T.DEFAULT_EDGE_SIZE;
        if (attrs.fillColorSelected === undefined) attrs.fillColorSelected = T.DEFAULT_FILL_COLOR_SELECTED;
        if (attrs.fillColorHover === undefined) attrs.fillColorHover = T.DEFAULT_FILL_COLOR_HOVER;
        if (attrs.fillColorActive === undefined) attrs.fillColorActive = T.DEFAULT_FILL_COLOR_ACTIVE;
        if (attrs.fillColorReady === undefined) attrs.fillColorReady = T.DEFAULT_FILL_COLOR_READY;
        if (attrs.labelTextColorSelected === undefined) attrs.labelTextColorSelected = T.DEFAULT_LABEL_TEXT_COLOR_SELECTED;
        
        // Other
        if (attrs.height === undefined) attrs.height = T.DEFAULT_HEIGHT;
        if (attrs.focusEmbellishment === undefined) attrs.focusEmbellishment = false;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setEdgeColor: function(v) {this.edgeColor = v;},
    setEdgeSize: function(v) {this.edgeSize = v;},
    setFillColorSelected: function(v) {this.fillColorSelected = v;},
    setFillColorHover: function(v) {this.fillColorHover = v;},
    setFillColorActive: function(v) {this.fillColorActive = v;},
    setFillColorReady: function(v) {this.fillColorReady = v;},
    setLabelTextColor: function(v) {this.labelTextColor = v;},
    setLabelTextColorSelected: function(v) {this.labelTextColorSelected = v;},
    setCornerRadius: function(v) {this.cornerRadius = v;},
    
    setSelected: function(v) {
        this.callSuper(v);
        if (this.inited) this.redraw();
    },
    
    setFocused: function(v) {
        this.callSuper(v);
        if (this.inited) this.redraw();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawButton */
    getDrawBounds: function() {
        var bounds = this.drawBounds;
        bounds.w = this.width;
        bounds.h = this.height;
        return bounds;
    },
    
    /** @overrides myt.DrawButton */
    getDrawConfig: function(state) {
        var config = this.callSuper(state);
        
        config.selected = this.selected;
        config.location = this.tabContainer.location;
        config.cornerRadius = this.cornerRadius;
        config.edgeColor = this.edgeColor;
        config.edgeSize = this.edgeSize;
        
        if (this.selected) {
            config.fillColor = this.fillColorSelected;
        } else {
            switch (state) {
                case 'hover':
                    config.fillColor = this.fillColorHover;
                    break;
                case 'active':
                    config.fillColor = this.fillColorActive;
                    break;
                case 'disabled':
                case 'ready':
                    config.fillColor = this.focused ? this.fillColorHover : this.fillColorReady;
                    break;
                default:
            }
        }
        
        return config;
    },
    
    /** @overrides myt.DrawButton */
    redraw: function(state) {
        this.callSuper(state);
        this.textView.setTextColor(this.selected ? this.labelTextColorSelected : this.labelTextColor);
    }
});


/** A simple tab component.
    
    Events:
        None
    
    Attributes:
        tabId:string The unique ID of this tab relative to its tab container.
        tabContainer:myt.TabContainer The tab container that manages this tab.
        edgeColor:color
        edgeSize:number
        selectedColor:color
        
        labelTextColorSelected:color The color to use for the label text when
            this tab is selected.
        cornerRadius:number Passed into the drawing config to determine if
            a rounded corner is drawn or not. Defaults to undefined which
            causes myt.TabDrawingMethod.DEFAULT_RADIUS to be used.
*/
myt.SimpleTab = new JS.Class('SimpleTab', myt.SimpleIconTextButton, {
    include: [myt.TabMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.DrawButton */
    initNode: function(parent, attrs) {
        var T = myt.Tab;
        
        // myt.IconTextButtonContent
        if (attrs.inset === undefined) attrs.inset = T.DEFAULT_INSET;
        if (attrs.outset === undefined) attrs.outset = T.DEFAULT_OUTSET;
        
        // myt.Tab
        if (attrs.selectedColor === undefined) attrs.selectedColor = T.DEFAULT_FILL_COLOR_SELECTED;
        if (attrs.hoverColor === undefined) attrs.hoverColor = T.DEFAULT_FILL_COLOR_HOVER;
        if (attrs.activeColor === undefined) attrs.activeColor = T.DEFAULT_FILL_COLOR_ACTIVE;
        if (attrs.readyColor === undefined) attrs.readyColor = T.DEFAULT_FILL_COLOR_READY;
        if (attrs.labelTextSelectedColor === undefined) attrs.labelTextSelectedColor = T.DEFAULT_LABEL_TEXT_COLOR_SELECTED;
        
        // Other
        if (attrs.height === undefined) attrs.height = T.DEFAULT_HEIGHT;
        if (attrs.focusEmbellishment === undefined) attrs.focusEmbellishment = false;
        
        this.callSuper(parent, attrs);
        
        this.__updateCornerRadius();
        this.__updateTextColor();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSelectedColor: function(v) {this.selectedColor = v;},
    
    setCornerRadius: function(v) {
        this.cornerRadius = v;
        
        if (this.inited) this.__updateCornerRadius();
    },
    
    setLabelTextColor: function(v) {this.labelTextColor = v;},
    
    setLabelTextSelectedColor: function(v) {
        this.labelTextSelectedColor = v;
        if (this.inited && this.selected) this.textView.setTextColor(v);
    },
    
    setSelected: function(v) {
        this.callSuper(v);
        if (this.inited) {
            this.updateUI();
            this.__updateTextColor();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __updateTextColor: function() {
        this.textView.setTextColor(this.selected ? this.labelTextSelectedColor : this.labelTextColor);
    },
    
    /** @private */
    __updateCornerRadius: function() {
        var r = this.cornerRadius != null ? this.cornerRadius : myt.TabDrawingMethod.DEFAULT_RADIUS;
        switch (this.tabContainer.location) {
            case 'top':
                this.setRoundedTopLeftCorner(r);
                this.setRoundedTopRightCorner(r);
                break;
            case 'bottom':
                this.setRoundedBottomLeftCorner(r);
                this.setRoundedBottomRightCorner(r);
                break;
            case 'left':
                this.setRoundedTopLeftCorner(r);
                this.setRoundedBottomLeftCorner(r);
                break;
            case 'right':
                this.setRoundedTopRightCorner(r);
                this.setRoundedBottomRightCorner(r);
                break;
        }
    },
    
    /** @overrides myt.SimpleButton */
    drawDisabledState: function() {
        this.callSuper();
        if (this.selected) this.setBgColor(this.selectedColor);
    },
    
    /** @overrides myt.SimpleButton */
    drawHoverState: function() {
        this.callSuper();
        if (this.selected) this.setBgColor(this.selectedColor);
    },
    
    /** @overrides myt.SimpleButton */
    drawActiveState: function() {
        this.callSuper();
        if (this.selected) this.setBgColor(this.selectedColor);
    },
    
    /** @overrides myt.SimpleButton */
    drawReadyState: function() {
        this.callSuper();
        if (this.selected) this.setBgColor(this.selectedColor);
    }
});


/** Generates input events and passes them on to one or more event observers.
    Requires myt.DomObservable as a super mixin. */
myt.InputObservable = new JS.Module('InputObservable', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of supported input event types. */
        EVENT_TYPES:{
            input:true,
            select:true,
            change:true
        },
        
        /** The common change/select event that gets reused. */
        EVENT:{source:null, type:null, value:null}
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DomObservable */
    createDomMethodRef: function(domObserver, methodName, type) {
        return this.createStandardDomMethodRef(domObserver, methodName, type, myt.InputObservable) || 
            this.callSuper(domObserver, methodName, type);
    }
});


/** A wrapper around a native browser input element.
    
    Events:
        value:* Fired when the setValue setter is called.
    
    Attributes:
        value:* the current value of the input element.
        inputType:string (read only) the type of the input element to create. 
            Changing this value after initialization will modify the type of the
            underlying dom element and is not generally supported.
            See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type
            for more info and a list of allowed values.
*/
myt.NativeInputWrapper = new JS.Class('NativeInputWrapper', myt.View, {
    include: [myt.Disableable, myt.InputObservable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        if (attrs.focusable === undefined) attrs.focusable = true;
        
        this.callSuper(parent, attrs);
        
        // Set a css class to allow scoping of CSS rules
        this.addDomClass('mytNativeInput');
    },
    
    /** @overrides myt.View */
    createOurDomElement: function(parent) {
        var elem = document.createElement('input');
        elem.style.position = 'absolute';
        elem.type = this.inputType;
        return elem;
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.Disableable */
    setDisabled: function(v) {
        if (this.disabled !== v) {
            this.domElement.disabled = v;
            this.callSuper(v);
        }
    },
    
    setValue: function(v) {
        if (this.value !== v) {
            this.value = v;
            this.setDomValue(v);
            if (this.inited) this.fireNewEvent('value', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Gets the value from the DOM.
        @returns * The value */
    getDomValue: function() {
        return this.domElement.value;
    },
    
    /** Sets the value on the DOM.
        @param v:* The value to set.
        @returns void */
    setDomValue: function(v) {
        var de = this.domElement;
        if (de.value !== v) de.value = v;
    }
});


/** Generates drag and drop events and passes them on to one or more event 
    observers.
    Requires myt.DomObservable as a super mixin. */
myt.DragDropObservable = new JS.Module('DragDropObservable', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** A map of supported drag and drop event types. */
        EVENT_TYPES:{
            dragleave:true,
            dragenter:true,
            dragover:true,
            drop:true
        },
        
        /** The common drag and drop event that gets reused. */
        EVENT:{source:null, type:null, value:null}
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DomObservable */
    createDomMethodRef: function(domObserver, methodName, type) {
        return this.createStandardDomMethodRef(domObserver, methodName, type, myt.DragDropObservable, true) || 
            this.callSuper(domObserver, methodName, type);
    }
});


/** Provides browser drag and drop support.
    
    Requires myt.Disableable as a super mixin. */
myt.DragDropSupport = new JS.Module('DragDropSupport', {
    include: [myt.DragDropObservable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        if (!this.disabled) this.setupDragListeners();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.Disableable */
    setDisabled: function(v) {
        if (this.disabled !== v) {
            this.domElement.disabled = v;
            this.callSuper(v);
            
            if (this.inited) {
                if (v) {
                    this.teardownDragListeners();
                } else {
                    this.setupDragListeners();
                }
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    setupDragListeners: function() {
        this.attachToDom(this, 'doDragOver', 'dragover', false);
        this.attachToDom(this, 'doDragEnter', 'dragenter', false);
        this.attachToDom(this, 'doDragLeave', 'dragleave', false);
        this.attachToDom(this, 'doDrop', 'drop', false);
    },
    
    /** @private */
    teardownDragListeners: function() {
        this.detachFromDom(this, 'doDragOver', 'dragover', false);
        this.detachFromDom(this, 'doDragEnter', 'dragenter', false);
        this.detachFromDom(this, 'doDragLeave', 'dragleave', false);
        this.detachFromDom(this, 'doDrop', 'drop', false);
    },
    
    doDragOver: function(event) {},
    
    doDragEnter: function(event) {},
    
    doDragLeave: function(event) {},
    
    doDrop: function(event) {
        this.handleFiles(event.value.dataTransfer.files, event);
    },
    
    /** @private */
    handleFiles: function(files, event) {
        if (files !== undefined) {
            var i = files.length, file;
            while (i) {
                file = files[--i];
                if (this.filterFiles(file)) this.handleDroppedFile(file, event);
            }
        } else {
            myt.dumpStack("Browser doesn't support the File API");
        }
    },
    
    filterFiles: function(file) {
        return true;
    },
    
    handleDroppedFile: function(file, event) {}
});


/** Provides AJAX functionality. This is a wrapper around JQuery's ajax
    request. */
myt.Ajax = new JS.Class('Ajax', myt.Node, {
    // Class Methods ///////////////////////////////////////////////////////////
    extend: {
        doRequest: function(opts, successCallback, failureCallback) {
            return $.ajax(opts).done(successCallback).fail(failureCallback);
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.opts = {};
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setUrl: function(v) {
        this.__s('url', v);
    },
    
    /** The request type.
        Supported values: 'GET' or 'POST'. */
    setRequestMethod: function(v) {
        this.__s('type', v);
    },
    
    /** A map of name value pairs for the request. */
    setRequestData: function(v) {
        this.__s('data', v);
    },
    
    /** The response type.
        Supported values: 'xml', 'html', 'json', 'jsonp', 'script', or 'text'. */
    setResponseType: function(v) {
        this.__s('datatype', v);
    },
    
    /** A specialized setter function used by the setters.
        @private */
    __s: function(key, value) {
        if (value) {
            this.opts[key] = value;
        } else {
            delete this.opts[key];
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    doRequest: function(opts, successCallback, failureCallback) {
        // Convert from myt.Ajax opts to JQuery.ajax opts.
        var mappedOpts = myt.extend({
            context:this,
            
            // Store url and anything stored under the "callbackData" and
            // "requestData" key on the jqxhr so we can read it in response 
            // handling code.
            beforeSend: function(jqxhr, settings) {
                jqxhr.callbackData = opts.callbackData;
                jqxhr.requestData = opts.requestData;
                
                jqxhr.requestURL = settings.url;
            }
        }, opts, function(key, target, source) {
            var targetKey = key;
            switch (key) {
                case 'requestData': targetKey = 'data'; break;
                case 'requestMethod': targetKey = 'type'; break;
                case 'responseType': targetKey = 'datatype'; break;
            }
            target[targetKey] = source[key];
        });
        
        return myt.Ajax.doRequest(
            myt.extend({}, this.opts, mappedOpts), 
            successCallback || this.handleSuccess, 
            failureCallback || this.handleFailure
        );
    },
    
    /** Handles request successes.
        @param data: The response data
        @param status: String the response status
        @param jqxhr: The request object */
    handleSuccess: function(data, status, jqxhr) {
        this.fireNewEvent('success', {data:data, status:status, xhr:jqxhr});
    },
    
    /** Handles request failures.
        @param jqxhr: The request object
        @param status: String the response status
        @param exception: XMLHttpRequestException */
    handleFailure: function(jqxhr, status, exception) {
        this.fireNewEvent('failure', {exception:exception, status:status, xhr:jqxhr});
    }
});


/** Provides "form" functionality to a node. Forms can be nested to build
    up larger forms from one or more subforms.
    
    Events:
        isValid:boolean Fired when the form changes validity.
        isChanged:boolean Fired when the form becomes changed or unchanged.
    
    Attributes:
        id:string The unique ID for this form relative to its parent form.
        form:myt.Form A reference to the parent form if it exists.
        errorMessages:array A list of error messages that occurred during the
            last execution of doValidation.
        isValid:boolean Indicates if the data in this form is valid or not.
        isChanged:boolean Indicates if the data in this form is different
            from the rollback value or not.
    
    Private Attributes:
        _lockCascade:boolean Prevents changes to "isChanged" and "isValid" 
            from cascading upwards to the parent form. Used during reset 
            and rollback.
        __sf:object A map of child forms/elements by ID.
        __acc:object A map of method references by accelerator identifier. 
            The values will be function references. An intended use of these 
            is to submit or cancel a form by keystroke.
        __v:array A list of validators to apply to this form.
*/
myt.Form = new JS.Module('Form', {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.isChanged = this._lockCascade = false;
        this.isValid = true;
        
        this.__sf = {};
        this.__v = [];
        this.__acc = {};
        
        this.callSuper(parent, attrs);
        
        if (this.form) this.form.addSubForm(this);
    },
    
    /** @overrides myt.Node. */
    destroy: function() {
        if (this.form) this.form.removeSubForm(this.id);
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setErrorMessages: function(v) {this.errorMessages = v;},
    
    setId: function(v) {
        if (this.id !== v) {
            var existingId = this.id;
            this.id = v;
            
            var form = this.form;
            if (form && this.inited) {
                form.removeSubForm(existingId);
                form.addSubForm(this);
            }
        }
    },
    
    setForm: function(v) {
        if (this.form !== v) {
            var existingForm = this.form;
            this.form = v;
            if (existingForm) existingForm.removeSubForm(this.id);
            if (v && this.inited) v.addSubForm(this);
        }
    },
    
    setIsValid: function(v) {
        // Don't abort when value hasn't changed. The reason this form is
        // invalid may have changed so we want an event to fire so any new
        // error messages can be shown.
        this.isValid = v;
        if (this.inited) this.fireNewEvent('isValid', v);
        
        var form = this.form;
        if (form && !this._lockCascade) {
            if (v) {
                form.verifyValidState(this);
            } else {
                form.notifySubFormInvalid();
            }
        }
    },
    
    setIsChanged: function(v) {
        if (this.isChanged !== v) {
            this.isChanged = v;
            if (this.inited) this.fireNewEvent('isChanged', v);
            
            var form = this.form;
            if (form && !this._lockCascade) {
                if (v) {
                    form.notifySubFormChanged();
                } else {
                    form.verifyChangedState(this);
                }
            }
        }
    },
    
    /** Allows bulk setting of validators.
        @param validators:array An array of myt.Validator instances or
            IDs of validators from the myt.global.validators registry.
        @returns void */
    setValidators: function(validators) {
        var i = validators.length, validator;
        while (i) {
            validator = validators[--i];
            if (typeof validator === 'string') {
                validators[i] = validator = myt.global.validators.getValidator(validator);
                if (!validator) validators.splice(i, 1);
            }
        }
        
        this.__v = validators;
    },
    
    /** Gets the value of this form. For a form this will be a map of
        all the subform values by ID. Form elements should override this
        to return an element specific value.
        @returns object */
    getValue: function() {
        // Allow for superclass to have custom getValue behavior.
        if (this.callSuper) return this.callSuper();
        
        // Only do "form" behavior for true forms, not for form elements.
        if (this.isA(myt.FormElement)) return this.value;
        
        var retval = {}, subForms = this.__sf, id;
        for (id in subForms) retval[id] = subForms[id].getValue();
        return retval;
    },
    
    /** Sets the value of this form. For a form the value should be a map
        containing values for each of the subform elements. The entries in
        the map will be applied to each of the subforms.
        @param value:object the value to set.
        @returns the value that was actually set. */
    setValue: function(value) {
        // Allow for superclass to have custom setValue behavior.
        if (this.callSuper) this.callSuper(value);
        
        // Only do "form" behavior for true forms, not for form elements.
        if (typeof value === 'object' && !this.isA(myt.FormElement)) {
            var subform, id;
            for (id in value) {
                subform = this.getSubForm(id);
                if (subform) {
                    value[id] = subform.setValue(value[id]);
                } else {
                    console.warn("ID in setValue for non-existant subform", id);
                }
            }
        }
        
        // Notify parent form of value change.
        if (this.form) this.form.notifyValueChanged(this);
        
        return value;
    },
    
    /** Gets the default value of this form. For a form this will be a map of
        all the subform default values by ID. Form elements should override this
        to return an element specific default value.
        @returns object */
    getDefaultValue: function() {
        var retval = {}, subForms = this.__sf, id;
        for (id in subForms) retval[id] = subForms[id].getDefaultValue();
        return retval;
    },
    
    /** Sets the default value of this form. For a form the value should be a 
        map containing default values for each of the subform elements. The 
        entries in the map will be applied to each of the subforms.
        @param value:object the value to set.
        @returns the value that was actually set. */
    setDefaultValue: function(value) {
        if (typeof value === 'object') {
            var subform, id;
            for (id in value) {
                subform = this.getSubForm(id);
                if (subform) {
                    value[id] = subform.setDefaultValue(value[id]);
                } else {
                    console.warn("ID in setDefaultValue for non-existant subform", id);
                }
            }
        }
        return value;
    },
    
    /** Gets the rollback value of this form. For a form this will be a map of
        all the subform rollback values by ID. Form elements should override this
        to return an element specific rollback value.
        @returns object */
    getRollbackValue: function() {
        var retval = {}, subForms = this.__sf, id;
        for (id in subForms) retval[id] = subForms[id].getRollbackValue();
        return retval;
    },
    
    /** Sets the rollback value of this form. For a form the value should be a 
        map containing rollback values for each of the subform elements. The 
        entries in the map will be applied to each of the subforms.
        @param value:object the value to set.
        @returns the value that was actually set. */
    setRollbackValue: function(value) {
        if (typeof value === 'object') {
            var subform, id;
            for (id in value) {
                subform = this.getSubForm(id);
                if (subform) {
                    value[id] = subform.setRollbackValue(value[id]);
                } else {
                    console.warn("ID in setRollbackValue for non-existant subform", id);
                }
            }
        }
        return value;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Add an accelerator to this form.
        @param id:string the ID for the accelerator.
        @param func:function the function to call when the accelerator 
            is invoked.
        @returns void */
    addAccelerator: function(id, func) {
        this.__acc[id] = func;
    },
    
    /** Removes an accelerator from this form.
        @param id:string the ID for the accelerator.
        @returns void */
    removeAccelerator: function(id) {
        delete this.__acc[id];
    },
    
    /** Executes an accelerator in this form with the provided ID.
        @param id:string The ID of the accelerator to invoke.
        @param value:* (optional) The value to pass to the function.
        @returns void */
    invokeAccelerator: function(id, value) {
        var accelerator = this.__acc[id];
        if (accelerator) accelerator.call(this, value === undefined ? null : value);
    },
    
    /** Adds a validator to this form.
        @param validator:myt.Validator The validator to add.
        @returns void */
    addValidator: function(validator) {
        if (validator) this.__v.push(validator);
    },
    
    /** Removes a validator from this form.
        @param id:string The ID of the validator to remove.
        @returns the removed myt.Validator or null if not found. */
    removeValidator: function(id) {
        if (id) {
            var validators = this.__v, i = validators.length, validator;
            while (i) {
                validator = validators[--i];
                if (validator.id === id) {
                    validators.splice(i, 1);
                    return validator;
                }
            }
        }
        return null;
    },
    
    /** Gets the oldest ancestor form of this form or the form itself.
        @returns myt.Form */
    getRootForm: function() {
        return this.form ? this.form.getRootForm() : this;
    },
    
    /** Adds an myt.Form to this form.
        @param subform:myt.Form the form to add as a subform.
        @returns void */
    addSubForm: function(subform) {
        var id = subform.id;
        if (this.getSubForm(id) != null) {
            console.warn("ID in use for subform, add aborted.", id, subform);
            return;
        }
        
        subform.setForm(this);
        this.__sf[id] = subform;
        
        if (subform.isChanged) this.notifySubFormChanged();
        if (!subform.isValid) this.notifySubFormInvalid();
    },
    
    /** Removes the subform with the provided ID from this form.
        @param id:string The ID of the form to remove.
        @returns myt.Form or undefined if not found. */
    removeSubForm: function(id) {
        var subform = this.getSubForm(id);
        if (subform) {
            subform.setForm(null);
            delete this.__sf[id];
            this.verifyChangedState();
            this.verifyValidState();
        }
        return subform;
    },
    
    /** Gets the subform with the provided ID from this form.
        @param id:string The ID of the form to get.
        @returns myt.Form or undefined if not found. */
    getSubForm: function(id) {
        return this.__sf[id];
    },
    
    /** Gets all error messages from the entire form tree.
        @returns array of error messages strings. */
    getAllErrorMessages: function() {
        var msgs = this.errorMessages.concat(), subForms = this.__sf, id;
        for (id in subForms) msgs = msgs.concat(subForms[id].getAllErrorMessages());
        return msgs;
    },
    
    /** Called when a subform changes to the "invalid" state.
        @returns void */
    notifySubFormInvalid: function() {
        this.setIsValid(false);
    },
    
    /** Tests if this form is valid or not and updates the isValid attribute 
        if necessary. Allows upwards cascade of validity.
        @param subformToIgnore:myt.Form (optional) A subform that will not
            be checked for validity. This is typically the subform that is
            invoking this method.
        @returns boolean true if this form is valid, false otherwise. */
    verifyValidState: function(subformToIgnore) {
        var isValid = true, subForms = this.__sf, subform, id;
        for (id in subForms) {
            subform = subForms[id];
            if (subform !== subformToIgnore) isValid = subform.isValid && isValid;
        }
        return this.__applyValidation(isValid);
    },
    
    /** Tests if this form is valid or not. Performs a top down validation 
        check across the entire form tree. Does not allow upwards cascade of
        validity check since this is intended to be a top down check.
        @returns boolean true if this form is valid, false otherwise. */
    doValidation: function() {
        var isValid = true, subForms = this.__sf, id;
        for (id in subForms) isValid = subForms[id].doValidation() && isValid;
        
        this._lockCascade = true;
        isValid = this.__applyValidation(isValid);
        this._lockCascade = false;
        
        return isValid;
    },
    
    /** Runs the validators on this form.
        @private
        @param isValid:boolean The currently determined validity.
        @returns boolean true if this form is valid, false otherwise. */
    __applyValidation: function(isValid) {
        var validators = this.__v, len = validators.length, 
            errorMessages = [], i = 0;
        for (; len > i;) isValid = validators[i++].isFormValid(this, null, errorMessages) && isValid;
        
        this.setErrorMessages(errorMessages);
        this.setIsValid(isValid);
        
        return isValid;
    },
    
    /** Called whenever a value changes for the form or any subform therein.
        @param sourceForm:myt.Form the form that had a value change.
        @returns void */
    notifyValueChanged: function(sourceForm) {
        if (this.form) this.form.notifyValueChanged(sourceForm);
    },
    
    /** Called when a subform changed to the "changed" state.
        @returns void */
    notifySubFormChanged: function() {
        this.setIsChanged(true);
    },
    
    /** Tests if this form is changed or not and updates the isChanged 
        attribute if necessary. Allows upwards cascade of changed state.
        @param subformToIgnore:myt.Form (optional) A subform that will not
            be checked for changed state. This is typically the subform that is
            invoking this method.
        @returns boolean true if this form is changed, false otherwise. */
    verifyChangedState: function(subformToIgnore) {
        var isChanged = false, subForms = this.__sf, subform, id;
        for (id in subForms) {
            subform = subForms[id];
            if (subform !== subformToIgnore) isChanged = subform.isChanged || isChanged;
        }
        this.setIsChanged(isChanged);
        return isChanged;
    },
    
    /** Initializes the form to the provided values.
        @param defaultValue:object The default value.
        @param rollbackValue:object The rollback value.
        @param value:object The current value.
        @returns void */
    setup: function(defaultValue, rollbackValue, value) {
        this._lockCascade = true;
        this.setIsChanged(false);
        this.setErrorMessages([]);
        this.setIsValid(true);
        this._lockCascade = false;
        
        if (defaultValue == null) defaultValue = {};
        if (rollbackValue == null) rollbackValue = {};
        if (value == null) value = {};
        
        var subForms = this.__sf, id;
        for (id in subForms) subForms[id].setup(defaultValue[id], rollbackValue[id], value[id]);
    },
    
    /** Resets this form to the default values.
        @returns void */
    resetForm: function() {
        this._lockCascade = true;
        
        var subForms = this.__sf, id;
        for (id in subForms) subForms[id].resetForm();
        
        this.setIsChanged(false);
        this.setErrorMessages([]);
        this.setIsValid(true);
        
        this._lockCascade = false;
    },
    
    /** Rolls back this form to the rollback values.
        @returns void */
    rollbackForm: function() {
        this._lockCascade = true;
        
        var subForms = this.__sf, id;
        for (id in subForms) subForms[id].rollbackForm();
        
        this.setIsChanged(false);
        this.setErrorMessages([]);
        this.setIsValid(true);
        
        this._lockCascade = false;
    },
    
    /** Gets the changed values of this form. For a form this will be a map of
        all the subform values by ID that are in the "changed" state. Form 
        elements should override this to return an element specific value.
        @returns object */
    getChangedValue: function() {
        var retval = {}, subForms = this.__sf, subform, id;
        for (id in subForms) {
            subform = subForms[id];
            if (subform.isChanged) retval[id] = subform.getChangedValue();
        }
        return retval;
    }
});


/** Provides additional common functionality for a root level form.
    
    Accelerators:
        submit: Invokes the doSubmit function which in turn may invoke the
            doValidSubmit or doInvalidSubmit function.
        cancel: Invokes the doCancel function.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.RootForm = new JS.Module('RootForm', {
    include: [myt.Form],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        this.addAccelerator('submit', this.doSubmit);
        this.addAccelerator('cancel', this.doCancel);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    doSubmit: function() {
        if (this.isChanged) {
            if (this.doValidation()) {
                this.doValidSubmit(this.getValue());
            } else {
                this.doInvalidSubmit();
            }
        }
    },
    
    /** Called when the form is submitted and it is valid.
        @returns void */
    doValidSubmit: function(value) {},
    
    /** Called when the form is submitted and it is not valid.
        @returns void */
    doInvalidSubmit: function() {},
    
    /** Rolls back the form and revalidates it.
        @returns void */
    doCancel: function() {
        this.rollbackForm();
        this.doValidation();
    }
});


/** Provides "form" element functionality to a node. A form element is a
    form that actually has a value.
    
    Events:
        defaultValue:* Fired when the default value changes.
        rollbackValue:* Fired when the rollback value changes.
    
    Attributes:
        value:* The current value of the form element.
        rollbackValue:* The rollback value of the form element.
        defaultValue:* The default value of the form element.
    
    Private Attributes:
        __vp:array A list of myt.ValueProcessors that get applied 
            to a value whenever it is retrieved via the methods: 
            getValue, getRollbackValue or getDefaultValue.
*/
myt.FormElement = new JS.Module('FormElement', {
    include: [myt.Form],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.__vp = [];
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.Form */
    getValue: function() {
        return this.__processValue(
            this.callSuper ? this.callSuper() : this.value, myt.ValueProcessor.CURRENT_ATTR
        );
    },
    
    /** @overrides myt.Form */
    setValue: function(value) {
        if (value === undefined) value = this.getRollbackValue();
        if (this.value !== value) {
            this.callSuper(value);
            this.verifyChangedState();
        }
        return value;
    },
    
    /** @overrides myt.Form */
    getDefaultValue: function() {
        return this.__processValue(this.defaultValue, myt.ValueProcessor.DEFAULT_ATTR);
    },
    
    /** @overrides myt.Form */
    setDefaultValue: function(value) {
        if (this.defaultValue !== value) {
            this.defaultValue = value;
            if (this.inited) this.fireNewEvent('defaultValue', value);
            this.verifyChangedState();
        }
        return value;
    },
    
    /** @overrides myt.Form */
    getRollbackValue: function() {
        return this.__processValue(this.rollbackValue, myt.ValueProcessor.ROLLBACK_ATTR);
    },
    
    /** @overrides myt.Form */
    setRollbackValue: function(value) {
        if (value === undefined) value = this.getDefaultValue();
        if (this.rollbackValue !== value) {
            this.rollbackValue = value;
            if (this.inited) this.fireNewEvent('rollbackValue', value);
            this.verifyChangedState();
        }
        return value;
    },
    
    /** Allows bulk setting of ValueProcessors.
        @param processors:array An array of myt.ValueProcessor instances or
            IDs of value processors from the myt.global.valueProcessors 
            registry.
        @returns void */
    setValueProcessors: function(processors) {
        var i = processors.length, processor;
        while (i) {
            processor = processors[--i];
            if (typeof processor === 'string') {
                processors[i] = processor = myt.global.valueProcessors.getValueProcessor(processor);
                if (!processor) processors.splice(i, 1);
            }
        }
        
        this.__vp = processors;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Adds a ValueProcessor to this form element.
        @param processor:myt.ValueProcessor
        @returns void */
    addValueProcessor: function(processor) {
        this.__vp.push(processor);
    },
    
    /** Removes a ValueProcessor from this form element.
        @param id:string the ID of the processor to remove.
        @returns the removed myt.ValueProcessor or null if not found. */
    removeValueProcessor: function(id) {
        if (id) {
            var processors = this.__vp, i = processors.length, processor;
            while (i) {
                processor = processors[--i];
                if (processor.id === id) {
                    processors.splice(i, 1);
                    return processor;
                }
            }
        }
        return null;
    },
    
    /** Runs the provided value through all the ValueProcessors.
        @private
        @param value:* The value to process.
        @param checkAttr:string The name of the attribute on each processor 
            that is checked to see if that processor should be run or not.
        @returns * The processed value. */
    __processValue: function(value, checkAttr) {
        var processors = this.__vp, len = processors.length, processor, i = 0;
        for (; len > i;) {
            processor = processors[i++];
            if (processor[checkAttr]) value = processor.process(value);
        }
        return value;
    },
    
    /** @overrides myt.Form */
    addSubForm: function(subform) {
        myt.dumpStack("addSubForm not supported on form elements.");
    },
    
    /** @overrides myt.Form */
    getSubForm: function(id) {
        myt.dumpStack("getSubForm not supported on form elements.");
        return null;
    },
    
    /** @overrides myt.Form */
    removeSubForm: function(id) {
        myt.dumpStack("removeSubForm not supported on form elements.");
        return null;
    },
    
    /** @overrides myt.Form */
    verifyChangedState: function(subformToIgnore) {
        var isChanged = this.value !== this.rollbackValue;
        this.setIsChanged(isChanged);
        return isChanged;
    },
    
    /** @overrides myt.Form */
    setup: function(defaultValue, rollbackValue, value) {
        this._lockCascade = true;
        
        // Reset values to uninitialized state to make repeated calls to
        // setup behave identically.
        this.defaultValue = undefined;
        this.rollbackValue = undefined;
        this.value = undefined;
        
        this.setDefaultValue(defaultValue);
        this.setRollbackValue(rollbackValue);
        
        this.setIsChanged(false);
        this.setErrorMessages([]);
        this.setIsValid(true);
        
        this._lockCascade = false;
        
        this.setValue(value);
    },
    
    /** @overrides myt.Form */
    resetForm: function() {
        this._lockCascade = true;
        
        var defaultValue = this.getDefaultValue();
        this.setRollbackValue(defaultValue);
        this.setValue(defaultValue);
        
        this.setIsChanged(false);
        this.setErrorMessages([]);
        this.setIsValid(true);
        
        this._lockCascade = false;
    },
    
    /** @overrides myt.Form */
    rollbackForm: function() {
        this._lockCascade = true;
        
        this.setValue(this.getRollbackValue());
        
        this.setIsChanged(false);
        this.setErrorMessages([]);
        this.setIsValid(true);
        
        this._lockCascade = false;
    },
    
    /** @overrides myt.Form
        @returns The current value if this form is in the changed state,
            otherwise undefined. */
    getChangedValue: function() {
        return this.isChanged ? this.getValue() : undefined;
    }
});


/** Component to upload files. */
myt.Uploader = new JS.Class('Uploader', myt.View, {
    include: [myt.DragDropSupport, myt.Disableable, myt.FormElement],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        /** The attribute key used in a file to store the path for the file
            on the server. */
        FILE_ATTR_SERVER_PATH: 'serverPath',
        
        MIME_TYPES_BY_EXTENSION: {
            gif:'image/gif',
            png:'image/png',
            jpg:'image/jpeg',
            jpeg:'image/jpeg'
        },
        
        readFile: function(file, handlerFunc) {
            if (FileReader !== undefined) {
                reader = new FileReader();
                reader.onload = handlerFunc;
                reader.readAsDataURL(file);
            }
        },
        
        isSameFile: function(f1, f2) {
            if (f1 == null || f2 == null) return false;
            return f1.name === f2.name && f1.type === f2.type && f1.size === f2.size;
        },
        
        createFile: function(urlStr) {
            var uri = new myt.URI(urlStr), name = uri.file, ext = name.split('.')[1];
            return {
                name: name,
                serverPath: urlStr,
                size: -1,
                type: this.MIME_TYPES_BY_EXTENSION[ext]
            };
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        this.files = [];
        
        // Modify attrs so setter gets called.
        if (attrs.requestFileParam === undefined) attrs.requestFileParam = 'file';
        if (attrs.maxFiles === undefined) attrs.maxFiles = -1;
        
        this.callSuper(parent, attrs);
        
        var self = this;
        
        // Support click to upload too.
        new myt.NativeInputWrapper(this, {
            name:'fileInput', percentOfParentWidth:100, percentOfParentHeight:100,
            opacity:0.01, disabled:this.disabled, overflow:'hidden'
        }, [myt.SizeToParent, {
            initNode: function(parent, attrs) {
                this.inputType = 'file';
                this.callSuper(parent, attrs);
                this.attachToDom(this, '_handleInput', 'change');
                
                this.domElement.multiple = self.maxFiles > 1;
            },
            
            _handleInput: function(event) {
                self.handleFiles(this.domElement.files, event);
            }
        }]);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Add a "remote" file when the value is set.
        @param v:string the URI for a remote image file. */
    setValue: function(v) {
        this.clearFiles();
        
        if (v) {
            if (!Array.isArray(v)) v = [v];
            var len = v.length, i = 0;
            for(; len > i; ++i) this.addFile(myt.Uploader.createFile(v[i]));
        }
        
        return this.callSuper ? this.callSuper(v) : v;
    },
    
    /** @returns the path to the uploaded files. */
    getValue: function() {
        return this.value;
    },
    
    /** @overrides myt.Disableable */
    setDisabled: function(v) {
        this.callSuper(v);
        
        if (this.fileInput) this.fileInput.setDisabled(v);
    },
    
    setMaxFiles: function(v) {
        if (this.maxFiles !== v) {
            this.maxFiles = v;
            if (this.inited) this.fireNewEvent('maxFiles', v);
            if (this.fileInput) this.fileInput.domElement.multiple = v > 1;
        }
    },
    
    setUploadUrl: function(v) {this.set('uploadUrl', v, true);},
    setRequestFileParam: function(v) {this.set('requestFileParam', v, true);},
    
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    bringSubviewToFront: function(sv) {
        if (sv === this.fileInput) {
            this.callSuper(sv);
        } else {
            this.sendSubviewBehind(sv, this.fileInput);
        }
    },
    
    /** @overrides myt.View */
    subviewAdded: function(sv) {
        this.callSuper(sv);
        
        if (this.fileInput) this.bringSubviewToFront(this.fileInput);
    },
    
    handleDroppedFile: function(file, event) {
        this.addFile(file);
    },
    
    /** @overrides myt.DragDropSupport */
    filterFiles: function(file) {
        var maxFiles = this.maxFiles;
        if (maxFiles >= 0 && this.files.length >= maxFiles) return false;
        
        return true;
    },
    
    uploadFiles: function(url, fileParam) {
        url = url || this.uploadUrl;
        
        var files = this.files, i = files.length;
        while (i) this.uploadFile(files[--i], url, fileParam);
    },
    
    uploadFile: function(file, url, fileParam) {
        url = url || this.uploadUrl;
        fileParam = fileParam || this.requestFileParam;
        
        var self = this;
        var ajax = new myt.Ajax(this, {
            url:url, requestMethod:'post', responseType:'json'
        }, [{
            handleSuccess: function(data, status, jqxhr) {
                this.callSuper(data, status, jqxhr);
                self.handleUploadSuccess(file, data, status, jqxhr);
            },
            
            handleFailure: function(jqxhr, status, exception) {
                this.callSuper(jqxhr, status, exception);
                self.handleUploadFailure(file, jqxhr, status, exception);
            }
        }]);
        
        var formData = new FormData();
        formData.append(fileParam, file, file.name);
        ajax.setRequestData(formData);
        
        ajax.doRequest({
            contentType:false,
            cache: false,
            processData: false
        });
    },
    
    handleUploadSuccess: function(file, data, status, jqxhr) {
        file[myt.Uploader.FILE_ATTR_SERVER_PATH] = this.parseServerPathFromResponse(data);
        this.updateValueFromFiles();
    },
    
    handleUploadFailure: function(file, jqxhr, status, exception) {
        myt.dumpStack("XHR failure: " + status + " : " + exception);
    },
    
    /** Subclasses must implement this to extract the uploaded file path from
        the response. By default this return null. */
    parseServerPathFromResponse: function(data) {
        return null;
    },
    
    addFile: function(file) {
        this.files.push(file);
        this.updateValueFromFiles();
        this.fireNewEvent('addFile', file);
    },
    
    removeFile: function(file) {
        var files = this.files, i = files.length;
        while (i) {
            if (myt.Uploader.isSameFile(files[--i], file)) {
                files.splice(i, 1);
                this.updateValueFromFiles();
                this.fireNewEvent('removeFile', file);
                break;
            }
        }
    },
    
    updateValueFromFiles: function() {
        var value = [], files = this.files, i = files.length, serverPath;
        while (i) {
            serverPath = files[--i][myt.Uploader.FILE_ATTR_SERVER_PATH];
            if (serverPath) value.push(serverPath);
        }
        
        var len = value.length;
        this.value = len === 1 ? value[0] : (len === 0 ? undefined : value);
        
        this.verifyChangedState(); // FIXME: mimics what happens in myt.FormElement setValue
        if (this.form) this.form.notifyValueChanged(this); // FIXME: mimics what happens in myt.Form setValue
        
        this.fireNewEvent('value', this.value);
    },
    
    clearFiles: function() {
        var files = this.files, i = files.length;
        while (i) this.removeFile(files[--i]);
    }
});


/** Component to upload image files. */
myt.ImageUploader = new JS.Class('ImageUploader', myt.Uploader, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        isImageFile: function(file) {
            return (/image/i).test(file.type);
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        attrs.maxFiles = 1;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    filterFiles: function(file) {
        if (!myt.ImageUploader.isImageFile(file)) return false;
        
        // Remove existing file
        while (this.files.length > 0) this.removeFile(this.files[0]);
        
        retval = this.callSuper(file);
        if (!retval) return false;
        
        return true;
    },
    
    addFile: function(file) {
        this.callSuper(file);
        
        var image = this.getImageToReadInto();
        if (image) {
            image.file = file;
            this.readImageInto(file, image);
        }
    },
    
    getImageToReadInto: function() {
        return new myt.Image(this, {
            useNaturalSize:false, align:'center', valign:'middle'
        });
    },
    
    scaleToFit: function(boundsWidth, boundsHeight, imgWidth, imgHeight) {
        var boundsRatio = boundsWidth / boundsHeight;
        var imgRatio = imgWidth / imgHeight;
        
        if (imgRatio > boundsRatio) {
            return [boundsWidth, imgHeight * boundsWidth / imgWidth];
        } else {
            return [imgWidth * boundsHeight / imgHeight, boundsHeight];
        }
    },
    
    removeFile: function(file) {
        this.callSuper(file);
        
        var images = this.getSubviews(), i = images.length, image;
        while (i) {
            image = images[--i];
            if (myt.Uploader.isSameFile(image.file, file)) {
                image.destroy();
                break;
            }
        }
    },
    
    handleDroppedFile: function(file, event) {
        this.callSuper(file, event);
        
        this.uploadFile(file, this.uploadUrl);
    },
    
    readImageInto: function(file, image) {
        var self = this;
        if (file.size === -1) {
            var img = new Image();
            img.onload = function() {
                file.width = this.width;
                file.height = this.height;
                
                if (!image || image.destroyed) return
                
                self.updateImage(file, image, this.src);
            };
            img.src = file.serverPath;
        } else if (FileReader !== undefined && myt.ImageUploader.isImageFile(file)) {
            myt.Uploader.readFile(file, function(event) {
                var img = new Image();
                img.onload = function() {
                    file.width = this.width;
                    file.height = this.height;
                    
                    if (!image || image.destroyed) return
                    
                    self.updateImage(file, image, this.src);
                };
                img.src = event.target.result;
            });
        }
    },
    
    updateImage: function(file, image, src) {
        var size = this.scaleToFit(this.width, this.height, file.width, file.height),
            w = Math.round(size[0]), 
            h = Math.round(size[1]);
        image.setImageSize(w + 'px ' + h + 'px');
        image.setWidth(w);
        image.setHeight(h);
        image.setImageUrl(src);
    }
});


// Spectrum Colorpicker v1.4.1
// https://github.com/bgrins/spectrum
// Author: Brian Grinstead
// License: MIT
(function (window, $, undefined) {
    "use strict";

    var defaultOpts = {
        color: false,
        allowEmpty: true,
        showSelectionPalette: true,
        localStorageKey: false,
        selectionWrapSize: 8,
        maxSelectionSize: 56,
        clearText: "Clear Color Selection",
        noColorSelectedText: "No Color Selected",
        palette: [],
        selectionPalette: []
    },
    spectrums = [],
    IE = BrowserDetect.browser === 'Explorer',
    markup = (function () {
        // IE does not support gradients with multiple stops, so we need to simulate
        //  that for the rainbow slider with 8 divs that each have a single gradient
        var gradientFix = "";
        if (IE) {
            for (var i = 1; i <= 6; i++) gradientFix += "<div class='sp-" + i + "'></div>";
        }

        return [
            "<div class='sp-container'>",
                "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                "</div>",
                "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                        "<div class='sp-fill'></div>",
                        "<div class='sp-top-inner'>",
                            "<div class='sp-color'>",
                                "<div class='sp-sat'>",
                                    "<div class='sp-val'>",
                                        "<div class='sp-dragger'></div>",
                                    "</div>",
                                "</div>",
                            "</div>",
                            "<div class='sp-clear sp-clear-display'>",
                            "</div>",
                            "<div class='sp-hue'>",
                                "<div class='sp-slider'></div>",
                                gradientFix,
                            "</div>",
                        "</div>",
                    "</div>",
                    "<div class='sp-input-container sp-cf'>",
                        "<input class='sp-input' type='text' spellcheck='false'/>",
                    "</div>",
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                "</div>",
            "</div>"
        ].join("");
    })();

    function paletteTemplate(p, color, opts) {
        var html = [];
        for (var i = 0; i < p.length; i++) {
            var current = p[i];
            if (current) {
                var tiny = tinycolor(current);
                var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
                c += tinycolor.equals(color, current) ? " sp-thumb-active" : "";
                var swatchStyle = "background-color:" + tiny.toHexString();
                html.push('<span title="' + tiny.toHexString() + '" data-color="' + tiny.toHexString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
            } else {
                var cls = 'sp-clear-display';
                html.push($('<div />')
                    .append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>')
                        .attr('title', opts.noColorSelectedText)
                    ).html()
                );
            }
        }
        return "<div class='sp-cf'>" + html.join('') + "</div>";
    }

    function spectrum(element, o) {
        var opts = myt.extend({}, defaultOpts, o),
            showSelectionPalette = opts.showSelectionPalette,
            localStorageKey = opts.localStorageKey,
            dragWidth = 0,
            dragHeight = 0,
            dragHelperHeight = 0,
            slideHeight = 0,
            slideWidth = 0,
            slideHelperHeight = 0,
            currentHue = 0,
            currentSaturation = 0,
            currentValue = 0,
            palette = [],
            paletteArray = [],
            paletteLookup = {},
            selectionPalette = opts.selectionPalette.slice(0),
            selectionWrapSize = opts.selectionWrapSize,
            maxSelectionSize = opts.maxSelectionSize,
            draggingClass = "sp-dragging",
            shiftMovementDirection = null;

        var doc = element.ownerDocument,
            body = doc.body,
            boundElement = $(element),
            container = $(markup, doc),
            pickerContainer = container.find(".sp-picker-container"),
            dragger = container.find(".sp-color"),
            dragHelper = container.find(".sp-dragger"),
            slider = container.find(".sp-hue"),
            slideHelper = container.find(".sp-slider"),
            textInput = container.find(".sp-input"),
            paletteContainer = container.find(".sp-palette"),
            initialColorContainer = container.find(".sp-initial"),
            clearButton = container.find(".sp-clear"),
            initialColor = opts.color,
            colorOnShow = false,
            isEmpty = !initialColor,
            allowEmpty = opts.allowEmpty,
            dialog = opts.dialog;

        function applyOptions() {
            if (opts.palette) {
                palette = opts.palette.slice(0);
                paletteArray = Array.isArray(palette[0]) ? palette : [palette];
                paletteLookup = {};
                for (var i = 0; i < paletteArray.length; i++) {
                    for (var j = 0; j < paletteArray[i].length; j++) {
                        var rgb = tinycolor(paletteArray[i][j]).toHexString();
                        paletteLookup[rgb] = true;
                    }
                }
            }
            container.toggleClass("sp-clear-enabled", allowEmpty);
            reflow();
        }

        function initialize() {
            if (IE) container.find("*:not(input)").attr("unselectable", "on");

            applyOptions();

            if (!allowEmpty) clearButton.hide();

            boundElement.after(container).hide();

            updateSelectionPaletteFromStorage();

            // Handle user typed input
            textInput.change(setFromTextInput);
            textInput.bind("paste", function() {
                setTimeout(setFromTextInput, 1);
            });
            textInput.keydown(function(e) {if (e.keyCode == 13) {setFromTextInput();}});

            clearButton.attr("title", opts.clearText);
            clearButton.bind("click.spectrum", function(e) {
                e.stopPropagation();
                e.preventDefault();
                isEmpty = true;
                updateUI();
            });

            draggable(slider, function(dragX, dragY) {
                currentHue = parseFloat(dragY / slideHeight);
                isEmpty = false;
                updateUI();
            }, dragStart, dragStop);

            draggable(dragger, function(dragX, dragY, e) {
                // shift+drag should snap the movement to either the x or y axis.
                if (!e.shiftKey) {
                    shiftMovementDirection = null;
                } else if (!shiftMovementDirection) {
                    var oldDragX = currentSaturation * dragWidth;
                    var oldDragY = dragHeight - (currentValue * dragHeight);
                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
                    shiftMovementDirection = furtherFromX ? "x" : "y";
                }

                var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
                var setValue = !shiftMovementDirection || shiftMovementDirection === "y";

                if (setSaturation) currentSaturation = parseFloat(dragX / dragWidth);
                if (setValue) currentValue = parseFloat((dragHeight - dragY) / dragHeight);

                isEmpty = false;

                updateUI();
            }, dragStart, dragStop);

            if (!!initialColor) {
                set(initialColor);
                addColorToSelectionPalette(initialColor);
            }

            reflow();
            colorOnShow = get();
            updateUI();

            function paletteElementClick(e) {
                set($(e.target).closest(".sp-thumb-el").data("color"));
                updateUI();
                return false;
            }

            var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum";
            paletteContainer.delegate(".sp-thumb-el", paletteEvent, paletteElementClick);
            initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, paletteElementClick);
        }

        function updateSelectionPaletteFromStorage() {
            if (localStorageKey && window.localStorage) {
                try {
                    selectionPalette = window.localStorage[localStorageKey].split(";");
                } catch (e) {}
            }
        }

        function addColorToSelectionPalette(color) {
            if (showSelectionPalette) {
                var rgb = tinycolor(color).toHexString();
                if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
                    selectionPalette.push(rgb);
                    while (selectionPalette.length > maxSelectionSize) selectionPalette.shift();
                }

                if (localStorageKey && window.localStorage) {
                    try {
                        window.localStorage[localStorageKey] = selectionPalette.join(";");
                    } catch(e) {}
                }
            }
        }

        function getUniqueSelectionPalette() {
            var unique = [];
            for (var i = 0; i < selectionPalette.length; i++) {
                var rgb = tinycolor(selectionPalette[i]).toHexString();
                if (!paletteLookup[rgb]) unique.push(selectionPalette[i]);
            }
            return unique.reverse().slice(0, opts.maxSelectionSize);
        }

        function drawPalette() {
            var currentColor = get();

            var html = $.map(paletteArray, function (palette, i) {
                return paletteTemplate(palette, currentColor, opts);
            });

            updateSelectionPaletteFromStorage();

            if (selectionPalette) {
                var uniquePalette = getUniqueSelectionPalette();
                for (var i = 0, len = uniquePalette.length; len > i; i += selectionWrapSize) {
                    html.push(paletteTemplate(uniquePalette.slice(i, i + selectionWrapSize), currentColor, opts));
                }
            }

            paletteContainer.html(html.join(""));
        }

        function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) reflow();
            container.addClass(draggingClass);
            shiftMovementDirection = null;
            boundElement.trigger('dragstart.spectrum', [get()]);
        }

        function dragStop() {
            container.removeClass(draggingClass);
            boundElement.trigger('dragstop.spectrum', [get()]);
        }

        function setFromTextInput() {
            var value = textInput.val();
            if ((value === null || value === "") && allowEmpty) {
                set(null);
            } else {
                var tiny = tinycolor(value);
                if (tiny.isValid()) {
                    set(tiny);
                } else {
                    textInput.addClass("sp-validation-error");
                }
            }
        }

        function set(color) {
            if (!tinycolor.equals(color, get())) {
                var newColor, newHsv;
                if (!color && allowEmpty) {
                    isEmpty = true;
                } else {
                    isEmpty = false;
                    newColor = tinycolor(color);
                    newHsv = newColor.toHsv();
                    currentHue = (newHsv.h % 360) / 360;
                    currentSaturation = newHsv.s;
                    currentValue = newHsv.v;
                }
            }

            // Update UI just in case a validation error needs to be cleared.
            updateUI();
        }

        function get() {
            if (allowEmpty && isEmpty) return null;

            return tinycolor.fromRatio({
                h: currentHue,
                s: currentSaturation,
                v: currentValue
            });
        }

        function updateUI() {
            textInput.removeClass("sp-validation-error");

            updateHelperLocations();

            // Update dragger background color (gradients take care of saturation and value).
            var flatColor = tinycolor.fromRatio({h:currentHue, s:1, v:1});
            dragger.css("background-color", flatColor.toHexString());

            var realColor = get(),
                displayColor = (realColor || !allowEmpty) ? realColor.toHexString() : '';

            // Update the text entry input as it changes happen
            textInput.val(displayColor);

            drawPalette();

            // Draw initial
            var initial = colorOnShow;
            var current = get();
            initialColorContainer.html(paletteTemplate([initial, current], current, opts));
        }

        function updateHelperLocations() {
            if (allowEmpty && isEmpty) {
                // if selected color is empty, hide the helpers
                slideHelper.hide();
                dragHelper.hide();
            } else {
                // make sure helpers are visible
                slideHelper.show();
                dragHelper.show();

                // Where to show the little circle in that displays your current selected color
                var dragX = currentSaturation * dragWidth,
                    dragY = dragHeight - (currentValue * dragHeight);
                dragX = Math.max(
                    -dragHelperHeight,
                    Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
                );
                dragY = Math.max(
                    -dragHelperHeight,
                    Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
                );
                dragHelper.css({
                    "top": dragY + "px",
                    "left": dragX + "px"
                });

                // Where to show the bar that displays your current selected hue
                var slideY = currentHue * slideHeight;
                slideHelper.css({
                    "top": (slideY - slideHelperHeight) + "px"
                });
            }
        }

        function reflow() {
            dragWidth = dragger.width();
            dragHeight = dragger.height();
            dragHelperHeight = dragHelper.height();
            slideWidth = slider.width();
            slideHeight = slider.height();
            slideHelperHeight = slideHelper.height();

            updateHelperLocations();
            drawPalette();

            boundElement.trigger('reflow.spectrum');
        }

        function destroy() {
            boundElement.show();
            container.remove();
            spectrums[spect.id] = null;
        }

        function option(optionName, optionValue) {
            if (optionName === undefined) return myt.extend({}, opts);
            if (optionValue === undefined) return opts[optionName];

            opts[optionName] = optionValue;
            applyOptions();
        }

        initialize();

        var spect = {
            reflow: reflow,
            option: option,
            set: set,
            addColorToSelectionPalette: addColorToSelectionPalette,
            get: get,
            destroy: destroy,
            container: container
        };

        spect.id = spectrums.push(spect) - 1;

        dialog._spectrumCallback(spect);

        return spect;
    }

    /**
      * Lightweight drag helper.  Handles containment within the element, so that
      * when dragging, the x is within [0,element.width] and y is within [0,element.height]
      */
    function draggable(element, onmove, onstart, onstop) {
        onmove = onmove || function () { };
        onstart = onstart || function () { };
        onstop = onstop || function () { };
        var doc = element.ownerDocument || document;
        var dragging = false;
        var offset = {};
        var maxHeight = 0;
        var maxWidth = 0;

        var duringDragEvents = {};
        duringDragEvents["selectstart"] = prevent;
        duringDragEvents["dragstart"] = prevent;
        duringDragEvents["mousemove"] = move;
        duringDragEvents["mouseup"] = stop;

        function prevent(e) {
            if (e.stopPropagation) e.stopPropagation();
            if (e.preventDefault) e.preventDefault();
            e.returnValue = false;
        }

        function move(e) {
            if (dragging) {
                // Mouseup happened outside of window
                if (IE && document.documentMode < 9 && !e.button) return stop();

                var dragX = Math.max(0, Math.min(e.pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(e.pageY - offset.top, maxHeight));
                onmove.apply(element, [dragX, dragY, e]);
            }
        }

        function start(e) {
            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

            if (!rightclick && !dragging) {
                if (onstart.apply(element, arguments) !== false) {
                    dragging = true;
                    maxHeight = $(element).height();
                    maxWidth = $(element).width();
                    offset = $(element).offset();

                    $(doc).bind(duringDragEvents);
                    $(doc.body).addClass("sp-dragging");

                    move(e);
                    prevent(e);
                }
            }
        }

        function stop() {
            if (dragging) {
                $(doc).unbind(duringDragEvents);
                $(doc.body).removeClass("sp-dragging");
                onstop.apply(element, arguments);
            }
            dragging = false;
        }

        $(element).bind("mousedown", start);
    }

    /**
      * Define a jQuery plugin
      */
    var dataID = "spectrum.id";
    $.fn.spectrum = function (opts, extra) {
        if (typeof opts == "string") {
            var returnValue = this;
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function () {
                var spect = spectrums[$(this).data(dataID)];
                if (spect) {
                    var method = spect[opts];
                    if (!method) {
                        throw new Error( "Spectrum: no such method: '" + opts + "'" );
                    }

                    if (opts == "get") {
                        returnValue = spect.get();
                    } else if (opts == "container") {
                        returnValue = spect.container;
                    } else if (opts == "option") {
                        returnValue = spect.option.apply(spect, args);
                    } else if (opts == "destroy") {
                        spect.destroy();
                        $(this).removeData(dataID);
                    } else {
                        method.apply(spect, args);
                    }
                }
            });
            return returnValue;
        }

        // Initializing a new instance of spectrum
        return this.spectrum("destroy").each(function () {
            var options = myt.extend({}, opts, $(this).data());
            var spect = spectrum(this, options);
            $(this).data(dataID, spect.id);
        });
    };

    $.fn.spectrum.load = true;
    $.fn.spectrum.draggable = draggable;
    $.fn.spectrum.defaults = defaultOpts;
    $.spectrum = {};

    // TinyColor v1.0.0
    // https://github.com/bgrins/TinyColor
    // Brian Grinstead, MIT License
    (function() {

    var trimHash = /^[#]+/,
        math = Math,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max;

    var tinycolor = function tinycolor(color) {
        color = color ? color : '';

        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) return color;

        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) return new tinycolor(color);

        // Input to RGB
        var rgb = {r:0, g:0, b:0},
            ok = false;
        if (typeof color == "string") color = stringInputToObject(color);
        if (typeof color == "object") {
            if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
            } else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
                color.s = convertToPercentage(color.s);
                color.v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, color.s, color.v);
                ok = true;
            }
        }

        this._r = mathMin(255, mathMax(rgb.r, 0));
        this._g = mathMin(255, mathMax(rgb.g, 0));
        this._b = mathMin(255, mathMax(rgb.b, 0));
        this._ok = ok;

        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) this._r = mathRound(this._r);
        if (this._g < 1) this._g = mathRound(this._g);
        if (this._b < 1) this._b = mathRound(this._b);
    };

    tinycolor.prototype = {
        isValid: function() {
            return this._ok;
        },
        toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return {h:hsv.h * 360, s:hsv.s, v:hsv.v};
        },
        toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return {h:hsl.h * 360, s:hsl.s, l:hsl.l};
        },
        toHexString: function() {
            return myt.Color.rgbToHex(this._r, this._g, this._b, true);
        }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function(color) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) newColor[i] = convertToPercentage(color[i]);
            }
            color = newColor;
        }
        return tinycolor(color);
    };

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) return false;
        return tinycolor(color1).toHexString() == tinycolor(color2).toHexString();
    };

    // `rgbToHsl`, `rgbToHsv`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
        return {
            r:bound01(r, 255) * 255,
            g:bound01(g, 255) * 255,
            b:bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return {h:h, s:s, l:l};
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if (max == min) {
            h = 0; // achromatic
        } else {
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return {h:h, s:s, v:v};
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return {r:r * 255, g:g * 255, b:b * 255};
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        var isString = typeof n == "string";
        if (isString && n.indexOf('.') != -1 && parseFloat(n) === 1) n = "100%";

        var isPercentage = isString && n.indexOf('%') != -1;
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (isPercentage) n = parseInt(n * max, 10) / 100;

        // Handle floating point rounding errors
        if (math.abs(n - max) < 0.000001) return 1;

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        return n <= 1 ? (n * 100) + "%" : n;
    }

    var matchers = (function() {
        // Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)";
        return {
            rgb: new RegExp("rgb[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?"),
            hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {
        color = color.trim().toLowerCase().replace(trimHash, '');

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if (match = matchers.rgb.exec(color)) return {r:match[1], g:match[2], b:match[3]};
        if (match = matchers.hex6.exec(color)) {
            return {
                r: parseInt(match[1], 16),
                g: parseInt(match[2], 16),
                b: parseInt(match[3], 16)
            };
        }
        return false;
    }

    window.tinycolor = tinycolor;
    })();

})(window, jQuery);


/** A dimmer that can be placed on another myt.View to obscure the subviews of
    that view.
    
    Events:
        None
    
    Attributes:
        restoreFocus:boolean when true focus will be sent back to the view
            that had focus before the dimmer was shown when the dimmer is
            hidden. Defaults to true.
        prevFocus:myt.View or dom element. The thing to set focus on when
            the dimmer is hidden if restoreFocus is true.
*/
myt.Dimmer = new JS.Class('Dimmer', myt.View, {
    include: [myt.SizeToParent],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_OPACITY: 0.35,
        DEFAULT_COLOR: '#000000'
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        this.restoreFocus = true;
        
        attrs.focusable = attrs.focusCage = true;
        
        if (attrs.percentOfParentWidth === undefined) attrs.percentOfParentWidth = 100;
        if (attrs.percentOfParentHeight === undefined) attrs.percentOfParentHeight = 100;
        if (attrs.visible === undefined) attrs.visible = false;
        if (attrs.ignoreLayout === undefined) attrs.ignoreLayout = true;
        
        this.callSuper(parent, attrs);
        
        // Eat mouse events
        this.attachDomObserver(this, 'eatMouseEvent', 'mouseover');
        this.attachDomObserver(this, 'eatMouseEvent', 'mouseout');
        this.attachDomObserver(this, 'eatMouseEvent', 'mousedown');
        this.attachDomObserver(this, 'eatMouseEvent', 'mouseup');
        this.attachDomObserver(this, 'eatMouseEvent', 'click');
        this.attachDomObserver(this, 'eatMouseEvent', 'dblclick');
        this.attachDomObserver(this, 'eatMouseEvent', 'mousemove');
        
        myt.RootView.setupCaptureDrop(this);
    },
    
    /** @overrides myt.View */
    doBeforeAdoption: function() {
        this.callSuper();
        
        var D = myt.Dimmer;
        new myt.View(this, {
            name:'overlay', ignorePlacement:true, 
            opacity:D.DEFAULT_OPACITY,
            bgColor:D.DEFAULT_COLOR,
            percentOfParentWidth:100,
            percentOfParentHeight:100
        }, [myt.SizeToParent]);
    },
    
    /** @overrides myt.View */
    destroyAfterOrphaning: function() {
        myt.RootView.teardownCaptureDrop(this);
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setRestoreFocus: function(v) {this.restoreFocus = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** A handler for mouse events that does nothing and prevents propogation.
        @return boolean True so that the dom event gets eaten. */
    eatMouseEvent: function(event) {
        return true;
    },
    
    /** Shows the dimmer and remembers the focus location.
        @returns void */
    show: function() {
        var gf = myt.global.focus;
        this.prevFocus = gf.focusedView || gf.focusedDom;
        
        this.makeHighestZIndex();
        
        // Prevent focus traversing
        if (this.focusable) this.focus();
        
        this.setVisible(true);
    },
    
    /** Hides the dimmer and restores focus if necessary.
        @returns void */
    hide: function(ignoreRestoreFocus) {
        this.setVisible(false);
        
        if (!ignoreRestoreFocus && this.restoreFocus && this.prevFocus) this.prevFocus.focus();
    }
});


/** An myt.Dimmer that also provides a content panel. */
myt.ModalPanel = new JS.Class('ModalPanel', myt.Dimmer, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_PADDING_X:20,
        DEFAULT_PADDING_Y:15
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.defaultPlacement = 'content';
        
        this.callSuper(parent, attrs);
    },
    
    doBeforeAdoption: function() {
        this.callSuper();
        
        var content = new myt.View(this, {
            name:'content', ignorePlacement:true, align:'center', valign:'middle'
        });
        var MP = myt.ModalPanel;
        new myt.SizeToChildren(content, {
            name:'sizeToChildren', axis:'both',
            paddingX:MP.DEFAULT_PADDING_X, 
            paddingY:MP.DEFAULT_PADDING_Y
        });
    }
});


/** A spinner. Makes use of Spin.js.
    
    Events:
        None
    
    Attributes:
        lines:number
        length:number
        lineWidth:number
        radius:number
        corners:number
        lineColor:string
        direction:number
        speed:number
        trail:number
        lineOpacity:number
    
    Private Attributes:
        __spinner:Spinner the Spin.js spinner.
*/
myt.Spinner = new JS.Class('Spinner', myt.View, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        this.lines = 12;
        this.length = 7;
        this.lineWidth = 5;
        this.radius = 10;
        this.corners = 1;
        this.lineColor = '#000000';
        this.direction = this.speed = 1;
        this.trail = 100;
        this.lineOpacity = 0.25;
        
        if (attrs.visible === undefined) attrs.visible = false;
        
        this.callSuper(parent, attrs);
        
        if (this.visible) this.__show();
    },
    
    /** @overrides myt.View */
    destroyBeforeOrphaning: function() {
        this.__hide();
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setLines: function(v) {this.lines = v;},
    setLength: function(v) {this.length = v;},
    setLineWidth: function(v) {this.lineWidth = v;},
    setRadius: function(v) {this.radius = v;},
    setCorners: function(v) {this.corners = v;},
    setLineColor: function(v) {this.lineColor = v;},
    setDirection: function(v) {this.direction = v;},
    setSpeed: function(v) {this.speed = v;},
    setTrail: function(v) {this.trail = v;},
    setLineOpacity: function(v) {this.lineOpacity = v;},
    
    /** @overrides myt.View */
    setVisible: function(v) {
        this.callSuper(v);
        
        if (this.inited) {
            if (this.visible) {
                this.__show();
            } else {
                this.__hide();
            }
        }
    },
    
    getSize: function() {
        return 2 * (this.radius + this.length + this.lineWidth);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __show: function() {
        var spinner = this.__spinner || (this.__spinner = new myt.Spinner.FACTORY({
            lines:this.lines, 
            length:this.length, 
            width:this.lineWidth, 
            radius:this.radius, 
            corners:this.corners,
            color:this.lineColor,
            direction:this.direction,
            speed:this.speed,
            trail:this.trail,
            opacity:this.lineOpacity
        }));
        
        var size = this.getSize();
        this.setWidth(size);
        this.setHeight(size);
        
        spinner.spin(this.domElement);
    },
    
    /** @private */
    __hide: function() {
        var spinner = this.__spinner;
        if (spinner) spinner.stop();
    }
});

/**
 * Copyright (c) 2011-2013 Felix Gnass
 * Licensed under the MIT license
 * 
 * fgnass.github.com/spin.js#v1.3
 */
myt.Spinner.FACTORY = function() {
  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */
    , animations = {} /* Animation rules keyed by their name */
    , useCssAnimations /* Whether to use CSS animations or setTimeout */

  /**
   * Utility function to create elements. If no tag name is given,
   * a DIV is created. Optionally properties can be passed.
   */
  function createEl(tag, prop) {
    var el = document.createElement(tag || 'div')
      , n

    for(n in prop) el[n] = prop[n]
    return el
  }

  /**
   * Appends children and returns the parent.
   */
  function ins(parent /* child1, child2, ...*/) {
    for (var i=1, n=arguments.length; i<n; i++)
      parent.appendChild(arguments[i])

    return parent
  }

  /**
   * Insert a new stylesheet to hold the @keyframe or VML rules.
   */
  var sheet = (function() {
    var el = createEl('style', {type : 'text/css'})
    ins(myt.getElement('head'), el)
    return el.sheet || el.styleSheet
  }())

  /**
   * Creates an opacity keyframe animation rule and returns its name.
   * Since most mobile Webkits have timing issues with animation-delay,
   * we create separate rules for each line/segment.
   */
  function addAnimation(alpha, trail, i, lines) {
    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')
      , start = 0.01 + i/lines * 100
      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)
      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()
      , pre = prefix && '-' + prefix + '-' || ''

    if (!animations[name]) {
      sheet.insertRule(
        '@' + pre + 'keyframes ' + name + '{' +
        '0%{opacity:' + z + '}' +
        start + '%{opacity:' + alpha + '}' +
        (start+0.01) + '%{opacity:1}' +
        (start+trail) % 100 + '%{opacity:' + alpha + '}' +
        '100%{opacity:' + z + '}' +
        '}', sheet.cssRules.length)

      animations[name] = 1
    }

    return name
  }

  /**
   * Tries various vendor prefixes and returns the first supported property.
   */
  function vendor(el, prop) {
    var s = el.style
      , pp
      , i

    if(s[prop] !== undefined) return prop
    prop = prop.charAt(0).toUpperCase() + prop.slice(1)
    for(i=0; i<prefixes.length; i++) {
      pp = prefixes[i]+prop
      if(s[pp] !== undefined) return pp
    }
  }

  /**
   * Sets multiple style properties at once.
   */
  function css(el, prop) {
    for (var n in prop)
      el.style[vendor(el, n)||n] = prop[n]

    return el
  }

  /** The constructor */
  function Spinner(o) {
    this.opts = o;
  }

  /**
   * Adds the spinner to the given target element. If this instance is already
   * spinning, it is automatically removed from its previous target b calling
   * stop() internally.
   */
  Spinner.prototype.spin = function(target) {
    this.stop()
    var el = this.el = css(createEl(), {
      position:'relative',
      left:(target.offsetWidth >> 1) + 'px',
      top:(target.offsetHeight >> 1) + 'px'
    })
    target.insertBefore(el, null)
    this.lines(el, this.opts)
    return this
  }
  
  /**
   * Stops and removes the Spinner.
   */
  Spinner.prototype.stop = function() {
    var el = this.el
    if (el) {
      if (el.parentNode) el.parentNode.removeChild(el)
      this.el = undefined
    }
    return this
  }
  
  /**
   * Internal method that draws the individual lines. Will be overwritten
   * in VML fallback mode below.
   */
  Spinner.prototype.lines = function(el, o) {
    var i = 0
      , start = (o.lines - 1) * (1 - o.direction) / 2
      , seg
    
    function fill(color) {
      return css(createEl(), {
        position: 'absolute',
        width: (o.length+o.width) + 'px',
        height: o.width + 'px',
        background: color,
        transformOrigin: 'left',
        transform: 'rotate(' + ~~(360/o.lines*i) + 'deg) translate(' + o.radius+'px' +',0)',
        borderRadius: (o.corners * o.width>>1) + 'px'
      })
    }
    
    for (; i < o.lines; i++) {
      seg = css(createEl(), {
        position: 'absolute',
        top: 1+~(o.width/2) + 'px',
        transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
        opacity: o.opacity,
        animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'
      })
      
      ins(el, ins(seg, fill(o.color)))
    }
    return el
  }

  var probe = css(createEl('group'))
  useCssAnimations = vendor(probe, 'animation')

  return Spinner
}();


/** A modal panel that contains a Dialog.
    
    Events:
        None
    
    Attributes:
        displayMode:string (read only) Indicates what kind of dialog this 
            component is currently configured as. Allowed values are: 'blank',
            'message', 'spinner', 'color_picker' and 'confirm'.
        callbackFunction:function (read only) A function that gets called when 
            the dialog is about to be closed. A single argument is passed in 
            that indicates the UI element interacted with that should close the 
            dialog. Supported values are: 'closeBtn', 'cancelBtn' and 
            'confirmBtn'. The function should return true if the close should 
            be aborted.
*/
myt.Dialog = new JS.Class('Dialog', myt.ModalPanel, {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_RADIUS: 12,
        DEFAULT_SHADOW: [0, 4, 20, '#666666'],
        DEFAULT_BGCOLOR: '#ffffff',
        
        /** Makes the text wrap at 200px and the dialog will be at
            least 200px wide. */
        WRAP_TEXT_DEFAULTS: {
            width:200,
            fontWeight:'bold',
            whiteSpace:'normal',
            wordWrap:'break-word'
        },
        
        /** Makes the text stay on a single line and the dialog sizes to fit. */
        NO_WRAP_TEXT_DEFAULTS: {
            width:'auto',
            fontWeight:'bold',
            whiteSpace:'nowrap',
            wordWrap:'break-word'
        },
        
        /** Defaults used in a confirm dialog. */
        CONFIRM_DEFAULTS: {
            cancelTxt:'Cancel',
            confirmTxt:'Confirm',
            maxContainerHeight:300
        },
        
        /** Defaults used in a color picker dialog. */
        PICKER_DEFAULTS: {
            cancelTxt:'Cancel',
            confirmTxt:'Choose',
            titleText:'Choose a Color',
            color:'#000000'
        },
        
        /** Does basic styling of a dialog and creates a close button.
            @param dialog:myt.Dialog The dialog to apply the styling to.
            @returns void */
        setupDialog: function(dialog) {
            var content = dialog.content;
            content.setRoundedCorners(this.DEFAULT_RADIUS);
            content.setBgColor(this.DEFAULT_BGCOLOR);
            content.setBoxShadow(this.DEFAULT_SHADOW);
            content.setFocusCage(true);
            
            this.createCloseButton(content, dialog);
        },
        
        /** Creates a close button on the provided targetView.
            @param targetView:myt.View The view to create the button on.
            @param callbackTarget:object An object with a doCallback method
                that will get called when the close button is activated.
            @param hoverColor:color (optional) The color used when the mouse 
                hovers over the button. Defaults to '#666666'.
            @param activeColor:color (optional) The color used when the button 
                is active. Defaults to '#000000'.
            @param readyColor:color (optional) The color used when the button 
                is ready to be activated. Defaults to '#333333'.
            @param iconColor:color (optional) The color used to draw the 
                close icon. Defaults to '#ffffff'.
            @returns myt.Button: The created button. */
        createCloseButton: function(
            targetView, callbackTarget, hoverColor, activeColor, readyColor, iconColor
        ) {
            hoverColor = hoverColor || '#666666';
            activeColor = activeColor || '#000000';
            readyColor = readyColor || '#333333';
            iconColor = iconColor || '#ffffff';
            
            return new myt.DrawButton(targetView, {
                name:'closeBtn', width:16, height:16, y:4,
                roundedCorners:8, tooltip:'Close Dialog.',
                ignoreLayout:true, align:'right', alignOffset:4
            }, [myt.TooltipMixin, {
                doActivated: function() {callbackTarget.doCallback(this);},
                
                draw: function(canvas, config) {
                    canvas.clear();
                    
                    var b = config.bounds;
                    if (b.w == 0 || b.h == 0) return;
                    
                    var fillColor;
                    switch (config.state) {
                        case 'hover':
                            fillColor = hoverColor;
                            break;
                        case 'active':
                            fillColor = activeColor;
                            break;
                        case 'ready':
                        case 'disabled':
                        default:
                            fillColor = readyColor;
                            break;
                    }
                    
                    canvas.beginPath();
                    canvas.circle(8, 8, 8);
                    canvas.closePath();
                    canvas.setFillStyle(fillColor);
                    canvas.fill();
                    
                    // Draw white X
                    canvas.beginPath();
                    canvas.moveTo(8,6);
                    canvas.lineTo(11,3);
                    canvas.lineTo(13,5);
                    canvas.lineTo(10,8);
                    canvas.lineTo(13,11);
                    canvas.lineTo(11,13);
                    canvas.lineTo(8,10);
                    canvas.lineTo(5,13);
                    canvas.lineTo(3,11);
                    canvas.lineTo(6,8);
                    canvas.lineTo(3,5);
                    canvas.lineTo(5,3);
                    canvas.closePath();
                    canvas.setFillStyle(iconColor);
                    canvas.fill();
                }
            }]);
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    doAfterAdoption: function() {
        myt.Dialog.setupDialog(this);
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setDisplayMode: function(v) {this.displayMode = v;},
    setCallbackFunction: function(v) {this.callbackFunction = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Dimmer */
    hide: function(ignoreRestoreFocus) {
        this.__hideSpinner();
        
        this.callSuper(ignoreRestoreFocus);
    },
    
    /** Hide spinner related elements.
        @private
        @returns void */
    __hideSpinner: function() {
        if (this.spinner) {
            this.spinner.setVisible(false);
            this.spinner = undefined;
        }
    },
    
    /** @overrides myt.Dimmer */
    eatMouseEvent: function(event) {
        if (this.displayMode === 'message') this.content.closeBtn.focus();
        return this.callSuper(event);
    },
    
    /** Called before a dialog is shown to reset state and cleanup UI elements
        from the previous display of the Dialog.
        @private
        @returns void */
    __destroyContent: function() {
        this.__hideSpinner();
        
        var content = this.content, MP = myt.ModalPanel,
            stc = content.sizeToChildren,
            svs = content.getSubviews(), 
            i = svs.length, sv;
        
        // Destroy all children except the close button since that gets reused.
        while (i) {
            sv = svs[--i];
            if (sv.name !== 'closeBtn') sv.destroy();
        }
        
        // Blank sets this.
        content.setVisible(true);
        this.overlay.setBgColor(myt.Dimmer.DEFAULT_COLOR);
        
        // Message and Confirm dialogs set this.
        this.setCallbackFunction();
        
        // Confirm dialog modifies this.
        stc.setPaddingY(MP.DEFAULT_PADDING_Y);
        
        // Confirm content dialog modifies this.
        stc.setPaddingX(MP.DEFAULT_PADDING_X);
    },
    
    /** Called by each of the buttons that can trigger the dialog to be hidden.
        @param sourceView:myt.View the view that triggered the hiding 
            of the dialog.
        @returns void */
    doCallback: function(sourceView) {
        var cbf = this.callbackFunction;
        if (!cbf || !cbf.call(this, sourceView.name)) this.hide();
    },
    
    /** Shows this dialog as a regular dimmer.
        @param opts:object If opts.bgColor is provided it will be used for
            the bgColor of the overlay.
        @returns void */
    showBlank: function(opts) {
        this.__destroyContent();
        
        this.content.setVisible(false);
        if (opts && opts.bgColor) this.overlay.setBgColor(opts.bgColor);
        
        this.show();
        
        this.setDisplayMode('blank');
    },
    
    /** Shows a dialog with a message and the standard cancel button.
        @param msg:string the message to show.
        @param callbackFunction:function (optional) A function that gets 
            called when the close button is activated. A single argument is
            passed in that indicates the UI element interacted with that should
            close the dialog. Supported values are: 'closeBtn', 'cancelBtn' and
            'confirmBtn'. The function should return true if the close should 
            be aborted.
        @param opts:object (optional) options that modify how the message is 
            displayed. Supports: fontWeight, whiteSpace, wordWrap and width.
        @returns void */
    showMessage: function(msg, callbackFunction, opts) {
        opts = myt.extend({}, myt.Dialog.WRAP_TEXT_DEFAULTS, opts);
        var content = this.content, MP = myt.ModalPanel;
        
        this.__destroyContent();
        
        this.setCallbackFunction(callbackFunction);
        
        new myt.Text(content, {
            name:'msg',
            text:msg,
            whiteSpace:opts.whiteSpace,
            wordWrap:opts.wordWrap,
            fontWeight:opts.fontWeight,
            x:MP.DEFAULT_PADDING_X,
            y:MP.DEFAULT_PADDING_Y,
            width:opts.width
        });
        
        this.show();
        
        var closeBtn = content.closeBtn;
        closeBtn.setVisible(true);
        closeBtn.focus();
        
        this.setDisplayMode('message');
    },
    
    /** Shows a dialog with a spinner and a message and no standard cancel
        button.
        @param msg:string the message to show.
        @param opts:object options that modify how the message is displayed.
            Supports: fontWeight, whiteSpace, wordWrap and width.
        @returns void */
    showSpinner: function(msg, opts) {
        opts = myt.extend({}, myt.Dialog.NO_WRAP_TEXT_DEFAULTS, opts);
        var content = this.content, MP = myt.ModalPanel;
        
        this.__destroyContent();
        
        var spinner = this.spinner = new myt.Spinner(content, {
            align:'center', visible:true,
            radius:10, lines:12, length:14, lineWidth:3,
            y:MP.DEFAULT_PADDING_Y
        });
        if (msg) {
            new myt.Text(content, {
                text:msg,
                whiteSpace:opts.whiteSpace,
                wordWrap:opts.wordWrap,
                fontWeight:opts.fontWeight,
                x:MP.DEFAULT_PADDING_X,
                y:spinner.y + spinner.getSize() + MP.DEFAULT_PADDING_Y,
                width:opts.width
            });
        }
        
        this.show();
        
        content.closeBtn.setVisible(false);
        this.focus(); // Focus on the dimmer itself to prevent user interaction.
        
        this.setDisplayMode('spinner');
    },
    
    showColorPicker: function(callbackFunction, opts) {
        var MP = myt.ModalPanel, content = this.content;
        
        opts = myt.extend({}, myt.Dialog.PICKER_DEFAULTS, opts);
        
        this.__destroyContent();
        
        var wrappedCallbackFunction = function(action) {
            switch(action) {
                case 'closeBtn':
                case 'cancelBtn':
                    callbackFunction.call(this, action);
                    break;
                case 'confirmBtn':
                    var color = this._spectrum.get();
                    this._spectrum.addColorToSelectionPalette(color);
                    callbackFunction.call(this, action, color ? color.toHexString() : 'transparent');
                    break;
            }
            this._spectrum.destroy();
        };
        
        
        this.setCallbackFunction(wrappedCallbackFunction);
        
        // Build Picker
        var picker = new myt.View(content, {
            name:'picker',
            x:MP.DEFAULT_PADDING_X,
            y:MP.DEFAULT_PADDING_Y + 24,
            width:337,
            height:177
        });
        var spectrumView = new myt.View(picker, {});
        
        $(spectrumView.domElement).spectrum({
            color:opts.color,
            palette: [['#000000','#111111','#222222','#333333','#444444','#555555','#666666','#777777'],
                      ['#888888','#999999','#aaaaaa','#bbbbbb','#cccccc','#dddddd','#eeeeee','#ffffff']],
            localStorageKey: "myt.default",
            dialog:this
        });
        
        this.show();
        
        var closeBtn = content.closeBtn;
        closeBtn.setVisible(true);
        closeBtn.focus();
        
        this.__setupConfirmButtons(picker, opts);
        
        var r = myt.Dialog.DEFAULT_RADIUS;
        var bg = new myt.View(content, {
            ignoreLayout:true,
            x:0, y:0,
            width:content.width, height:24,
            bgColor:'#eeeeee',
            roundedTopLeftCorner:r,
            roundedTopRightCorner:r
        });
        bg.sendToBack();
        new myt.Text(content, {
            name:'title', x:r, y:4, text:opts.titleText, fontWeight:'bold'
        });
        
        this.setDisplayMode('color_picker');
    },
    
    _spectrumCallback: function(spectrum) {
        this._spectrum = spectrum;
    },
    
    showConfirm: function(msg, callbackFunction, opts) {
        opts = myt.extend({}, myt.Dialog.CONFIRM_DEFAULTS, opts);
        
        this.showMessage(msg, callbackFunction, opts);
        
        this.__setupConfirmButtons(this.content.msg, opts);
        
        this.setDisplayMode('confirm');
    },
    
    showContentConfirm: function(contentBuilderFunc, callbackFunction, opts) {
        var MP = myt.ModalPanel, content = this.content;
        
        opts = myt.extend({}, myt.Dialog.CONFIRM_DEFAULTS, opts);
        
        this.__destroyContent();
        
        content.sizeToChildren.setPaddingX(1);
        this.setCallbackFunction(callbackFunction);
        
        // Setup form
        var maxHeight = opts.maxContainerHeight;
        var contentContainer = new myt.View(content, {
            name:'contentContainer',
            x:1, y:25, overflow:'auto'
        }, [{
            setHeight: function(v) {
                if (v > maxHeight) v = maxHeight;
                this.callSuper(v);
            }
        }]);
        
        contentBuilderFunc.call(this, contentContainer);
        
        new myt.SizeToChildren(contentContainer, {axis:'both'});
        
        this.show();
        
        var closeBtn = content.closeBtn;
        closeBtn.setVisible(true);
        closeBtn.focus();
        
        this.__setupConfirmButtons(contentContainer, opts);
        
        var r = myt.Dialog.DEFAULT_RADIUS;
        var bg = new myt.View(content, {
            ignoreLayout:true,
            x:0, y:0,
            width:content.width, height:24,
            bgColor:'#eeeeee',
            roundedTopLeftCorner:r,
            roundedTopRightCorner:r
        });
        bg.sendToBack();
        
        new myt.Text(content, {
            name:'title', x:r, y:4, text:opts.titleText,
            fontWeight:'bold'
        });
        
        this.setDisplayMode('content');
        
        // Set initial focus
        if (contentContainer.initialFocus) contentContainer.initialFocus.focus();
    },
    
    /** @private */
    __setupConfirmButtons: function(mainView, opts) {
        var self = this, content = this.content, 
            MP = myt.ModalPanel,
            MP_DPY = MP.DEFAULT_PADDING_Y;
        
        var btnContainer = new myt.View(content, {
            y:mainView.y + mainView.height + MP_DPY, align:'center'
        });
        
        // Cancel Button
        var attrs = {
            name:'cancelBtn', text:opts.cancelTxt, shrinkToFit:true,
            height:20, inset:10, outset:10, roundedCorners:5,
            activeColor:'#bbbbbb',
            hoverColor:'#dddddd',
            readyColor:'#cccccc'
        };
        if (opts.activeColor !== undefined) attrs.activeColor = opts.activeColor;
        if (opts.hoverColor !== undefined) attrs.hoverColor = opts.hoverColor;
        if (opts.readyColor !== undefined) attrs.readyColor = opts.readyColor;
        if (opts.textColor !== undefined) attrs.textColor = opts.textColor;
        
        new myt.SimpleIconTextButton(btnContainer, attrs, [{
            doActivated: function() {self.doCallback(this);}
        }]);
        
        // Confirm Button
        attrs.name = 'confirmBtn';
        attrs.text = opts.confirmTxt;
        if (opts.activeColorConfirm !== undefined) attrs.activeColor = opts.activeColorConfirm;
        if (opts.hoverColorConfirm !== undefined) attrs.hoverColor = opts.hoverColorConfirm;
        if (opts.readyColorConfirm !== undefined) attrs.readyColor = opts.readyColorConfirm;
        if (opts.textColorConfirm !== undefined) attrs.textColor = opts.textColorConfirm;
        
        new myt.SimpleIconTextButton(btnContainer, attrs, [{
            doActivated: function() {self.doCallback(this);}
        }]);
        
        // Additional Buttons
        var buttons = opts.buttons;
        if (buttons) {
            for (var i = 0, len = buttons.length; len > i; i++) {
                attrs = buttons[i];
                if (attrs.name == null) attrs.name = 'btn_' + i;
                if (attrs.shrinkToFit == null) attrs.shrinkToFit = true;
                if (attrs.height == null) attrs.height = 20;
                if (attrs.inset == null) attrs.inset = 10;
                if (attrs.outset == null) attrs.outset = 10;
                if (attrs.roundedCorners == null) attrs.roundedCorners = 5;
                if (attrs.activeColor == null) attrs.activeColor = '#bbbbbb';
                if (attrs.hoverColor == null) attrs.hoverColor = '#dddddd';
                if (attrs.readyColor == null) attrs.readyColor = '#cccccc';
                if (attrs.textColor == null) attrs.textColor = '#000000';
                
                new myt.SimpleIconTextButton(btnContainer, attrs, [{
                    doActivated: function() {self.doCallback(this);}
                }]);
            }
        }
        
        new myt.SizeToChildren(btnContainer, {axis:'y'});
        new myt.SpacedLayout(btnContainer, {spacing:4, axis:'x', collapseParent:true});
        
        content.sizeToChildren.setPaddingY(MP_DPY / 2);
        
        var r = myt.Dialog.DEFAULT_RADIUS;
        var bg = new myt.View(content, {
            ignoreLayout:true,
            x:0,
            y:btnContainer.y - (MP_DPY / 2),
            width:content.width,
            bgColor:'#eeeeee',
            roundedBottomLeftCorner:r,
            roundedBottomRightCorner:r
        });
        bg.setHeight(content.height - bg.y);
        bg.sendToBack();
    }
});


/** Tests if a value is "valid" or not.
    
    Events:
        None
    
    Attributes:
        id:string the ideally unique ID for this Validator so it can be
            stored and retreived from the myt.global.validators registry.
*/
myt.Validator = new JS.Class('Validator', {
    // Constructor /////////////////////////////////////////////////////////////
    /** Creates a new Validator
        @param id:string the ideally unique ID for a validator instance. */
    initialize: function(id) {
        this.id = id;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Tests if the value is valid or not.
        @param value:* the value to test validity for.
        @param config:Object (optional) A map of configuration values that
            can be used to augment the validation function as needed. The
            nature of this config will be specific to each Validator class.
        @param errorMessages:array (optional) Any error messages arising during
            validation will be pushed onto thiis array if it is provided.
        @returns boolean true if the value is valid, false otherwise. */
    isValid: function(value, config, errorMessages) {
        return true;
    },
    
    /** Tests if the form is valid or not.
        @param form:myt.Form the form to test validity for.
        @param config:Object (optional) A map of configuration values that
            can be used to augment the validation function as needed. The
            nature of this config will be specific to each Validator class.
        @param errorMessages:array (optional) Any error messages arising during
            validation will be pushed onto thiis array if it is provided.
        @returns boolean true if the form is valid, false otherwise. */
    isFormValid: function(form, config, errorMessages) {
        if (!config) config = {};
        config.form = form;
        
        return this.isValid(form.getValue(), config, errorMessages);
    }
});


/** A Validator composed from multiple Validators.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __v:array The array of myt.Validators that compose 
            this Validator.
*/
myt.CompoundValidator = new JS.Class('CompoundValidator', myt.Validator, {
    // Constructor /////////////////////////////////////////////////////////////
    /** Creates a new CompoundValidator for the ID and 0 or more Validators
        provided.
        @param arguments:args ever argument after the first must be a
            Validator or a Validator ID from the myt.global.validators
            registry.*/
    initialize: function(id) {
        this.callSuper(id);
        
        var args = Array.prototype.slice.call(arguments);
        args.shift();
        
        // Make sure each arg is an myt.Validator
        var i = args.length, validator;
        while (i) {
            validator = args[--i];
            if (typeof validator === 'string') {
                args[i] = validator = myt.global.validators.getValidator(validator);
                if (!validator) args.splice(i, 1);
            }
        }
        
        this.__v = args;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Add a Validator to this CompoundValidator.
        @param validator:myt.Validator|string The validator to add or a string
            used to lookup a validator in the validator repository.
        @returns void */
    addValidator: function(v) {
        if (typeof v === 'string') v = myt.global.validators.getValidator(v);
        if (v) this.__v.push(v);
    },
    
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        var isValid = true, validators = this.__v, len = validators.length, i = 0;
        for (; len > i;) isValid = validators[i++].isValid(value, config, errorMessages) && isValid;
        return isValid;
    }
});


/** Tests that the value differs from the form rollback value by more than
    just case. */
myt.EqualsIgnoreCaseValidator = new JS.Class('EqualsIgnoreCaseValidator', myt.Validator, {
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        var rbv = config.form.getRollbackValue();
        if (value && rbv && value.toLowerCase() === rbv.toLowerCase()) {
            if (errorMessages) errorMessages.push("Value must differ by more than just case.");
            return false;
        }
        
        return true;
    }
});


/** Tests that a value is not null, undefined or empty. */
myt.RequiredFieldValidator = new JS.Class('RequiredFieldValidator', myt.Validator, {
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        if (value == null || value === '') {
            if (errorMessages) errorMessages.push("This value is required.");
            return false;
        }
        
        return true;
    }
});


/** Models a URI and provides parsing of strings into URIs.
    
    Makes use of:
        parseUri 1.2.2
        (c) Steven Levithan <stevenlevithan.com>
        MIT License
        See: http://blog.stevenlevithan.com/archives/parseuri
        
    When more complex URI parsing is needed, perhaps try URI.js which can be
    found at: http://medialize.github.io/URI.js/
*/
myt.URI = new JS.Class('URI', {
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function(str, loose) {
        if (str) this.parse(str, loose);
    },
    
    
    // Attributes and Setters/Getters //////////////////////////////////////////
    setSource: function(v) {this.source = v;},
    setProtocol: function(v) {this.protocol = v;},
    setAuthority: function(v) {this.authority = v;},
    setUserInfo: function(v) {this.userInfo = v;},
    setUser: function(v) {this.user = v;},
    setPassword: function(v) {this.password = v;},
    setHost: function(v) {this.host = v;},
    setPort: function(v) {this.port = v;},
    setRelative: function(v) {this.relative = v;},
    setPath: function(v) {this.path = v;},
    setDirectory: function(v) {this.directory = v;},
    setFile: function(v) {this.file = v;},
    setQuery: function(v) {this.query = v;},
    setAnchor: function(v) {this.anchor = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    parse: function(str, loose) {
        // match order: "source", "protocol", "authority", "userInfo", "user",
        //              "password", "host", "port", "relative", "path", 
        //              "directory", "file", "query", "anchor".
        var m = myt.URI[loose ? "_looseParser" : "_strictParser"].exec(str);
        
        this.setSource(m[0] || "");
        
        this.setProtocol(m[1] || "");
        this.setAuthority(m[2] || "");
        this.setUserInfo(m[3] || "");
        this.setUser(m[4] || "");
        this.setPassword(m[5] || "");
        this.setHost(m[6] || "");
        this.setPort(m[7] || "");
        this.setRelative(m[8] || "");
        this.setPath(m[9] || "");
        this.setDirectory(m[10] || "");
        this.setFile(m[11] || "");
        this.setQuery(m[12] || "");
        this.setAnchor(m[13] || "");
        
        this.queryPairs = {};
        
        var self = this;
        this.query.replace(myt.URI._queryParser, function ($0, $1, $2) {
            if ($1) self.queryPairs[$1] = $2;
        });
    },
    
    /** Unescape a query param value. */
    decodeQueryParam: function(v) {
        v = decodeURIComponent(v);
        return v.replace('+', ' ');
    },
    
    getQuery: function() {
        var pairs = this.queryPairs, parts = [], key, s;
        for (key in pairs) {
            parts.push(key + '=' + encodeURIComponent(pairs[key]));
        }
        s = parts.join('&');
        return s.length > 0 ? '?' + s : s;
    },
    
    getQueryParam: function(name) {
        var v = this.queryPairs[name];
        return v == null ? undefined : this.decodeQueryParam(v);
    },
    
    getPathParts: function(allowEmpties) {
        var parts = this.path.split('/');
        
        if (!allowEmpties) {
            var i = parts.length;
            while (i) if (parts[--i].length === 0) parts.splice(i, 1);
        }
        
        return parts;
    },
    
    toString: function() {
        var protocol = this.protocol,
            host = this.host,
            userInfo = this.userInfo,
            port = this.port,
            path = this.path,
            query = this.getQuery(),
            anchor = this.anchor,
            s = '';
        
        if (protocol) s += protocol + '://';
        if (userInfo && host) s += userInfo + '@';
        
        if (host) {
            s += host;
            if (port) s += ':' + port;
        }
        
        if (path) {
            s += path;
        } else if (host && (query || anchor)) {
            s += '/';
        }
        
        if (query) s += query;
        if (anchor) s += '#' + anchor;
        
        return s;
    }
});
myt.URI._queryParser = /(?:^|&)([^&=]*)=?([^&]*)/g;
myt.URI._strictParser = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/;
myt.URI._looseParser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;


/** Verifies that a value is in the form of a URL. */
myt.URLValidator = new JS.Class('URLValidator', myt.Validator, {
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        var uri = new myt.URI(value);
        if (uri.toString() !== value) {
            if (errorMessages) errorMessages.push("Not a valid URL.");
            return false;
        }
        return true;
    }
});


/** Verifies that a value is JSON. */
myt.JSONValidator = new JS.Class('JSONValidator', myt.Validator, {
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        try {
            JSON.parse(value);
            return true;
        } catch(e) {
            if (errorMessages) errorMessages.push(e);
            return false;
        }
    }
});


/** Stores myt.Validators by ID so they can be used in multiple
    places easily.
    
    Events:
        validatorAdded:myt.Validator Fired when a validator is added to
            this registry.
        validatorRemoved:myt.Validator Fired when a validator is removed
            from this registry.
    
    Attributes:
        None
    
    Private Attributes:
        __c:object A map of myt.Validators by ID.
*/
new JS.Singleton('GlobalValidatorRegistry', {
    include: [myt.Observable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initialize: function() {
        this.__c = {};
        
        myt.global.register('validators', this);
        
        // Register a few common Validators
        this.register(new myt.RequiredFieldValidator('required'));
        this.register(new myt.EqualsIgnoreCaseValidator('equalsIgnoreCase'));
        this.register(new myt.URLValidator('url'));
        this.register(new myt.JSONValidator('json'));
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Gets a Validator for the ID.
        @param id:string the ID of the Validator to get.
        @returns an myt.Validator or undefined if not found. */
    getValidator: function(id) {
        return this.__c[id];
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Adds a Validator to this registry.
        @param validator:myt.Validator the Validator to add.
        @returns void */
    register: function(validator) {
        if (validator) {
            var id = validator.id;
            if (id) {
                this.__c[id] = validator;
                this.fireNewEvent('validatorAdded', validator);
            } else {
                myt.dumpStack("No ID");
            }
        } else {
            myt.dumpStack("No validator");
        }
    },
    
    /** Removes a Validator from this registery.
        @param validator:myt.Validator the Validator to remove.
        @returns boolean true if removal succeeds, false otherwise. */
    unregister: function(validator) {
        if (validator) {
            var id = validator.id;
            if (id) {
                // Make sure it's in the repository.
                validator = this.getValidator(id);
                
                if (validator) {
                    delete this.__c[id];
                    this.fireNewEvent('validatorRemoved', validator);
                    return true;
                }
            } else {
                myt.dumpStack("No ID");
            }
        } else {
            myt.dumpStack("No validator");
        }
        return false;
    }
});


/** Tests that the value from two fields are equal. */
myt.EqualFieldsValidator = new JS.Class('EqualFieldsValidator', myt.Validator, {
    // Constructor /////////////////////////////////////////////////////////////
    /** @overrides myt.Validator
        @param fieldA the first form field to compare.
        @param fieldB the second form field to compare. */
    initialize: function(id, fieldA, fieldB) {
        this.callSuper(id);
        
        this.fieldA = fieldA;
        this.fieldB = fieldB;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        if (value && fieldA.getValue() === fieldB.getValue()) return true;
        
        if (errorMessages) errorMessages.push('Field "' + this.fieldA.key + '" must be equal to field "' + this.fieldB.key + '".');
        return false;
    }
});


/** Tests that the value has a length between min and max. */
myt.LengthValidator = new JS.Class('LengthValidator', myt.Validator, {
    // Constructor /////////////////////////////////////////////////////////////
    /** @overrides myt.Validator
        @param min:number The minimum length value.
        @param max:number The maximum length value. */
    initialize: function(id, min, max) {
        this.callSuper(id);
        
        this.min = min;
        this.max = max;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        var len = value ? value.length : 0,
            min = this.min,
            max = this.max;
        
        // Test min
        if (min !== undefined && min > len) {
            if (errorMessages) errorMessages.push('Value must not be less than ' + min + '.');
            return false;
        }
        
        // Test max
        if (max !== undefined && max < len) {
            if (errorMessages) errorMessages.push('Value must not be greater than ' + max + '.');
            return false;
        }
        
        return true;
    }
});


/** Tests that adBinary value is between min and max. */
myt.NumericRangeValidator = new JS.Class('NumericRangeValidator', myt.Validator, {
    // Constructor /////////////////////////////////////////////////////////////
    /** @overrides myt.Validator
        @param min:number The minimum value.
        @param max:number The maximum value. */
    initialize: function(id, min, max) {
        this.callSuper(id);
        
        this.min = min;
        this.max = max;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Validator */
    isValid: function(value, config, errorMessages) {
        // Treat empty values as valid.
        if (value === "") return true;
        
        // Must be a number
        var numericValue = Number(value), min = this.min, max = this.max;
        if (isNaN(numericValue)) {
            if (errorMessages) errorMessages.push("Value is not a number.");
            return false;
        }
        
        // Test min
        if (min !== undefined && min > numericValue) {
            if (errorMessages) errorMessages.push('Value must not be less than ' + min + '.');
            return false;
        }
        
        // Test max
        if (max !== undefined && max < numericValue) {
            if (errorMessages) errorMessages.push('Value must not be greater than ' + max + '.');
            return false;
        }
        
        return true;
    }
});


/** Modifies a value. Typically used to convert a form element value to its
    canonical form.
    
    Events:
        None
    
    Attributes:
        id:string The ideally unique ID for this value processor.
        runForDefault:boolean Indicates this processor should be run for
            default form values. Defaults to true.
        runForRollback:boolean Indicates this processor should be run for
            rollback form values. Defaults to true.
        runForCurrent:boolean Indicates this processor should be run for
            current form values. Defaults to true.
*/
myt.ValueProcessor = new JS.Class('ValueProcessor', {
    // Class Methods ///////////////////////////////////////////////////////////
    extend: {
        DEFAULT_ATTR: 'runForDefault',
        ROLLBACK_ATTR: 'runForRollback',
        CURRENT_ATTR: 'runForCurrent'
    },
    
    
    // Constructor /////////////////////////////////////////////////////////////
    /** Creates a new ValueProcessor
        @param id:string the ideally unique ID for a processor instance.
        @param runForDefault:boolean (optional) 
        @param runForRollback:boolean (optional) 
        @param runForCurrent:boolean (optional) */
    initialize: function(id, runForDefault, runForRollback, runForCurrent) {
        this.id = id;
        
        var VP = myt.ValueProcessor;
        this[VP.DEFAULT_ATTR] = runForDefault ? true : false;
        this[VP.ROLLBACK_ATTR] = runForRollback ? true : false;
        this[VP.CURRENT_ATTR] = runForCurrent ? true : false;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Processes the value. The default implementation returns the value
        unmodified.
        @param value:* the value to modify.
        @returns * the modified value. */
    process: function(value) {
        return value;
    }
});


/** Converts values to a Number if possible. If the value becomes NaN
    the original value is returned. */
myt.ToNumberValueProcessor = new JS.Class('ToNumberValueProcessor', myt.ValueProcessor, {
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ValueProcessor */
    process: function(v) {
        // Don't convert "empty" values to a number since they'll become zero
        // which is probably incorrect. Also catch undefined/null values since
        // they will become NaN.
        if (v == null || v === "" || v === "-") return v;
        
        var numericValue = Number(v);
        return isNaN(numericValue) ? v : numericValue;
    }
});


/** Trims the whitespace from a value.
    
    Attributes:
        trim:string Determines what kind of trimming to do. Supported values
            are 'left', 'right' and 'both'. The default value is 'both'.
*/
myt.TrimValueProcessor = new JS.Class('TrimValueProcessor', myt.ValueProcessor, {
    // Constructor /////////////////////////////////////////////////////////////
    /** @overrides myt.ValueProcessor
        @param trim:string Determines the type of trimming to do. Allowed
            values are 'left', 'right' or 'both'. The default value 
            is 'both'. */
    initialize: function(id, runForDefault, runForRollback, runForCurrent, trim) {
        this.callSuper(id, runForDefault, runForRollback, runForCurrent);
        
        this.trim = trim;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ValueProcessor */
    process: function(v) {
        v += '';
        if (this.trim === 'left') {
            return v.trimLeft();
        } else if (this.trim === 'right') {
            return v.trimRight();
        }
        return v.trim();
    }
});


/** Converts undefined values to a default value.
    
    Attributes:
        defaultValue:* The value to return when the processed value is
            undefined.
*/
myt.UndefinedValueProcessor = new JS.Class('UndefinedValueProcessor', myt.ValueProcessor, {
    // Constructor /////////////////////////////////////////////////////////////
    /** @overrides myt.ValueProcessor
        @param defaultValue:* The default value to convert undefined to. */
    initialize: function(id, runForDefault, runForRollback, runForCurrent, defaultValue) {
        this.callSuper(id, runForDefault, runForRollback, runForCurrent);
        
        this.defaultValue = defaultValue;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ValueProcessor */
    process: function(v) {
        return v === undefined ? this.defaultValue : v;
    }
});


/** Stores myt.ValueProcessors by ID so they can be used in multiple
    places easily.
    
    Events:
        processorAdded:myt.ValueProcessor Fired when a processor is registered
            with the registry.
        processorRemoved:myt.ValueProcessor Fired when a processor is 
            unregistered from the registry.
    
    Attributes:
        None
    
    Private Attributes:
        __c:object A map of myt.ValueProcessors by ID.
*/
new JS.Singleton('GlobalValueProcessorRegistry', {
    include: [myt.Observable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initialize: function() {
        this.__c = {};
        
        var m = myt;
        m.global.register('valueProcessors', this);
        
        // Register a few common ValueProcessors
        this.register(new m.UndefinedValueProcessor('undefToEmpty', true, true, true, ''));
        this.register(new m.ToNumberValueProcessor('toNumber', true, true, true));
        this.register(new m.TrimValueProcessor('trimLeft', true, true, true, 'left'));
        this.register(new m.TrimValueProcessor('trimRight', true, true, true, 'right'));
        this.register(new m.TrimValueProcessor('trimBoth', true, true, true, 'both'));
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** Gets a ValueProcessor for the ID.
        @param id:string the ID of the ValueProcessor to get.
        @returns an myt.ValueProcessor or undefined if not found. */
    getValueProcessor: function(id) {
        return this.__c[id];
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Adds a ValueProcessor to this registry.
        @param processor:myt.ValueProcessor the ValueProcessor to add.
        @returns void */
    register: function(processor) {
        if (processor) {
            var id = processor.id;
            if (id) {
                this.__c[id] = processor;
                this.fireNewEvent('processorAdded', processor);
            } else {
                myt.dumpStack("No ID");
            }
        } else {
            myt.dumpStack("No processor");
        }
    },
    
    /** Removes a ValueProcessor from this registery.
        @param processor:myt.ValueProcessor the ValueProcessor to remove.
        @returns boolean true if removal succeeds, false otherwise. */
    unregister: function(processor) {
        if (processor) {
            var id = processor.id;
            if (id) {
                // Make sure it's in the repository.
                processor = this.getValueProcessor(id);
                
                if (processor) {
                    delete this.__c[id];
                    this.fireNewEvent('processorRemoved', processor);
                    return true;
                }
            } else {
                myt.dumpStack("No ID");
            }
        } else {
            myt.dumpStack("No processor");
        }
        return false;
    }
});


/** Pulls the current value from another form field if the provided value
    is undefined, null or empty string.
    
    Attributes:
        otherField:myt.FormElement The form element to pull the current 
            value from.
*/
myt.UseOtherFieldIfEmptyValueProcessor = new JS.Class('UseOtherFieldIfEmptyValueProcessor', myt.ValueProcessor, {
    // Constructor /////////////////////////////////////////////////////////////
    /** @overrides myt.ValueProcessor
        @param otherField:myt.FormElement The form field to pull the 
            value from. */
    initialize: function(id, runForDefault, runForRollback, runForCurrent, otherField) {
        this.callSuper(id, runForDefault, runForRollback, runForCurrent);
        
        this.otherField = otherField;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.ValueProcessor */
    process: function(v) {
        return (v == null || v === "") ? this.otherField.getValue() : v;
    }
});


/** A wrapper around a native browser select component.
    
    Events:
        multiple:boolean
        size:int
        value:string
    
    Attributes:
        multiple:boolean Indicates if multiple options can be selected or not.
            Defaults to false.
        size:int The number of options to show. The default value is 4 for
            multiple == true and 1 for multiple == false. It is recommended
            that a size of at least 4 be used when multiple is 2.
        options:array (write only) Adds a list of options to this select list.
            The value should be an array of myt.InputSelectOptions attrs that 
            will be used to instantiate new myt.InputSelectOption instances on
            this select list.
*/
myt.InputSelect = new JS.Class('InputSelect', myt.NativeInputWrapper, {
    include: [myt.SizeHeightToDom],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.NativeInputWrapper */
    initNode: function(parent, attrs) {
        if (attrs.multiple === undefined) attrs.multiple = false;
        if (attrs.size === undefined) attrs.size = attrs.multiple ? 4 : 1;
        
        this.callSuper(parent, attrs);
        
        this.attachToDom(this, '__syncToDom', 'change');
        
        // Make sure initial value is in sync with the UI
        this.__syncToDom();
    },
    
    /** @overrides myt.NativeInputWrapper */
    createOurDomElement: function(parent) {
        var elem = document.createElement('select');
        elem.style.position = 'absolute';
        return elem;
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setMultiple: function(v) {
        if (this.multiple !== v) {
            this.multiple = this.domElement.multiple = v;
            if (this.inited) this.fireNewEvent('multiple', v);
        }
    },
    
    setSize: function(v) {
        if (this.size !== v) {
            this.size = this.domElement.size = v;
            if (this.inited) this.fireNewEvent('size', v);
        }
    },
    
    setOptions: function(v) {
        this.destroyAllOptions();
        if (Array.isArray(v)) {
            for (var i = 0, len = v.length; len > i; ++i) this.addOption(v[i]);
        }
    },
    
    /** The options are just the subviews.
        @returns an array of options for this select list. */
    getOptions: function() {
        return this.getSubviews().concat();
    },
    
    /** @overrides myt.NativeInputWrapper
        Does not update the dom since the dom element's 'value' attribute
        doesn't support lists. */
    setValue: function(v) {
        if (Array.isArray(v) && myt.areArraysEqual(v, this.value)) return;
        
        if (this.value !== v) {
            this.value = v;
            if (this.inited) this.fireNewEvent('value', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    subviewAdded: function(sv) {
        // Destroy subview if it's not supported.
        if (!(sv instanceof myt.InputSelectOption)) {
            myt.dumpStack("Subview not supported. Destroying it.");
            sv.destroy();
        }
    },
    
    /** @overrides myt.FocusObservable */
    showFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow(myt.Button.DEFAULT_FOCUS_SHADOW_PROPERTY_VALUE);
    },
    
    /** @overrides myt.FocusObservable */
    hideFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow();
    },
    
    // Options //
    /** Gets an array of selected myt.InputSelectOptions.
        @returns array: An array of selected myt.InputSelectOptions. */
    getSelectedOptions: function() {
        var options = this.getOptions(), i = options.length, option, retval = [];
        while (i) {
            option = options[--i];
            if (option.isSelected()) retval.push(option);
        }
        return retval;
    },
    
    /** Gets an array of selected myt.InputSelectOption values.
        @returns array: An array of selected option values. */
    getSelectedOptionValues: function() {
        var options = this.getOptions(), i = options.length, option, retval = []
        while (i) {
            option = options[--i];
            if (option.isSelected()) retval.push(option.value);
        }
        return retval;
    },
    
    /** Gets the myt.InputSelectOption with the provided value.
        @param value:* The value of the option to get.
        @returns myt.InputSelectOption: The matching option or null if not
            found. */
    getOptionForValue: function(value) {
        var options = this.getOptions(), i = options.length, option;
        while (i) {
            option = options[--i];
            if (option.value === value) return option;
        }
        return null;
    },
    
    /** Adds a new myt.InputSelectionOption to this select list.
        @param attrs:object The attrs for the new option
        @returns myt.InputSelectOption: The newly created option. */
    addOption: function(attrs) {
        new myt.InputSelectOption(this, attrs);
    },
    
    destroyAllOptions: function() {
        var options = this.getOptions(), i = options.length;
        while (i) options[--i].destroy();
    },
    
    /** Destroys an option that has the provided value.
        @param value:* The value of the option to remove.
        @returns boolean: true if the option is destroyed, false otherwise. */
    destroyOptionWithValue: function(value) {
        var option = this.getOptionForValue(value);
        if (option) {
            option.destroy();
            if (option.destroyed) return true;
        }
        return false;
    },
    
    // Selection //
    /** Deselects all selected options included disabled options.
        @returns void */
    deselectAll: function() {
        var options = this.getOptions(), i = options.length, option, changed = false;
        while (i) {
            option = options[--i];
            if (option.isSelected()) {
                option.setSelected(false);
                changed = true;
            }
        }
        
        if (changed) this.__doChanged();
    },
    
    selectValues: function(values) {
        values = Array.isArray(values) ? values : [values];
        var i = values.length;
        while (i) this.selectValue(values[--i]);
    },
    
    /** Selects the option that has the provided value.
        @param value:* The value of the option to select.
        @returns void */
    selectValue: function(value) {
        this.select(this.getOptionForValue(value));
    },
    
    /** Selects the provided option.
        @param option:myt.InputSelectOption The option to select.
        @returns void */
    select: function(option) {
        if (option && option.canSelect(this)) {
            option.setSelected(true);
            this.__syncToDom();
        }
    },
    
    /** Deselects the option that has the provided value.
        @param value:* The value of the option to deselect.
        @returns void */
    deselectValue: function(value) {
        this.deselect(this.getOptionForValue(value));
    },
    
    /** Deselects the provided option.
        @param option:myt.InputSelectOption The option to deselect.
        @returns void */
    deselect: function(option) {
        if (option && option.canDeselect(this)) {
            option.setSelected(false);
            this.__syncToDom();
        }
    },
    
    /** @private */
    __doChanged: function(event) {
        this.__syncToDom();
        this.doChanged();
    },
    
    /** Called whenever the underlying dom element fires a "change" event.
        @returns void */
    doChanged: function() {},
    
    /** @private */
    __syncToDom: function() {
        this.setValue(this.multiple ? this.getSelectedOptionValues() : this.getDomValue());
    }
});


/** An option in a native browser select element.
    
    Events:
        value:*
        label:string
    
    Attributes:
        value:* the value of the option.
        label:string the text label for the option.
*/
myt.InputSelectOption = new JS.Class('InputSelectOption', myt.View, {
    include: [myt.Disableable, myt.Selectable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Input */
    createOurDomElement: function(parent) {
        return document.createElement('option');
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrideds myt.Selectable */
    setSelected: function(v) {
        // Adapt to event from syncTo
        if (v !== null && typeof v === 'object') v = v.value;
        
        var de = this.domElement;
        if (de.selected !== v) de.selected = v;
    },
    
    /** @overrides myt.Disableable */
    setDisabled: function(v) {
        if (this.disabled !== v) {
            this.domElement.disabled = v;
            this.callSuper(v);
        }
    },
    
    setValue: function(v) {
        if (this.value !== v) {
            this.value = v;
            if (this.domElement.value !== v) this.domElement.value = v;
            if (this.inited) this.fireNewEvent('value', v);
        }
    },
    
    setLabel: function(v) {
        if (this.label !== v) {
            this.domElement.textContent = this.label = v;
            if (this.inited) this.fireNewEvent('label', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrideds myt.Selectable */
    isSelected: function() {
        return this.domElement.selected;
    },
    
    /** @overrideds myt.Selectable */
    canSelect: function(selectionManager) {
        return !this.disabled && !this.domElement.selected && this.parent === selectionManager;
    },
    
    /** @overrideds myt.Selectable */
    canDeselect: function(selectionManager) {
        return !this.disabled && this.domElement.selected && this.parent === selectionManager;
    }
});


/** An myt.InputSelect that is also a FormElement.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __abortSetValue:boolean Prevents setValue from being called again
            when performing operations from within setValue.
*/
myt.FormInputSelect = new JS.Class('FormInputSelect', myt.InputSelect, {
    include: [myt.FormElement],
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.FormElement */
    setValue: function(v) {
        if (this.__abortSetValue) return;
        
        var retval = this.callSuper(v);
        
        // Clear Selection and then reselect
        this.__abortSetValue = true;
        this.deselectAll();
        this.selectValues(retval);
        this.__abortSetValue = false;
        
        return retval;
    }
});


/** Monitors a radio button group for a form.
    
    Events:
        None
    
    Attributes:
        groupId:string The ID of the radio group to monitor.
*/
myt.FormRadioGroup = new JS.Class('FormRadioGroup', myt.Node, {
    include: [myt.ValueComponent, myt.FormElement],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.groupId === undefined) attrs.groupId = myt.generateGuid();
        
        this.callSuper(parent, attrs);
        
        if (this.value !== undefined) this.__updateGroupValue();
        this.__startMonitoring();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.FormElement */
    setValue: function(v) {
        var retval = this.callSuper(v);
        if (this.inited) this.__updateGroupValue();
        return retval;
    },
    
    setGroupId: function(v) {
        if (this.groupId !== v) {
            this.__stopMonitoring();
            this.groupId = v;
            if (this.inited) this.__startMonitoring();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __startMonitoring: function() {
        if (this.groupId) {
            var bag = this.__getBAG();
            if (bag) this.syncTo(bag, '__syncValue', 'trueNode');
        }
    },
    
    /** @private */
    __stopMonitoring: function() {
        if (this.groupId) {
            var bag = this.__getBAG();
            if (bag) this.detachFrom(bag, '__syncValue', 'trueNode');
        }
    },
    
    /** @private */
    __syncValue: function(event) {
        this.setValue(event.value ? event.value.optionValue : null);
    },
    
    /** Search the radio group for a matching node and make that one the
        true node.
        @private */
    __updateGroupValue: function() {
        var bag = this.__getBAG();
        if (bag) {
            var nodes = bag.getNodes(), i = nodes.length, node, v = this.value;
            while (i) {
                node = nodes[--i];
                if (node.optionValue === v) {
                    bag.setTrue(node);
                    break;
                }
            }
        }
    },
    
    /** @private */
    __getBAG: function() {
        return myt.BAG.getGroup('selected', this.groupId);
    }
});


/** An myt.Checkbox that is also a FormElement.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.FormCheckbox = new JS.Class('FormCheckbox', myt.Checkbox, {
    include: [myt.FormElement],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.rollbackValue = this.defaultValue = false;
        
        this.callSuper(parent, attrs);
    }
});


/** An myt.TextCheckbox that is also a FormElement.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.FormTextCheckbox = new JS.Class('FormTextCheckbox', myt.TextCheckbox, {
    include: [myt.FormElement],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.rollbackValue = this.defaultValue = false;
        
        this.callSuper(parent, attrs);
    }
});


/** Provides common functionality for text related form elements.
    
    Accelerators:
        accept: Invokes the doAccept function. Activated upon key down of
            the ENTER key.
        reject: Invokes the doReject function. Activated upon key up of 
            the ESC key.
    
    Events:
        None
    
    Attributes:
        errorColor:color_string The color to use when a validation 
            error exists. Defaults to '#ff9999'.
        actionRequiredColor:color_string The color to use when a validation 
            error exists but the user has not modified the value. Defaults
            to '#996666'.
        normalColor:color_string The color to use when no validation 
            error exists. Defaults to '#999999'.
        validateWhen:string Indicates when to run validation.
            Supported values are:
                key: Validate as the user types.
                blur: Validate when blurring out of the UI control
                blurWithKeyFix: The same as blur except we also validate as 
                    the user types if currently invalid.
                none: Don't do any validation when interacting with the field.
            The default value is 'key'.
        acceleratorScope:string The scope the accelerators will be applied to.
            Supported values are:
                element: Take action on this element only
                root: Take action on the root form.
                none: Take no action.
            The default value is 'element'.
*/
myt.FormInputTextMixin = new JS.Module('FormInputTextMixin', {
    include: [myt.FormElement, myt.UpdateableUI],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Input */
    initNode: function(parent, attrs) {
        this.acceleratorScope = 'element';
        this.validateWhen = 'key';
        this.errorColor = '#ff9999';
        this.actionRequiredColor = '#996666';
        this.normalColor = '#999999';
        
        if (attrs.bgColor === undefined) attrs.bgColor = '#ffffff';
        if (attrs.borderWidth === undefined) attrs.borderWidth = 1;
        if (attrs.borderStyle === undefined) attrs.borderStyle = 'solid';
        if (attrs.focusEmbellishment === undefined) attrs.focusEmbellishment = true;
        
        this.callSuper(parent, attrs);
        
        this.addValueProcessor(myt.global.valueProcessors.getValueProcessor('undefToEmpty'));
        
        this.attachToDom(this, '__handleKeyDown', 'keydown');
        this.attachToDom(this, '__handleKeyUp', 'keyup');
        
        this.addAccelerator('accept', this.doAccept);
        this.addAccelerator('reject', this.doReject);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setValidateWhen: function(v) {this.validateWhen = v;},
    setAcceleratorScope: function(v) {this.acceleratorScope = v;},
    setErrorColor: function(v) {this.errorColor = v;},
    setActionRequiredColor: function(v) {this.actionRequiredColor = v;},
    setNormalColor: function(v) {this.normalColor = v;},
    
    setIsChanged: function(v) {
        this.callSuper(v);
        if (this.inited) this.updateUI();
    },
    
    setIsValid: function(v) {
        this.callSuper(v);
        if (this.inited) this.updateUI();
    },
    
    /** @overrides myt.FormElement */
    setValue: function(v) {
        var retval = this.callSuper(v);
        
        // Validate as we type.
        var when = this.validateWhen;
        if (when === 'key' || when === 'blurWithKeyFix') this.verifyValidState();
        
        return retval;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    doAccept: function() {
        if (!this.disabled) {
            switch (this.acceleratorScope) {
                case 'root':
                    this.getRootForm().invokeAccelerator("submit");
                    break;
                case 'element':
                    // Tab navigate forward
                    myt.global.focus.next(false);
                    break;
                case 'none':
                default:
            }
        }
    },
    
    doReject: function() {
        if (!this.disabled) {
            switch (this.acceleratorScope) {
                case 'root':
                    this.getRootForm().invokeAccelerator("cancel");
                    break;
                case 'element':
                    this.rollbackForm();
                    this.getRootForm().doValidation();
                    if (this.form) this.form.verifyChangedState(this);
                    break;
                case 'none':
                default:
            }
        }
    },
    
    /** @private */
    __handleKeyDown: function(event) {
        if (myt.KeyObservable.getKeyCodeFromEvent(event) === 13) this.invokeAccelerator("accept");
    },
    
    /** @private */
    __handleKeyUp: function(event) {
        if (myt.KeyObservable.getKeyCodeFromEvent(event) === 27) this.invokeAccelerator("reject");
    },
    
    /** @overrides myt.FocusObservable */
    doBlur: function() {
        this.callSuper();
        
        // Validate on blur
        var when = this.validateWhen;
        if (when === 'blur' || when === 'blurWithKeyFix') this.verifyValidState();
    },
    
    /** @overrides myt.UpdateableUI */
    updateUI: function() {
        this.setBorderColor(
            this.isValid ? this.normalColor : (this.isChanged ? this.errorColor : this.actionRequiredColor)
        );
    }
});


/** A base class for input:text and textarea components.
    
    Events:
        spellcheck:boolean
        maxLength:int
        placeholder:string
    
    Attributes:
        spellcheck:boolean Turns browser spellchecking on and off. Defaults
            to false.
        maxLength:int Sets a maximum number of input characters. Set to a
            negative number to turn off max length. Defaults to undefined
            which is equivalent to a negative number.
        allowedChars:string Each character in the string is an allowed
            input character. If not set or empty all characters are allowed. 
            Defaults to undefined.
        placeholder:string Text that will be shown if the value is empty.
*/
myt.BaseInputText = new JS.Class('BaseInputText', myt.NativeInputWrapper, {
    include: [myt.TextSupport],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.NativeInputWrapper */
    initNode: function(parent, attrs) {
        if (attrs.bgColor === undefined) attrs.bgColor = 'transparent';
        if (attrs.spellcheck === undefined) attrs.spellcheck = false;
        
        this.callSuper(parent, attrs);
        
        this.attachToDom(this, '__syncToDom', 'input');
        
        // Allow filtering of input
        this.attachToDom(this, '__filterInputPress', 'keypress');
        this.attachToDom(this, '__filterInput', 'keyup');
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.TextSupport
        Alias setText to setValue. */
    setText: function(v) {
        this.callSuper(v);
        
        this.setValue(v);
    },
    
    setSpellcheck: function(v) {
        if (this.spellcheck !== v) {
            this.spellcheck = this.domElement.spellcheck = v;
            if (this.inited) this.fireNewEvent('spellcheck', v);
        }
    },
    
    setMaxLength: function(v) {
        if (v == null || 0 > v) v = undefined;
        
        if (this.maxLength !== v) {
            this.maxLength = this.domElement.maxLength = v;
            if (this.inited) this.fireNewEvent('maxLength', v);
        }
    },
    
    setAllowedChars: function(v) {this.allowedChars = v;},
    
    setPlaceholder: function(v) {
        if (this.placeholder !== v) {
            this.domElement.placeholder = this.placeholder = v;
            if (this.inited) this.fireNewEvent('placeholder', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.FocusObservable */
    showFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow(myt.Button.DEFAULT_FOCUS_SHADOW_PROPERTY_VALUE);
    },
    
    /** @overrides myt.FocusObservable */
    hideFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow();
    },
    
    /** @private */
    __filterInput: function(event) {
        this.setDomValue(this.filterInput(this.getDomValue()));
    },
    
    /** @private */
    __filterInputPress: function(event) {
        var domEvent = event.value,
            c = String.fromCharCode(domEvent.which);
        
        // Filter for allowed characters
        var allowedChars = this.allowedChars;
        if (allowedChars && allowedChars.indexOf(c) === -1) domEvent.preventDefault();
        
        this.filterInputPress(domEvent);
    },
    
    /** A hook for subclasses/instances to do input filtering. The default
        implementation returns the value unchanged.
        @param v:string the current value of the form element.
        @returns string: The new value of the form element. */
    filterInput: function(v) {
        return v;
    },
    
    /** A hook for subclasses/instances to do input filtering during key press.
        The default implementation does nothing.
        @param domEvent:object The dom key press event.
        @returns void */
    filterInputPress: function(domEvent) {},
    
    /** @private */
    __syncToDom: function(event) {
        this.setValue(this.getDomValue());
    },
    
    /** Gets the location of the caret.
        @returns int. */
    getCaretPosition: function() {
        // IE Support
        if (document.selection) {
            var selection = document.selection.createRange();
            selection.moveStart('character', -this.getDomValue().length);
            return selection.text.length;
        }
        
        return this.domElement.selectionStart || 0;
    },
    
    /** Sets the caret and selection.
        @param start:int the start of the selection or location of the caret
            if no end is provided.
        @param end:int (optional) the end of the selection.
        @returns void */
    setCaretPosition: function(start, end) {
        if (end === undefined || start === end) {
            // Don't update if the current position already matches.
            if (this.getCaretPosition() === start) return;
            
            end = start;
        }
        var elem = this.domElement;
        
        if (elem.setSelectionRange) {
            elem.setSelectionRange(start, end);
        } else if (elem.createTextRange) {
            var range = elem.createTextRange();
            range.collapse(true);
            range.moveEnd('character', end);
            range.moveStart('character', start);
            range.select();
        }
    },
    
    /** Sets the caret to the start of the text input.
        @returns void */
    setCaretToStart: function() {
        this.setCaretPosition(0);
    },
    
    /** Sets the caret to the end of the text input.
        @returns void */
    setCaretToEnd: function() {
        this.setCaretPosition(this.getDomValue().length);
    },
    
    // Selection //
    /** Selects all the text in the input element.
        @returns void */
    selectAll: function() {
        this.domElement.select();
    },
    
    getSelection: function() {
        var de = this.domElement;
        return {
            start:de.selectionStart,
            startElem:de,
            end:de.selectionEnd,
            endElem:de
        };
    },
    
    setSelection: function(selection) {
        if (selection) this.setCaretPosition(selection.start, selection.end);
    },
    
    saveSelection: function(selection) {
        this._selRange = selection || this.getSelection() || this._selRange;
    },
    
    restoreSelection: function() {
        this.setSelection(this._selRange);
    }
});


/** A view that accepts single line user text input. */
myt.InputText = new JS.Class('InputText', myt.BaseInputText, {
    include: [myt.SizeHeightToDom],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Input */
    initNode: function(parent, attrs) {
        this.inputType = 'text';
        
        this.callSuper(parent, attrs);
        
        this.setCaretToEnd();
    }
});


/** An myt.InputText that is also a FormElement.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.FormInputText = new JS.Class('FormInputText', myt.InputText, {
    include: [myt.FormInputTextMixin]
});


/** A text input with select list.
    
    Events:
        None
    
    Attributes:
        filterItems:boolean Indicates if the list items should be filtered
            down based on the current value. Defaults to true.
        fullItemConfig:array The full list of items that can be shown in the
            list. The actual itemConfig used will be filtered based on the
            current value of the input text.
*/
myt.ComboBox = new JS.Class('ComboBox', myt.InputText, {
    include: [
        myt.Activateable,
        myt.KeyActivation,
        myt.ListViewAnchor
    ],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Input */
    initNode: function(parent, attrs) {
        this.filterItems = true;
        
        if (attrs.activationKeys === undefined) attrs.activationKeys = [13,27,38,40];
        if (attrs.bgColor === undefined) attrs.bgColor = '#ffffff';
        if (attrs.borderWidth === undefined) attrs.borderWidth = 1;
        if (attrs.borderStyle === undefined) attrs.borderStyle = 'solid';
        if (attrs.floatingAlignOffset === undefined) attrs.floatingAlignOffset = attrs.borderWidth;
        if (attrs.listViewAttrs === undefined) attrs.listViewAttrs = {maxHeight:99};
        if (attrs.fullItemConfig === undefined) attrs.fullItemConfig = [];
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setFullItemConfig: function(v) {this.fullItemConfig = v;},
    setFilterItems: function(v) {this.filterItems = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Show floating panel if the value has changed during during
        user interaction.
        @overrides */
    __syncToDom: function(event) {
        var existing = this.value;
        this.callSuper(event);
        if (existing !== this.value) this.showFloatingPanel();
    },
    
    /** @overrides */
    showFloatingPanel: function(panelId) {
        var fp = this.getFloatingPanel(panelId);
        if (fp) {
            // Filter config
            var itemConfig;
            if (this.filterItems) {
                itemConfig = [];
                
                var curValue = this.value,
                    normalizedCurValue = curValue == null ? '' : ('' + curValue).toLowerCase(),
                    fullItemConfig = this.fullItemConfig,
                    len = fullItemConfig.length, i = 0, 
                    item, normalizedItemValue, idx;
                for (; len > i;) {
                    item = fullItemConfig[i++];
                    normalizedItemValue = item.attrs.text.toLowerCase();
                    idx = normalizedItemValue.indexOf(normalizedCurValue);
                    if (idx === 0) {
                        if (normalizedItemValue !== normalizedCurValue) itemConfig.push(item);
                    } else if (idx > 0) {
                        itemConfig.push(item);
                    }
                }
            } else {
                itemConfig = this.fullItemConfig;
            }
            
            if (itemConfig.length > 0) {
                fp.setMinWidth(this.width - 2 * this.borderWidth); // Must be set before setItemConfig
                this.setItemConfig(itemConfig);
                this.callSuper(panelId);
            } else {
                this.hideFloatingPanel(panelId);
            }
        }
    },
    
    /** @overrides */
    doItemActivated: function(itemView) {
        this.setValue(itemView.text);
        this.callSuper(itemView);
    },
    
    /** @overrides */
    doActivated: function() {
        this.toggleFloatingPanel();
    }
});


/** An myt.ComboBox that is also a FormElement.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.FormComboBox = new JS.Class('FormComboBox', myt.ComboBox, {
    include: [myt.FormElement, myt.UpdateableUI],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Input */
    initNode: function(parent, attrs) {
        this.acceleratorScope = 'element';
        this.validateWhen = 'key';
        this.errorColor = '#ff9999';
        this.actionRequiredColor = '#996666';
        this.normalColor = '#999999';
        
        this.callSuper(parent, attrs);
        
        this.addValueProcessor(myt.global.valueProcessors.getValueProcessor('undefToEmpty'));
        
        this.addAccelerator('accept', this.doAccept);
        this.addAccelerator('reject', this.doReject);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setValidateWhen: function(v) {this.validateWhen = v;},
    setAcceleratorScope: function(v) {this.acceleratorScope = v;},
    setErrorColor: function(v) {this.errorColor = v;},
    setActionRequiredColor: function(v) {this.actionRequiredColor = v;},
    setNormalColor: function(v) {this.normalColor = v;},
    
    setIsChanged: function(v) {
        this.callSuper(v);
        if (this.inited) this.updateUI();
    },
    
    setIsValid: function(v) {
        this.callSuper(v);
        if (this.inited) this.updateUI();
    },
    
    /** @overrides myt.FormElement */
    setValue: function(v) {
        var retval = this.callSuper(v);
        
        // Validate as we type.
        var when = this.validateWhen;
        if (when === 'key' || when === 'blurWithKeyFix') this.verifyValidState();
        
        return retval;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    doAccept: function() {
        if (!this.disabled) {
            switch (this.acceleratorScope) {
                case 'root':
                    this.getRootForm().invokeAccelerator("submit");
                    break;
                case 'element':
                    // Tab navigate forward
                    myt.global.focus.next(false);
                    break;
                case 'none':
                default:
            }
        }
    },
    
    doReject: function() {
        if (!this.disabled) {
            switch (this.acceleratorScope) {
                case 'root':
                    this.getRootForm().invokeAccelerator("cancel");
                    break;
                case 'element':
                    this.rollbackForm();
                    this.getRootForm().doValidation();
                    if (this.form) this.form.verifyChangedState(this);
                    break;
                case 'none':
                default:
            }
        }
    },
    
    notifyPanelShown: function(panel) {
        this._isShown = true;
    },
    
    notifyPanelHidden: function(panel) {
        this._isShown = false;
    },
    
    /** @overrides myt.ListViewAnchor. */
    doActivationKeyDown: function(key, isRepeat) {
        if (key === 27 && !this._isShown) {
            this.invokeAccelerator("reject");
        } else {
            this.callSuper(key, isRepeat);
        }
    },
    
    /** @overrides myt.ListViewAnchor. */
    doActivationKeyUp: function(key) {
        if (key === 13 && !this._isShown) {
            this.invokeAccelerator("accept");
        } else {
            this.callSuper(key);
        }
    },
    
    /** @overrides myt.FocusObservable */
    doBlur: function() {
        this.callSuper();
        
        // Validate on blur
        var when = this.validateWhen;
        if (when === 'blur' || when === 'blurWithKeyFix') this.verifyValidState();
    },
    
    /** @overrides myt.UpdateableUI */
    updateUI: function() {
        this.setBorderColor(
            this.isValid ? this.normalColor : (this.isChanged ? this.errorColor : this.actionRequiredColor)
        );
    }
});


/** A view that accepts multi line user text input.
    
    Events:
        resize:string
        wrap:string
    
    Attributes:
        resize:string Sets how the textarea can be resized. Defaults to 'none'.
            Allowed values: 'none', 'both', 'horizontal', 'vertical'.
        wrap:string Sets how text will wrap. Defaults to 'soft'.
            Allowed values: 'off', 'hard', 'soft'.
*/
myt.InputTextArea = new JS.Class('InputTextArea', myt.BaseInputText, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.BaseInputText */
    initNode: function(parent, attrs) {
        if (attrs.resize === undefined) attrs.resize = 'none';
        if (attrs.wrap === undefined) attrs.wrap = 'soft';
        
        this.callSuper(parent, attrs);
    },
    
    /** @overrides myt.NativeInputWrapper */
    createOurDomElement: function(parent) {
        var elem = document.createElement('textarea');
        elem.style.position = 'absolute';
        return elem;
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setResize: function(v) {
        if (this.resize !== v) {
            this.resize = this.deStyle.resize = v || 'none';
            if (this.inited) this.fireNewEvent('resize', v);
        }
    },
    
    setWrap: function(v) {
        if (this.wrap !== v) {
            this.wrap = this.domElement.wrap = v;
            if (this.inited) this.fireNewEvent('wrap', v);
        }
    }
});


/** An myt.InputTextArea that is also a FormElement.
    
    Accelerators:
        Only "reject" from myt.FormInputTextMixin.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.FormInputTextArea = new JS.Class('FormInputTextArea', myt.InputTextArea, {
    include: [myt.FormInputTextMixin],
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.FormInputTextMixin */
    __handleKeyDown: function(event) {
        // Do nothing so the "accept" accelerator is not invoked.
    },
});


/** Text content that can be edited.
    
    Events:
        contentEditable:boolean
        minWidth:number
    
    Attributes:
        contentEditble:boolean Makes the text editable or not.
        minWidth:number The minimum width for the component. Defaults to 
            undefined which is effectively 0.
        minHeight:number The minimum height for the component. Defaults to 
            undefined which is effectively 0.
    
    Private Attributes:
        _selRange:object Stores the start and end of the selection.
*/
myt.EditableText = new JS.Class('EditableText', myt.BaseInputText, {
    include: [myt.SizeToDom],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.BaseInputText */
    initNode: function(parent, attrs) {
        if (attrs.whiteSpace === undefined) attrs.whiteSpace = 'pre';
        if (attrs.contentEditable === undefined) attrs.contentEditable = true;
        
        this.callSuper(parent, attrs);
        
        this.attachToDom(this, '__cleanInput', 'keydown');
        
        this.attachToDom(this, '__userInteraction', 'keyup');
        this.attachToDom(this, '__userInteraction', 'mouseup');
        
        this.setCaretToEnd();
    },
    
    /** @overrides myt.NativeInputWrapper */
    createOurDomElement: function(parent) {
        var elem = document.createElement('div');
        elem.style.position = 'absolute';
        return elem;
    },
    
    
    // Attributes //////////////////////////////////////////////////////////////
    setMinWidth: function(v) {this.__setProp(v, 'minWidth');},
    setMinHeight: function(v) {
        if (BrowserDetect.browser === 'Firefox') v += 2;
        
        this.__setProp(v, 'minHeight');
    },
    setPadding: function(v) {
        this.setPaddingTop(v);
        this.setPaddingRight(v);
        this.setPaddingBottom(v);
        this.setPaddingLeft(v);
    },
    setPaddingTop: function(v) {this.__setProp(v, 'paddingTop');},
    setPaddingRight: function(v) {this.__setProp(v, 'paddingRight');},
    setPaddingBottom: function(v) {this.__setProp(v, 'paddingBottom');},
    setPaddingLeft: function(v) {this.__setProp(v, 'paddingLeft');},
    
    /** @private */
    __setProp: function(v, propName) {
        if (this[propName] !== v) {
            this[propName] = v;
            this.deStyle[propName] = v + 'px';
            if (this.inited) {
                this.fireNewEvent(propName, v);
                this.sizeViewToDom();
            }
        }
    },
    
    setContentEditable: function(v) {
        if (this.contentEditable !== v) {
            this.contentEditable = this.domElement.contentEditable = v;
            if (this.inited) this.fireNewEvent('contentEditable', v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.BaseInputText */
    filterInputPress: function(domEvent) {
        // Implement maxLength
        var maxLength = this.maxLength;
        if (maxLength >= 0 && this.getCharacterCount() === maxLength) domEvent.preventDefault();
        
        this.callSuper(domEvent);
    },
    
    /** @overrides myt.NativeInputWrapper */
    getDomValue: function() {
        return this.domElement.innerHTML;
    },
    
    /** @overrides myt.NativeInputWrapper */
    setDomValue: function(v) {
        var de = this.domElement;
        if (de.innerHTML !== v) {
            de.innerHTML = v;
            this.sizeViewToDom();
            this.restoreSelection();
        }
    },
    
    /** @private */
    __cleanInput: function(event) {
        // Prevent enter key from inserting a div
        if (myt.KeyObservable.getKeyCodeFromEvent(event) === 13) {
            event.value.preventDefault();
            
            // Instead, insert a linefeed if wrapping is allowed.
            if (this.whitespace !== 'nowrap') {
                document.execCommand('insertHTML', false, this.isCaretAtEnd() ? '\n\n' : '\n');
            }
        }
    },
    
    /** @overrides myt.BaseInputText */
    __syncToDom: function(event) {
        this.callSuper(event);
        
        this.saveSelection();
        this.sizeViewToDom();
        this.restoreSelection();
    },
    
    // Caret handling
    getCharacterCount: function() {
        var elem = this.domElement.firstChild;
        return elem ? elem.length : 0;
    },
    
    isCaretAtEnd: function() {
        return this.getCaretPosition() === this.getCharacterCount();
    },
    
    /** @overrides myt.BaseInputText */
    getCaretPosition: function() {
        var selection = this.getSelection();
        return selection ? selection.end : 0;
    },
    
    /** @overrides myt.BaseInputText */
    setCaretPosition: function(start, end) {
        if (end === undefined || start === end) {
            // Don't update if the current position already matches.
            if (this.getCaretPosition() === start) return;
            
            end = start;
        }
        this.saveSelection({
            start:start,
            startElem:this.domElement.firstChild,
            end:end,
            endElem:this.domElement.firstChild
        });
    },
    
    // Selection handling
    /** @overrides myt.FocusObservable */
    doFocus: function() {
        this.callSuper();
        this.restoreSelection();
    },
    
    /** @private */
    __userInteraction: function(event) {
        this.saveSelection();
        return true;
    },
    
    /** @overrides myt.BaseInputText */
    getSelection: function() {
        var range;
        if (window.getSelection) {
            var sel = window.getSelection();
            if (sel.rangeCount > 0) {
                // Sometimes when deleting we get an unexpected node
                if (sel.extentNode === this.domElement) return null;
                
                range = sel.getRangeAt(0);
            }
        } else if (document.selection) {
            range = document.selection.createRange();
        }
        
        return {
            start:range ? range.startOffset : 0,
            startElem:range ? range.startContainer : this.domElement.firstChild,
            end:range ? range.endOffset : 0,
            endElem:range ? range.endContainer : this.domElement.firstChild
        };
    },
    
    /** @overrides myt.BaseInputText */
    setSelection: function(selection) {
        if (selection) {
            var startElem = selection.startElem,
                endElem = selection.endElem;
            if (startElem && startElem.parentNode && endElem && endElem.parentNode) {
                var range = document.createRange();
                range.setStart(startElem, Math.min(selection.start, startElem.length));
                range.setEnd(endElem, Math.min(selection.end, endElem.length));
                
                if (window.getSelection) {
                    var sel = window.getSelection();
                    if (sel.rangeCount > 0) sel.removeAllRanges();
                    sel.addRange(range);
                } else if (document.selection) {
                    range.select();
                }
            }
        }
    }
});


/** An myt.EditableText that is also a FormElement.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.FormEditableText = new JS.Class('FormEditableText', myt.EditableText, {
    include: [myt.FormInputTextMixin],
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.FormInputTextMixin */
    __handleKeyDown: function(event) {
        // Only allow enter key as accelerator if no wrapping is occurring
        if (this.whitespace === 'nowrap') this.callSuper(event);
    },
});


/** A data point in an myt.ScatterGraph
    
    Attributes:
        id:string The unique ID of the point relative to the ScatterGraph it
            is in.
        x:number The raw x value of the data.
        y:number The raw y value of the data.
        px:number The converted x pixel location.
        py:number The converted y pixel location.
        ax:number The animation target x for a point being animated.
        ay:number The animation target y for a point being animated.
        config:object holds arbitrary config information. Typically used to
            provide drawing hints.
        _progress:number The animation progress.
        _origX:number The starting x when an animation begins.
        _origY:number The starting y when an animation begins.
        _xAttrDiff:number The x difference between the original and animation
            target when an animation begins.
        _yAttrDiff:number The y difference between the original and animation
            target when an animation begins.
*/
myt.ScatterGraphPoint = new JS.Class('ScatterGraphPoint', {
    include: [myt.Selectable],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new Path. */
    initialize: function(id, x, y, config) {
        this.setId(id);
        this.setX(x);
        this.setY(y);
        this.setConfig(config);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setId: function(v) {this.id = v;},
    setX: function(v) {this.x = v;},
    setY: function(v) {this.y = v;},
    setPx: function(v) {this.px = v;},
    setPy: function(v) {this.py = v;},
    setAx: function(v) {this.ax = v;},
    setAy: function(v) {this.ay = v;},
    setConfig: function(v) {this.config = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    getTemplate: function(graph) {
        return graph.getPointTemplate(this.selected ? this.config.selectedTemplateKey : this.config.templateKey);
    },
    
    setData: function(key, value) {
        var data = this._data;
        if (!data) this._data = data = {};
        data[key] = value;
    },
    
    getData: function(key) {
        return this._data ? this._data[key] : undefined;
    },
    
    prepareForAnimation: function(ax, ay) {
        this.ax = ax;
        this.ay = ay;
        
        this._origX = this.x;
        this._origY = this.y;
        this._xAttrDiff = ax - this.x;
        this._yAttrDiff = ay - this.y;
        this._progress = 0;
    },
    
    updateForAnimation: function(timeDiff) {
        // Snap to final value when close
        if (Math.abs(this.x - this.ax) + Math.abs(this.y - this.ay) < 0.00000001) {
            this.x = this.ax;
            this.y = this.ay;
            return false;
        }
        
        // Animate
        this._progress += timeDiff;
        if (this._progress > 1000) this._progress = 1000;
        
        var easingFunc = this.config.easingFunction || myt.Animator.DEFAULT_EASING_FUNCTION;
        
        this.x = this._origX + easingFunc(this._progress, this._xAttrDiff, 1000);
        this.y = this._origY + easingFunc(this._progress, this._yAttrDiff, 1000);
        return true;
    }
});


/** A k-d Tree implementation.
    
    Ported from:
        k-d Tree JavaScript - V 1.0
        
        https://github.com/ubilabs/kd-tree-javascript
        
        @author Mircea Pricop <pricop@ubilabs.net>, 2012
        @author Martin Kleppe <kleppe@ubilabs.net>, 2012
        @author Ubilabs http://ubilabs.net, 2012
        @license MIT License <http://www.opensource.org/licenses/mit-license.php>
*/
myt.KDTreeNode = new JS.Class('KDTreeNode', {
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new Path. */
    initialize: function(obj, dimension, parent) {
        this.obj = obj;
        this.left = null;
        this.right = null;
        this.parent = parent;
        this.dimension = dimension;
    }
});

/** Binary heap implementation from:
    http://eloquentjavascript.net/appendix2.html */
myt.BinaryHeap = new JS.Class('BinaryHeap', {
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new Path. */
    initialize: function(scoreFunction) {
        this.content = [];
        this.scoreFunction = scoreFunction;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    push: function(element) {
        // Add the new element to the end of the array.
        this.content.push(element);
        // Allow it to bubble up.
        this.bubbleUp(this.content.length - 1);
    },
    
    pop: function() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it sink down.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.sinkDown(0);
        }
        return result;
    },
    
    peek: function() {
        return this.content[0];
    },
    
    remove: function(node) {
        var len = this.content.length;
        // To remove a value, we must search through the array to find it.
        for (var i = 0; i < len; i++) {
            if (this.content[i] == node) {
                // When it is found, the process seen in 'pop' is repeated
                // to fill up the hole.
                var end = this.content.pop();
                if (i != len - 1) {
                    this.content[i] = end;
                    if (this.scoreFunction(end) < this.scoreFunction(node)) {
                        this.bubbleUp(i);
                    } else {
                        this.sinkDown(i);
                    }
                }
                return;
            }
        }
        throw new Error("Node not found.");
    },
    
    size: function() {
        return this.content.length;
    },
    
    bubbleUp: function(n) {
        // Fetch the element that has to be moved.
        var element = this.content[n];
        // When at 0, an element can not go up any further.
        while (n > 0) {
            // Compute the parent element's index, and fetch it.
            var parentN = Math.floor((n + 1) / 2) - 1,
            parent = this.content[parentN];
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            } else {
                // Found a parent that is less, no need to move it further.
                break;
            }
        }
    },
    
    sinkDown: function(n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);
        
        while(true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) * 2, child1N = child2N - 1;
            // This is used to store the new position of the element,
            // if any.
            var swap = null;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N],
                    child1Score = this.scoreFunction(child1);
                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore) swap = child1N;
            }
            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N],
                    child2Score = this.scoreFunction(child2);
                if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;
            }
            
            // If the element needs to be moved, swap it, and continue.
            if (swap != null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            } else {
                // Otherwise, we are done.
                break;
            }
        }
    }
});

myt.KDTree = new JS.Class('KDTree', {
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        EUCLIDEAN_METRIC: function(a, b) {
            return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
        }
    },
    
    
    // Constructor /////////////////////////////////////////////////////////////
    /** Create a new Path. */
    initialize: function(points, metric, dimensions) {
        this.metric = metric;
        this.dimensions = dimensions;
        
        // If points is not an array, assume we're loading a pre-built tree
        this.rebuildTree(points);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    rebuildTree: function(points) {
        this.root = this.buildTree(points, 0, null);
    },
    
    buildTree: function(points, depth, parent) {
        var dimensions = this.dimensions,
            dim = depth % dimensions.length, median, node;
        
        if (points.length === 0) return null;
        if (points.length === 1) return new myt.KDTreeNode(points[0], dim, parent);
        
        points.sort(function (a, b) {
            return a[dimensions[dim]] - b[dimensions[dim]];
        });
        
        median = Math.floor(points.length / 2);
        node = new myt.KDTreeNode(points[median], dim, parent);
        node.left = this.buildTree(points.slice(0, median), depth + 1, node);
        node.right = this.buildTree(points.slice(median + 1), depth + 1, node);
        
        return node;
    },
    
    insert: function(point) {
        var dimensions = this.dimensions;
        
        function innerSearch(node, parent, point) {
            if (node === null) return parent;
            
            var dimension = dimensions[node.dimension];
            if (point[dimension] < node.obj[dimension]) {
                return innerSearch(node.left, node, point);
            } else {
                return innerSearch(node.right, node, point);
            }
        }
        
        var insertPosition = innerSearch(this.root, null, point), newNode, dimension;
        
        if (insertPosition === null) {
            this.root = new myt.KDTreeNode(point, 0, null);
            return;
        }
        
        newNode = new myt.KDTreeNode(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);
        dimension = dimensions[insertPosition.dimension];
        
        if (point[dimension] < insertPosition.obj[dimension]) {
            insertPosition.left = newNode;
        } else {
            insertPosition.right = newNode;
        }
    },
    
    /*remove: function(point) {
console.log("remove", point);
        var node, dimensions = this.dimensions, self = this;
        
        function nodeSearch(node, point) {
            if (node === null) return null;
            
            if (node.obj === point) return node;
            
            var dimension = dimensions[node.dimension];
            
            if (point[dimension] < node.obj[dimension]) {
                return nodeSearch(node.left, point);
            } else {
                return nodeSearch(node.right, point);
            }
        }
        
        function removeNode(node) {
            var nextNode, nextObj, pDimension;
            
            function findMax(node, dim) {
                var dimension, own, left, right, max;
                
                if (node === null) return null;
                
                dimension = dimensions[dim];
                if (node.dimension === dim) {
                    if (node.right !== null) return findMax(node.right, dim);
                    return node;
                }
                
                own = node.obj[dimension];
                left = findMax(node.left, dim);
                right = findMax(node.right, dim);
                max = node;
                
                if (left !== null && left.obj[dimension] > own) max = left;
                if (right !== null && right.obj[dimension] > max.obj[dimension]) max = right;
                return max;
            }
            
            function findMin(node, dim) {
                var dimension, own, left, right, min;
                
                if (node === null) return null;
                
                dimension = dimensions[dim];
                
                if (node.dimension === dim) {
                    if (node.left !== null) return findMin(node.left, dim);
                    return node;
                }
                
                own = node.obj[dimension];
                left = findMin(node.left, dim);
                right = findMin(node.right, dim);
                min = node;
                
                if (left !== null && left.obj[dimension] < own) min = left;
                if (right !== null && right.obj[dimension] < min.obj[dimension]) min = right;
                return min;
            }
            
            if (node.left === null && node.right === null) {
                if (node.parent === null) {
                    self.root = null;
                    return;
                }
                
                pDimension = dimensions[node.parent.dimension];
                
                if (node.obj[pDimension] < node.parent.obj[pDimension]) {
                    node.parent.left = null;
                } else {
                    node.parent.right = null;
                }
                return;
            }
            
            if (node.left !== null) {
                nextNode = findMax(node.left, node.dimension);
            } else {
                nextNode = findMin(node.right, node.dimension);
            }
            
            nextObj = nextNode.obj;
            removeNode(nextNode);
            node.obj = nextObj;
        }
        
        node = nodeSearch(this.root, point);
console.log("found", node ? node.obj : null);
        if (node !== null) removeNode(node);
    },*/
    
    nearest: function(point, maxNodes, maxDistance) {
        var i, result, bestNodes, dimensions = this.dimensions, self = this;
        
        bestNodes = new myt.BinaryHeap(
            function(e) {return -e[1];}
        );
        
        function nearestSearch(node) {
            var bestChild,
                dimension = dimensions[node.dimension],
                ownDistance = self.metric(point, node.obj),
                linearPoint = {},
                linearDistance,
                otherChild,
                i;
            
            function saveNode(node, distance) {
                bestNodes.push([node, distance]);
                if (bestNodes.size() > maxNodes) bestNodes.pop();
            }
            
            for (i = 0; i < dimensions.length; i += 1) {
                if (i === node.dimension) {
                    linearPoint[dimensions[i]] = point[dimensions[i]];
                } else {
                    linearPoint[dimensions[i]] = node.obj[dimensions[i]];
                }
            }
            
            linearDistance = self.metric(linearPoint, node.obj);
            
            if (node.right === null && node.left === null) {
                if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                    saveNode(node, ownDistance);
                }
                return;
            }
            
            if (node.right === null) {
                bestChild = node.left;
            } else if (node.left === null) {
                bestChild = node.right;
            } else {
                if (point[dimension] < node.obj[dimension]) {
                    bestChild = node.left;
                } else {
                    bestChild = node.right;
                }
            }
            
            nearestSearch(bestChild);
            
            if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                saveNode(node, ownDistance);
            }
            
            if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
                if (bestChild === node.left) {
                    otherChild = node.right;
                } else {
                    otherChild = node.left;
                }
                if (otherChild !== null) nearestSearch(otherChild);
            }
        }
        
        if (maxDistance) {
            for (i = 0; i < maxNodes; i += 1) {
                bestNodes.push([null, maxDistance]);
            }
        }
        
        if (self.root) nearestSearch(self.root);
        
        result = [];
        
        for (i = 0; i < maxNodes; i += 1) {
            if (bestNodes.content[i][0]) {
                result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);
            }
        }
        return result;
    },
    
    balanceFactor: function() {
        var self = this;
        
        function height(node) {
            if (node === null) return 0;
            return Math.max(height(node.left), height(node.right)) + 1;
        }
        
        function count(node) {
            if (node === null) return 0;
            return count(node.left) + count(node.right) + 1;
        }
        
        return height(self.root) / (Math.log(count(self.root)) / Math.log(2));
    },
    
    dump: function() {this._dump(this.root, '  ', 'root');},
    _dump: function(node, depth, label) {
        console.log(depth + label + ' ' + node.dimension + ': ' + node.obj.id + ' x:' + node.obj.x + ' y:' + node.obj.y);
        if (node.left) this._dump(node.left, depth + '  ', 'L');
        if (node.right) this._dump(node.right, depth + '  ', 'R');
    }
});


/** A graph of points.
    
    Attributes:
        allowSelection:boolean If true selecting graph points is allowed.
            Defaults to true.
        scaleDataX:number The number of pixels per data unit in the x-axis.
        scaleDataY:number The number of pixels per data unit in the y-axis.
        originX:number The origin of the graph in pixels along the x-axis.
        originY:number The origin of the graph in pixels along the y-axis.
        data:array An array of myt.ScatterGraphPoints this graph is displaying.
        _animating:array An array of myt.ScatterGraphPoints this graph is
            displaying and that are currently animating.
        filter:function a filter function that reduces what gets drawn. The 
            function should be of the form function(point, graph) and return 
            true if the point should not be drawn or false if the point
            should be drawn.
*/
// TODO: Replace scale and origin with just the conversion functions.
myt.ScatterGraph = new JS.Class('ScatterGraph', myt.Canvas, {
    include: [myt.SelectionManager],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        createCircleTemplate: function(radius, color, opacity, strokeWidth, strokeColor, strokeOpacity) {
            var strokeWidth = strokeWidth == null ? 0 : strokeWidth,
                center = radius + strokeWidth + 1, // 1 is extra space for antialiasing
                offscreen = new myt.Canvas(myt.global.roots.getRoots()[0], {
                    width:2 * center, height:2 * center, visible:false
                });
            
            offscreen.beginPath();
            offscreen.circle(center, center, radius);
            offscreen.closePath();
            offscreen.setFillStyle(color);
            offscreen.setGlobalAlpha(opacity == null ? 1 : opacity);
            offscreen.fill();
            
            if (strokeWidth > 0) {
                offscreen.setGlobalAlpha(strokeOpacity == null ? 1 : strokeOpacity);
                offscreen.setStrokeStyle(strokeColor == null ? color : strokeColor);
                offscreen.setLineWidth(strokeWidth);
                offscreen.stroke();
            }
            
            var retval = offscreen.__canvas;
            retval.centerX = retval.centerY = center;
            
            offscreen.destroy();
            return retval;
        },
        
        convertXPixelToValue: function(px, graph) {return (px - graph.originX) / graph.scaleDataX;},
        convertYPixelToValue: function(py, graph) {return (py - graph.originY) / graph.scaleDataY;},
        
        convertXValueToPixel: function(x, graph) {return Math.round((x * graph.scaleDataX) + graph.originX);},
        convertYValueToPixel: function(y, graph) {return Math.round((y * graph.scaleDataY) + graph.originY);},
        
        /** A filter to prevent drawing points outside the bounds of
            the scatter graph. */
        BASE_FILTER: function(p, graph) {
            return p.px < 0 || p.px > graph.width || p.py < 0 || p.py > graph.height;
        }
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this._pointTemplates = {};
        this._animating = [];
        this._maxTemplateSizeSquared = 0;
        
        this.drawnCount = this.drawnAnimatingCount = this.drawnCountTotal = 0;
        
        if (attrs.data === undefined) attrs.data = [];
        
        if (attrs.scaleDataX === undefined) attrs.scaleDataX = 1;
        if (attrs.scaleDataY === undefined) attrs.scaleDataY = 1;
        if (attrs.originX === undefined) attrs.originX = 0;
        if (attrs.originY === undefined) attrs.originY = 0;
        
        var SG = myt.ScatterGraph;
        if (attrs.xConversionFuncPxToV === undefined) attrs.xConversionFuncPxToV = SG.convertXPixelToValue;
        if (attrs.yConversionFuncPxToV === undefined) attrs.yConversionFuncPxToV = SG.convertYPixelToValue;
        if (attrs.xConversionFuncVToPx === undefined) attrs.xConversionFuncVToPx = SG.convertXValueToPixel;
        if (attrs.yConversionFuncVToPx === undefined) attrs.yConversionFuncVToPx = SG.convertYValueToPixel;
        
        if (attrs.highlightColor === undefined) attrs.highlightColor = '#000000';
        if (attrs.highlightSelectedColor === undefined) attrs.highlightSelectedColor = '#000000';
        if (attrs.highlightWidth === undefined) attrs.highlightWidth = 1;
        if (attrs.highlightOffset === undefined) attrs.highlightOffset = 2;
        
        if (attrs.allowSelection === undefined) attrs.allowSelection = true;
        
        this.callSuper(parent, attrs);
        
        var w = this.width, h = this.height, al = this.animationLayer, hl = this.highlightLayer;
        al.setWidth(w);
        hl.setWidth(w);
        al.setHeight(h);
        hl.setHeight(h);
        
        this.redrawPointsDelayed();
        this.redrawAnimatingPointsDelayed();
        
        this.attachToDom(this, '_doMouseMove', 'mousemove');
    },
    
    doBeforeAdoption: function() {
        this.callSuper();
        
        new myt.Canvas(this, {name:'animationLayer'});
        new myt.Canvas(this, {name:'highlightLayer'});
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    setWidth: function(v) {
        this.callSuper(v);
        
        if (this.inited) {
            this.animationLayer.setWidth(v);
            this.highlightLayer.setWidth(v);
        }
    },
    
    /** @overrides myt.View */
    setHeight: function(v) {
        this.callSuper(v);
        
        if (this.inited) {
            this.animationLayer.setHeight(v);
            this.highlightLayer.setHeight(v);
        }
    },
    
    setAllowSelection: function(v) {
        if (this.allowSelection === v) return;
        this.allowSelection = v;
        if (this.inited) this.fireNewEvent('allowSelection', v);
        
        if (v) {
            this.attachToDom(this, '_doClick', 'click');
        } else {
            if (this.inited) this.detachFromDom(this, '_doClick', 'click');
        }
    },
    
    setXConversionFuncPxToV: function(v) {this.xConversionFuncPxToV = v},
    setYConversionFuncPxToV: function(v) {this.yConversionFuncPxToV = v},
    setXConversionFuncVToPx: function(v) {this.xConversionFuncVToPx = v},
    setYConversionFuncVToPx: function(v) {this.yConversionFuncVToPx = v},
    
    setScaleDataX: function(v) {
        if (this.scaleDataX === v) return;
        this.scaleDataX = v;
        if (this.inited) {
            this.fireNewEvent('scaleDataX', v);
            this.redrawPointsDelayed();
            this.redrawAnimatingPointsDelayed();
        }
    },
    
    setScaleDataY: function(v) {
        if (this.scaleDataY === v) return;
        this.scaleDataY = v;
        if (this.inited) {
            this.fireNewEvent('scaleDataY', v);
            this.redrawPointsDelayed();
            this.redrawAnimatingPointsDelayed();
        }
    },
    
    setOriginX: function(v) {
        if (this.originX === v) return;
        this.originX = v;
        if (this.inited) {
            this.fireNewEvent('originX', v);
            this.redrawPointsDelayed();
            this.redrawAnimatingPointsDelayed();
        }
    },
    
    setOriginY: function(v) {
        if (this.originY === v) return;
        this.originY = v;
        if (this.inited) {
            this.fireNewEvent('originY', v);
            this.redrawPointsDelayed();
            this.redrawAnimatingPointsDelayed();
        }
    },
    
    setScaleAndOrigin: function(scaleDataX, scaleDataY, originX, originY) {
        var changed = false;
        
        if (this.scaleDataX !== scaleDataX) {
            this.scaleDataX = scaleDataX;
            changed = true;
        }
        if (this.scaleDataY !== scaleDataY) {
            this.scaleDataY = scaleDataY;
            changed = true;
        }
        if (this.originX !== originX) {
            this.originX = originX;
            changed = true;
        }
        if (this.originY !== originY) {
            this.originY = originY;
            changed = true;
        }
        
        if (changed) {
            this.redrawPoints();
            this.redrawAnimatingPoints();
        }
    },
    
    setData: function(v) {
        this.data = v;
        this._kdtree = v ? new myt.KDTree(v, myt.KDTree.EUCLIDEAN_METRIC, ["x", "y"]) : null;
        if (this.inited) this.redrawPointsDelayed();
    },
    
    setAnimating: function(v) {
        if (this.animating === v) return;
        this.animating = v;
        if (this.inited) {
            if (v) {
                this.attachTo(myt.global.idle, '__animate', 'idle');
            } else {
                this.detachFrom(myt.global.idle, '__animate', 'idle');
            }
        }
    },
    
    setHighlightedPoint: function(v) {
        if (this.highlightedPoint === v) return;
        this.highlightedPoint = v;
        if (this.inited) {
            this.fireNewEvent('highlightedPoint', v);
            this.drawHighlightedPoint();
        }
    },
    
    setHighlightColor: function(v) {this.highlightColor = v;},
    setHighlightSelectedColor: function(v) {this.highlightSelectedColor = v;},
    setHighlightWidth: function(v) {this.highlightWidth = v;},
    setHighlightOffset: function(v) {this.highlightOffset = v;},
    
    setFilter: function(func) {
        this.filter = func;
        if (this.inited) {
            this.redrawPointsDelayed();
            this.redrawAnimatingPointsDelayed();
        }
    },
    
    setDrawnCount: function(v) {
        this.drawnCount = v;
        this.setDrawnCountTotal(v + this.drawnAnimatingCount);
    },
    
    setDrawnAnimatingCount: function(v) {
        this.drawnAnimatingCount = v;
        this.setDrawnCountTotal(v + this.drawnCount);
    },
    
    setDrawnCountTotal: function(v) {this.set('drawnCountTotal', v, true);},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.SelectionManager */
    getManagedItems: function() {
        return this.data.concat(this.animating);
    },
    
    getMinX: function() {return this.convertXPixelToValue(0);},
    getMinY: function() {return this.convertYPixelToValue(0);},
    getMaxX: function() {return this.convertXPixelToValue(this.width);},
    getMaxY: function() {return this.convertYPixelToValue(this.height);},
    
    _doClick: function(event) {
        var hp = this.highlightedPoint, 
            isToggle = this.isToggleMode(), 
            isAdd = this.isAddMode();
        if (hp) {
            if (isToggle) {
                hp.selected ? this.deselect(hp) : this.select(hp);
            } else if (isAdd) {
                this.select(hp);
            } else {
                this.deselectAll();
                this.select(hp);
            }
            
            this.redrawPointsDelayed();
            this.redrawAnimatingPointsDelayed();
        } else if (this.selectedCount > 0 && !isToggle && !isAdd) {
            this.deselectAll();
            this.redrawPointsDelayed();
            this.redrawAnimatingPointsDelayed();
        }
        return true;
    },
    
    // Hit testing
    _doMouseMove: function(event) {
        var pos = myt.MouseObservable.getMouseFromEventRelativeToView(event, this);
        pos.x = this.convertXPixelToValue(pos.x);
        pos.y = this.convertYPixelToValue(pos.y);
        var maxSize = this._maxTemplateSizeSquared / this.scaleDataX; // FIXME: assumes uniform scale
        
        var nearest = this.nearest(pos, 1000, maxSize);
        
        // Filter down to list that we're actually inside
        var len = nearest.length, i = len, item, point, distance, template, templateSize,
            BASE_FILTER = myt.ScatterGraph.BASE_FILTER,
            smallestRadius = 0;
        while (i) {
            item = nearest[--i];
            point = item[0];
            distance = item[1];
            template = point.getTemplate(this);
            templateSize = Math.max(template.centerX, template.centerY) / this.scaleDataX;
            if (distance > (templateSize * templateSize) ||
                BASE_FILTER(point, this) || (this.filter && this.filter(point, this))
            ) {
                nearest.splice(i, 1);
            } else {
                smallestRadius = smallestRadius === 0 ? templateSize : Math.min(smallestRadius, templateSize);
            }
        }
        
        // Filter down to smallest radius
        i = nearest.length;
        while (i) {
            item = nearest[--i];
            point = item[0];
            template = point.getTemplate(this);
            templateSize = Math.max(template.centerX, template.centerY) / this.scaleDataX;
            if (templateSize !== smallestRadius) nearest.splice(i, 1);
        }
        
        // Take closest
        var nearestPoint;
        if (nearest.length > 0) {
            nearest.sort(function(a,b) {return a[1] - b[1];});
            nearestPoint = nearest[0][0];
        }
        this.setHighlightedPoint(nearestPoint);
        
        return true;
    },
    
    nearest: function(point, count, maxDistance) {
        if (this._kdtree) {
            return this._kdtree.nearest(point, count, maxDistance);
        } else {
            return null;
        }
    },
    
    drawHighlightedPoint: function() {
        var layer = this.highlightLayer, hp = this.highlightedPoint;
        layer.clear();
        if (hp) {
            if (myt.ScatterGraph.BASE_FILTER(hp, this) || (this.filter && this.filter(hp, this))) return;
            
            var template = hp.getTemplate(this);
            layer.beginPath();
            layer.circle(hp.px, hp.py, template.centerX + this.highlightOffset);
            layer.closePath();
            layer.setLineWidth(this.highlightWidth);
            layer.setStrokeStyle(hp.selected ? this.highlightSelectedColor : this.highlightColor);
            layer.stroke();
        }
    },
    
    // Data
    /** Adds a single myt.ScatterGraphPoint
        @param dataPoint:myt.ScatterGraphPoint the point to add.
        @returns void */
    addDataPoint: function(dataPoint) {
        this.data.push(dataPoint);
        this._kdtree.insert(dataPoint);
        this.drawPoint(dataPoint);
    },
    
    /** Adds multiple data points.
        @param dataPoints:array of myt.ScatterGraphPoint
        @returns void */
    addDataPoints: function(dataPoints) {
        this.data = this.data.concat(dataPoints);
        this.drawPoints(dataPoints);
        if (!this._lockRebuild) this._kdtree.rebuildTree(this.data);
    },
    
    // Get points
    /** Gets one or more myt.ScatterGraphPoints that match the provided
        matcher function which are not currently animating.
        @param matchFunc:function the match function to use.
        @param multiple:boolean (optional) indicates if only the first point 
            found or all points found should be returned. Defaults to false.
        @returns a single point or an array of points. */
    getDataPoint: function(matchFunc, multiple) {
        return this._getDataPoint(this.data, matchFunc, multiple);
    },
    
    /** Gets one or more myt.ScatterGraphPoints that match the provided
        matcher function which are currently animating.
        @param matchFunc:function the match function to use.
        @param multiple:boolean (optional) indicates if only the first point 
            found or all points found should be returned. Defaults to false.
        @returns a single point or an array of points. */
    getAnimatingDataPoint: function(matchFunc, multiple) {
        return this._getDataPoint(this._animating, matchFunc, multiple);
    },
    
    /** Gets all data points that match the provided match function.
        @param matchFunc:function (optional) A function that filters the
            returned points.
        @param invert:boolean (optional) If true the points that don't match
            will be returned.
        @returns array */
    getAllDataPoints: function(matchFunc, invert) {
        var retval = [];
        
        if (matchFunc) {
            var data = this.data, i = data.length, dataPoint;
            while (i) {
                dataPoint = data[--i];
                if (matchFunc.call(this, dataPoint, i) === !invert) retval.push(dataPoint);
            }
            
            data = this._animating;
            i = data.length;
            
            while (i) {
                dataPoint = data[--i];
                if (matchFunc.call(this, dataPoint, i) === !invert) retval.push(dataPoint);
            }
        } else {
            retval = this.data.concat(this._animating);
        }
        
        return retval;
    },
    
    _getDataPoint: function(data, matchFunc, multiple) {
        var i = data.length, dataPoint, retval = [];
        while (i) {
            dataPoint = data[--i];
            if (matchFunc.call(this, dataPoint, i)) {
                if (!multiple) return dataPoint;
                retval.push(dataPoint);
            }
        }
        
        if (retval.length === 0) return null;
        return retval;
    },
    
    /** Gets an myt.ScatterGraphPoint with the matching ID.
        @param id:string the id to match.
        @param type:string (optional) indicates if 'animating', 'still' or 
            'both' types of points should be searched. Defaults to 'both'.
        @returns the data point or null if not found. */
    getDataPointById: function(id, type) {
        return this._getDataPointsBy(function(p, i) {return p.id === id;}, type);
    },
    
    _getDataPointsBy: function(func, type, multiple) {
        if (type === 'animating') {
            return this.getDataPoint(func, multiple);
        } else if (type === 'still') {
            return this.getAnimatingDataPoint(func, multiple);
        } else {
            // Check both
            if (multiple) {
                return this._getDataPoint(this.getAllDataPoints(), func, true);
            } else {
                return this.getDataPoint(func, multiple) || this.getAnimatingDataPoint(func, multiple);
            }
        }
    },
    
    getDataPointsInsideCircle: function(centerX, centerY, radius, isLatLng, points) {
        var func = myt.Geometry[isLatLng ? 'circleContainsLatLng' : 'circleContainsPoint'];
        func = func.bind(myt.Geometry);
        
        if (!points) points = this.getAllDataPoints();
        
        return this._getDataPoint(points, function(p, i) {
            return func(p.y, p.x, centerY, centerX, radius);
        }, true);
    },
    
    /** @param path:myt.Path */
    getDataPointsInsidePolygon: function(path, points) {
        var bounds = path.getBoundingBox(), pathData = path.vectors;
        
        if (!points) points = this.getAllDataPoints();
        
        return this._getDataPoint(points, function(p, i) {
            return myt.Geometry.isPointInPath(p.x, p.y, bounds, pathData);
        }, true);
    },
    
    // Remove points
    /** Remove all data points from this graph.
        @returns void */
    removeAllDataPoints: function() {
        var data = this.data;
        data.length = 0;
        this._animating.length = 0;
        this._kdtree.rebuildTree(data);
        
        this.setHighlightedPoint(null);
        this.deselectAll();
        this.redrawPoints(true);
        this.redrawAnimatingPoints(true);
    },
    
    removeDataPoint: function(matchFunc, multiple) {
        var retval = this._removeDataPoint(this.data, matchFunc, multiple);
        if (retval) this.redrawPoints(true);
        return retval;
    },
    
    removeAnimatingDataPoint: function(matchFunc, multiple) {
        var retval = this._removeDataPoint(this._animating, matchFunc, multiple);
        if (retval) this.redrawAnimatingPoints(true);
        return retval;
    },
    
    /** Removes one or more myt.ScatterGraphPoint that the provided matcher
        function returns true for.
        @param data:array the data to search on.
        @param matchFunc:function
        @param multiple:boolean (optional) If true all matching points will
            be removed.
        @returns the removed point or null if not found. If multiple is true
            an array of removed mytScatterGraphPoints will be returned. */
    _removeDataPoint: function(data, matchFunc, multiple) {
        var i = data.length, dataPoint, retval = [];
        while (i) {
            dataPoint = data[--i];
            if (matchFunc.call(this, dataPoint, i)) {
                data.splice(i, 1);
                
                if (!this._lockRebuild && this.data === data) this._kdtree.rebuildTree(this.data);
                
                if (this.highlightedPoint === dataPoint) this.setHighlightedPoint(null);
                if (!multiple) return dataPoint;
                retval.push(dataPoint);
            }
        }
        
        return retval.length === 0 ? null : retval;
    },
    
    removeDataPointById: function(id, type) {
        return this._removeDataPointBy(function(p, i) {return p.id === id;}, type);
    },
    
    /** Removes a list of data points that match the provided list of IDs.
        Both still and animating points will be removed if they match.
        @param idList:array an array of IDs to remove.
        @returns void */
    removeDataPointsById: function(idList) {
        var i = idList.length, id, func, atLeastOneRemoval = false, atLeastOneAnimatingRemoval = false;
        
        this._lockDraw = this._lockRebuild = true;
        while (i) {
            id = idList[--i];
            func = function(p, i) {return p.id === id;};
            
            if (this.removeDataPoint(func)) {
                atLeastOneRemoval = true;
            } else if (this.removeAnimatingDataPoint(func)) {
                atLeastOneAnimatingRemoval = true;
            }
        }
        this._lockDraw = this._lockRebuild = false;
        
        if (atLeastOneRemoval) {
            this.redrawPoints(true);
            this._kdtree.rebuildTree(this.data);
        }
        if (atLeastOneAnimatingRemoval) {
            this.redrawAnimatingPoints(true);
        }
    },
    
    removeDataPointByIndex: function(idx, type) {
        return this._removeDataPointBy(function(p, i) {return i === idx;}, type);
    },
    
    removeDataPointByEquality: function(point, type) {
        return this._removeDataPointBy(function(p, i) {return p === point;}, type);
    },
    
    _removeDataPointBy: function(func, type) {
        if (type === 'animating') {
            return this.removeDataPoint(func);
        } else if (type === 'still') {
            return this.removeAnimatingDataPoint(func);
        } else {
            // Check both
            return this.removeDataPoint(func) || this.removeAnimatingDataPoint(func);
        }
    },
    
    removeDataPointInsideBounds: function(x, y, w, h, includeBounds) {
        return this.removeDataPoint(function(p, i) {
            if (includeBounds) {
                return (p.x >= x) && (p.x <= x + w) && (p.y >= y) && (p.y <= y + h);
            } else {
                return (p.x > x) && (p.x < x + w) && (p.y > y) && (p.y < y + h);
            }
        }, true);
    },
    
    removeDataPointOutsideBounds: function(x, y, w, h, includeBounds) {
        return this.removeDataPoint(function(p, i) {
            if (includeBounds) {
                return (p.x <= x) || (p.x >= x + w) || (p.y <= y) || (p.y >= y + h);
            } else {
                return (p.x < x) || (p.x > x + w) || (p.y < y) || (p.y > y + h);
            }
        }, true);
    },
    
    // Drawing Templates
    /** Adds an image data object to use as a template for a point.
        @param key:string the key to store the template under.
        @param template:object the template for a point.
        @returns void */
    addPointTemplate: function(key, template) {
        this._pointTemplates[key] = template;
        this._recalcMaxTemplateSizeSquared();
    },
    
    /** Gets a point template.
        @param key:string the key to get.
        @returns image data object or undefined if not found. */
    getPointTemplate: function(key) {
        return this._pointTemplates[key];
    },
    
    /** Removes a point template.
        @param key:string the key to remove.
        @returns image data object or undefined if not found. */
    removePointTemplate: function(key) {
        var retval = this._pointTemplates[key];
        delete this._pointTemplates[key];
        this._recalcMaxTemplateSizeSquared();
        return retval;
    },
    
    _recalcMaxTemplateSizeSquared: function() {
        var v = 0, key, templates = this._pointTemplates, template;
        
        for (key in templates) {
            template = templates[key];
            v = Math.max(v, Math.max(template.centerX, template.centerY));
        }
        
        this._maxTemplateSizeSquared = v * v;
    },
    
    // Value Conversion
    convertXPixelToValue: function(px) {return this.xConversionFuncPxToV(px, this);},
    convertYPixelToValue: function(py) {return this.yConversionFuncPxToV(py, this);},
    
    convertXValueToPixel: function(x) {return this.xConversionFuncVToPx(x, this);},
    convertYValueToPixel: function(y) {return this.yConversionFuncVToPx(y, this);},
    
    /** Modifies the provided point so the value is in pixels.
        @param p:object with a x and y properties each of which is a number.
        @return void */
    convertPointToPixels: function(p) {
        p.setPx(this.convertXValueToPixel(p.x));
        p.setPy(this.convertYValueToPixel(p.y));
    },
    
    /** Modifies the provided array of points so the value is in pixels.
        @param points:array an array of object with a x and y properties each 
            of which is a number.
        @return void */
    convertPointsToPixels: function(points) {
        var i = points.length;
        while (i) this.convertPointToPixels(points[--i]);
    },
    
    // Drawing
    drawPoint: function(p, context, skipConversion) {
        if (!this._lockDraw) {
            if (!context) context = this.__ctx;
            if (!skipConversion) this.convertPointToPixels(p);
            
            if (myt.ScatterGraph.BASE_FILTER(p, this) || (this.filter && this.filter(p, this))) return;
            
            var template = p.getTemplate(this);
            context.drawImage(template, p.px - template.centerX, p.py - template.centerY);
        }
    },
    
    drawPoints: function(data, context, skipConversion) {
        var drawnCount = 0;
        if (!this._lockDraw) {
            var i = data.length, p, templates = this._pointTemplates, template, 
                w = this.width, h = this.height,
                BASE_FILTER = myt.ScatterGraph.BASE_FILTER;
            if (!context) context = this.__ctx;
            
            if (!skipConversion) this.convertPointsToPixels(data);
            
            while (i) {
                p = data[--i];
                
                if (BASE_FILTER(p, this) || (this.filter && this.filter(p, this))) continue;
                
                template = p.getTemplate(this);
                context.drawImage(template, p.px - template.centerX, p.py - template.centerY);
                ++drawnCount;
            }
        }
        return drawnCount;
    },
    
    redrawPoints: function(skipConversion) {
        this.clear();
        var drawnCount = this.drawPoints(this.data, this.__ctx, skipConversion);
        this.drawHighlightedPoint();
        this.setDrawnCount(drawnCount);
    },
    
    redrawAnimatingPoints: function(skipConversion) {
        this.animationLayer.clear();
        var drawnCount = this.drawPoints(this._animating, this.animationLayer.__ctx, skipConversion);
        this.drawHighlightedPoint();
        this.setDrawnAnimatingCount(drawnCount);
    },
    
    // Animating
    animatePoints: function(triplets) {
        this._lockDraw = this._lockRebuild = true;
        
        var animatingCount = this._animating.length,
            len = triplets.length, i = 0;
        if (len % 3 === 0) {
            while (len > i) this.animatePoint(triplets[i++], triplets[i++], triplets[i++]);
        }
        
        this._lockDraw = this._lockRebuild = false;
        
        this.redrawAnimatingPoints(true);
        if (this._animating.length !== animatingCount) this.redrawPoints(true);
        
        if (this._kdtree) this._kdtree.rebuildTree(this.data);
    },
    
    /** Animates the provided ScatterGraphPoint to the new x and y */
    animatePoint: function(p, x, y) {
        if (p) {
            p.prepareForAnimation(x, y);
            
            this.removeDataPointByEquality(p);
            
            // Add animating point
            this._animating.push(p);
            this.setAnimating(true);
        }
    },
    
    __animate: function(idleEvent) {
        var points = this._animating, i = points.length, point,
            delta = idleEvent.value.delta;
        while (i) {
            point = points[--i];
            if (!point.updateForAnimation(delta)) {
                // Remove point since it no longer needs to animate
                points.splice(i, 1);
                this.addDataPoint(point);
            }
        }
        
        this.redrawAnimatingPoints();
        
        if (points.length === 0) this.setAnimating(false);
    },
    
    // Metrics
    countDataPoints: function(func) {
        if (func) {
            return this.getAllDataPoints(func).length;
        } else {
            return this._animating.length + this.data.length;
        }
    }
});

myt.DelayedMethodCall.createDelayedMethodCall(myt.ScatterGraph, 0, 'redrawPoints');
myt.DelayedMethodCall.createDelayedMethodCall(myt.ScatterGraph, 0, 'redrawAnimatingPoints');


/** A numeric value component that stays within a minimum and maximum value.
    
    Events:
        minValue:number
        maxValue:number
        snapToInt:boolean
    
    Attributes:
        minValue:number the largest value allowed. If undefined or null no
            min value is enforced.
        maxValue:number the lowest value allowed. If undefined or null no
            max value is enforced.
        snapToInt:boolean If true values can only be integers. Defaults to true.
*/
myt.BoundedValueComponent = new JS.Module('BoundedValueComponent', {
    include: [myt.ValueComponent],
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (attrs.snapToInt === undefined) attrs.snapToInt = true;
        
        if (!attrs.valueFilter) {
            var self = this;
            attrs.valueFilter = function(v) {
                var max = self.maxValue;
                if (max != null && v > max) return max;
                
                var min = self.minValue;
                if (min != null && v < min) return min;
                
                return v;
            };
        }
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSnapToInt: function(v) {
        if (this.snapToInt !== v) {
            this.snapToInt = v;
            if (this.inited) {
                this.fireNewEvent('snapToInt', v);
                
                // Update min, max and value since snap has been turned on
                if (v) {
                    this.setMinValue(this.minValue);
                    this.setMaxValue(this.maxValue);
                    this.setValue(this.value);
                }
            }
        }
    },
    
    setMinValue: function(v) {
        if (v != null && this.snapToInt) v = Math.round(v);
        
        if (this.minValue !== v) {
            var max = this.maxValue;
            if (max != null && v > max) v = max;
            
            this.minValue = v;
            if (this.inited) {
                this.fireNewEvent('minValue', v);
                
                // Rerun setValue since the filter has changed.
                this.setValue(this.value);
            }
        }
    },
    
    setMaxValue: function(v) {
        if (v != null && this.snapToInt) v = Math.round(v);
        
        if (this.maxValue !== v) {
            var min = this.minValue;
            if (min != null && v < min) v = min;
            
            this.maxValue = v;
            if (this.inited) {
                this.fireNewEvent('maxValue', v);
                
                // Rerun setValue since the filter has changed.
                this.setValue(this.value);
            }
        }
    },
    
    /** @overrides myt.ValueComponent */
    setValue: function(v) {
        this.callSuper(this.snapToInt && v != null && !isNaN(v) ? Math.round(v) : v);
    }
});


/** Provides global drag and drop functionality.
    
    Events:
        dragLeave:myt.DropTarget Fired when a myt.Dropable is dragged out of
            the drop target.
        dragEnter:myt.DropTarget Fired when a myt.Dropable is dragged over
            the drop target.
        startDrag:object Fired when a drag starts. Value is the object
            being dragged.
        stopDrag:object Fired when a drag ends. Value is the object 
            that is no longer being dragged.
        drop:object Fired when a drag ends over a drop target. The value is
            an array containing the dropable at index 0 and the drop target
            at index 1.
    
    Attributes:
        dragView:myt.View The view currently being dragged.
        overView:myt.View The view currently being dragged over.
        dropTargets:array The list of myt.DropTargets currently registered
            for notification when drag and drop events occur.
        autoScrollers:array The list of myt.AutoScrollers currently registered
            for notification when drags start and stop.
*/
new JS.Singleton('GlobalDragManager', {
    include: [myt.Observable],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    initialize: function() {
        this.dropTargets = [];
        this.autoScrollers = [];
        
        myt.global.register('dragManager', this);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setDragView: function(v) {
        var cur = this.dragView;
        if (cur !== v) {
            this.dragView = v;
            
            var isStart = !!v, targets, i, dv, funcName, eventName;
            
            if (isStart) {
                dv = v;
                funcName = 'notifyDragStart';
                eventName = 'startDrag';
            } else {
                dv = cur;
                funcName = 'notifyDragStop';
                eventName = 'stopDrag';
            }
            
            targets = this.__filterList(dv, this.dropTargets);
            i = targets.length;
            while (i) targets[--i][funcName](dv);
            
            targets = this.__filterList(dv, this.autoScrollers);
            i = targets.length;
            while (i) targets[--i][funcName](dv);
            
            this.fireNewEvent(eventName, v);
        }
    },
    
    setOverView: function(v) {
        var cur = this.overView;
        if (cur !== v) {
            var dv = this.dragView;
            if (cur) {
                cur.notifyDragLeave(dv);
                dv.notifyDragLeave(cur);
                this.fireNewEvent('dragLeave', cur);
            }
            
            this.overView = v;
            
            if (v) {
                v.notifyDragEnter(dv);
                dv.notifyDragEnter(v);
                this.fireNewEvent('dragEnter', cur);
            }
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Registers the provided auto scroller to receive notifications.
        @param autoScroller:myt.AutoScroller The auto scroller to register.
        @returns void */
    registerAutoScroller: function(autoScroller) {
        this.autoScrollers.push(autoScroller);
    },
    
    /** Unregisters the provided auto scroller.
        @param autoScroller:myt.AutoScroller The auto scroller to unregister.
        @returns void */
    unregisterAutoScroller: function(autoScroller) {
        var autoScrollers = this.autoScrollers, i = autoScrollers.length;
        while (i) {
            if (autoScrollers[--i] === autoScroller) {
                autoScrollers.splice(i, 1);
                break;
            }
        }
    },
    
    /** Registers the provided drop target to receive notifications.
        @param dropTarget:myt.DropTarget The drop target to register.
        @returns void */
    registerDropTarget: function(dropTarget) {
        this.dropTargets.push(dropTarget);
    },
    
    /** Unregisters the provided drop target.
        @param dropTarget:myt.DropTarget The drop target to unregister.
        @returns void */
    unregisterDropTarget: function(dropTarget) {
        var dropTargets = this.dropTargets, i = dropTargets.length;
        while (i) {
            if (dropTargets[--i] === dropTarget) {
                dropTargets.splice(i, 1);
                break;
            }
        }
    },
    
    /** Called by a myt.Dropable when a drag starts.
        @param dropable:myt.Dropable The dropable that started the drag.
        @returns void */
    startDrag: function(dropable) {
        this.setDragView(dropable);
    },
    
    /** Called by a myt.Dropable when a drag stops.
        @param event:event The mouse event that triggered the stop drag.
        @param dropable:myt.Dropable The dropable that stopped being dragged.
        @returns void */
    stopDrag: function(event, dropable, isAbort) {
        var overView = this.overView;
        dropable.notifyDrop(overView, isAbort);
        if (overView && !isAbort) overView.notifyDrop(dropable);
        
        this.setOverView();
        this.setDragView();
        
        if (overView && !isAbort) this.fireNewEvent('drop', [dropable, overView]);
    },
    
    /** Called by a myt.Dropable during dragging.
        @param event:event The mousemove event for the drag update.
        @param dropable:myt.Dropable The dropable that is being dragged.
        @returns void */
    updateDrag: function(event, dropable) {
        // Get the frontmost myt.DropTarget that is registered with this 
        // manager and is under the current mouse location and has a 
        // matching drag group.
        var topDropTarget,
            dropTargets = this.__filterList(dropable, this.dropTargets);
            i = dropTargets.length;
        
        if (i > 0) {
            var domMouseEvent = event.value,
                mouseX = domMouseEvent.pageX,
                mouseY = domMouseEvent.pageY,
                dropTarget;
            
            while (i) {
                dropTarget = dropTargets[--i];
                if (dropTarget.willAcceptDrop(dropable) &&
                    dropable.willPermitDrop(dropTarget) &&
                    dropTarget.isPointVisible(mouseX, mouseY) && 
                    (!topDropTarget || dropTarget.isInFrontOf(topDropTarget))
                ) {
                    topDropTarget = dropTarget;
                }
            }
        }
        
        this.setOverView(topDropTarget);
    },
    
    /** Filters the provided array of myt.DragGroupSupport items for the
        provided dropable.
        @private
        @param dropable:myt.Dropable The dropable to filter for.
        @returns array: An array of the matching list items. */
    __filterList: function(dropable, list) {
        var retval;
        
        if (dropable.acceptAnyDragGroup()) {
            retval = list;
        } else {
            retval = [];
            
            var dragGroups = dropable.getDragGroups(),
                i = list.length, 
                item, targetGroups, dragGroup;
            while (i) {
                item = list[--i];
                if (item.acceptAnyDragGroup()) {
                    retval.push(item);
                } else {
                    targetGroups = item.getDragGroups();
                    for (dragGroup in dragGroups) {
                        if (targetGroups[dragGroup]) {
                            retval.push(item);
                            break;
                        }
                    }
                }
            }
        }
        
        return retval;
    },
});


/** Makes an myt.View draggable via the mouse.
    
    Also supresses context menus since the mouse down to open it causes bad
    behavior since a mouseup event is not always fired.
    
    Events:
        isDragging:boolean Fired when the isDragging attribute is modified
            via setIsDragging.
    
    Attributes:
        allowAbort:boolean Allows a drag to be aborted by the user by
            pressing the 'esc' key. Defaults to undefined which is equivalent
            to false.
        isDraggable:boolean Configures the view to be draggable or not. The 
            default value is true.
        distanceBeforeDrag:number The distance, in pixels, before a mouse 
            down and drag is considered a drag action. Defaults to 0.
        isDragging:boolean Indicates that this view is currently being dragged.
        draggableAllowBubble:boolean Determines if mousedown and mouseup
            dom events handled by this component will bubble or not. Defaults
            to true.
        dragOffsetX:number The x amount to offset the position during dragging.
            Defaults to 0.
        dragOffsetY:number The y amount to offset the position during dragging.
            Defaults to 0.
        dragInitX:number Stores initial mouse x position during dragging.
        dragInitY:number Stores initial mouse y position during dragging.
        centerOnMouse:boolean If true this draggable will update the dragInitX
            and dragInitY to keep the view centered on the mouse. Defaults
            to undefined which is equivalent to false.
    
    Private Attributes:
        __lastMousePosition:object The last position of the mouse during
            dragging.
*/
myt.Draggable = new JS.Module('Draggable', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        this.isDraggable = this.isDragging = false;
        this.draggableAllowBubble = true;
        this.distanceBeforeDrag = this.dragOffsetX = this.dragOffsetY = 0;
        
        // Will be set after init since the draggable subview probably
        // doesn't exist yet.
        var isDraggable = true;
        if (attrs.isDraggable !== undefined) {
            isDraggable = attrs.isDraggable;
            delete attrs.isDraggable;
        }
        
        this.callSuper(parent, attrs);
        
        this.setIsDraggable(isDraggable);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setIsDraggable: function(v) {
        if (this.isDraggable !== v) {
            this.isDraggable = v;
            // No event needed.
            
            var func;
            if (v) {
                func = this.attachToDom;
            } else if (this.inited) {
                func = this.detachFromDom;
            }
            
            if (func) {
                var dvs = this.getDragViews(), dragview, i = dvs.length;
                while (i) {
                    dragview = dvs[--i];
                    func.call(this, dragview, '__doMouseDown', 'mousedown');
                    func.call(this, dragview, '__doContextMenu', 'contextmenu');
                }
            }
        }
    },
    
    setIsDragging: function(v) {
        if (this.isDragging !== v) {
            this.isDragging = v;
            if (this.inited) this.fireNewEvent('isDragging', v);
        }
    },
    
    setDragOffsetX: function(v, supressUpdate) {
        if (this.dragOffsetX !== v) {
            this.dragOffsetX = v;
            if (this.inited && this.isDragging && !supressUpdate) this.__requestDragPosition();
        }
    },
    
    setDragOffsetY: function(v, supressUpdate) {
        if (this.dragOffsetY !== v) {
            this.dragOffsetY = v;
            if (this.inited && this.isDragging && !supressUpdate) this.__requestDragPosition();
        }
    },
    
    setDistanceBeforeDrag: function(v) {this.distanceBeforeDrag = v;},
    setDraggableAllowBubble: function(v) {this.draggableAllowBubble = v;},
    setCenterOnMouse: function(v) {this.centerOnMouse = v;},
    setAllowAbort: function(v) {this.allowAbort = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @returns an array of views that can be moused down on to start the
        drag. Subclasses should override this to return an appropriate list
        of views. By default this view is returned thus making the entire
        view capable of starting a drag. */
    getDragViews: function() {
        return [this];
    },
    
    /** @private */
    __doContextMenu: function(event) {
        // Do nothing so the context menu event is supressed.
    },
    
    /** @private */
    __doMouseDown: function(event) {
        var pos = myt.MouseObservable.getMouseFromEvent(event);
        this.dragInitX = pos.x - this.x;
        this.dragInitY = pos.y - this.y;
        
        var gm = myt.global.mouse;
        this.attachToDom(gm, '__doMouseUp', 'mouseup', true);
        if (this.distanceBeforeDrag > 0) {
            this.attachToDom(gm, '__doDragCheck', 'mousemove', true);
        } else {
            this.startDrag(event);
        }
        
        event.value.preventDefault();
        return this.draggableAllowBubble;
    },
    
    /** @private */
    __doMouseUp: function(event) {
        if (this.isDragging) {
            this.stopDrag(event, false);
        } else {
            var gm = myt.global.mouse;
            this.detachFromDom(gm, '__doMouseUp', 'mouseup', true);
            this.detachFromDom(gm, '__doDragCheck', 'mousemove', true);
        }
        return this.draggableAllowBubble;
    },
    
    /** @private */
    __watchForAbort: function(event) {
        if (event.value === 27) this.stopDrag(event, true);
    },
    
    /** @private */
    __doDragCheck: function(event) {
        var pos = myt.MouseObservable.getMouseFromEvent(event),
            distance = myt.Geometry.measureDistance(pos.x, pos.y, this.dragInitX + this.x, this.dragInitY + this.y);
        if (distance >= this.distanceBeforeDrag) {
            this.detachFromDom(myt.global.mouse, '__doDragCheck', 'mousemove', true);
            this.startDrag(event);
        }
    },
    
    /** Active until stopDrag is called. The view position will be bound
        to the mouse position. Subclasses typically call this onmousedown for
        subviews that allow dragging the view.
        @param event:event The event the mouse event when the drag started.
        @returns void */
    startDrag: function(event) {
        if (this.centerOnMouse) {
            this.syncTo(this, '__updateDragInitX', 'width');
            this.syncTo(this, '__updateDragInitY', 'height');
        }
        
        var g = myt.global;
        if (this.allowAbort) this.attachTo(g.keys, '__watchForAbort', 'keyup');
        
        this.setIsDragging(true);
        this.attachToDom(g.mouse, 'updateDrag', 'mousemove', true);
        this.updateDrag(event);
    },
    
    /** Called on every mousemove event while dragging.
        @returns void */
    updateDrag: function(event) {
        this.__lastMousePosition = myt.MouseObservable.getMouseFromEvent(event);
        this.__requestDragPosition();
    },
    
    /** @private */
    __updateDragInitX: function(event) {
        this.dragInitX = this.width / 2 * (this.scaleX || 1);
    },
    
    /** @private */
    __updateDragInitY: function(event) {
        this.dragInitY = this.height / 2 * (this.scaleY || 1);
    },
    
    /** @private */
    __requestDragPosition: function() {
        var pos = this.__lastMousePosition;
        this.requestDragPosition(
            pos.x - this.dragInitX + this.dragOffsetX, 
            pos.y - this.dragInitY + this.dragOffsetY
        );
    },
    
    /** Stop the drag. (see startDrag for more details)
        @param event:object The event that ended the drag.
        @param isAbort:boolean Indicates if the drag ended normally or was
            aborted.
        @returns void */
    stopDrag: function(event, isAbort) {
        var g = myt.global, gm = g.mouse;
        this.detachFromDom(gm, '__doMouseUp', 'mouseup', true);
        this.detachFromDom(gm, 'updateDrag', 'mousemove', true);
        if (this.centerOnMouse) {
            this.detachFrom(this, '__updateDragInitX', 'width');
            this.detachFrom(this, '__updateDragInitY', 'height');
        }
        if (this.allowAbort) this.detachFrom(g.keys, '__watchForAbort', 'keyup');
        this.setIsDragging(false);
    },
    
    /** Repositions the view to the provided values. The default implementation
        is to directly set x and y. Subclasses should override this method
        when it is necessary to constrain the position.
        @param x:number the new x position.
        @param y:number the new y position.
        @returns void */
    requestDragPosition: function(x, y) {
        if (!this.disabled) {
            this.setX(x);
            this.setY(y);
        }
    }
});


/** Provides Slider thumb functionality.
    
    Requires:
        myt.Button
    
    Events:
        None
    
    Attributes:
        None
*/
myt.SliderThumbMixin = new JS.Module('SliderThumbMixin', {
    include: [myt.Draggable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Checkbox */
    initNode: function(parent, attrs) {
        if (attrs.width === undefined) attrs.width = parent.thumbWidth;
        if (attrs.height === undefined) attrs.height = parent.thumbHeight;
        
        if (attrs.repeatKeyDown === undefined) attrs.repeatKeyDown = true;
        if (attrs.activationKeys === undefined) {
            attrs.activationKeys = [
                37, // left arrow
                38, // up arrow
                39, // right arrow
                40 // down arrow
            ];
        }
        
        this.callSuper(parent, attrs);
        
        if (parent.axis === 'x') {
            this.setY(parent.thumbOffset);
        } else {
            this.setX(parent.thumbOffset);
        }
        
        this.syncTo(parent, 'setDisabled', 'disabled');
        
        parent._syncThumbToValue(this, parent.getValue());
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.Disableable */
    setDisabled: function(v) {
        // Adapt to event from syncTo
        if (v !== null && typeof v === 'object') v = v.value;
        
        this.callSuper(v);
    },
    
    /** @overrides myt.FocusObservable */
    setFocused: function(v) {
        this.callSuper(v);
        if (v) this.makeHighestZIndex();
    },
    
    /** @overrides myt.View */
    setX: function(v) {
        if (this.x !== v) {
            this.callSuper(v);
            
            if (this.parent.axis === 'x') this.parent._syncValueToThumb(this);
        }
    },
    
    /** @overrides myt.View */
    setY: function(v) {
        if (this.y !== v) {
            this.callSuper(v);
            
            if (this.parent.axis === 'y') this.parent._syncValueToThumb(this);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Draggable */
    requestDragPosition: function(x, y) {
        if (!this.disabled) {
            var parent = this.parent,
                minPx = parent.getMinPixelValueForThumb(this),
                maxPx = parent.getMaxPixelValueForThumb(this),
                halfSize, pos, func;
            
            if (parent.axis === 'x') {
                halfSize = this.width / 2;
                pos = x;
                func = this.setX;
            } else {
                halfSize = this.height / 2;
                pos = y;
                func = this.setY;
            }
            
            func.call(this, Math.min(Math.max(pos, minPx - halfSize), maxPx - halfSize));
        }
    },
    
    /** @overrides myt.Button. */
    doActivationKeyDown: function(key, isRepeat) {
        var parent = this.parent;
        switch (key) {
            case 37: // Left
                parent.nudgeValueLeft(this);
                break;
            case 38: // Up
                parent.nudgeValueUp(this);
                break;
            case 39: // Right
                parent.nudgeValueRight(this);
                break;
            case 40: // Down
                parent.nudgeValueDown(this);
                break;
        }
        
        this.callSuper(key, isRepeat);
    }
});


/** A simple implementation of a slider thumb. */
myt.SimpleSliderThumb = new JS.Class('SimpleSliderThumb', myt.SimpleButton, {
    include: [myt.SliderThumbMixin],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.SimpleButton */
    initNode: function(parent, attrs) {
        if (attrs.activeColor === undefined) attrs.activeColor = '#bbbbbb';
        if (attrs.readyColor === undefined) attrs.readyColor = '#cccccc';
        if (attrs.hoverColor === undefined) attrs.hoverColor = '#dddddd';
        
        if (attrs.boxShadow === undefined) attrs.boxShadow = [0, 0, 4, '#666666'];
        
        this.callSuper(parent, attrs);
        
        if (attrs.roundedCorners === undefined) this.setRoundedCorners(Math.min(this.height, this.width) / 2);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.FocusObservable */
    showFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow([0, 0, 9, '#666666']);
    },
    
    /** @overrides myt.FocusObservable */
    hideFocusEmbellishment: function() {
        this.hideDefaultFocusEmbellishment();
        this.setBoxShadow([0, 0, 4, '#666666']);
    }
});


/** A base class for slider components.
    
    Events:
        None
    
    Attributes:
        axis:string Indicates the direction the slider moves in. Allowed values
            are 'x' and 'y'. Defaults to 'x'.
        trackInset:number the number of pixels to inset the start of the track
            from the top/left edge of the component. Defaults to 0.
        trackOutset:number the number of pixels to inset the end of the track
            from the bottom/right edge of the component. Default to 0.
        thumbWidth:number The width of the thumb.
        thumbHeight:number The height of the thumb.
        thumbOffset:number The x/y offset of the thumb. Will applied to the
            opposite dimension to the axis.
        thumbClass:JS.Class the class to use to create the thumb.
        nudgeAmount:number the amount to nudge the value when the arrows keys
            are invoked. Defaults to 1.
*/
myt.BaseSlider = new JS.Class('BaseSlider', myt.View, {
    include: [myt.Disableable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        if (attrs.axis === undefined) attrs.axis = 'x';
        if (attrs.axis === 'x') {
            if (attrs.width === undefined) attrs.width = 100;
            if (attrs.height === undefined) attrs.height = 18;
        } else {
            if (attrs.width === undefined) attrs.width = 18;
            if (attrs.height === undefined) attrs.height = 100;
        }
        
        if (attrs.bgColor === undefined) attrs.bgColor = '#999999';
        if (attrs.roundedCorners === undefined) attrs.roundedCorners = 9;
        
        if (attrs.trackInset === undefined) attrs.trackInset = 9;
        if (attrs.trackOutset === undefined) attrs.trackOutset = 9;
        if (attrs.thumbWidth === undefined) attrs.thumbWidth = 16;
        if (attrs.thumbHeight === undefined) attrs.thumbHeight = 16;
        if (attrs.thumbOffset === undefined) attrs.thumbOffset = 1;
        
        if (attrs.nudgeAmount === undefined) attrs.nudgeAmount = 1;
        
        if (attrs.thumbClass === undefined) attrs.thumbClass = myt.SimpleSliderThumb;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setAxis: function(v) {this.axis = v;},
    setTrackInset: function(v) {this.trackInset = v;},
    setTrackOutset: function(v) {this.trackOutset = v;},
    setThumbWidth: function(v) {this.thumbWidth = v;},
    setThumbHeight: function(v) {this.thumbHeight = v;},
    setThumbOffset: function(v) {this.thumbOffset = v;},
    setThumbClass: function(v) {this.thumbClass = v;},
    setNudgeAmount: function(v) {this.nudgeAmount = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    convertValueToPixels: function(v) {
        var minV = this.minValue, ti = this.trackInset,
            pxRange = (this.axis === 'x' ? this.width : this.height) - ti - this.trackOutset,
            valueRange = this.maxValue - minV;
        return ti + ((v - minV) * (pxRange / valueRange));
    },
    
    convertPixelsToValue: function(px) {
        var minV = this.minValue, ti = this.trackInset,
            pxRange = (this.axis === 'x' ? this.width : this.height) - ti - this.trackOutset,
            valueRange = this.maxValue - minV;
        return ((px - ti) * (valueRange / pxRange)) + minV;
    },
    
    nudgeValueLeft: function(thumb) {
        this._nudge(thumb, false);
    },
    
    nudgeValueUp: function(thumb) {
        this._nudge(thumb, false);
    },
    
    nudgeValueRight: function(thumb) {
        this._nudge(thumb, true);
    },
    
    nudgeValueDown: function(thumb) {
        this._nudge(thumb, true);
    },
    
    _nudge: function(thumb, up) {
        // Subclasses to implement
    },
    
    _syncThumbToValue: function(thumb, value) {
        value = this.convertValueToPixels(value);
        if (this.axis === 'x') {
            thumb.setX(value - thumb.width / 2);
        } else {
            thumb.setY(value - thumb.height / 2);
        }
    }
});


/** A slider component.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __lockSync:boolean Used internally to prevent infinite loops.
*/
myt.Slider = new JS.Class('Slider', myt.BaseSlider, {
    include: [myt.BoundedValueComponent],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    doAfterAdoption: function() {
        new this.thumbClass(this, {name:'thumb'});
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides */
    setValue: function(v) {
        this.callSuper(v);
        
        // Sync position of thumb
        if (this.inited && !this.__lockSync) this._syncThumbToValue(this.thumb, this.getValue());
    },
    
    /** Update the thumb position if the width changes.
        @overrides */
    setWidth: function(v, supressEvent) {
        var existing = this.width;
        this.callSuper(v, supressEvent);
        if (this.inited && this.axis === 'x' && this.width !== existing) this._syncThumbToValue(this.thumb, this.getValue());
    },
    
    /** Update the thumb position if the height changes.
        @overrides */
    setHeight: function(v, supressEvent) {
        var existing = this.height;
        this.callSuper(v, supressEvent);
        if (this.inited && this.axis === 'y' && this.height !== existing) this._syncThumbToValue(this.thumb, this.getValue());
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Should only be called by myt.SliderThumbMixin.
        @private */
    _syncValueToThumb: function(thumb) {
        this.__lockSync = true;
        
        this.setValue(this.convertPixelsToValue(
            this.axis === 'x' ? thumb.x + thumb.width / 2 : thumb.y + thumb.height / 2
        ));
        
        // Update thumb position since value may have been adjusted
        this._syncThumbToValue(thumb, this.getValue());
        
        this.__lockSync = false;
    },
    
    /** @overrides myt.BaseSlider */
    _nudge: function(thumb, up) {
        this.setValue(this.getValue() + this.nudgeAmount * (up ? 1 : -1));
    },
    
    /** Should only be called by myt.SliderThumbMixin.
        @private */
    getMinPixelValueForThumb: function(thumb) {
        return this.convertValueToPixels(this.minValue);
    },
    
    /** Should only be called by myt.SliderThumbMixin.
        @private */
    getMaxPixelValueForThumb: function(thumb) {
        return this.convertValueToPixels(this.maxValue);
    }
});


/** A value that consists of an upper and lower value. The lower value must
    be less than or equal to the upper value. The value object that must be
    passed into setValue and returned from getValue is an object of the
    form: {lower:number, upper:number}. */
myt.RangeComponent = new JS.Module('RangeComponent', {
    include: [myt.ValueComponent],
    
    // Accessors ///////////////////////////////////////////////////////////////
    setLowerValue: function(v) {
        this.setValue({
            lower:v, 
            upper:(this.value && this.value.upper !== undefined) ? this.value.upper : v
        });
    },
    
    getLowerValue: function() {
        return this.value ? this.value.lower : undefined;
    },
    
    setUpperValue: function(v) {
        this.setValue({
            lower:(this.value && this.value.lower !== undefined) ? this.value.lower : v,
            upper:v
        });
    },
    
    getUpperValue: function() {
        return this.value ? this.value.upper : undefined;
    },
    
    setValue: function(v) {
        if (v) {
            var existing = this.value,
                existingLower = existing ? existing.lower : undefined,
                existingUpper = existing ? existing.upper : undefined;
            
            if (this.valueFilter) v = this.valueFilter(v);
            
            // Do nothing if value is identical
            if (v.lower === existingLower && v.upper === existingUpper) return;
            
            // Assign upper to lower if no lower was provided.
            if (v.lower === undefined) v.lower = v.upper;
            
            // Assign lower to upper if no upper was provided.
            if (v.upper === undefined) v.upper = v.lower;
            
            // Swap lower and upper if they are in the wrong order
            if (v.lower !== undefined && v.upper !== undefined && v.lower > v.upper) {
                var temp = v.lower;
                v.lower = v.upper;
                v.upper = temp;
            }
            
            this.value = v;
            if (this.inited) {
                this.fireNewEvent('value', this.getValue());
                if (v.lower !== existingLower) this.fireNewEvent('lowerValue', v.lower);
                if (v.upper !== existingUpper) this.fireNewEvent('upperValue', v.upper);
            }
        } else {
            this.callSuper(v);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    getValueCopy: function() {
        var v = this.value;
        return {lower:v.lower, upper:v.upper};
    }
});


/** A numeric value component that stays within an upper and lower value and
    where the value is a range. */
myt.BoundedRangeComponent = new JS.Module('BoundedRangeComponent', {
    include: [myt.BoundedValueComponent, myt.RangeComponent],
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (!attrs.valueFilter) {
            var self = this;
            attrs.valueFilter = function(v) {
                if (v) {
                    var max = self.maxValue, min = self.minValue;
                    if (max != null && v.upper > max) v.upper = max;
                    if (min != null && v.lower < min) v.lower = min;
                }
                return v;
            };
        }
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    /** @overrides myt.ValueComponent */
    setValue: function(v) {
        if (this.snapToInt && v != null) {
            if (v.lower != null && !isNaN(v.lower)) v.lower = Math.round(v.lower);
            if (v.upper != null && !isNaN(v.upper)) v.upper = Math.round(v.upper);
        }
        this.callSuper(v);
    }
});


/** A simple implementation of the range fill for a RangeSlider. */
myt.SimpleSliderRangeFill = new JS.Class('SimpleSliderRangeFill', myt.View, {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.Checkbox */
    initNode: function(parent, attrs) {
        if (attrs.bgColor === undefined) attrs.bgColor = '#666666';
        
        this.callSuper(parent, attrs);
        
        if (parent.axis === 'x') {
            this.setY(parent.thumbOffset);
            this.setHeight(parent.thumbHeight);
            this.setRoundedCorners(parent.thumbHeight / 2);
        } else {
            this.setX(parent.thumbOffset);
            this.setWidth(parent.thumbWidth);
            this.setRoundedCorners(parent.thumbWidth / 2);
        }
        parent._syncRangeFillToValue();
    }
});


/** A slider component that support two thumbs.
    
    Events:
        None
    
    Attributes:
        rangeFillClass:JS.Class The class used to instantiate the rangeFill
    
    Private Attributes:
        __lockSync:boolean Used internally to prevent infinite loops.
*/
myt.RangeSlider = new JS.Class('RangeSlider', myt.BaseSlider, {
    include: [myt.BoundedRangeComponent],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.BaseSlider */
    initNode: function(parent, attrs) {
        if (attrs.rangeFillClass === undefined) attrs.rangeFillClass = myt.SimpleSliderRangeFill;
        
        this.callSuper(parent, attrs);
    },
    
    /** @overrides */
    doAfterAdoption: function() {
        new this.rangeFillClass(this, {name:'rangeFill'});
        new this.thumbClass(this, {name:'thumbLower'});
        new this.thumbClass(this, {name:'thumbUpper'});
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setRangeFillClass: function(v) {this.rangeFillClass = v;},
    
    /** @overrides */
    setValue: function(v) {
        this.callSuper(v);
        
        if (this.inited) {
            // Sync position of thumb
            if (!this.__lockSync) {
                v = this.getValue();
                this._syncThumbToValue(this.thumbLower, v);
                this._syncThumbToValue(this.thumbUpper, v);
            }
            
            this._syncRangeFillToValue();
        }
    },
    
    /** Update the thumb position if the width changes.
        @overrides */
    setWidth: function(v, supressEvent) {
        var existing = this.width;
        this.callSuper(v, supressEvent);
        if (this.inited && this.axis === 'x' && this.width !== existing) {
            var value = this.getValue();
            this._syncThumbToValue(this.thumbLower, value);
            this._syncThumbToValue(this.thumbUpper, value);
        }
    },
    
    /** Update the thumb position if the height changes.
        @overrides */
    setHeight: function(v, supressEvent) {
        var existing = this.height;
        this.callSuper(v, supressEvent);
        if (this.inited && this.axis === 'y' && this.height !== existing) {
            var value = this.getValue();
            this._syncThumbToValue(this.thumbLower, value);
            this._syncThumbToValue(this.thumbUpper, value);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Should only be called by myt.SimpleSliderRangeFill.
        @private */
    _syncRangeFillToValue: function() {
        var rangeFill = this.rangeFill, value = this.getValue(),
            lowerPx = this.convertValueToPixels(value.lower),
            extent = this.convertValueToPixels(value.upper) - lowerPx;
        if (this.axis === 'x') {
            rangeFill.setX(lowerPx);
            rangeFill.setWidth(extent);
        } else {
            rangeFill.setY(lowerPx);
            rangeFill.setHeight(extent);
        }
    },
    
    /** @overrides myt.BaseSlider */
    _syncThumbToValue: function(thumb, value) {
        this.callSuper(thumb, thumb.name === 'thumbLower' ? value.lower : value.upper);
    },
    
    /** Should only be called by myt.SliderThumbMixin.
        @private */
    _syncValueToThumb: function(thumb) {
        this.__lockSync = true;
        
        var converted = this.convertPixelsToValue(
            this.axis === 'x' ? thumb.x + thumb.width / 2 : thumb.y + thumb.height / 2
        );
        
        var value = this.getValueCopy();
        if (thumb.name === 'thumbLower') {
            value.lower = converted;
        } else {
            value.upper = converted;
        }
        this.setValue(value);
        
        // Update thumb position since value may have been adjusted
        value = this.getValue();
        if (this.thumbLower) this._syncThumbToValue(this.thumbLower, value);
        if (this.thumbUpper) this._syncThumbToValue(this.thumbUpper, value);
        
        this.__lockSync = false;
    },
    
    /** @overrides myt.BaseSlider */
    _nudge: function(thumb, up) {
        var value = this.getValueCopy(),
            adj = this.nudgeAmount * (up ? 1 : -1);
        if (thumb.name === 'thumbLower') {
            value.lower += adj;
            if (value.lower > value.upper) value.lower = value.upper;
        } else {
            value.upper += adj;
            if (value.lower > value.upper) value.upper = value.lower;
        }
        this.setValue(value);
    },
    
    /** Should only be called by myt.SliderThumbMixin.
        @private */
    getMinPixelValueForThumb: function(thumb) {
        return this.convertValueToPixels(
            thumb.name === 'thumbLower' ? this.minValue : this.getValue().lower
        );
    },
    
    /** Should only be called by myt.SliderThumbMixin.
        @private */
    getMaxPixelValueForThumb: function(thumb) {
        return this.convertValueToPixels(
            thumb.name === 'thumbLower' ? this.getValue().upper : this.maxValue
        );
    }
});


/** Draws a divider into an myt.Canvas. */
myt.DividerDrawingMethod = new JS.Class('DividerDrawingMethod', myt.DrawingMethod, {
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.DrawingMethod */
    draw: function(canvas, config) {
        var b = config.bounds, x = b.x, y = b.y, w = b.w, h = b.h, 
            inset = config.inset, fillColor, bumpColor, grd, bumpSize, bumpLength;
        
        canvas.clear();
        
        if (w == 0 || h == 0) return;
        
        // background
        switch (config.state) {
            case 'hover':
                fillColor = config.hoverFillColor || '#d8d8d8';
                bumpColor = config.hoverBumpColor || '#e8e8e8';
                break;
            case 'active':
                fillColor = config.activeFillColor || '#b8b8b8';
                bumpColor = config.activeBumpColor || '#c8c8c8';
                break;
            case 'ready':
                fillColor = config.focused ? (config.focusedFillColor || '#d8d8d8') : (config.readyFillColor || '#cccccc');
                bumpColor = config.focused ? (config.focusedBumpColor || '#e8e8e8') : (config.readyBumpColor || '#dddddd');
                break;
            case 'disabled':
                fillColor = config.readyFillColor || '#cccccc';
                bumpColor = config.readyBumpColor || '#dddddd';
                break;
        }
        
        if (config.axis === 'y') {
            y += inset;
            h -= 2 * inset;
            grd = canvas.createLinearGradient(x, y, x + w, y);
        } else {
            x += inset;
            w -= 2 * inset;
            bumpSize = w / 2;
            grd = canvas.createLinearGradient(x, y, x, y + h);
        }
        
        canvas.beginPath();
        canvas.rect(x, y, w, h);
        canvas.closePath();
        
        grd.addColorStop(0, config.readyFillColor || '#cccccc');
        grd.addColorStop(0.5, fillColor);
        grd.addColorStop(1, config.readyFillColor || '#cccccc');
        canvas.setFillStyle(grd);
        
        canvas.fill();
        
        // Bumps
        canvas.setFillStyle(bumpColor);
        if (config.axis === 'y') {
            bumpSize = h / 2;
            bumpLength = Math.max(3 * bumpSize, config.bumpMaxLength || 14);
            x = x + (w - bumpLength) / 2;
            y = y + bumpSize / 2;
            
            myt.DrawingUtil.drawRoundedRect(canvas, bumpSize / 2, 0, x, y, bumpLength, bumpSize);
        } else {
            bumpSize = w / 2;
            bumpLength = Math.max(3 * bumpSize, config.bumpMaxLength || 14);
            y = y + (h - bumpLength) / 2;
            x = x + bumpSize / 2;
            
            myt.DrawingUtil.drawRoundedRect(canvas, bumpSize / 2, 0, x, y, bumpSize, bumpLength);
        }
        canvas.fill();
    }
});


/** A divider is a UI control that allows the user to resize two area by
    dragging the divider left/right or up/down.
    
    Events:
        limitToParent:number
        inset:number
    
    Attributes:
        axis:string Indicates if the divider should be constrained horizontally
            or vertically. Allowed values: 'x' or 'y'. This value can only
            be set during instantiation.
        limitToParent:number If set, this will constrain the maxValue to the
            appropriate parent view dimension less the limitToParent amount.
        inset:number Insets the rendered portion of the divider thus allowing
            the interactive footprint of the component to be larger than the
            visible footprint. This value will be applied to the top and bottom
            or left and right edge of the component.
        expansionState:number Used by the "primary" action to update the 
            divider position. Allowed values are:
                collapsed:0
                restored just collapsed:1
                restored just expanded:2
                expanded:3
        restoreValue:number The value used to restore the position in the
            "primary" action.
    
    Private Attributes:
        __nudgeAcc:number The multiplier in px per nudge.
*/
myt.BaseDivider = new JS.Class('BaseDivider', myt.DrawButton, {
    include: [myt.BoundedValueComponent, myt.Draggable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        if (attrs.drawingMethodClassname === undefined) attrs.drawingMethodClassname = 'myt.DividerDrawingMethod';
        if (attrs.axis === undefined) attrs.axis = 'x';
        if (attrs.inset === undefined) attrs.inset = 2;
        if (attrs.minValue === undefined) attrs.minValue = -attrs.inset;
        if (attrs.value === undefined) attrs.value = attrs.minValue;
        if (attrs.focusEmbellishment === undefined) attrs.focusEmbellishment = false;
        if (attrs.repeatKeyDown === undefined) attrs.repeatKeyDown = true;
        if (attrs.expansionState === undefined) attrs.expansionState = 2;
        
        if (attrs.activationKeys === undefined) {
            attrs.activationKeys = [
                37, // left arrow
                38, // up arrow
                39, // right arrow
                40, // down arrow
                13, // enter
                32  // spacebar
            ];
        }
        
        if (attrs.axis === 'y') {
            if (attrs.height === undefined) attrs.height = 8;
            if (attrs.cursor === undefined) attrs.cursor = 'row-resize';
        } else {
            if (attrs.width === undefined) attrs.width = 8;
            if (attrs.cursor === undefined) attrs.cursor = 'col-resize';
        }
        
        // Controls acceleration of the nudge amount
        this.__nudgeAcc = 1;
        
        this.callSuper(parent, attrs);
        
        // Do afterwards since value might have been constrained from the
        // value provided in attrs.
        if (attrs.restoreValue === undefined) this.setRestoreValue(this.value);
        
        if (this.limitToParent !== undefined) this.__updateLimitToParentConstraint();
        
        this.attachDomObserver(this, 'doPrimaryAction', 'dblclick');
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setExpansionState: function(v) {this.expansionState = v;},
    setRestoreValue: function(v) {this.restoreValue = v;},
    
    setLimitToParent: function(v) {
        if (this.limitToParent !== v) {
            this.limitToParent = v;
            if (this.inited) {
                this.fireNewEvent('limitToParent', v);
                
                if (v === undefined) {
                    this.releaseConstraint('__limitToParent');
                } else {
                    this.__updateLimitToParentConstraint();
                }
            }
        }
    },
    
    setInset: function(v) {
        if (this.inset !== v) {
            this.inset = v;
            if (this.inited) {
                this.fireNewEvent('inset', v);
                this.updateUI();
            }
        }
    },
    
    setAxis: function(v) {
        if (this.inited) {
            myt.dumpStack("Axis may not be updated after instantiation.");
            return;
        }
        
        this.axis = v;
    },
    
    /** Update the x or y position of the component as the value changes.
        @param restoreValueAlso:boolean (optional) If true, the restoreValue
            will also be updated.
        @overrides myt.ValueComponent */
    setValue: function(v, restoreValueAlso) {
        this.callSuper(v);
        
        v = this.value;
        if (this.axis === 'y') {
            this.setY(v);
        } else {
            this.setX(v);
        }
        
        if (restoreValueAlso) this.setRestoreValue(v);
    },
    
    /** Ensure the component gets redrawn when it gains and loses focus.
        @overrides myt.FocusObservable. */
    setFocused: function(v) {
        this.callSuper(v);
        
        if (this.inited) this.redraw();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Setup the limitToParent constraint.
        @private */
    __updateLimitToParentConstraint: function() {
        var dim = this.axis === 'y' ? 'height' : 'width';
        this.applyConstraint('__limitToParent', [this, 'limitToParent', this, 'inset', this, dim, this.parent, dim]);
    },
    
    /** Do the limitToParent constraint.
        @private */
    __limitToParent: function(event) {
        var dim = this.axis === 'y' ? 'height' : 'width';
        this.setMaxValue(this.parent[dim] - this.limitToParent - this[dim] + this.inset);
    },
    
    /** Nudge the divider when the arrow keys are used. Nudging accelerates
        up to a limit if the key is held down.
        @overrides myt.Button. */
    doActivationKeyDown: function(key, isRepeat) {
        this.callSuper(key, isRepeat);
        
        // Determine nudge direction
        var dir = 0;
        switch (key) {
            case 37: case 38: dir = -1; break;
            case 39: case 40: dir = 1; break;
            case 13: case 32: default:
                this.doPrimaryAction();
                return;
        }
        
        // Update nudge amount, but never nudge more than 64.
        this.__nudgeAcc = isRepeat ? Math.min(this.__nudgeAcc + 1, 64) : 1;
        
        this.setValue(this.value + dir * this.__nudgeAcc, true);
        this.setExpansionState(2);
    },
    
    doPrimaryAction: function() {
        var toValue, rv = this.restoreValue, maxV = this.maxValue, minV = this.minValue;
        switch (this.expansionState) {
            case 0:
                if (rv != null) {
                    this.setExpansionState(1);
                    if (rv === minV) {
                        // Prevent infinite loop if there's nowhere to animate to.
                        if (rv !== maxV) this.doPrimaryAction();
                    } else {
                        toValue = rv;
                    }
                }
                break;
            case 1:
                if (maxV != null) {
                    this.setExpansionState(3);
                    if (this.value === maxV) {
                        this.doPrimaryAction();
                    } else {
                        toValue = maxV;
                    }
                }
                break;
            case 2:
                if (minV != null) {
                    this.setExpansionState(0);
                    if (this.value === minV) {
                        this.doPrimaryAction();
                    } else {
                        toValue = minV;
                    }
                }
                break;
            case 3:
                if (rv != null) {
                    this.setExpansionState(2);
                    if (rv === maxV) {
                        this.doPrimaryAction();
                    } else {
                        toValue = rv;
                    }
                }
                break;
        }
        if (toValue != null) {
            this.stopActiveAnimators('value');
            this.animateOnce('value', toValue, null, 250);
        }
    },
    
    /** Constrain dragging to horizontal or vertical based on axis.
        @overrides myt.Draggable */
    requestDragPosition: function(x, y) {
        if (!this.disabled) {
            this.setValue(this.axis === 'y' ? y : x, true);
            this.setExpansionState(2);
        }
    },
    
    /** @overrides myt.DrawButton */
    getDrawConfig: function(state) {
        var cfg = this.callSuper(state);
        cfg.axis = this.axis;
        cfg.inset = this.inset;
        return cfg;
    },
});


/** A divider that moves left/right. */
myt.HorizontalDivider = new JS.Class('HorizontalDivider', myt.BaseDivider, {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        attrs.axis = 'x';
        this.callSuper(parent, attrs);
    }
});


/** A divider that moves left/right. */
myt.VerticalDivider = new JS.Class('VerticalDivider', myt.BaseDivider, {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        attrs.axis = 'y';
        this.callSuper(parent, attrs);
    }
});


/** Makes a view behave as a grid column header.
    
    Events:
        sortable:boolean
        sortState:string
        resizable:boolean
    
    Attributes:
        columnId:string The unique ID for this column relative to the grid it
            is part of.
        gridController:myt.GridController the controller for the grid this
            component is part of.
        flex:number If 1 or more the column will get extra space if any exists.
        resizable:boolean Indicates if this column can be resized or not.
            Defaults to true.
        last:boolean Indicates if this is the last column header or not.
        sortable:boolean Indicates if this column can be sorted or not.
            Defaults to true.
        sortState:string The sort state of this column. Allowed values are:
            'ascending': Sorted in ascending order.
            'descending': Sorted in descending order.
            'none': Not currently an active sort column.
        cellXAdj:number The amount to shift the x values of cells updated by
            this column. Defaults to 0.
        cellWidthAdj:number The amount to grow/shrink the width of cells 
            updated by this column. Defaults to 0.
*/
myt.GridColumnHeader = new JS.Module('GridColumnHeader', {
    include: [myt.BoundedValueComponent],
    
    
    // Class Methods and Attributes ////////////////////////////////////////////
    extend: {
        DEFAULT_MIN_VALUE: 16,
        DEFAULT_MAX_VALUE: 9999
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        var GCH = myt.GridColumnHeader;
        if (attrs.minValue === undefined) attrs.minValue = GCH.DEFAULT_MIN_VALUE;
        if (attrs.maxValue === undefined) attrs.maxValue = GCH.DEFAULT_MAX_VALUE;
        if (attrs.resizable === undefined) attrs.resizable = true;
        if (attrs.flex === undefined) attrs.flex = 0;
        if (attrs.cellXAdj === undefined) attrs.cellXAdj = 0;
        if (attrs.cellWidthAdj === undefined) attrs.cellWidthAdj = 0;
        
        if (attrs.sortable === undefined) attrs.sortable = true;
        if (attrs.sortState === undefined) attrs.sortState = 'none';
        
        // Ensure participation in determinePlacement method of myt.Grid
        if (attrs.placement === undefined) attrs.placement = '*';
        
        this.callSuper(parent, attrs);
        
        new myt.View(this, {
            name:'resizer', cursor:'col-resize', width:10, zIndex:1,
            percentOfParentHeight:100, align:'right', alignOffset:-5,
            draggableAllowBubble:false
        }, [myt.SizeToParent, myt.Draggable, {
            requestDragPosition: function(x, y) {
                var p = this.parent, gc = p.gridController,
                    diff = x - this.x;
                
                if (gc.fitToWidth) {
                    if (diff > 0) {
                        // Get amount that this header can grow
                        var growAmt = p.maxValue - p.value;
                        // Get amount that can be given on the left
                        var giveLeft = p._getGiveLeft();
                        
                        // Get amount that can be stolen on the right
                        var takeRight = p._getTakeRight();
                        
                        diff = Math.min(diff, Math.min(-takeRight, growAmt + giveLeft));
                    } else if (diff < 0) {
                        // Get amount that this header can shrink
                        var shrinkAmt = p.minValue - p.value;
                        // Get amount that can be stolen on the left
                        var takeLeft = p._getTakeLeft();
                        
                        // Get amount that can be given on the right
                        var giveRight = p._getGiveRight();
                        
                        diff = Math.max(diff, Math.max(-giveRight, shrinkAmt + takeLeft));
                    }
                    
                    if (diff === 0) return;
                }
                
                var newValue = p.value + diff;
                
                if (p.resizable) p.setValue(newValue);
                var remainingDiff = newValue - p.value;
                var stolenAmt = remainingDiff - diff;
                var additionalActualDiff = 0;
                if (remainingDiff < 0) {
                    additionalActualDiff = p._stealPrevWidth(remainingDiff);
                } else if (remainingDiff > 0) {
                    additionalActualDiff = p._givePrevWidth(remainingDiff);
                }
                this.dragInitX += additionalActualDiff;
                stolenAmt -= additionalActualDiff;
                
                if (gc.fitToWidth) {
                    if (stolenAmt < 0) {
                        p._stealNextWidth(stolenAmt);
                    } else if (stolenAmt > 0) {
                        p._giveNextWidth(stolenAmt);
                    }
                }
            }
        }]);
        
        var gc = this.gridController;
        if (gc) {
            gc.notifyAddColumnHeader(this);
            gc.notifyColumnHeaderXChange(this);
        }
        this.setWidth(this.value);
        this._updateLast();
    },
    
    destroy: function(v) {
        this.setGridController();
        
        this.callSuper(v);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSortable: function(v) {this.set('sortable', v, true);},
    setSortState: function(v) {this.set('sortState', v, true);},
    
    setCellWidthAdj: function(v) {this.cellWidthAdj = v;},
    setCellXAdj: function(v) {this.cellXAdj = v;},
    setFlex: function(v) {this.flex = v;},
    setColumnId: function(v) {this.columnId = v;},
    
    setLast: function(v) {
        this.last = v;
        if (this.inited) this._updateLast();
    },
    
    setResizable: function(v) {this.set('resizable', v, true);},
    
    setGridController: function(v) {
        var existing = this.gridController;
        if (existing !== v) {
            if (existing) existing.notifyRemoveColumnHeader(this);
            this.gridController = v;
            if (this.inited && v) {
                v.notifyAddColumnHeader(this);
                v.notifyColumnHeaderXChange(this);
                v.notifyColumnHeaderWidthChange(this);
            }
        }
    },
    
    /** @overrides myt.BoundedValueComponent */
    setValue: function(v) {
        this.callSuper(v);
        
        if (this.inited) this.setWidth(this.value);
    },
    
    /** @overrides myt.BoundedValueComponent */
    setMinValue: function(v) {
        var oldValue = this.minValue || 0, 
            gc = this.gridController;
        
        this.callSuper(v);
        v = this.minValue;
        
        if (this.inited && gc && oldValue !== v) {
            gc.setMinWidth(gc.minWidth + v - oldValue);
        }
    },
    
    /** @overrides myt.BoundedValueComponent */
    setMaxValue: function(v) {
        var oldValue = this.maxValue || 0,
            gc = this.gridController;
        
        if (v == null) v = myt.GridColumnHeader.DEFAULT_MAX_VALUE;
        
        this.callSuper(v);
        v = this.maxValue;
        
        if (this.inited && gc && oldValue !== v) {
            gc.setMaxWidth(gc.maxWidth + v - oldValue);
        }
    },
    
    /** @overrides myt.View */
    setWidth: function(v, supressEvent) {
        var cur = this.width;
        this.callSuper(v, supressEvent);
        
        if (this.inited && cur !== this.width) {
            var gc = this.gridController;
            if (gc) gc.notifyColumnHeaderWidthChange(this);
        }
    },
    
    /** @overrides myt.View */
    setX: function(v) {
        var cur = this.x;
        this.callSuper(v);
        
        if (this.inited && cur !== this.x) {
            var gc = this.gridController;
            if (gc) gc.notifyColumnHeaderXChange(this);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    _updateLast: function() {
        this.resizer.setVisible(!(this.last && this.gridController.fitToWidth));
    },
    
    /** Steals width from previous column headers.
        @param diff:number the amount to steal. Will be a negative number.
        @returns number:the amount of width actually stolen. */
    _stealPrevWidth: function(diff) {
        var hdr = this.gridController.getPrevColumnHeader(this),
            usedDiff = 0;
        if (hdr) {
            var newValue = hdr.value + diff;
            if (hdr.resizable) hdr.setValue(newValue);
            var remainingDiff = newValue - hdr.value;
            usedDiff = diff - remainingDiff;
            if (remainingDiff < 0) usedDiff += hdr._stealPrevWidth(remainingDiff);
        }
        
        return usedDiff;
    },
    
    /** Gives width to previous column headers.
        @param diff:number the amount to give. Will be a positive number.
        @returns number:the amount of width actually given. */
    _givePrevWidth: function(diff) {
        var hdr = this.gridController.getPrevColumnHeader(this),
            usedDiff = 0;
        if (hdr) {
            var newValue = hdr.value + diff;
            if (hdr.resizable) hdr.setValue(newValue);
            var remainingDiff = newValue - hdr.value;
            usedDiff = diff - remainingDiff;
            if (remainingDiff > 0) usedDiff += hdr._givePrevWidth(remainingDiff);
        }
        
        return usedDiff;
    },
    
    /** Steals width from next column headers.
        @param diff:number the amount to steal. Will be a negative number.
        @returns number:the amount of width actually stolen. */
    _stealNextWidth: function(diff) {
        var hdr = this.gridController.getNextColumnHeader(this);
        if (hdr) {
            var newValue = hdr.value + diff;
            if (hdr.resizable) hdr.setValue(newValue);
            var remainingDiff = newValue - hdr.value;
            if (remainingDiff < 0) hdr._stealNextWidth(remainingDiff);
        }
    },
    
    /** Gives width to next column headers.
        @param diff:number the amount to give. Will be a positive number.
        @returns number:the amount of width actually given. */
    _giveNextWidth: function(diff) {
        var hdr = this.gridController.getNextColumnHeader(this);
        if (hdr) {
            var newValue = hdr.value + diff;
            if (hdr.resizable) hdr.setValue(newValue);
            var remainingDiff = newValue - hdr.value;
            if (remainingDiff > 0) hdr._giveNextWidth(remainingDiff);
        }
    },
    
    _getGiveLeft: function() {
        var hdr = this.gridController.getPrevColumnHeader(this),
            give = 0;
        if (hdr) give = hdr.maxValue - hdr.value + hdr._getGiveLeft();
        return give;
    },
    
    _getGiveRight: function() {
        var hdr = this.gridController.getNextColumnHeader(this),
            give = 0;
        if (hdr) give = hdr.maxValue - hdr.value + hdr._getGiveRight();
        return give;
    },
    
    _getTakeLeft: function() {
        var hdr = this.gridController.getPrevColumnHeader(this),
            take = 0;
        if (hdr) take = hdr.minValue - hdr.value + hdr._getTakeLeft();
        return take;
    },
    
    _getTakeRight: function() {
        var hdr = this.gridController.getNextColumnHeader(this),
            take = 0;
        if (hdr) take = hdr.minValue - hdr.value + hdr._getTakeRight();
        return take;
    }
});


/** Makes a view behave as a row in a grid.
    
    Events:
        None
    
    Attributes:
        gridController:myt.GridConstroller A reference to the grid controller
            that is managing this row.
*/
myt.GridRow = new JS.Module('GridRow', {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        // Ensure participation in determinePlacement method of myt.Grid
        if (attrs.placement === undefined) attrs.placement = '*';
        
        this.callSuper(parent, attrs);
        
        var gc = this.gridController;
        if (gc) gc.notifyAddRow(this);
    },
    
    destroy: function(v) {
        this.setGridController();
        
        this.callSuper(v);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setGridController: function(v) {
        var existing = this.gridController;
        if (existing !== v) {
            if (existing) existing.notifyRemoveRow(this);
            this.gridController = v;
            if (this.inited && v) v.notifyAddRow(this);
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    notifyColumnHeaderXChange: function(columnHeader) {
        var sv = this[columnHeader.columnId + 'View'];
        if (sv) sv.setX(columnHeader.x + columnHeader.cellXAdj);
    },
    
    notifyColumnHeaderWidthChange: function(columnHeader) {
        var sv = this[columnHeader.columnId + 'View'];
        if (sv) sv.setWidth(columnHeader.width + columnHeader.cellWidthAdj);
    }
});


/** Coordinates the behavior of a grid.
    
    Events:
        sort:array
        maxWidth:number
        minWidth:number
    
    Attributes:
        maxWidth:number the sum of the maximum widths of the columns.
        minWidth:number the sum of the minimum widths of the columns.
        gridWidth:number the width of the grid component.
        fitToWidth:boolean determines if the columns will always fill up the
            width of the grid or not. Defaults to true.
        lastColumn:myt.GridColumnHeader Holds a reference to the last
            column header.
        sort:array An array containing the id of the column to sort by and
            the order to sort by.
        locked:boolean Prevents the grid from updating the UI. Defaults to
            true. After a grid has been setup a call should be made to
            setLocked(false)
    
    Private Attributes:
        columnHeaders:array An array of column headers in this grid.
        rows:array An array of rows in this grid.
        __tempLock:boolean Prevents "change" notifications from being processed.
*/
myt.GridController = new JS.Module('GridController', {
    // Life Cycle //////////////////////////////////////////////////////////////
    initNode: function(parent, attrs) {
        this.columnHeaders = [];
        this.rows = [];
        
        this.maxWidth = this.minWidth = this.gridWidth = 0;
        this.fitToWidth = this.locked = true;
        
        this.callSuper(parent, attrs);
        
        this._fitToWidth();
        this._notifyHeadersOfSortState();
        if (!this.locked) this.doSort();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSort: function(v) {
        if (!myt.areArraysEqual(v, this.sort)) {
            this.sort = v;
            if (this.inited) {
                this.fireNewEvent('sort', v);
                this._notifyHeadersOfSortState();
                if (!this.locked) this.doSort();
            }
        }
    },
    
    setLastColumn: function(v) {
        var cur = this.lastColumn;
        if (cur !== v) {
            if (cur) cur.setLast(false);
            this.lastColumn = v;
            if (v) v.setLast(true);
        }
    },
    
    setFitToWidth: function(v) {this.fitToWidth = v;},
    
    setLocked: function(v) {
        this.locked = v;
        if (this.inited && !v) {
            this.__tempLock = true; // Prevent change calls during fitToWidth
            this._fitToWidth();
            this.__tempLock = false;
            
            var hdrs = this.columnHeaders, i = hdrs.length, hdr;
            while (i) {
                hdr = hdrs[--i];
                this.notifyColumnHeaderXChange(hdr);
                this.notifyColumnHeaderWidthChange(hdr);
            }
            
            this.doSort();
        }
    },
    
    setMaxWidth: function(v) {this.set('maxWidth', v, true);},
    setMinWidth: function(v) {this.set('minWidth', v, true);},
    
    setGridWidth: function(v) {
        if (v !== null && typeof v === 'object') v = v.value;
        
        if (this.gridWidth !== v) {
            this.gridWidth = v;
            if (this.inited) this._fitToWidth();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    _fitToWidth: function() {
        if (this.locked || !this.fitToWidth) return;
        
        var hdrs = this.columnHeaders, len = hdrs.length, i = len, hdr;
        
        // Determine max extent
        var maxExtent = 0, extent;
        while(i) {
            hdr = hdrs[--i];
            extent = hdr.x + hdr.width;
            if (extent > maxExtent) maxExtent = extent;
        }
        
        var extra = this.gridWidth - maxExtent;
        
        if (extra === 0) return;
        var isGrow = extra > 0;
        
        // Get resizable columns
        var resizeInfo = [], limit;
        i = len;
        while(i) {
            hdr = hdrs[--i];
            if (hdr.resizable && hdr.flex > 0) {
                limit = (isGrow ? hdr.maxValue : hdr.minValue) - hdr.value;
                resizeInfo.push({hdr:hdr, limit:limit, amt:0});
            }
        }
        
        // Abort if no resizable flex columns.
        var resizeCount = resizeInfo.length;
        if (resizeCount <= 0) return;
        
        // Calculate resize amounts
        var idx = 0, fullCount = 0, incr, info;
        while (extra !== 0) {
            info = resizeInfo[idx];
            hdr = info.hdr;
            
            if (!info.full) {
                if (isGrow) {
                    incr = Math.min(hdr.flex, extra);
                    if (info.amt + incr > info.limit) {
                        incr = info.limit - info.amt;
                        info.full = true;
                    }
                } else {
                    incr = Math.max(-hdr.flex, extra);
                    if (info.amt + incr < info.limit) {
                        incr = info.limit - info.amt;
                        info.full = true;
                    }
                }
                info.amt += incr;
                extra -= incr;
            } else {
                ++fullCount;
            }
            
            if (fullCount === resizeCount) break;
            
            ++idx;
            if (idx === resizeCount) {
                idx = 0;
                fullCount = 0;
            }
        }
        
        // Distribute amounts
        i = resizeCount;
        while (i) {
            info = resizeInfo[--i];
            hdr = info.hdr;
            hdr.setValue(hdr.value + info.amt);
        }
        
        // Distribute remaing extra to resizable non-flex columns
        if (extra !== 0) {
            // Get resizable columns
            resizeInfo = [];
            i = len;
            while(i) {
                hdr = hdrs[--i];
                if (hdr.resizable && hdr.flex === 0) {
                    limit = (isGrow ? hdr.maxValue : hdr.minValue) - hdr.value;
                    resizeInfo.push({hdr:hdr, limit:limit, amt:0});
                }
            }
            
            // Abort if no resizable columns.
            resizeCount = resizeInfo.length;
            if (resizeCount <= 0) return;
            
            // Calculate resize amounts
            idx = 0;
            fullCount = 0;
            while (extra !== 0) {
                info = resizeInfo[idx];
                hdr = info.hdr;
                
                if (!info.full) {
                    if (isGrow) {
                        incr = Math.min(1, extra);
                        if (info.amt + incr > info.limit) {
                            incr = info.limit - info.amt;
                            info.full = true;
                        }
                    } else {
                        incr = Math.max(-1, extra);
                        if (info.amt + incr < info.limit) {
                            incr = info.limit - info.amt;
                            info.full = true;
                        }
                    }
                    info.amt += incr;
                    extra -= incr;
                } else {
                    ++fullCount;
                }
                
                if (fullCount === resizeCount) break;
                
                ++idx;
                if (idx === resizeCount) {
                    idx = 0;
                    fullCount = 0;
                }
            }
            
            // Distribute amounts
            i = resizeCount;
            while (i) {
                info = resizeInfo[--i];
                hdr = info.hdr;
                hdr.setValue(hdr.value + info.amt);
            }
        }
    },
    
    // Sorting
    _notifyHeadersOfSortState: function() {
        var hdrs = this.columnHeaders, i = hdrs.length, hdr,
            sort = this.sort,
            sortColumnId = sort ? sort[0] : '',
            sortOrder = sort ? sort[1] : '';
        while (i) {
            hdr = hdrs[--i];
            if (hdr.columnId === sortColumnId) {
                if (hdr.sortable) hdr.setSortState(sortOrder);
            } else {
                hdr.setSortState('none');
            }
        }
    },
    
    /** Sorts the rows according to the current sort criteria. Subclasses and
        instances should implement this as needed.
        @returns void */
    doSort: function() {},
    
    // Column Headers
    /** Gets the column header before the provided one.
        @returns myt.GridColumnHeader or null if none exists. */
    getPrevColumnHeader: function(columnHeader) {
        var idx = this.getColumnHeaderIndex(columnHeader) - 1;
        return idx >= 0 ? this.columnHeaders[idx] : null;
    },
    
    /** Gets the column header after the provided one.
        @returns myt.GridColumnHeader or null if none exists. */
    getNextColumnHeader: function(columnHeader) {
        var idx = this.getColumnHeaderIndex(columnHeader) + 1;
        var hdrs = this.columnHeaders;
        return idx > 0 && idx < hdrs.length ? hdrs[idx] : null;
    },
    
    hasColumnHeader: function(columnHeader) {
        return this.getColumnHeaderIndex(columnHeader) !== -1;
    },
    
    getColumnHeaderIndex: function(columnHeader) {
        return this.columnHeaders.indexOf(columnHeader);
    },
    
    notifyAddColumnHeader: function(columnHeader) {
        if (!this.hasColumnHeader(columnHeader)) {
            this.columnHeaders.push(columnHeader);
            this.setLastColumn(columnHeader);
            this.setMaxWidth(this.maxWidth + columnHeader.maxValue);
            this.setMinWidth(this.minWidth + columnHeader.minValue);
            this._fitToWidth();
        }
    },
    
    notifyRemoveColumnHeader: function(columnHeader) {
        var idx = this.getColumnHeaderIndex(columnHeader);
        if (idx >= 0) {
            var hdrs = this.columnHeaders;
            hdrs.splice(idx, 1);
            if (columnHeader.last) this.setLastColumn(hdrs[hdrs.length - 1]);
            this.setMaxWidth(this.maxWidth - columnHeader.maxValue);
            this.setMinWidth(this.minWidth - columnHeader.minValue);
            this._fitToWidth();
        }
    },
    
    notifyColumnHeaderXChange: function(columnHeader) {
        if (this.locked || this.__tempLock) return;
        var rows = this.rows, i = rows.length;
        while (i) rows[--i].notifyColumnHeaderXChange(columnHeader);
    },
    
    notifyColumnHeaderWidthChange: function(columnHeader) {
        if (this.locked || this.__tempLock) return;
        var rows = this.rows, i = rows.length;
        while (i) rows[--i].notifyColumnHeaderWidthChange(columnHeader);
    },
    
    // Rows
    hasRow: function(row) {
        return this.getRowIndex(row) !== -1;
    },
    
    getRowIndex: function(row) {
        return this.rows.indexOf(row);
    },
    
    notifyAddRow: function(row) {
        if (!this.hasRow(row)) {
            this.rows.push(row);
            
            // Update cell positions
            if (!this.locked) {
                var hdrs = this.columnHeaders, i = hdrs.length, hdr;
                while (i) {
                    hdr = hdrs[--i];
                    row.notifyColumnHeaderXChange(hdr);
                    row.notifyColumnHeaderWidthChange(hdr);
                }
                
                this.doSort();
            }
        }
    },
    
    notifyRemoveRow: function(row) {
        var idx = this.getRowIndex(row);
        if (idx >= 0) this.rows.splice(idx, 1);
    }
});


/** An implementation of a grid component.
    
    Events:
        None
    
    Attributes:
        rowSpacing:number The spacing between rows. Defaults to 1.
        columnSpacing:number the spacing between columns. Defaults to 1.
        sizeHeightToRows:boolean If true, this component will be sized to fit
            all the rows without showing scrollbars. Defaults to undefined
            which is equivalent to false.
*/
myt.Grid = new JS.Class('Grid', myt.View, {
    include: [myt.GridController],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        // Allows horizontal scrolling if the grid columns are too wide.
        if (attrs.overflow === undefined) attrs.overflow = 'auto';
        
        if (attrs.bgColor === undefined) attrs.bgColor = '#cccccc';
        if (attrs.rowSpacing === undefined) attrs.rowSpacing = 1;
        if (attrs.columnSpacing === undefined) attrs.columnSpacing = 1;
        
        this.callSuper(parent, attrs);
    },
    
    /** @overrides myt.View */
    doAfterAdoption: function() {
        var shtr = this.sizeHeightToRows, m = myt;
        
        var header = new m.View(this, {name:'header', overflow:'hidden'});
        new m.SpacedLayout(header, {
            name:'xLayout', locked:true, axis:'x', collapseParent:true, 
            spacing:this.columnSpacing
        });
        new m.SizeToChildren(header, {name:'yLayout', locked:true, axis:'y'});
        
        var content = new m.View(this, {name:'content', overflow:shtr ? 'hidden' : 'auto'});
        new m.SpacedLayout(content, {
            name:'yLayout', locked:true, axis:'y', spacing:this.rowSpacing,
            collapseParent:shtr
        });
        
        this.syncTo(this, 'setGridWidth', 'width');
        this.syncTo(header, '_updateContentWidth', 'width');
        
        this.applyConstraint('_updateContentHeight', [
            shtr ? content : this, 'height', 
            header, 'height', 
            header, 'y'
        ]);
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSizeHeightToRows: function(v) {this.sizeHeightToRows = v;},
    
    setRowSpacing: function(v) {
        if (this.rowSpacing !== v) {
            this.rowSpacing = v;
            if (this.inited) this.content.yLayout.setSpacing(v);
        }
    },
    
    setColumnSpacing: function(v) {
        if (this.columnSpacing !== v) {
            this.columnSpacing = v;
            if (this.inited) this.header.xLayout.setSpacing(v);
        }
    },
    
    /** @overrides myt.GridController */
    setLocked: function(v) {
        // Performance: don't update layouts until the grid is unlocked.
        if (this.inited) {
            var header = this.header,
                headerXLayout = header.xLayout,
                headerYLayout = header.yLayout,
                contentYLayout = this.content.yLayout;
            if (v) {
                headerXLayout.incrementLockedCounter();
                headerYLayout.incrementLockedCounter();
                contentYLayout.incrementLockedCounter();
            } else {
                headerXLayout.decrementLockedCounter();
                headerXLayout.update();
                headerYLayout.decrementLockedCounter();
                headerYLayout.update();
                contentYLayout.decrementLockedCounter();
                contentYLayout.update();
            }
        }
        
        this.callSuper(v);
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    _updateContentWidth: function(event) {
        this.content.setWidth(event.value);
    },
    
    _updateContentHeight: function(event) {
        var header = this.header, content = this.content,
            y = header.y + header.height;
        content.setY(y);
        
        if (this.sizeHeightToRows) {
            this.setHeight(y + content.height);
        } else {
            content.setHeight(this.height - y);
        }
    },
    
    /** @overrides myt.Node */
    determinePlacement: function(placement, subnode) {
        // Automatically place column headers and rows in the header and
        // content views respectively.
        if (placement === '*') {
            var target;
            if (subnode.isA(myt.GridRow)) {
                target = this.content;
            } else if (subnode.isA(myt.GridColumnHeader)) {
                target = this.header;
            }
            
            if (target) {
                if (subnode.gridController !== this) subnode.setGridController(this);
                return target;
            }
        }
        
        return this.callSuper(placement, subnode);
    },
    
    /** @overrides myt.GridController */
    doSort: function() {
        var sort = this.sort,
            sortFunc = this.getSortFunction(sort ? sort[0] : '', sort ? sort[1] : '');
        if (sortFunc) {
            var content = this.content, 
                yLayout = content.yLayout;
            content.sortSubviews(sortFunc);
            yLayout.sortSubviews(sortFunc);
            yLayout.update();
        }
    },
    
    /** Gets the sort function used to sort the rows. Subclasses and instances
        should implement this as needed.
        @returns function a comparator function used for sorting. */
    getSortFunction: function(sortColumnId, sortOrder) {
        if (sortColumnId && sortOrder) {
            // Default sort function uses the 'text' attribute of the subview.
            var sortNum = sortOrder === 'ascending' ? 1 : -1;
            return function(a, b) {
                var aValue = a[sortColumnId + 'View'].text,
                    bValue = b[sortColumnId + 'View'].text;
                if (aValue > bValue) {
                    return sortNum;
                } else if (bValue > aValue) {
                    return -sortNum;
                }
                return 0;
            };
        }
    }
});


/** A simple implementation of a grid column header.
    
    Attributes:
        sortIconColor:color the color to fill the sort icon with if shown.
            Defaults to '#666666'.
*/
myt.SimpleGridColumnHeader = new JS.Class('SimpleGridColumnHeader', myt.SimpleIconTextButton, {
    include: [myt.GridColumnHeader],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        if (attrs.activeColor === undefined) attrs.activeColor = '#999999';
        if (attrs.hoverColor === undefined) attrs.hoverColor = '#bbbbbb';
        if (attrs.readyColor === undefined) attrs.readyColor = '#aaaaaa';
        if (attrs.inset === undefined) attrs.inset = 2;
        if (attrs.outset === undefined) attrs.outset = 2;
        
        if (attrs.height === undefined) attrs.height = 18;
        
        if (attrs.contentAlign === undefined) attrs.contentAlign = 'left';
        if (attrs.sortIconColor === undefined) attrs.sortIconColor = '#666666';
        
        
        this.callSuper(parent, attrs);
        
        if (this.sortable) this.setOutset(14);
        
        this.setDisabled(!this.sortable);
        this._updateTextWidth();
        this._drawSortIcon();
    },
    
    /** @overrides myt.View */
    doAfterAdoption: function() {
        new myt.Canvas(this, {
            name:'sortIcon', align:'right', alignOffset:3, width:8, height:10,
            y:Math.floor((this.height - 10) / 2)
        });
        
        this.callSuper();
        
        this.textView.enableEllipsis();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setSortIconColor: function(v) {this.sortIconColor = v;},
    
    /** @overrides myt.GridColumnHeader */
    setSortable: function(v) {
        this.callSuper(v);
        
        if (this.inited) {
            if (v) this.setOutset(14);
            this.setDisabled(!v);
            this._drawSortIcon();
        }
    },
    
    /** @overrides myt.GridColumnHeader */
    setSortState: function(v) {
        this.callSuper(v);
        
        if (this.inited) this._drawSortIcon();
    },
    
    /** @overrides myt.View */
    setWidth: function(v, supressEvent) {
        this.callSuper(v, supressEvent);
        
        if (this.inited) this._updateTextWidth();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    _drawSortIcon: function() {
        var canvas = this.sortIcon;
        canvas.clear();
        
        if (this.sortable) {
            canvas.beginPath();
            
            var fillColor;
            switch (this.sortState) {
                case 'ascending':
                    fillColor = this.sortIconColor;
                    canvas.moveTo(0,10);
                    canvas.lineTo(4,0);
                    canvas.lineTo(8,10);
                    break;
                case 'descending':
                    fillColor = this.sortIconColor;
                    canvas.moveTo(0,0);
                    canvas.lineTo(4,10);
                    canvas.lineTo(8,0);
                    break;
                case 'none':
                    fillColor = this.activeColor;
                    canvas.moveTo(0,5);
                    canvas.lineTo(4,10);
                    canvas.lineTo(8,5);
                    canvas.lineTo(4,0);
                    break;
            }
            
            canvas.closePath();
            canvas.setFillStyle(fillColor);
            canvas.fill();
        }
    },
    
    /** @private */
    _updateTextWidth: function() {
        if (this.contentAlign === 'left') {
            var tv = this.textView;
            tv.setWidth(this.width - this.outset - tv.x);
        }
    },
    
    doActivated: function() {
        if (!this.disabled) {
            switch (this.sortState) {
                case 'ascending': this.setSortState('descending'); break;
                case 'descending': this.setSortState('ascending'); break;
                case 'none': this.setSortState('ascending'); break;
            }
            this.gridController.setSort([this.columnId, this.sortState]);
        }
    },
    
    /** @overrides myt.SimpleButton */
    drawDisabledState: function() {
        this.setBgColor(this.readyColor);
    },
    
    /** @overrides myt.Button */
    showFocusEmbellishment: function() {this.hideDefaultFocusEmbellishment();},
    
    /** @overrides myt.Button */
    hideFocusEmbellishment: function() {this.hideDefaultFocusEmbellishment();}
});


/** Makes a view act as a panel in a myt.PanelStack.
    
    Events:
        None
    
    Attributes:
        panelId:string The unique ID of the panel.
        panelStack:myt.PanelStack A reference to the panel stack this panel
            belongs to. If undefined the parent view will be used.
*/
myt.StackablePanel = new JS.Module('StackablePanel', {
    include: [myt.Selectable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        attrs.visible = attrs.selected = false;
        
        if (attrs.bgColor === undefined) attrs.bgColor = '#ffffff';
        if (attrs.panelId === undefined) attrs.panelId = attrs.name;
        
        this.callSuper(parent, attrs);
        
        if (this.selected) this.doStackTransition();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setPanelStack: function(v) {this.panelStack = v;},
    setPanelId: function(v) {this.panelId = v;},
    
    /** @overrides myt.Selectable */
    setSelected: function(v) {
        if (this.selected !== v) {
            this.callSuper(v);
            if (this.inited) this.doStackTransition();
        }
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called whenever a transition between panels is initiated by this panel.
        Default behavior is to defer to the panelStack's doStackTransition
        method.
        @returns void */
    doStackTransition: function() {
        (this.panelStack || this.parent).doStackTransition(this);
    }
});


/** Manages a stack of myt.View panel children that can be transitioned to
    an "active" state as they are selected. The active panel will be sized
    to fit the bounds of the stack.
    
    Events:
        None
    
    Attributes:
        None
*/
// FIXME: handle panel destruction
// FIXME: handle panel insertion
myt.PanelStack = new JS.Class('PanelStack', myt.View, {
    include: [myt.SelectionManager],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides myt.View */
    initNode: function(parent, attrs) {
        attrs.overflow = 'hidden';
        
        if (attrs.itemSelectionId === undefined) attrs.itemSelectionId = 'panelId';
        if (attrs.maxSelected === undefined) attrs.maxSelected = 1;
        
        this.callSuper(parent, attrs);
        
        this.syncTo(this, '__updateHeight', 'height');
        this.syncTo(this, '__updateWidth', 'width');
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @private */
    __updateWidth: function(event) {
        // Only resize the active panel
        var panel = this.getActivePanel();
        if (panel) panel.setWidth(event.value);
    },
    
    /** @private */
    __updateHeight: function(event) {
        // Only resize the active panel
        var panel = this.getActivePanel();
        if (panel) panel.setHeight(event.value);
    },
    
    /** Gets the selected panel.
        @returns myt.StackablePanel: The selected panel or undefined if
            none selected. */
    getActivePanel: function() {
        return this.getSelected()[0];
    },
    
    getPanel: function(panelId) {
        return this.getSelectableItem(panelId);
    },
    
    selectPanel: function(panelId) {
        this.selectById(panelId);
    },
    
    /** @overrides myt.SelectionManager */
    doSelected: function(item) {
        item.setWidth(this.width);
        item.setHeight(this.height);
    },
    
    /** Called by a panel when it transitions between selected states. Should
        not be called directly.
        @param panel:myt.StackablePanel The panel that is transitioning.
        @returns void */
    doStackTransition: function(panel) {
        var selected = panel.selected;
        if (selected) panel.makeHighestZIndex();
        panel.setVisible(selected);
    }
});


/** Adds drag group support to drag and drop related classes.
    
    Events:
        None
    
    Attributes:
        None
    
    Private Attributes:
        __dragGroups:object The keys are the set of drag groups this view
            supports. By default the special drag group of '*' which accepts
            all drag groups is defined.
        __acceptAny:boolean The precalculated return value for the
            acceptAnyDragGroup method.
*/
myt.DragGroupSupport = new JS.Module('DragGroupSupport', {
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.__dragGroups = {'*':true};
        this.__acceptAny = true;
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setDragGroups: function(v) {
        var newDragGroups = {};
        for (var dragGroup in v) newDragGroups[dragGroup] = true;
        this.__dragGroups = newDragGroups;
        this.__acceptAny = newDragGroups.hasOwnProperty('*');
    },
    
    getDragGroups: function() {
        return this.__dragGroups;
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Adds the provided dragGroup to the dragGroups.
        @param dragGroup:string The drag group to add.
        @returns void */
    addDragGroup: function(dragGroup) {
        if (dragGroup) {
            this.__dragGroups[dragGroup] = true;
            if (dragGroup === '*') this.__acceptAny = true;
        }
    },
    
    /** Removes the provided dragGroup from the dragGroups.
        @param dragGroup:string The drag group to remove.
        @returns void */
    removeDragGroup: function(dragGroup) {
        if (dragGroup) {
            delete this.__dragGroups[dragGroup];
            if (dragGroup === '*') this.__acceptAny = false;
        }
    },
    
    /** Determines if this drop target will accept drops from any drag group.
        @returns boolean: True if any drag group will be accepted, false
            otherwise. */
    acceptAnyDragGroup: function() {
        return this.__acceptAny;
    }
});


/** Makes an myt.View drag and dropable via the mouse.
    
    Events:
        None
    
    Attributes:
        dropped:boolean Indicates this dropable was just dropped.
        dropFailed:boolean Indicates this dropable was just dropped outside
            of a drop target.
        dropTarget:myt.DropTarget The drop target this dropable is currently
            over.
*/
myt.Dropable = new JS.Module('Dropable', {
    include: [myt.Draggable, myt.DragGroupSupport],
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setDropTarget: function(v) {this.dropTarget = v;},
    setDropped: function(v) {this.dropped = v;},
    setDropFailed: function(v) {this.dropFailed = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called by myt.GlobalDragManager when a dropable is dragged over a
        target. Gives this dropable a chance to reject a drop regardless
        of drag group. The default implementation returns true.
        @param dropTarget:myt.DropTarget The drop target dragged over.
        @returns boolean: True if the drop will be allowed, false otherwise. */
    willPermitDrop: function(dropTarget) {
        return true;
    },
    
    /** @overrides myt.Draggable */
    startDrag: function(event) {
        this.setDropped(false);
        this.setDropFailed(false);
        
        myt.global.dragManager.startDrag(this);
        this.callSuper(event);
    },
    
    /** @overrides myt.Draggable */
    updateDrag: function(event) {
        myt.global.dragManager.updateDrag(event, this);
        this.callSuper(event);
    },
    
    /** @overrides myt.Draggable */
    stopDrag: function(event, isAbort) {
        myt.global.dragManager.stopDrag(event, this, isAbort);
        this.callSuper(event, isAbort);
        
        if (isAbort) {
            this.notifyDropAborted();
        } else if (this.dropFailed) {
            this.notifyDropFailed();
        }
    },
    
    /** Called by myt.GlobalDragManager when this view is dragged over a drop
        target.
        @param dropTarget:myt.DropTarget The target that was dragged over.
        @returns void */
    notifyDragEnter: function(dropTarget) {
        this.setDropTarget(dropTarget);
    },
    
    /** Called by myt.GlobalDragManager when this view is dragged out of a drop
        target.
        @param dropTarget:myt.DropTarget The target that was dragged out of.
        @returns void */
    notifyDragLeave: function(dropTarget) {
        this.setDropTarget();
    },
    
    /** Called by myt.GlobalDragManager when this view is dropped.
        @param dropTarget:myt.DropTarget The target that was dropped on. Will
            be undefined if this dropable was dropped on no drop target.
        @param isAbort:boolean Indicates if the drop was the result of an
            abort or a normal drop.
        @returns void */
    notifyDrop: function(dropTarget, isAbort) {
        this.setDropped(true);
        
        if (!this.dropTarget) this.setDropFailed(true);
    },
    
    /** Called after dragging stops and the drop failed. The default
        implementation does nothing.
        @returns void */
    notifyDropFailed: function() {},
    
    /** Called after dragging stops and the drop was aborted. The default
        implementation does nothing.
        @returns void */
    notifyDropAborted: function() {}
});


/** Makes an myt.View support having myt.Dropable views dropped on it.
    
    Events:
        None
    
    Attributes:
        None
*/
myt.DropTarget = new JS.Module('DropTarget', {
    include: [myt.DragGroupSupport],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.callSuper(parent, attrs);
        
        myt.global.dragManager.registerDropTarget(this);
    },
    
    /** @overrides */
    destroyAfterOrphaning: function() {
        myt.global.dragManager.unregisterDropTarget(this);
        
        this.callSuper();
    },
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called by myt.GlobalDragManager when a dropable is dragged over this
        target. Gives this drop target a chance to reject a drop regardless
        of drag group. The default implementation returns true if the view
        is not disabled.
        @param dropable:myt.Dropable The dropable being dragged.
        @returns boolean: True if the drop will be allowed, false otherwise. */
    willAcceptDrop: function(dropable) {
        // Handle the common case of a disabled or not visible component.
        if (this.disabled || !this.isVisible()) return false;
        
        return true;
    },
    
    /** Called by myt.GlobalDragManager when a dropable starts being dragged
        that has a matching drag group.
        @param dropable:myt.Dropable The dropable being dragged.
        @returns void */
    notifyDragStart: function(dropable) {},
    
    /** Called by myt.GlobalDragManager when a dropable stops being dragged
        that has a matching drag group.
        @param dropable:myt.Dropable The dropable no longer being dragged.
        @returns void */
    notifyDragStop: function(dropable) {},
    
    /** Called by myt.GlobalDragManager when a dropable is dragged over this
        view and has a matching drag group.
        @param dropable:myt.Dropable The dropable being dragged over this view.
        @returns void */
    notifyDragEnter: function(dropable) {},
    
    /** Called by myt.GlobalDragManager when a dropable is dragged out of this
        view and has a matching drag group.
        @param dropable:myt.Dropable The dropable being dragged out of 
            this view.
        @returns void */
    notifyDragLeave: function(dropable) {},
    
    /** Called by myt.GlobalDragManager when a dropable is dropped onto this
        view and has a matching drag group.
        @param dropable:myt.Dropable The dropable being dropped onto this view.
        @returns void */
    notifyDrop: function(dropable) {}
});


/** Makes an myt.View support being a source for myt.Dropable instances. Makes
    use of myt.Draggable for handling drag initiation but this view is not
    itself, actually draggable.
    
    Events:
        None
    
    Attributes:
        dropParent:myt.View The view to make the myt.Dropable instances in.
            Defaults to the myt.RootView that contains this drop source.
        dropClass:JS.Class The myt.Dropable class that gets created in the
            default implementation of makeDropable.
        dropClassAttrs:object The attrs to use when making the dropClass
            instance.
        dropable:mytDropable (read only) The dropable that was most 
            recently created. Once the dropable has been dropped this will
            be set to null.
*/
myt.DropSource = new JS.Module('DropSource', {
    include: [myt.Draggable],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        if (attrs.distanceBeforeDrag === undefined) attrs.distanceBeforeDrag = 2;
        if (attrs.dropParent === undefined) attrs.dropParent = parent.getRoot();
        
        this.callSuper(parent, attrs);
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setDropClass: function(v) {this.dropClass = v;},
    setDropClassAttrs: function(v) {this.dropClassAttrs = v;},
    setDropParent: function(v) {this.dropParent = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** @overrides myt.Draggable */
    startDrag: function(event) {
        var dropable = this.dropable = this.makeDropable();
        
        // Emulate mouse down on the dropable
        if (dropable) {
            // Remember distance and set to zero so a drag will begin for sure.
            var origDistance = dropable.distanceBeforeDrag;
            dropable.distanceBeforeDrag = 0;
            
            dropable.doMouseDown(event); // Execute MouseDownMixin
            dropable.__doMouseDown(event); // Execute Draggable
            
            // Restore distance
            dropable.distanceBeforeDrag = origDistance;
        }
    },
    
    /** @overrides myt.MouseDown */
    doMouseUp: function(event) {
        this.callSuper(event);
        
        // Emulate mouse up on the dropable
        var dropable = this.dropable;
        if (dropable) {
            dropable.__doMouseUp(event);
            dropable.doMouseUp(event);
            this.dropable = null;
        }
    },
    
    /** Called by startDrag to make a dropable.
        @returns myt.Dropable or undefined if one can't be created. */
    makeDropable: function() {
        var dropClass = this.dropClass,
            dropParent = this.dropParent;
        if (dropClass && dropParent) {
            var pos = myt.DomElementProxy.getPagePosition(this.domElement, dropParent.domElement),
                attrs = this.dropClassAttrs || {};
            attrs.x = pos.x || 0;
            attrs.y = pos.y || 0;
            return new dropClass(dropParent, attrs);
        }
    },
});


/** Makes an myt.View auto scroll during drag and drop.
    
    Events:
        None
    
    Attributes:
        scrollBorder:number The thickness of the auto scroll border. Defaults
            to 40 pixels.
        scrollFrequency:number The time between autoscroll adjustments.
            Defaults to 50 millis.
        scrollAmount:number The number of pixels to adjust by each time.
            Defaults to 2 pixels.
        scrollAcceleration:number The amount to increase scrolling by as the
            mouse gets closer to the edge of the view. Setting this to 0 will
            result in no acceleration. Defaults to 7.
    
    Private Attributes:
        __amountscrollUp:number
        __amountscrollDown:number
        __amountscrollLeft:number
        __amountscrollRight:number
        __isAutoscrollUp:boolean
        __timerIdAutoscrollUp:number
        __isAutoscrollDown:boolean
        __timerIdAutoscrollDown:number
        __isAutoscrollLeft:boolean
        __timerIdAutoscrollLeft:number
        __isAutoscrollRight:boolean
        __timerIdAutoscrollRight:number
*/
myt.AutoScroller = new JS.Module('AutoScroller', {
    include: [myt.DragGroupSupport],
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** @overrides */
    initNode: function(parent, attrs) {
        this.scrollBorder = 40;
        this.scrollFrequency = 50;
        this.scrollAmount = 2;
        this.scrollAcceleration = 7;
        
        if (attrs.overflow === undefined) attrs.overflow = 'auto';
        
        this.callSuper(parent, attrs);
        
        myt.global.dragManager.registerAutoScroller(this);
    },
    
    /** @overrides */
    destroyAfterOrphaning: function() {
        myt.global.dragManager.unregisterAutoScroller(this);
        
        this.callSuper();
    },
    
    
    // Accessors ///////////////////////////////////////////////////////////////
    setScrollBorder: function(v) {this.scrollBorder = v;},
    setScrollFrequency: function(v) {this.scrollFrequency = v;},
    setScrollAmount: function(v) {this.scrollAmount = v;},
    setScrollAcceleration: function(v) {this.scrollAcceleration = v;},
    
    
    // Methods /////////////////////////////////////////////////////////////////
    /** Called by myt.GlobalDragManager when a dropable starts being dragged
        that has a matching drag group.
        @param dropable:myt.Dropable The dropable being dragged.
        @returns void */
    notifyDragStart: function(dropable) {
        var de = this.domElement;
        if (de.scrollHeight > de.clientHeight || de.scrollWidth > de.clientWidth) {
            this.attachToDom(myt.global.mouse, '__handleMouseMove', 'mousemove', true);
        }
    },
    
    /** Called by myt.GlobalDragManager when a dropable stops being dragged
        that has a matching drag group.
        @param dropable:myt.Dropable The dropable no longer being dragged.
        @returns void */
    notifyDragStop: function(dropable) {
        this.detachFromDom(myt.global.mouse, '__handleMouseMove', 'mousemove', true);
        
        this.__resetVScroll();
        this.__resetHScroll();
    },
    
    /** @private */
    __handleMouseMove: function(event) {
        var mousePos = event.value, 
            mouseX = mousePos.pageX, 
            mouseY = mousePos.pageY;
        
        if (this.containsPoint(mouseX, mouseY)) {
            var pos = this.getPagePosition(), 
                scrollBorder = this.scrollBorder;
            
            mouseX -= pos.x;
            mouseY -= pos.y;
            
            if (mouseY < scrollBorder) {
                this.__isAutoscrollUp = true;
                this.__amountscrollUp = this.__calculateAmount((scrollBorder - mouseY) / scrollBorder);
                if (!this.__timerIdAutoscrollUp) this.__doAutoScrollAdj('scrollUp', -1);
            } else if (this.height - mouseY < scrollBorder) {
                this.__isAutoscrollDown = true;
                this.__amountscrollDown = this.__calculateAmount((scrollBorder - (this.height - mouseY)) / scrollBorder);
                if (!this.__timerIdAutoscrollDown) this.__doAutoScrollAdj('scrollDown', 1);
            } else {
                this.__resetVScroll();
            }
            
            if (mouseX < scrollBorder) {
                this.__isAutoscrollLeft = true;
                this.__amountscrollLeft = this.__calculateAmount((scrollBorder - mouseX) / scrollBorder);
                if (!this.__timerIdAutoscrollLeft) this.__doAutoScrollAdj('scrollLeft', -1);
            } else if (this.width - mouseX < scrollBorder) {
                this.__isAutoscrollRight = true;
                this.__amountscrollRight = this.__calculateAmount((scrollBorder - (this.width - mouseX)) / scrollBorder);
                if (!this.__timerIdAutoscrollRight) this.__doAutoScrollAdj('scrollRight', 1);
            } else {
                this.__resetHScroll();
            }
        } else {
            this.__resetVScroll();
            this.__resetHScroll();
        }
    },
    
    /** @private */
    __calculateAmount: function(percent) {
        return Math.round(this.scrollAmount * (1 + this.scrollAcceleration * percent));
    },
    
    /** @private */
    __resetVScroll: function() {
        this.__isAutoscrollUp = false;
        this.__timerIdAutoscrollUp = null;
        this.__isAutoscrollDown = false;
        this.__timerIdAutoscrollDown = null;
    },
    
    /** @private */
    __resetHScroll: function() {
        this.__isAutoscrollLeft = false;
        this.__timerIdAutoscrollLeft = null;
        this.__isAutoscrollRight = false;
        this.__timerIdAutoscrollRight = null;
    },
    
    /** @private */
    __doAutoScrollAdj: function(dir, amt) {
        if (this['__isAuto' + dir]) {
            this.domElement[dir === 'scrollUp' || dir === 'scrollDown' ? 'scrollTop' : 'scrollLeft'] += amt * this['__amount' + dir];
            
            var self = this;
            this['__timerIdAuto' + dir] = setTimeout(function() {
                self.__doAutoScrollAdj(dir, amt);
            }, this.scrollFrequency);
        }
    }
});


/** An object that provides accessors, events and simple lifecycle management.
    Useful as a light weight alternative to myt.Node when parent child
    relationships are not needed.
    
    Events:
        None.
    
    Attributes:
        inited:boolean Set to true after this Eventable has completed 
            initializing.
*/
myt.Eventable = new JS.Class('Eventable', {
    include: [myt.AccessorSupport, myt.Destructible, myt.Observable, myt.Constrainable],
    
    
    // Constructor /////////////////////////////////////////////////////////////
    /** The standard JSClass initializer function.
        @param attrs:object (Optional) A map of attribute names and values.
        @param mixins:array (Optional) a list of mixins to be added onto
            the new instance.
        @returns void */
    initialize: function(attrs, mixins) {
        if (mixins) {
            for (var i = 0, len = mixins.length; len > i;) this.extend(mixins[i++]);
        }
        
        this.inited = false;
        this.init(attrs || {});
    },
    
    
    // Life Cycle //////////////////////////////////////////////////////////////
    /** Called during initialization. Calls setter methods and lastly, sets 
        inited to true. Subclasses must callSuper.
        @param attrs:object A map of attribute names and values.
        @returns void */
    init: function(attrs) {
        this.callSetters(attrs);
        this.inited = true;
    },
    
    /** @overrides myt.Destructible. */
    destroy: function() {
        this.releaseAllConstraints();
        this.detachFromAllObservables();
        this.detachAllObservers();
        
        this.callSuper();
    }
});


/** Provides a dependency target that pulls in all of the myt package. */
myt.all = true;


(pkg => {
    /* Based on browser detection from: http://www.quirksmode.org/js/detect.html
        
        Events:
            none
        
        Attributes:
            browser:string The browser name.
            version:number The browser version number.
            os:string The operating system.
    */
    let versionSearchString,
        dom,
        pre;
    
    const searchString = data => {
            let i = data.length;
            while (i) {
                const dataItem = data[--i];
                versionSearchString = dataItem.ver ?? dataItem.id;
                if (dataItem.str?.includes(dataItem.sub) || dataItem.prop) return dataItem.id;
            }
        },
        
        searchVersion = dataString => {
            const index = dataString.indexOf(versionSearchString);
            if (index >= 0) return parseFloat(dataString.slice(index + versionSearchString.length + 1));
        },
        
        userAgent = navigator.userAgent, 
        platform = navigator.platform, 
        unknown = 'UNKNOWN',
        
        BrowserDetect = pkg.BrowserDetect = {
            browser:searchString([
                {prop:window.opera,                   id:'Opera',    ver:'Version'},
                {str:navigator.vendor, sub:'Apple',   id:'Safari',   ver:'Version'},
                {str:userAgent,        sub:'Firefox', id:'Firefox'},
                {str:userAgent,        sub:'Chrome',  id:'Chrome'},
                {str:userAgent,        sub:'MSIE',    id:'Explorer', ver:'MSIE'}
            ]) ?? unknown,
            
            version:searchVersion(userAgent) || searchVersion(navigator.appVersion) || unknown,
            
            os:searchString([
                {str:userAgent, sub:'iPhone', id:'iPhone/iPod'},
                {str:platform,  sub:'Linux',  id:'Linux'},
                {str:platform,  sub:'Mac',    id:'Mac'},
                {str:platform,  sub:'Win',    id:'Windows'}
            ]) ?? unknown
        };
    
    switch (BrowserDetect.browser) {
        case 'Chrome': case 'Safari': dom = 'WebKit'; break;
        case 'Explorer': dom = 'MS'; break;
        case 'Firefox': dom = 'Moz'; break;
        case 'Opera': dom = 'O'; break;
        default: dom = unknown; break;
    }
    pre = dom.toLowerCase();
    
    BrowserDetect.prefix = {
        dom:dom,
        lowercase:pre,
        css:'-' + pre + '-',
        js:pre[0].toUpperCase() + pre.substr(1)
    };
})(global);


/** Formats a date using a pattern.
  * Implementation from: https://github.com/jacwright/date.format
  * 
  * Copyright (c) 2005 Jacob Wright
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE
  */
Date.prototype.format = Date.prototype.format ?? (() => {
    const {abs:mathAbs, floor:mathFloor, ceil:mathCeil} = Math,
        
        shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        longMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        longDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        
        zeroPad = value => (value < 10 ? '0' : '') + value,
        timezoneOffsetFunc = (date, useColon) => {
            const offset = date.getTimezoneOffset();
            return (offset > 0 ? '-' : '+') + zeroPad(mathFloor(mathAbs(offset / 60))) + (useColon ? ':' : '') + (mathAbs(offset % 60) == 0 ? '00' : zeroPad(mathAbs(offset % 60)));
        },
        
        replaceChars = {
            // Day
            d: date => zeroPad(date.getDate()),
            D: date => shortDays[date.getDay()],
            j: date => date.getDate(),
            l: date => longDays[date.getDay()],
            N: date => (date.getDay() == 0 ? 7 : date.getDay()),
            S: date => {
                const dayOfMonth = date.getDate();
                return (dayOfMonth % 10 == 1 && dayOfMonth != 11 ? 'st' : (dayOfMonth % 10 == 2 && dayOfMonth != 12 ? 'nd' : (dayOfMonth % 10 == 3 && dayOfMonth != 13 ? 'rd' : 'th')));
            },
            w: date => date.getDay(),
            z: date => {
                const d = new Date(date.getFullYear(), 0, 1);
                return mathCeil((date - d) / 86400000);
            },
            // Week
            W: date => {
                const target = new Date(date.valueOf()), dayNr = (date.getDay() + 6) % 7;
                target.setDate(target.getDate() - dayNr + 3);
                const firstThursday = target.valueOf();
                target.setMonth(0, 1);
                if (target.getDay() !== 4) target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
                return zeroPad(1 + mathCeil((firstThursday - target) / 604800000));
            },
            // Month
            F: date => longMonths[date.getMonth()],
            m: date => zeroPad(date.getMonth() + 1),
            M: date => shortMonths[date.getMonth()],
            n: date => date.getMonth() + 1,
            t: date => {
                let year = date.getFullYear(),
                    nextMonth = date.getMonth() + 1;
                if (nextMonth === 12) {
                    year = year++;
                    nextMonth = 0;
                }
                return new Date(year, nextMonth, 0).getDate();
            },
            // Year
            L: date => {
                const year = date.getFullYear();
                return (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0));
            },
            o: date => {
                const d = new Date(date.valueOf());
                d.setDate(d.getDate() - ((date.getDay() + 6) % 7) + 3);
                return d.getFullYear();
            },
            Y: date => date.getFullYear(),
            y: date => ('' + date.getFullYear()).substr(2),
            // Time
            a: date => date.getHours() < 12 ? 'am' : 'pm',
            A: date => date.getHours() < 12 ? 'AM' : 'PM',
            B: date => mathFloor((((date.getUTCHours() + 1) % 24) + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600) * 1000 / 24),
            g: date => date.getHours() % 12 || 12,
            G: date => date.getHours(),
            h: date => zeroPad(date.getHours() % 12 || 12),
            H: date => zeroPad(date.getHours()),
            i: date => zeroPad(date.getMinutes()),
            s: date => zeroPad(date.getSeconds()),
            // Timezone
            e: date => /\((.*)\)/.exec(new Date().toString())[1],
            I: date => {
                let DST = null, i = 0;
                for (; i < 12;) {
                    const d = new Date(date.getFullYear(), i++, 1),
                        offset = d.getTimezoneOffset();
                    if (DST === null) {
                        DST = offset;
                    } else if (offset < DST) {
                        DST = offset; break;
                    } else if (offset > DST) {
                        break;
                    }
                }
                return (date.getTimezoneOffset() == DST) | 0;
            },
            O: date => timezoneOffsetFunc(date, false),
            P: date => timezoneOffsetFunc(date, true),
            T: date => Intl.DateTimeFormat().resolvedOptions().timeZone,
            Z: date => -date.getTimezoneOffset() * 60,
            // Full Date/Time
            c: date => date.format('Y-m-d\\TH:i:sP'),
            r: date => date.toString(),
            U: date => date.getTime() / 1000,
            x: date => date.toLocaleDateString(),
            X: date => date.toLocaleTimeString()
        };
    
    return function(format) {
        return format.replace(/(\\?)(.)/g, (_, esc, chr) => (esc === '' && replaceChars[chr]) ? replaceChars[chr](this) : chr);
    };
})();


(exports => {
    const 
        /*  Gets an array of JS.Methods for the provided method name.
            @param {string} name - The name of the method to lookup.
            @returns {!Array} An array of JS.Methods from the ancestors chain. */
        lookup = (module, name) => {
            const cached = module.__mct__.get(name);
            if (cached) return cached.slice();
            
            // Get the ancestor classes array
            const methods = [],
                cachedAncestors = module.__anc__;
            if (cachedAncestors) {
                const len = cachedAncestors.length;
                for (let i = 0; i < len;) {
                    const fns = cachedAncestors[i++].__fns__;
                    if (fns.has(name)) methods.push(fns.get(name));
                }
            } else {
                const ancestors = module.__anc__ = [],
                    walk = theModule => {
                        const includes = theModule.__inc__,
                            len = includes.length;
                        for (let i = 0; i < len;) walk(includes[i++]);
                        if (!ancestors.includes(theModule)) {
                            ancestors.push(theModule);
                            const fns = theModule.__fns__;
                            if (fns.has(name)) methods.push(fns.get(name));
                        }
                    };
                walk(module);
            }
            module.__mct__.set(name, methods.slice());
            return methods;
        },
        
        compile = (method, hostModule) => {
            const callable = method.callable;
            return method.__hs ? function(...args) {
                const existing = this.callSuper,
                    methods = lookup(hostModule, method.name);
                let stackIndex = methods.length - 1;
                if (stackIndex === 0) {
                    if (existing) delete this.callSuper;
                } else {
                    const argsLen = args.length,
                        _super = this.callSuper = (...superArgs) => {
                            for (let i = superArgs.length; i < argsLen;) superArgs[i] = args[i++];
                            if (--stackIndex === 0) delete this.callSuper;
                            const returnValue = methods[stackIndex].callable.call(this, ...superArgs);
                            this.callSuper = _super;
                            stackIndex++;
                            return returnValue;
                        };
                }
                const returnValue = callable.call(this, ...args);
                if (existing) {
                    this.callSuper = existing;
                } else {
                    delete this.callSuper;
                }
                return returnValue;
            } : callable;
        },
        
        resolveModule = (module, hostModule) => {
            hostModule = hostModule ?? module;
            
            if (hostModule === module) {
                module.__anc__ = null;
                module.__mct__ = new Map();
                const dep = module.__dep__;
                for (let i = dep.length; i > 0;) resolveModule(dep[--i]);
            }
            
            const target = hostModule.__tgt__,
                inc = module.__inc__,
                len = inc.length;
            for (let i = 0; i < len;) resolveModule(inc[i++], hostModule);
            
            for (const [key, method] of module.__fns__) {
                const compiled = method instanceof Method ? compile(method, hostModule) : method;
                if (target[key] !== compiled) target[key] = compiled;
            }
        },
        
        eigenFunc = target => target.__meta__ ?? (target.__meta__ = new Module(null, null, target)).include(target.klass, true),
        
        makeClass = parent => {
            const constructor = function(...args) {return this.initialize(...args) ?? this;};
            constructor.prototype = Object.create(parent.prototype);
            return constructor;
        },
        
        createMethod = (module, name, callable) => callable?.__fns__ || typeof callable !== 'function' ? callable : new Method(module, name, callable),
        
        Method = makeClass(Object),
        Module = exports.Module = makeClass(Object);
    
    Method.prototype.initialize = function(module, name, callable) {
        this.module = module;
        this.name = name;
        this.callable = callable;
        
        // Indicates if this Method has a super call or not.
        this.__hs = callable.toString().includes('callSuper');
    };
    
    const moduleProto = Module.prototype;
    moduleProto.initialize = function(name, methods, target) {
        this.__inc__ = [];
        this.__dep__ = [];
        this.__fns__ = new Map();
        this.__mct__ = new Map();
        this.__tgt__ = target;
        
        if (name) this.__displayName = name;
        
        this.include(methods, true);
    };
    /*  Mixes a module into this module.
        @param {!Function} module - The JS.Module to mix in.
        @param {boolean} [noResolve]
        @returns {!Function) this JS.Module. */
    moduleProto.include = function(module, noResolve) {
        if (module) {
            if (module.__fns__) {
                this.__inc__.push(module);
                module.__dep__.push(this);
            } else {
                const extend = module.extend,
                    include = module.include;
                if (extend && (extend.__fns__ || typeof extend !== 'function')) this.extend(extend);
                if (include && (include.__fns__ || typeof include !== 'function')) {
                    const len = include.length;
                    for (let i = 0; i < len;) this.include(include[i++], true);
                }
                for (const field of Object.keys(module)) {
                    const value = module[field];
                    if ((field !== 'extend' && field !== 'include') || (!value.__fns__ && typeof value === 'function')) {
                        // Adds a single named method to a JS.Class/JS.Module. If you’re modifying a 
                        // class, the method instantly becomes available in instances of the class, 
                        // and in its subclasses.
                        if (this.__fns__.has(field)) {
                            // Handles the case where the new function would clobber an existing one.
                            // This can occur by using Module.extend twice with the same named
                            // function. By turning it into a formal Module it gets put into the
                            // ancestor chain and thus callSuper will work as expected.
                            console.warn('JS.Module already has field: "' + field + '" auto generating a JS.Module from the field for inclusion.');
                            this.include(new Module('Auto_' + field, {[field]:value}), false);
                        } else {
                            this.__fns__.set(field, createMethod(this, field, value));
                        }
                    }
                }
            }
            if (noResolve !== true) resolveModule(this);
        }
        return this;
    };
    /*  Checks if this module includes the provided Module.
        @param {!Function} module - The module to check for.
        @returns {boolean} True if the module is included, otherwise false. */
    moduleProto.includes = function(module) {
        if (module === this) return true;
        const inc = this.__inc__, 
            len = inc.length;
        for (let i = 0; i < len;) {
            if (inc[i++].includes(module)) return true;
        }
        return false;
    };
    /*  Extracts a single named method from a Module.
        @param {string} name - The name of the method to extract.
        @return {!Function) The extracted JS.Method. */
    moduleProto.instanceMethod = function(name) {
        return lookup(this, name).pop();
    };
    
    const Kernel = new Module('Kernel', {
        extend: function(module) {
            eigenFunc(this).include(module);
        },
        /** Checks if this object includes, extends or is the provided Module.
            @param {!Function} module - The JS.Module module to check for.
            @returns {boolean} */
        isA: function(module) {
            return (typeof module === 'function' && this instanceof module) || eigenFunc(this).includes(module);
        }
    });
    
    const Class = exports.Class = makeClass(Module),
        classProto = Class.prototype;
    classProto.initialize = function(name, parent, methods) {
        if (typeof parent !== 'function') {
            methods = parent;
            parent  = Object;
        }
        
        Module.prototype.initialize.call(this, name);
        
        const klass = makeClass(parent);
        
        // The klass extends from this.
        for (const field in this) {
            if (klass[field] !== this[field] && !klass.hasOwnProperty(field)) klass[field] = this[field];
        }
        
        klass.prototype.constructor = klass.prototype.klass = klass;
        eigenFunc(klass).include(parent.__meta__);
        klass.__tgt__ = klass.prototype;
        
        const parentModule = parent === Object ? {} : (parent.__fns__ ? parent : new Module(parent.prototype, true));
        klass.include(Kernel, true).include(parentModule, true).include(methods, true);
        
        resolveModule(klass);
        
        return klass;
    };
    
    const classify = (klass, parent) => {
        klass.__inc__ = [];
        klass.__dep__ = [];
        const proto = klass.__tgt__ = klass.prototype,
            methods = klass.__fns__ = new Map();
        
        for (const field of Object.keys(proto)) methods.set(field, createMethod(klass, field, proto[field]));
        proto.constructor = proto.klass = klass;
        
        // The klass extends from Class.prototype.
        for (const field in classProto) {
            if (klass[field] !== classProto[field] && !klass.hasOwnProperty(field)) klass[field] = classProto[field];
        }
        
        klass.include(parent);
        klass.constructor = klass.klass = Class;
    };
    classify(Method, Kernel);
    classify(Module, Kernel);
    classify(Class,  Module);
    
    resolveModule(eigenFunc(Method));
    resolveModule(eigenFunc(Module));
    eigenFunc(Class).include(Module.__meta__);
    
    /** Create a single instance of a "private" class. */
    exports.Singleton = new Class('Singleton', {
        initialize: (name, parent, methods) => new (new Class(name, parent, methods))
    });
})(global.JS = {});

(pkg => {
    /*
     * http://github.com/maynarddemmon/myt
     * Maynard Demmon <maynarddemmon@gmail.com>
     * @copyright Copyright (c) 2012-2023 Maynard Demmon and contributors
     * Myt: A simple javascript UI framework
     * Version: 20220118.1318
     * MIT License
     * 
     * Parts of the Software incorporates code from the following open-source projects:
     * * JS.Class, (c) 2007-2012 James Coglan and contributors (MIT License)
     * * Easing Functions, (c) 2001 Robert Penner (BSD License)
     * * jQuery Easing v1.3, (c) 2008 George McGinley Smith (BSD License)
     * * jQuery Cookie Plugin v1.3.1, (c) 2013 Klaus Hartl (MIT License)
     * * parseUri 1.2.2, (c) Steven Levithan <stevenlevithan.com> (MIT License)
     * * date.format Date:03/10/15, Copyright (c) 2005 Jacob Wright https://github.com/jacwright/date.format
     * * k-d Tree JavaScript - v1.0 (c) Mircea Pricop <pricop@ubilabs.net>,
     *                                  Martin Kleppe <kleppe@ubilabs.net>,
     *                                  Ubilabs http://ubilabs.net (MIT License)
     */
    
    class FetchError extends Error {
        constructor(status, url, ...params) {
            super(...params);
            this.name = 'FetchError';
            this.status = status;
            this.url = url;
        }
    }
    
    
    let 
        // Used to generate globally unique IDs.
        GUID_COUNTER = 0,
        
        // The current locale for the user.
        currentLocale;
    
    const consoleWarn = console.warn,
        
        math = Math,
        {abs:mathAbs, min:mathMin, max:mathMax, pow:mathPow} = math,
        
        isArray = Array.isArray,
        
        documentElem = document,
        headElem = documentElem.head,
        createElement = documentElem.createElement.bind(documentElem),
        
        /* Font functionality */
        fontTargets = {},
        fontLoaded = {
            // Empty entry is so that notifyInstanceThatFontLoaded will get triggered for 
            // registerForFontNotification when an empty font name is provided. This should be 
            // done when a built in font will be used.
            '':true
        },
        docFonts = documentElem.fonts,
        
        notifyFontLoaded = fontFace => {
            // Fix for Firefox and FontAwesome because of double quotes returned in the font family 
            // name. Seems OK to just do it for all fonts since double quotes in a font name is 
            // most likely going to be confusing anyhow.
            const familyName = fontFace.family.split('"').join('');
            for (const fontName of [familyName, familyName + ' ' + fontFace.weight]) {
                if (!fontLoaded[fontName]) {
                    fontLoaded[fontName] = true;
                    const targets = fontTargets[fontName] ?? [];
                    while (targets.length) notifyInstanceThatFontLoaded(targets.pop());
                }
            }
        },
        
        notifyInstanceThatFontLoaded = instance => {
            if (instance && !instance.destroyed && instance.isVisible()) instance.sizeViewToDom();
        },
        
        // The default locale for I18N.
        defaultLocale = 'en',
        
        // The localization dictionaries for I18N
        dictionaries = {},
        
        memoize = func => {
            const cache = {};
            return (...args) => {
                const hash = JSON.stringify(args);
                return hash in cache ? cache[hash] : cache[hash] = func(...args);
            };
        },
        
        /*  Generates a globally unique id, (GUID).
            @returns {number} */
        generateGuid = () => ++GUID_COUNTER,
        
        I18N_PLURAL_REGEX = /\{\{plural:\$(.*?)\|(.*?)\|(.*?)\}\}/g,
        I18N_NUMERIC_ARG_REGEX = /\$(\d+)/g,
        
        CSV_OBJECT_REGEX = /(\,|\r?\n|\r|^)(?:"((?:\\.|""|[^\\"])*)"|([^\,"\r\n]*))/gi,
        CSV_UNESCAPE_REGEX = /[\\"](.)/g,
        
        myt = pkg.myt = {
            /** A version number based on the time this distribution of myt was created. */
            version:20230602.1558,
            
            generateGuid: generateGuid,
            
            /** Creates a non-secure hash of a string.
                @param {string} s - The string to hash.
                @returns {number} */
            hash: s => s.split('').reduce((a, b) => {a = ((a << 5) - a) + b.charCodeAt(0); return a&a;}, 0),
            
            /** Adds an event listener to a dom element. 
                @param {!Object} elem - The DomElement to listen to.
                @param {string} type - The name of the event to listen to.
                @param {!Function} callback - The callback function that will be registered for 
                    the event.
                @param {boolean} [capture] - Indicates if the listener is registered during the 
                    capture phase or bubble phase.
                @param {boolean} passive
                @returns {undefined} */
            addEventListener: (elem, type, callback, capture, passive) => {
                elem.addEventListener(type, callback, {
                    capture:capture || false,
                    passive:passive || false
                });
            },
            
            /** Removes an event listener from a dom element. 
                @param elem:DomElement The dom element to listen to.
                @param {string} type - The name of the event to listen to.
                @param {!Function} callback - The callback function that will be registered for 
                    the event.
                @param {boolean} [capture] indicates if the listener is registered during the 
                    capture phase or bubble phase.
                @returns {undefined} */
            removeEventListener: (elem, type, callback, capture) => {
                elem.removeEventListener(type, callback, capture || false);
            },
            
            /** Takes a '.' separated string such as "foo.bar.baz" and resolves it into the value 
                found at that location relative to a starting scope. If no scope is provided global 
                scope is used.
                @param {string|?Array} objName - The name to resolve or an array of path parts in 
                    descending order.
                @param {?Object} [scope] - The scope to resolve from. If not provided global scope 
                    is used.
                @returns {?Object} The referenced object or undefined if resolution failed. */
            resolveName: (objName, scope) => {
                if (!objName || objName.length === 0) return undefined;
                
                scope = scope ?? global;
                
                const parts = isArray(objName) ? objName : objName.split('.'), 
                    len = parts.length;
                for (let i = 0; i < len; i++) {
                    scope = scope[parts[i]];
                    if (scope == null) {
                        consoleWarn('resolveName failed for', objName, 'at part', i, parts[i]);
                        return undefined;
                    }
                }
                return scope;
            },
            
            /** Resolves a provided string into a JS.Class object. If a non-string value is 
                provided it is verified to be a JS.Class object.
                @param {*} value - The value to resolve and/or verify.
                @returns {?Function} - A JS.Class or null if the string could not be resolved or 
                    the value was not a JS.Class object. */
            resolveClassname: value => {
                if (typeof value === 'string') value = myt.resolveName(value);
                
                // Make sure what we found is really a JS.Class otherwise return null.
                return (value && typeof value.isA === 'function' && value.isA(JS.Class)) ? value : null;
            },
            
            /** Gets the file extension from a file name.
                @param {string} fileName - The filename to extract the extension from.
                @returns {string) The file extension or null if a falsy fileName argument was 
                    provided. */
            getExtension: fileName => {
                if (fileName) {
                    const parts = fileName.split('.');
                    return parts.length > 1 ? parts.pop() : null;
                } else {
                    return null;
                }
            },
            
            /** Dynamically load a script into the dom.
                @param {string} src - The URL to the script file.
                @param {?Function} [callback] - A function called when the script loads.
                @param {boolean} [noCacheBust] - If true, not cacheBust query param will be added. 
                    Defaults to undefined which is equivalent to false.
                @returns {?Object} The created script element or null if the script has already 
                    been loaded. */
            loadScript: function(src, callback, noCacheBust) {
                // Prevent reloading the same script
                const loadedScripts = this._loadedScripts ??= {};
                if (loadedScripts[src]) {
                    consoleWarn('script already loaded for src', src);
                    return null;
                } else {
                    loadedScripts[src] = true;
                    
                    const scriptElem = createElement('script');
                    scriptElem.type = 'text/javascript';
                    scriptElem.async = false;
                    
                    if (callback) {
                        let fired = false;
                        scriptElem.onload = scriptElem.onreadystatechange = () => {
                            if (!fired && (!scriptElem.readyState || scriptElem.readyState === 'complete')) {
                                // Prevent refiring callback
                                fired = true;
                                
                                // Prevent later events from this script. For example, if the src 
                                // is changed.
                                scriptElem.onload = scriptElem.onreadystatechange = null;
                                
                                callback();
                            }
                        };
                    }
                    
                    // Must set src AFTER adding onreadystatechange listener otherwise we’ll miss 
                    // the loaded event for cached scripts
                    scriptElem.src = src + (noCacheBust ? '' : (src.includes('?') ? '&' : '?') + 'cacheBust=' + Date.now());
                    
                    headElem.appendChild(scriptElem);
                    
                    return scriptElem;
                }
            },
            
            /** A wrapper on myt.global.error.notify
                @param {string|?Error} err - The error or message to dump stack for.
                @param {string} [type] - The type of console message to write. Allowed values are 
                    'error', 'warn', 'log' and 'debug'. Defaults to 'error'.
                @returns {undefined} */
            dumpStack: (err, type) => {
                let msg;
                if (typeof err === 'string') {
                    msg = err;
                    err = null;
                }
                myt.global.error.notify(type || 'error', null, msg, err);
            },
            
            // Random numbers
            /** Generates a random number between 0 (inclusive) and 1 (exclusive)
                @param {?Function} [func] - A distribution function for the random numbers. The 
                    function should map a number between 0 and 1 to another number between 0 
                    (inclusive) and 1 (exclusive). If not provided a flat distribution will be 
                    used. Example functions:
                        - function(v) {return v * v;} will skew the value towards 0.
                        - function(v) {return 0.9999999999 - v * v;} will skew the value towards a 
                          value very close to 1.
                @returns {number} a random number between 0 and almost 1. */
            getRandom: func => {
                const v = math.random();
                // Min and max is to correct for badly behaved skew functions.
                return func ? mathMax(0, mathMin(func(v), 0.9999999999)) : v;
            },
            
            /** @returns a random number between min (inclusive) and max (exclusive).
                @param {number} min - the minimum value returned.
                @param {number} max - the maximum value returned.
                @param {?Function} [func] - A distribution function. See myt.getRandom for more.
                @returns {number} a number between min and max. */
            getRandomArbitrary: (min, max, func) => {
                const actualMin = mathMin(min, max);
                return myt.getRandom(func) * (mathMax(min, max) - actualMin) + actualMin;
            },
            
            /** Generates a random integer between min (inclusive) and max (inclusive).
                @param {number} min - the minimum value returned.
                @param {number} max - the maximum value returned.
                @param {?Function} [func] - A distribution function. See myt.getRandom for more.
                @returns {number} a number between min and max. */
            getRandomInt: (min, max, func) => {
                const actualMin = mathMin(min, max);
                return math.floor(myt.getRandom(func) * (mathMax(min, max) - actualMin + 1) + actualMin);
            },
            
            // Equality
            /** Tests if two floats are essentially equal to each other.
                @param {number} a - A float
                @param {number} b - A float
                @param {number} [epsilon] - The percent of difference of the smaller magnitude 
                    number allowed between a and b. Defaults to 0.000001 if not provided.
                @returns {boolean} true if equal, false otherwise. */
            areFloatsEqual: (a, b, epsilon) => {
                const absA = mathAbs(a),
                    absB = mathAbs(b);
                return mathAbs(a - b) <= (absA > absB ? absB : absA) * (epsilon == null ? 0.000001 : mathAbs(epsilon));
            },
            
            /** Tests if two array are equal. For a more complete deep equal implementation 
                use underscore.js
                @param {?Array} a
                @param {?Array} b
                @returns {boolean} */
            areArraysEqual: (a, b) => {
                if (a !== b) {
                    if (a == null || b == null) return false;
                    let i = a.length;
                    if (i !== b.length) return false;
                    
                    while (i) {
                        if (a[--i] !== b[i]) return false;
                    }
                }
                return true;
            },
            
            /** Tests if two objects are shallowly equal.
                @param {?Object} a
                @param {?Object} b
                @returns {boolean} */
            areObjectsEqual: (a, b) => {
                if (a !== b) {
                    if (a == null || b == null) return false;
                    for (const key in a) if (a[key] !== b[key]) return false;
                    for (const key in b) if (a[key] !== b[key]) return false;
                }
                return true;
            },
            
            // DOM
            /** Gets the dom element of the provided tagname and index.
                @param {string} [tagname] - The name of the tag to search for. 
                    Defaults to 'body' if not provided
                @param {number} [index] - The index of the tag to get. 
                    Defaults to 0 if not provided.
                @returns {?Object} a dom element or undefined if none exist. */
            getElement: (tagname, index) => documentElem.getElementsByTagName(tagname || 'body')[index > 0 ? index : 0],
            
            // Fonts
            loadFontFaces: (fontList, callback) => {
                const fonts = [];
                for (const fontInfo of fontList) {
                    const fontFace = new FontFace(fontInfo.family, 'url(' + fontInfo.url + ')', fontInfo.options);
                    fonts.push(fontFace.load());
                }
                
                Promise.all(fonts).then(loadedFonts => {
                    for (const font of loadedFonts) {
                        docFonts.add(font);
                        notifyFontLoaded(font);
                    }
                    callback?.(loadedFonts);
                });
            },
            
            loadFontFace: (fontName, fontUrl, fontOptions={}, callback) => {
                const fontFace = new FontFace(fontName, 'url(' + fontUrl + ')', fontOptions);
                fontFace.loaded.then(loadedFontFace => {
                    docFonts.add(loadedFontFace);
                    notifyFontLoaded(loadedFontFace);
                    callback?.(loadedFontFace);
                });
                fontFace.load();
            },
            
            registerForFontNotification: (textView, fontName) => {
                if (fontLoaded[fontName]) {
                    notifyInstanceThatFontLoaded(textView);
                } else {
                    (fontTargets[fontName] ??= []).push(textView);
                }
            },
            
            /** Create a CSS rule that defines the base font for the document.
                @param {string} fontFamily
                @returns {undefined} */
            createBaseFontCSSRule: fontFamily => {
                myt.addCSSRule(myt.createStylesheet(), 'body, input', 'font-family:' + fontFamily, 0);
            },
            
            /** @param {?Array} fontUrls
                @returns {undefined} */
            loadCSSFonts: fontUrls => {
                fontUrls?.forEach(myt.createStylesheetLink);
            },
            
            // CSS
            /** Creates a "link" dom element.
                @param {string} [href] The href attribute for the link.
                @returns {!Object} */
            createStylesheetLink: href => {
                const link = createElement('link');
                link.rel = 'stylesheet';
                if (href) link.href = href;
                headElem.appendChild(link);
                return link;
            },
            
            /** Creates a "style" dom element.
                @returns {!Object} */
            createStylesheet: () => {
                const style = createElement('style');
                headElem.appendChild(style);
                return style.sheet;
            },
            
            addCSSRule: (sheet, selector, rules, index) => {
                sheet.insertRule(selector + '{' + rules + '}', index);
            },
            
            removeCSSRules: sheet => {
                let i = sheet.cssRules.length;
                while (i) sheet.deleteRule(--i);
            },
            
            createInputPlaceholderCSSRule: (view, color, fontFamily, opacity=1) => {
                // Clear existing sheet if it exists or create a new sheet
                let sheet = view.__sheet;
                if (sheet) {
                    myt.removeCSSRules(sheet);
                } else {
                    sheet = view.__sheet = myt.createStylesheet();
                }
                
                // Make sure the view has a dom ID for rule targeting and then write the CSS rules.
                const ode = view.getODE(),
                    domId = ode.id || (ode.id = 'id' + generateGuid()),
                    rules = [];
                if (color) rules.push('color:' + color);
                if (fontFamily) rules.push('font-family:' + fontFamily);
                if (opacity) rules.push('opacity:' + opacity);
                myt.addCSSRule(sheet, '#' + domId + '::placeholder', rules.join('; '), 0);
            },
            
            // Sort Util
            /** Tests if the provided array is already sorted according to the provided comparator
                function.
                @param {!Array} arr - The array to check.
                @param {!Function} comparatorFunc - The comparator function to check with.
                @returns {boolean} - True if the array is not sorted, false if it is. */
            isNotSorted: (arr, comparatorFunc) => {
                const len = arr.length;
                for (let i = 1; i < len; i++) {
                    if (comparatorFunc(arr[i - 1], arr[i]) > 0) return true;
                }
            },
            
            /** Chains together N comparator functions into a new comparator function such that 
                calls each in order of descending priority.
                @param {...!Function} comparatorFunctions - The comparator functions to call.
                @returns {!Function} - The new composite comparator function. */
            chainSortFunc: (...comparatorFunctions) => {
                return (a, b) => {
                    for (const comparatorFunc of comparatorFunctions) {
                        const retval = comparatorFunc(a, b);
                        if (retval !== 0) return retval;
                    }
                    return 0;
                };
            },
            
            /** Gets an alphanumeric sort function for sorting Objects by a named property or
                Arrays by an index. Object property values that are falsy are coerced to "" if 
                fixNonStrings is false.
                @param {string|number} propName - The name of the property to sort by or an index
                    if the things being sorted are Arrays.
                @param {boolean} ascending
                @param {boolean} caseInsensitive
                @param {boolean} fixNonStrings When true non-string values will be converted to 
                    strings by concatenating them with "".
                @returns {!Function} */
            getAlphaObjSortFunc: memoize((propName, ascending, caseInsensitive, fixNonStrings) => {
                const order = ascending ? 1 : -1;
                return (a, b) => {
                    a = a[propName];
                    b = b[propName];
                    if (fixNonStrings) {
                        // Fix non-string values
                        if (typeof a !== 'string') a = '' + a;
                        if (typeof b !== 'string') b = '' + b;
                    } else {
                        // Otherwise, only fix falsy values, typically null or undefined.
                        a = a || '';
                        b = b || '';
                    }
                    if (caseInsensitive) {
                        a = a.toLowerCase();
                        b = b.toLowerCase();
                    }
                    return a.localeCompare(b) * order;
                };
            }),
            
            /** Gets a numeric sort function for sorting Objects by a named property. Object 
                property values that are falsy are coerced to 0.
                @param {string} propName
                @param {boolean} ascending
                @returns {!Function} */
            getNumericObjSortFunc: memoize((propName, ascending) => {
                const order = ascending ? 1 : -1;
                return (a, b) => {
                    // Fix falsy values, typically null or undefined.
                    a = a[propName] || 0;
                    b = b[propName] || 0;
                    return (a - b) * order;
                };
            }),
            
            // CSV
            /** Converts a CSV string to an array of arrays or an array of objects.
                Code from: https://gist.github.com/plbowers/7560ae793613ee839151624182133159
                @param {string} [strData]
                @param {boolean} [header] - If true each row will be converted to an object with 
                    keys based on the first row being treated as an array of header strings.
                @returns {!Array} An array of arrays or an array of objects if the header param 
                    is true. */
            csvStringToArray: (strData, header) => {
                if (!strData) return [];
                
                const arrData = [[]];
                let arrMatches;
                while (arrMatches = CSV_OBJECT_REGEX.exec(strData)) {
                    if (arrMatches[1].length && arrMatches[1] !== ',') arrData.push([]);
                    arrData[arrData.length - 1].push(arrMatches[2] ? arrMatches[2].replace(CSV_UNESCAPE_REGEX, '$1') : arrMatches[3]);
                }
                
                if (header) {
                    const headerData = arrData.shift();
                    return arrData.map(row => {
                        let i = 0;
                        return headerData.reduce((acc, key) => {acc[key] = row[i++]; return acc;}, {});
                    });
                } else {
                    return arrData;
                }
            },
            
            /** Prepare a CSV data URI according to RFC 4180.
                @param {?Array} rows
                @param {?Array} [headerNames]
                @returns {string} */
            prepareCSVDataURI: (rows, headerNames) => {
                const prepareRow = row => {
                        if (row && isArray(row)) {
                            const colAccum = [],
                                len = row.length;
                            for (let i = 0, col; len > i; i++) {
                                col = row[i];
                                
                                // All columns must have a value.
                                col = col == null ? '' : col.toString();
                                
                                // " are escaped as ""
                                col = col.replace(/"/g, '""');
                                
                                // If the column contains reserved characters it must be wrapped in 
                                // double quotes.
                                if (col.search(/("|,|\n)/g) >= 0) col = '"' + col + '"';
                                
                                colAccum.push(col);
                            }
                            return colAccum.join(',');
                        } else {
                            consoleWarn('Unexpected row', row);
                            return null;
                        }
                    },
                    rowAccum = [];
                
                if (headerNames) {
                    const row = prepareRow(headerNames);
                    if (row) rowAccum.push(row);
                }
                
                if (rows) {
                    if (isArray(rows)) {
                        const len = rows.length;
                        for (let i = 0; len > i; i++) {
                            const row = prepareRow(rows[i]);
                            if (row) rowAccum.push(row);
                        }
                    } else {
                        consoleWarn('Rows were not an array');
                    }
                }
                
                return myt.encodeCSVDataURI(rowAccum.join('\r\n'), headerNames);
            },
            
            encodeCSVDataURI: (csvData, headerNames) => {
                const header = headerNames == null ? '' : ';header=' + (headerNames ? 'present' : 'absent');
                return 'data:text/csv;charset=utf-8' + 
                    header + ',' + 
                    encodeURIComponent(csvData);
            },
            
            // Misc
            dataURIToBlob: dataURI => {
                const idx = dataURI.indexOf(','),
                    mimeStr = dataURI.slice(0, idx).split(':')[1].split(';')[0];
                let data = dataURI.slice(idx + 1);
                if (mimeStr.startsWith('text/')) {
                    data = decodeURIComponent(data);
                } else {
                    const binStr = atob(data);
                    let i = binStr.length;
                    const intArr = new Uint8Array(i);
                    while (i) intArr[--i] = binStr.charCodeAt(i);
                    data = intArr;
                }
                return new Blob([data], {type:mimeStr});
            },
            
            /** Format a number between 0 and 1 as a percentage.
                @param {number} num The number to convert.
                @param {number} [fixed] The number of decimal places to use during formatting. If 
                    the percentage is a whole number no decimal places will be used. For example,
                    0.55781 -> 55.78% and 0.55 -> 55%
                @returns {string} */
            formatAsPercentage: (num, fixed=2) => {
                switch (typeof num) {
                    case 'number':
                        fixed = mathMin(16, mathMax(0, fixed));
                        const percent = math.round(mathMax(0, mathMin(1, num)) * mathPow(10, 2+fixed)) / mathPow(10, fixed);
                        return (percent % 1 === 0 ? percent : percent.toFixed(fixed)) + '%';
                    case 'string':
                        // Assume a string passed to this function is already correctly formatted 
                        // so pass it through unchanged.
                        return num;
                    default:
                        consoleWarn('formatAsPercentage: expects a number');
                        return num;
                }
            },
            
            /** Memoize a function.
                @param {!Function} func - The function to memoize
                @returns {!Function} - The memoized function. */
            memoize: memoize,
            
            /** Returns a function that wraps the provided function and that, as long as it 
                continues to be invoked, will not invoke the wrapped function. The wrapped function 
                will be called after the returned function stops being called for "wait" 
                milliseconds. If "immediate" is passed, the wrapped function will be invoked on the 
                leading edge instead of the trailing edge.
                @param {!Function} func - The function to wrap.
                @param {number} [wait] - The time in millis to delay invocation by. If not 
                    provided 0 is used.
                @param {boolean} [immediate] - If true the function will be invoked immediately and 
                    then the wait time will be used to block subsequent calls.
                @returns {!Function} - The debounced function. */
            debounce: (func, wait, immediate) => {
                const timeoutKey = '__DBTO' + '_' + generateGuid();
                return function() {
                    const context = this,
                        timeout = context[timeoutKey],
                        args = arguments,
                        later = function() {
                            context[timeoutKey] = null;
                            if (!immediate) func.apply(context, args);
                        },
                        callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    context[timeoutKey] = setTimeout(later, wait);
                    if (callNow) func.apply(context, args);
                };
            },
            
            /** Mixes threshold counter functionality with a fixed threshold onto the provided 
                scope. A threshold is exceeded when the counter value equals the threshold value.
                @param {!Object|!Function} scope - Either an myt.Observable, JS.Class or JS.Module 
                    to mix onto.
                @param {number} thresholdValue - The fixed threshold value.
                @param {string} exceededAttrName - The name of the boolean attribute that will 
                    indicate if the threshold is exceeded or not.
                @param {string} [counterAttrName] - The name of the number attribute that will get 
                    adjusted up and down. If not provided the 'exceeded' attribute name will be 
                    used with 'Counter' appended to it. For example if the exceeded attribute was 
                    'locked' this would be 'lockedCounter'.
                @returns {boolean} - True if creation succeeded, false otherwise. */
            createFixedThresholdCounter: (scope, thresholdValue, exceededAttrName, counterAttrName) => {
                const genNameFunc = myt.AccessorSupport.generateName,
                    isModuleOrClass = typeof scope === 'function' || scope instanceof JS.Module,
                    mod = {};
                counterAttrName = counterAttrName || genNameFunc('counter', exceededAttrName);
                
                const incrName = genNameFunc(counterAttrName, 'increment'),
                    decrName = genNameFunc(counterAttrName, 'decrement');
                
                // Prevent clobbering
                if ((isModuleOrClass ? scope.instanceMethod(incrName) : scope[incrName]) !== undefined) {
                    consoleWarn('Increment: Abort clobber', incrName, scope);
                    return false;
                }
                if ((isModuleOrClass ? scope.instanceMethod(decrName) : scope[decrName]) !== undefined) {
                    consoleWarn('Decrement: Abort clobber', decrName, scope);
                    return false;
                }
                
                // Define the "module".
                /** Increments the counter attribute on the scope object by 1.
                    @returns {undefined} */
                mod[incrName] = function() {
                    const value = this[counterAttrName] + 1;
                    this[counterAttrName] = value;
                    this.fireEvent(counterAttrName, value);
                    if (value === thresholdValue) this.set(exceededAttrName, true);
                };
                
                /** Decrements the counter attribute on the scope object by 1.
                    @returns {undefined} */
                mod[decrName] = function() {
                    const curValue = this[counterAttrName];
                    if (curValue === 0) return;
                    const value = curValue - 1;
                    this[counterAttrName] = value;
                    this.fireEvent(counterAttrName, value);
                    if (curValue === thresholdValue) this.set(exceededAttrName, false);
                };
                
                // Mixin in the "module"
                scope[isModuleOrClass ? 'include' : 'extend'](mod);
                
                return true;
            },
            
            // Fetch
            makeURLSearchParams: (params={}) => {
                const urlSearchParams = new URLSearchParams();
                for (const key in params) {
                    const value = params[key];
                    if (value !== undefined) urlSearchParams.set(key, value);
                }
                return urlSearchParams;
            },
            
            doFetch: (url, options, raw, successFunc, errorFunc, finallyFunc) => fetch(url, options).then(
                // Throw normal HTTP errors to the catch clause below
                response => {
                    if (!response.ok) throw new FetchError(response.status, url, response.statusText);
                    return response;
                }
            ).then(
                // Convert the response to JSON or text
                response => raw ? response.text() : response.json()
            ).then(
                response => {
                    if (successFunc) {
                        try {
                            if (raw) {
                                successFunc(response);
                            } else {
                                // Throw application errors to the catch clause below
                                if (response.success === false) throw new FetchError(200, url, response.message);
                                successFunc(response.data);
                            }
                        } catch (ex) {
                            // Ensure errors from successFunc get rethrown as FetchError with the 
                            // original stack trace.
                            const fetchError = new FetchError(200, url, ex.message);
                            fetchError.stack = ex.stack;
                            throw fetchError;
                        }
                    }
                }
            ).catch(
                error => {
                    if (errorFunc) {
                        // Convert non FetchErrors into FetchErrors
                        if (error.name !== 'FetchError') {
                            const fetchError = new FetchError(0, url, error.message);
                            fetchError.stack = error.stack;
                            error = fetchError;
                        }
                        
                        errorFunc(error);
                    }
                }
            ).finally(
                () => {finallyFunc?.();}
            ),
            
            // I18N
            I18N: {
                setLocale: locale => {
                    currentLocale = locale;
                },
                getLocale: () => currentLocale,
                addDictionary: (dictionary, locale) => {
                    dictionaries[locale] = Object.assign(dictionaries[locale] ?? {}, dictionary);
                },
                setDictionary: (dictionary, locale) => {
                    dictionaries[locale] = dictionary ?? {};
                },
                get: (key, ...args) => {
                    const locale = currentLocale ?? (currentLocale = (navigator.language ?? defaultLocale).split('-')[0].toLowerCase()),
                        value = (dictionaries[locale] ?? dictionaries[defaultLocale] ?? {})[key];
                    if (value != null) {
                        if (args.length > 0) {
                            return value.replaceAll(
                                // Process each {{plural:$n|single|multiple}} replacement
                                I18N_PLURAL_REGEX, (m, p1, p2, p3) => (p2 && p3) ? (args[parseInt(p1)] == 1 ? p2 : p3) : ''
                            ).replaceAll(
                                // Process $n replacement for every arg
                                I18N_NUMERIC_ARG_REGEX, (m, idx) => args[idx]
                            );
                        } else {
                            return value;
                        }
                    }
                    return key;
                }
            }
        };
    
    docFonts.onloadingdone = fontFaceSetEvent => {
        for (const fontFace of fontFaceSetEvent.fontfaces) notifyFontLoaded(fontFace);
    };
})(global);


(pkg => {
    const 
        /*  Function to convert a stored cookie value into a value that can be returned. */
        converted = (s, useJson) => {
            // This is a quoted cookie as according to RFC2068, unescape
            if (s.startsWith('"')) s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
            
            try {return useJson ? JSON.parse(s) : s;} catch(ex) {}
        },
        
        /** Browser cookie utility functions.
            
            Ported from:
                jQuery Cookie Plugin v1.3.1
                https://github.com/carhartl/jquery-cookie
                Copyright 2013 Klaus Hartl
                Released under the MIT license
            
            @class */
        Cookie = pkg.Cookie = {
            // Attributes //////////////////////////////////////////////////////
            /* Default cookie properties and settings. */
            defaults: {
                raw:false, // If true, don't use encodeURIComponent/decodeURIComponent
                json:false // If true, do JSON stringify and parse
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Reads a cookie.
                @param {string} key - The name of the cookie to read.
                @param {?Object} options - Options that determine how the cookie is read and/or 
                    parsed. Supported options are:
                        raw:boolean If true the cookie key and value will be used as is. Otherwise 
                            decodeURIComponent will be used.
                        json:boolean If true JSON.parse will be used to parse the cookie value 
                            before it is returned.
                @returns {*} - The cookie value string or a parsed cookie value. */
            read: (key, options) => {
                options = {...Cookie.defaults, ...options};
                
                const decodeFunc = options.raw ? str => str : str => decodeURIComponent(str.split('+').join(' ')),
                    useJson = options.json,
                    cookies = document.cookie.split('; '),
                    len = cookies.length,
                    retval = key ? undefined : {};
                for (let i = 0; i < len;) {
                    const parts = cookies[i++].split('='),
                        name = decodeFunc(parts.shift()),
                        cookie = decodeFunc(parts.join('='));
                    if (key) {
                        if (key === name) return converted(cookie, useJson);
                    } else {
                        retval[name] = converted(cookie, useJson);
                    }
                }
                return retval;
            },
            
            /** Stores a cookie.
                @param {string} key - the name of the cookie to store.
                @param {*} value - The value to store.
                @param {?Object} options - The options that determine how the cookie is written and 
                    stored. Supported options are: 
                        expires:number the number of days until the cookie expires.
                        path:string the path scope for the cookie.
                        domain:string the domain scope for the cookie.
                        secure:boolean the cookie must be secure.
                        samesite:string the samesite property of the cookie.
                        raw:boolean If true the cookie key and value will be used as is. Otherwise 
                            encodeURIComponent will be used.
                        json:boolean If true JSON.stringify will be used to encode the cookie value.
                @returns {undefined} */
            write: (key, value, options) => {
                options = {...Cookie.defaults, ...options};
                
                if (typeof options.expires === 'number') {
                    const days = options.expires,
                        t = options.expires = new Date();
                    t.setDate(t.getDate() + days);
                }
                
                value = options.json ? JSON.stringify(value) : String(value);
                
                const {raw, expires, path, domain, samesite} = options;
                return (document.cookie = [
                    raw ? key : encodeURIComponent(key),
                    '=',
                    raw ? value : encodeURIComponent(value),
                    expires ? '; expires=' + expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                    path    ? '; path=' + path : '',
                    domain  ? '; domain=' + domain : '',
                    samesite ? '; samesite=' + samesite : '',
                    options.secure  ? '; secure' : ''
                ].join(''));
            },
            
            /** Removes a stored cookie by setting its expires option to -1 days.
                @param {string} key - the name of the cookie to remove.
                @param {?Object} options - Options used to read/write the cookie.
                @returns {boolean} - true if a cookie was removed, false otherwise. */
            remove: (key, options) => {
                if (Cookie.read(key, options) !== undefined) {
                    // Must not alter options, thus extending a fresh object.
                    Cookie.write(key, '', {...options, expires: -1});
                    return true;
                }
                return false;
            }
        };
})(myt);


(pkg => {
    const consoleError = console.error,
        
        JSONParse = JSON.parse,
        
        localStorage = global.localStorage,
        
        /*  @param {string} key - The name of the storage entry to return.
            @returns {*} - The value of the storage entry or null if not found. */
        getItem = localStorage.getItem.bind(localStorage),
        
        /*  Stores the value under the key. If a value already exists for the key the value will be 
            replaced with the new value.
            @param {string} key - The key to store the value under.
            @param {*} value - The value to store.
            @returns {undefined} */
        setItem = localStorage.setItem.bind(localStorage),
        
        /*  Removes the storage entry for the key.
            @param {string} key - The key to remove.
            @returns {undefined} */
        removeItem = localStorage.removeItem.bind(localStorage),
        
        /*  Removes all storage entries.
            @returns {undefined} */
        clear = localStorage.clear.bind(localStorage),
        
        getStoreId = storeId => storeId = storeId ?? 'myt',
        getItemByStoreId = storeId => getItem(getStoreId(storeId)),
        setItemForStoreId = (storeId, data) => {setItem(storeId, JSON.stringify(data));},
        
        doFuncWithOptionalDelay = (func, delay, timerKey) => {
            if (delay > 0) {
                const timerIdKey = '__timerId_' + timerKey,
                    timerId = LocalStorage[timerIdKey];
                if (timerId) clearTimeout(timerId);
                
                LocalStorage[timerIdKey] = setTimeout(() => {
                    func();
                    delete LocalStorage[timerIdKey];
                }, delay);
            } else {
                func();
            }
        },
        
        /** Browser local storage utility functions.
            
            The Data methods utilize a single JSON object to store multiple values under a single 
            local storage item.
            
            @class */
        LocalStorage = pkg.LocalStorage = {
            /** Check if data has been stored under the key and storage id.
                @param {string} key - The key to look for.
                @param {string} [storeId] - The id of the data store to look in. If not provided 
                    the default "myt" storeId will be used.
                @returns {boolean} - false if an undefined or null value is found, otherwise true. */
            hasDatum: (key, storeId) => {
                if (key) {
                    const data = getItemByStoreId(storeId);
                    if (data) {
                        try {
                            return JSONParse(data)[key] != null;
                        } catch (e) {
                            consoleError(e);
                            return false;
                        }
                    }
                }
                return false;
            },
            
            /** Get the data stored under the key and storage id.
                @param {string} key - The key to get data for.
                @param {string} [storeId] - The id of the data store to get data for. If not 
                    provided the default "myt" storeId will be used.
                @returns {*} the value of the data or undefined if the datum was not found. */
            getDatum: (key, storeId) => {
                if (key) {
                    const data = getItemByStoreId(storeId);
                    if (data) {
                        try {
                            const jsonData = JSONParse(data);
                            if (typeof jsonData === 'object') return jsonData[key];
                        } catch (e) {
                            consoleError(e);
                        }
                    }
                }
            },
            
            /** Sets a single entry in a data store.
                @param {string} key - The key to store the value under.
                @param {*} value - The value to store.
                @param {string} [storeId] - The id of the data store to put data in. If not 
                    provided the default "myt" storeId will be used.
                @param {number} [delay] - A number of millis to wait before actually storing the 
                    data. This can be useful to prevent excessive numbers of writes when a value 
                    will be set a large number of times over a short time interval. For example, 
                    when saving the position of a UI control as it is being repositioned or a value 
                    the user is typing.
                @returns {undefined} */
            setDatum: (key, value, storeId, delay) => {
                storeId = getStoreId(storeId);
                doFuncWithOptionalDelay(() => {
                    const data = LocalStorage.getData(storeId);
                    data[key] = value;
                    setItemForStoreId(storeId, data);
                }, delay, storeId + '___' + key);
            },
            
            /** Removes a single entry in a data store.
                @param {string} key - The key to remove the entry for.
                @param {string} [storeId] - The id of the data store to remove data from. If not 
                    provided the default "myt" storeId will be used.
                @param {number} [delay] - A number of millis to wait before actually removing 
                    the data.
                @returns {undefined} */
            removeDatum: (key, storeId, delay) => {
                storeId = getStoreId(storeId);
                doFuncWithOptionalDelay(() => {
                    const data = LocalStorage.getData(storeId);
                    delete data[key];
                    setItemForStoreId(storeId, data);
                }, delay, storeId + '___' + key);
            },
            
            /** Check if data has been stored under the storage id.
                @param {string} [storeId] - THe id of the data store to look in. If not provided 
                    the default "myt" storeId will be used.
                @returns {boolean} - false if an undefined or null value is found, otherwise true. */
            hasData: storeId => getItemByStoreId(storeId) != null,
            
            /** Get the data store stored under storage id.
                @param {string} [storeId] - The id of the data store to get data for. If not 
                    provided the default "myt" storeId will be used.
                @returns {!Object} - The store object. */
            getData: storeId => {
                const data = getItemByStoreId(storeId);
                if (data) {
                    try {
                        return JSONParse(data);
                    } catch (e) {
                        consoleError(e);
                    }
                }
                return {};
            },
            
            /** Store data under the storage id. This replaces an entire data store with the new 
                data object.
                @param {?Object} [data] - The data object to store under the storage id.
                @param {string} [storeId] - The id of the data store to put data in. If not 
                    provided the default "myt" storeId will be used.
                @param {number} [delay] - A number of millis to wait before actually storing the 
                    data. This can be useful to prevent excessive numbers of writes when a value 
                    will be set a large number of times over a short time interval. For example, 
                    when saving the position of a UI control as it is being repositioned or a value 
                    the user is typing.
                @returns {boolean} - true if the data is of type object false otherwise. */
            setData: (data, storeId, delay) => {
                storeId = getStoreId(storeId);
                
                data ??= {};
                
                if (typeof data === 'object') {
                    doFuncWithOptionalDelay(() => {setItemForStoreId(storeId, data);}, delay, storeId);
                    return true;
                }
                
                return false;
            },
            
            /** Removes a data store.
                @param {string} [storeId] - The id of the data store to remove. If not provided the 
                    default "myt" storeId will be used.
                @param {number} [delay] - A number of millis to wait beforeactually removing 
                    the data.
                @returns {undefined} */
            removeData: (storeId, delay) => {
                storeId = getStoreId(storeId);
                doFuncWithOptionalDelay(() => {removeItem(storeId);}, delay, storeId);
            },
            
            // Wrapper functions on localStorage
            /** @returns {number} - The number of data items stored in the Storage object. */
            getLength: () => localStorage.length,
            
            /** @param {number} n - The index of the key name to retrieve.
                @returns {string} The name of the nth key in the storage. */
            getKey: localStorage.key.bind(localStorage),
            
            getItem: getItem,
            setItem: setItem,
            removeItem: removeItem,
            clear: clear,
            
            // Aliases for better API compatibility with some libraries.
            get: getItem,
            set: setItem,
            remove: removeItem,
            clearAll: clear
        };
})(myt);


(pkg => {
    const queryParser = /(?:^|&)([^&=]*)=?([^&]*)/g,
        strictParser = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        looseParser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    
    /** Models a URI and provides parsing of strings into URIs.
        
        Makes use of:
            parseUri 1.2.2
            (c) Steven Levithan <stevenlevithan.com>
            MIT License
            See: http://blog.stevenlevithan.com/archives/parseuri
            
        When more complex URI parsing is needed, perhaps try URI.js which can be
        found at: http://medialize.github.io/URI.js/
        
        @class */
    pkg.URI = new JS.Class('URI', {
        // Constructor /////////////////////////////////////////////////////////
        initialize: function(str, loose) {
            if (str) this.parse(str, loose);
        },
        
        
        // Attributes and Setters/Getters //////////////////////////////////////
        setSource: function(v) {this.source = v;},
        setProtocol: function(v) {this.protocol = v;},
        setAuthority: function(v) {this.authority = v;},
        setUserInfo: function(v) {this.userInfo = v;},
        setUser: function(v) {this.user = v;},
        setPassword: function(v) {this.password = v;},
        setHost: function(v) {this.host = v;},
        setPort: function(v) {this.port = v;},
        setRelative: function(v) {this.relative = v;},
        setPath: function(v) {this.path = v;},
        setDirectory: function(v) {this.directory = v;},
        setFile: function(v) {this.file = v;},
        setQuery: function(v) {this.query = v;},
        setAnchor: function(v) {this.anchor = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        parse: function(str, loose) {
            const self = this,
                [
                    source, protocol, authority, userInfo, user, password, host, 
                    port, relative, path, directory, file, query, anchor
                ] = (loose ? looseParser : strictParser).exec(str) ?? [];
            
            self.setSource(source ?? '');
            self.setProtocol(protocol ?? '');
            self.setAuthority(authority ?? '');
            self.setUserInfo(userInfo ?? '');
            self.setUser(user ?? '');
            self.setPassword(password ?? '');
            self.setHost(host ?? '');
            self.setPort(port ?? '');
            self.setRelative(relative ?? '');
            self.setPath(path ?? '');
            self.setDirectory(directory ?? '');
            self.setFile(file ?? '');
            self.setQuery(query ?? '');
            self.setAnchor(anchor ?? '');
            
            // Parse the query into pairs
            self.queryPairs = {};
            self.query.replace(queryParser, ($0, $1, $2) => {
                if ($1) self.queryPairs[$1] = $2;
            });
        },
        
        /** Unescape a query param value.
            @param {string} paramValue
            @returns {string} */
        decodeQueryParam: paramValue => decodeURIComponent(paramValue).split('+').join(' '),
        
        getQuery: function() {
            const pairs = this.queryPairs,
                parts = [];
            for (const key in pairs) parts.push(key + '=' + encodeURIComponent(this.getQueryParam(key)));
            const s = parts.join('&');
            return s.length > 0 ? '?' + s : s;
        },
        
        getQueryParam: function(name) {
            const v = this.queryPairs[name];
            return v == null ? undefined : this.decodeQueryParam(v);
        },
        
        setQueryParam: function(name, value) {
            this.queryPairs[encodeURIComponent(name)] = encodeURIComponent(value);
        },
        
        removeQueryParam: function(name) {
            delete this.queryPairs[name];
        },
        
        getPathParts: function(allowEmpties) {
            const parts = this.path.split('/');
            
            if (!allowEmpties) {
                let i = parts.length;
                while (i) if (parts[--i].length === 0) parts.splice(i, 1);
            }
            
            return parts;
        },
        
        toString: function(originalRawQuery) {
            const self = this,
                path = self.path,
                query = originalRawQuery ? (self.query ? '?' + self.query : '') : self.getQuery(),
                anchor = self.anchor;
            let s = self.toStringThroughPort();
            
            if (path) {
                s += path;
            } else if (self.host && (query || anchor)) {
                s += '/';
            }
            
            if (query) s += query;
            if (anchor) s += '#' + anchor;
            
            return s;
        },
        
        toStringThroughPort: function() {
            const self = this,
                protocol = self.protocol,
                host = self.host,
                userInfo = self.userInfo,
                port = self.port;
            let s = '';
            
            if (protocol) s += protocol + '://';
            if (userInfo && host) s += userInfo + '@';
            
            if (host) {
                s += host;
                if (port) s += ':' + port;
            }
            
            return s;
        }
    });
})(myt);


(pkg => {
    const math = Math,
        {PI, cos:mathCos, sin:mathSin, sqrt:mathSqrt} = math,
        
        /*  Convert radians to degrees.
            @param {number} deg - The degrees to convert.
            @returns {number} - The converted radians. */
        degreesToRadians = deg => deg * PI / 180,
        
        /*  Convert degrees to radians.
            @param {number} rad - The radians to convert.
            @returns {number} The converted degrees. */
        radiansToDegrees = rad => rad * 180 / PI,
        
        /*  Checks if the provided point is inside or on the edge of the provided rectangle.
            @param {number|!Object} pX - The x coordinate of the point to test or alternately a 
                point object with properties x and y.
            @param {number} pY - The y coordinate of the point to test.
            @param {number|!Object} rX - The x coordinate of the rectangle or alternately a rect 
                object with properties x, y, width and height.
            @param {number} rY - The y coordinate of the rectangle.
            @param {number} rW - The width of the rectangle.
            @param {number} rH - The height of the rectangle.
            @returns {boolean} - True if the point is inside or on the rectangle. */
        rectContainsPoint = (pX, pY, rX, rY, rW, rH) => {
            if (typeof pX === 'object') {
                rH = rW;
                rW = rY;
                rY = rX;
                rX = pY;
                pY = pX.y;
                pX = pX.x;
            }
            
            if (typeof rX === 'object') {
                rH = rX.height;
                rW = rX.width;
                rY = rX.y;
                rX = rX.x;
            }
            
            return pX >= rX && pY >= rY && pX <= rX + rW && pY <= rY + rH;
        },
        
        /*  Measure the distance between two points.
            @param {number} x1 - The x position of the first point.
            @param {number} y1 - The y position of the first point.
            @param {number} x2 - The x position of the second point.
            @param {number} y2 - The y position of the second point.
            @param {boolean} [squared] - If true, the squared distance will be returned.
            @returns {number} - The distance between the two points. */
        measureDistance = (x1, y1, x2, y2, squared) => {
            const diffX = x2 - x1, 
                diffY = y2 - y1, 
                diffSquared = diffX * diffX + diffY * diffY;
            return squared ? diffSquared : mathSqrt(diffSquared);
        },
        
        /*  Measures the distance between two points on a sphere using latitude and longitude.
            @param {number} lat1 - the latitude of the first point.
            @param {number} lng1 - the longitude of the first point.
            @param {number} lat2 - the latitude of the second point.
            @param {number} lng2 - the longitude of the second point.
            @param {number} [sphereRadius] - The radius of the sphere the measurement is being 
                taken on in kilometers. If not provided the radius of the earth is used.
            @returns {number} - The distance between the points in kilometers. */
        measureLatLngDistance = (lat1, lng1, lat2, lng2, sphereRadius) => {
            // Taken from: http://www.movable-type.co.uk/scripts/latlong.html
            if (sphereRadius == null) sphereRadius = 6371; // kilometers for earth
            lat1 = degreesToRadians(lat1);
            lat2 = degreesToRadians(lat2);
            return sphereRadius * math.acos(
                mathSin(lat1) * mathSin(lat2) + 
                mathCos(lat1) * mathCos(lat2) * mathCos(degreesToRadians(lng2) - degreesToRadians(lng1))
            );
        };
    
    /** Provides common geometry related functions. */
    pkg.Geometry = {
        // Methods /////////////////////////////////////////////////////////
        /** Get the closest point on a line, or segment, to a given point.
            @param {number} Ax - The x-coordinate of the first endpoint that defines the segment.
            @param {number} Ay - The y-coordinate of the first endpoint that defines  the segment.
            @param {number} Bx - The x-coordinate of the second endpoint that defines the segment.
            @param {number} By - The y-coordinate of the second endpoint that defines the segment.
            @param {number} Px - The x-coordinate of the point.
            @param {number} Py - The y-coordinate of the point.
            @param {boolean} [isSegment] - If true the endpoints will be treated as a segment 
                rather than an infinitely long line.
            @returns {!Object} - A position object with x and y properties. */
        getClosestPointOnALineToAPoint: (Ax, Ay, Bx, By, Px, Py, isSegment) => {
            const APx = Px - Ax,
                APy = Py - Ay,
                ABx = Bx - Ax,
                ABy = By - Ay,
                magAB2 = ABx * ABx + ABy * ABy,
                ABdotAP = ABx * APx + ABy * APy;
            let t = ABdotAP / magAB2;
            if (isSegment) t = math.min(1, math.max(0, t));
            return {x:Ax + ABx * t, y:Ay + ABy * t};
        },
        
        /** Tests if the provided point is inside this path.
            @param {number|!Object} x - The x coordinate to test or alternately a point object 
                with x and y properties.
            @param {number} y - The y coordinate to test.
            @param {!Object} boundingBox - A bounding box object that bounds the path.
            @param {!Araay} path - An array of points where the index 0,2,4,... are the x 
                values and index 1,3,5,... are the y values.
            @return {boolean} - True if inside, false otherwise. */
        isPointInPath: (x, y, boundingBox, path) => {
            if (typeof x === 'object') {
                path = boundingBox;
                boundingBox = y;
                y = x.y;
                x = x.x;
            }
            
            // First test bounding box
            if (rectContainsPoint(x, y, boundingBox)) {
                // Test using Jordan Curve Theorem
                let len = path.length;
                
                // Must at least be a triangle to have an inside.
                if (len >= 6) {
                    let c = false, 
                        x1 = path[0], 
                        y1 = path[1], 
                        x2, 
                        y2;
                    while (len) {
                        y2 = path[--len];
                        x2 = path[--len];
                        if (((y2 > y) !== (y1 > y)) && (x < (x1 - x2) * (y - y2) / (y1 - y2) + x2)) c = !c;
                        x1 = x2;
                        y1 = y2;
                    }
                    return c;
                }
            }
            return false;
        },
        
        measureDistance: measureDistance,
        measureLatLngDistance: measureLatLngDistance,
        degreesToRadians: degreesToRadians,
        radiansToDegrees: radiansToDegrees,
        rectContainsPoint: rectContainsPoint,
        
        /** Checks if the provided point lies inside or on the edge of the provided circle.
            @param {number} pX - The x coordinate of the point to test.
            @param {number} pY - The y coordinate of the point to test.
            @param {number} cX - The x coordinate of the center of the circle.
            @param {number} cY - The y coordinate of the center of the circle.
            @param {number} cR - The radius of the circle.
            @return {boolean} - True if the point is inside or on the circle. */
        circleContainsPoint: (pX, pY, cX, cY, cR) => measureDistance(pX, pY, cX, cY, true) <= cR * cR,
        
        // Geometry on a sphere
        /** Checks if the provided lat/lng point lies inside or on the edge of the provided circle.
            @param {number} pLat - The latitude of the point to test.
            @param {number} pLng - The longitude of the point to test.
            @param {number} cLat - The latitude of the center of the circle.
            @param {number} cLng - The longitude of the center of the circle.
            @param {number} cR - The radius of the circle in kilometers.
            @param {number} [sphereRadius] - The radius of the sphere the measurement is being 
                taken on in kilometers. If not provided the radius of the earth is used.
            @return {boolean} - True if the point is inside or on the circle. */
        circleContainsLatLng: (pLat, pLng, cLat, cLng, cR, sphereRadius) => measureLatLngDistance(pLat, pLng, cLat, cLng, sphereRadius) <= cR,
        
        /** Convert from polar to cartesian coordinates.
            @param {number} radius - The radius of the point to convert relative to the circle.
            @param {number} degrees - The angle coordinate of the point to convert.
            @param {number} [cx] - The x coordinate of the center of the circle.
            @param {number} [cy] - The y coordinate of the center of the circle.
            @returns {!Array} - Where index 0 is the x coordinate and index 1 is the y coordinate. */
        polarToCartesian: (radius, degrees, cx, cy) => {
            cx ??= 0;
            cy ??= 0;
            degrees = degrees % 360;
            
            let x, 
                y;
            if (degrees === 0) {
                x = radius;
                y = 0;
            } else if (degrees === 90) {
                x = 0;
                y = radius;
            } else if (degrees === 180) {
                x = -radius;
                y = 0;
            } else if (degrees === 270) {
                x = 0;
                y = -radius;
            } else {
                const radians = degreesToRadians(degrees);
                x = radius * mathCos(radians);
                y = radius * mathSin(radians);
            }
            
            return [cx + x, cy + y];
        },
        
        /** Convert from cartesian to polar coordinates.
            @param {number} x - The x coordinate to transform.
            @param {number} y - The y coordinate to transform.
            @param {number} [cx] - The x coordinate of the center of the circle.
            @param {number} [cy] - The y coordinate of the center of the circle.
            @param {boolean} [useRadians] - If true the angle returned will be in radians 
                otherwise it will be degrees.
            @return {!Array} An array where index 0 is the radius and index 1 is angle in 
                degrees (or radians if userRadians is true). */
        cartesianToPolar: (x, y, cx, cy, useRadians) => {
            cx ??= 0;
            cy ??= 0;
            
            const diffX = x - cx,
                diffY = y - cy,
                radius = mathSqrt(diffX*diffX + diffY*diffY);
            let radians = math.atan2(diffY, diffX);
            if (radians < 0) radians += 2 * PI;
            return [radius, useRadians ? radians : radiansToDegrees(radians)];
        }
    };
})(myt);


(pkg => {
    const JSModule = JS.Module,
        
        consoleLog = console.log,
        
        dumpStack = pkg.dumpStack;
    
    /** Apply this mixin to any Object that needs to fire events.
        
        Private Attributes:
            __obsbt:object Stores arrays of myt.Observers and method names by event type
            __aet:Object Stores active event type strings. An event type is active if it has been 
                fired from this Observable as part of the current call stack. If an event type 
                is "active" it will not be fired again. This provides protection against infinite 
                event loops.
        
        @class */
    pkg.Observable = new JSModule('Observable', {
        // Methods /////////////////////////////////////////////////////////////
        /** Adds the observer to the list of event recipients for the event type.
            @param observer:myt.Observer The observer that will observe this observable. If 
                methodName is a function this object will be the context for the function when it 
                is called.
            @param methodName:string|function The name of the method to call, or a function, on 
                the observer when the event fires.
            @param type:string The name of the event the observer will listen to.
            @returns boolean true if the observer was successfully attached, false otherwise. */
        attachObserver: function(observer, methodName, type) {
            if (observer && methodName && type) {
                this.getObservers(type).push(methodName, observer);
                return true;
            }
            return false;
        },
        
        /** Removes the observer from the list of observers for the event type.
            @param observer:myt.Observer The observer that will no longer be observing 
                this observable.
            @param methodName:string|function The name of the method that was to be called or the 
                function to be called.
            @param type:string The name of the event the observer will no longer be listening to.
            @returns boolean true if the observer was successfully detached, false otherwise. */
        detachObserver: function(observer, methodName, type) {
            if (observer && methodName && type) {
                const observersByType = this.__obsbt;
                if (observersByType) {
                    const observers = observersByType[type];
                    if (observers) {
                        // Remove all instances of the observer and methodName combination.
                        let retval = false;
                        for (let i = observers.length - 2; i >= 0; i -= 2) {
                            const [method, obs] = observers.slice(i);
                            if (observer === obs && methodName === method) {
                                observers.splice(i, 2); // <- Detach Activity that detachAllObservers cares about.
                                retval = true;
                            }
                        }
                        return retval;
                    }
                }
            }
            return false;
        },
        
        /** Removes all observers from this Observable.
            @returns {undefined} */
        detachAllObservers: function() {
            const observersByType = this.__obsbt;
            if (observersByType) {
                for (const type in observersByType) {
                    const observers = observersByType[type];
                    for (let i = observers.length - 2; i >= 0; i -= 2) {
                        const [methodName, observer] = observers.slice(i);
                        
                        // If an observer is registered more than once the list may get shortened 
                        // by observer.detachFrom. If so, just continue decrementing downwards.
                        if (observer && methodName) {
                            if (typeof observer.detachFrom !== 'function' || 
                                !observer.detachFrom(this, methodName, type)
                            ) {
                                // Observer may not have a detachFrom function or the observer may 
                                // not have attached via Observer.attachTo so do the default detach 
                                // activity as implemented in Observable.detachObserver
                                observers.splice(i, 2);
                            }
                        }
                    }
                }
            }
        },
        
        /** Gets an array of observers and method names for the provided type. The array is 
            structured as:
                [methodName1, observerObj1, methodName2, observerObj2,...].
            @param type:string The name of the event to get observers for.
            @returns array: The observers of the event. */
        getObservers: function(type) {
            const observersByType = this.__obsbt ??= {};
            return observersByType[type] ??= [];
        },
        
        /** Checks if any observers exist for the provided event type.
            @param type:string The name of the event to check.
            @returns boolean: True if any exist, false otherwise. */
        hasObservers: function(type) {
            const observersByType = this.__obsbt;
            return observersByType ? observersByType[type]?.length > 0 : false;
        },
        
        /** Creates a new event with the type and value and using this as the source.
            @param type:string The event type.
            @param value:* The event value.
            @returns An event object consisting of source, type and value. */
        createEvent: function(type, value) {
            return {source:this, type:type, value:value}; // Inlined in this.fireEvent
        },
        
        /** Generates a new event from the provided type and value and fires it to the provided 
            observers or the registered observers.
            @param type:string The event type to fire.
            @param value:* The value to set on the event.
            @param observers:array (Optional) If provided the event will be sent to this specific 
                list of observers and no others.
            @returns {undefined} */
        fireEvent: function(type, value, observers) {
            // Determine observers to use
            const self = this;
            
            // We avoid using getObservers since that lazy instantiates __obsbt and fireEvent will
            // get called predominantly when no observers exist.
            observers = observers ?? (self.hasObservers(type) ? self.__obsbt[type] : null);
            
            // Fire event
            if (observers) {
                // Prevent "active" events from being fired again
                const event = {source:self, type:type, value:value}, // Inlined from this.createEvent
                    activeEventTypes = self.__aet ??= {};
                if (activeEventTypes[type]) {
                    pkg.global.error.notify(
                        'warn', 'eventLoop', 'Abort refiring event:' + type, null, {
                            observable:self,
                            type:type,
                            value:value
                        }
                    );
                } else {
                    // Mark event type as "active"
                    activeEventTypes[type] = true;
                    
                    // Walk through observers backwards so that if the observer is detached by the 
                    // event handler the index won't get messed up.
                    // FIXME: If necessary we could queue up detachObserver calls that come in 
                    // during iteration or make some sort of adjustment to 'i'.
                    for (let i = observers.length - 2; i >= 0; i -= 2) {
                        const [methodName, observer] = observers.slice(i);
                        
                        // Sometimes the list gets shortened as a side effect of the method we 
                        // called thus resulting in a nullish observer and methodName. In that case 
                        // just continue decrementing downwards.
                        if (observer && methodName) {
                            // Stop firing the event if it was "consumed". An event is considered
                            // consumed if the invoked function returns true.
                            try {
                                if (typeof methodName === 'function') {
                                    if (methodName.call(observer, event)) break;
                                } else {
                                    if (observer[methodName](event)) break;
                                }
                            } catch (err) {
                                dumpStack(err);
                                consoleLog('Additional context', methodName, observer);
                            }
                        }
                    }
                    
                    // Mark event type as "inactive"
                    activeEventTypes[type] = false;
                }
            }
        }
    });
    
    /** Provides a mechanism to remember which Observables this instance has registered itself 
        with. This can be useful when we need to cleanup the instance later.
        
        When this module is used registration and unregistration must be done using the methods 
        below. Otherwise, it is possible for the relationship between observer and observable to 
        be broken.
        
        This mixin also provides the ability to apply and release constraints.
        
        Private Attributes:
            __obt:object Stores arrays of Observables by event type
            __methodNameCounter:int Used to create unique method names when a callback should only 
                be called once.
            __DO_ONCE_*:function The names used for methods that only get run one time.
            __cbmn:object Holds arrays of constraints by method name.
        
        @class */
    pkg.Observer = new JSModule('Observer', {
        // Methods /////////////////////////////////////////////////////////////
        /** Extracts the value from an "event like" object if encountered. Otherwise it returns 
            the provided eventOrValue.
            @param {*} v The candidate event or value to get the value from. An event like value 
                is a non-null Object with a truthy "type" property.
            @returns {*} the provided event or the event's value if found. */
        valueFromEvent: v => v && typeof v === 'object' && v.type ? v.value : v,
        
        /** Does the same thing as this.attachTo and also immediately calls the method with an 
            event containing the attributes value. If 'once' is true no attachment will occur 
            which means this probably isn't the correct method to use in that situation.
            @param observable:myt.Observable the Observable to attach to.
            @param methodName:string the method name on this instance to execute.
            @param eventType:string the event type to attach for.
            @param attrName:string (optional: the eventType will be used if not provided) the name 
                of the attribute on the Observable to pull the value from.
            @param once:boolean (optional) if true  this Observer will detach from the Observable 
                after the event is handled once.
            @returns {undefined} */
        syncTo: function(observable, methodName, eventType, attrName, once) {
            attrName ??= eventType;
            try {
                this[methodName](observable.createEvent(eventType, observable.get(attrName)));
            } catch (err) {
                dumpStack(err);
            }
            
            // Providing a true value for once means we will never actually attach.
            if (!once) this.attachTo(observable, methodName, eventType, once);
        },
        
        /** Checks if this Observer is attached to the provided observable for the methodName 
            and eventType.
            @param observable:myt.Observable the Observable to check with.
            @param methodName:string the method name on this instance to execute.
            @param eventType:string the event type to check for.
            @returns true if attached, false otherwise. */
        isAttachedTo: function(observable, methodName, eventType) {
            if (observable && methodName && eventType) {
                const observablesByType = this.__obt;
                if (observablesByType) {
                    const observables = observablesByType[eventType];
                    if (observables) {
                        for (let i = observables.length - 2; i >= 0; i -= 2) {
                            const [method, obs] = observables.slice(i);
                            if (observable === obs && methodName === method) return true;
                        }
                    }
                }
            }
            return false;
        },
        
        /** Gets an array of observables and method names for the provided type. The array is 
            structured as:
                [methodName1, observableObj1, methodName2, observableObj2,...].
            @param eventType:string the event type to check for.
            @returns an array of observables. */
        getObservables: function(eventType) {
            const observablesByType = this.__obt ??= {};
            return observablesByType[eventType] ??= [];
        },
        
        /** Checks if any observables exist for the provided event type.
            @param eventType:string the event type to check for.
            @returns true if any exist, false otherwise. */
        hasObservables: function(eventType) {
            const observablesByType = this.__obt;
            return observablesByType ? observablesByType[eventType]?.length > 0 : false;
        },
        
        /** Registers this Observer with the provided Observable for the provided eventType.
            @param observable:myt.Observable the Observable to attach to.
            @param methodName:string the method name on this instance to execute.
            @param eventType:string the event type to attach for.
            @param once:boolean (optional) if true  this Observer will detach from the Observable 
                after the event is handled once.
            @returns boolean true if the observable was successfully registered, 
                false otherwise. */
        attachTo: function(observable, methodName, eventType, once) {
            if (observable && methodName && eventType) {
                const observables = this.getObservables(eventType);
                
                // Setup wrapper method when 'once' is true.
                if (once) {
                    const self = this, 
                        origMethodName = methodName;
                    
                    // Generate one time method name.
                    this.__methodNameCounter ??= 0;
                    methodName = '__DO_ONCE_' + this.__methodNameCounter++;
                    
                    // Setup wrapper method that will do the detachFrom.
                    this[methodName] = event => {
                        self.detachFrom(observable, methodName, eventType);
                        delete self[methodName];
                        return self[origMethodName](event);
                    };
                }
                
                // Register this observer with the observable
                if (observable.attachObserver(this, methodName, eventType)) {
                    observables.push(methodName, observable);
                    return true;
                }
            }
            return false;
        },
        
        /** Unregisters this Observer from the provided Observable for the provided eventType.
            @param observable:myt.Observable the Observable to attach to.
            @param methodName:string the method name on this instance to execute.
            @param eventType:string the event type to attach for.
            @returns boolean true if one or more detachments occurred, false otherwise. */
        detachFrom: function(observable, methodName, eventType) {
            if (observable && methodName && eventType) {
                // No need to unregister if observable array doesn't exist.
                const observablesByType = this.__obt;
                if (observablesByType) {
                    const observables = observablesByType[eventType];
                    if (observables) {
                        // Remove all instances of this observer/methodName/eventType from 
                        // the observable
                        let retval = false;
                        for (let i = observables.length - 2; i >= 0; i -= 2) {
                            const [method, obs] = observables.slice(i);
                            if (observable === obs && methodName === method) {
                                if (observable.detachObserver(this, methodName, eventType)) {
                                    observables.splice(i, 2);
                                    retval = true;
                                }
                            }
                        }
                        
                        // Source wasn't found
                        return retval;
                    }
                }
            }
            return false;
        },
        
        /** Tries to detach this Observer from all Observables it is attached to.
            @returns {undefined} */
        detachFromAllObservables: function() {
            const observablesByType = this.__obt;
            if (observablesByType) {
                for (const [eventType, observables] of Object.entries(observablesByType)) {
                    for (let i = observables.length - 2; i >= 0; i -= 2) {
                        const [methodName, observable] = observables.slice(i);
                        observable.detachObserver(this, methodName, eventType);
                    }
                    observables.length = 0;
                }
            }
        },
        
        // Constraints
        /** Creates a constraint. The method will be executed on this object whenever any of the 
            provided observables fire the indicated event type.
            @param {string} methodName - The name of the method to call on this object.
            @param {?Array} observables - An array of observable/type pairs. An observer will 
                attach to each observable for the event type.
            @returns {undefined} */
        constrain: function(methodName, observables) {
            if (methodName && observables) {
                // Make sure an even number of observable/type was provided
                const len = observables.length;
                if (len % 2 !== 0) {
                    consoleLog('Observables uneven', this);
                } else {
                    // Lazy instantiate constraints array.
                    const constraints = this.__cbmn ??= {},
                        constraint = constraints[methodName] ??= [];
                    
                    // Don't allow a constraint to be clobbered.
                    if (constraint.length > 0) {
                        consoleLog('Constraint exists for ' + methodName + ' on ' + this);
                    } else {
                        for (let i = 0; i < len; i += 2) {
                            const [observable, type] = observables.slice(i);
                            if (observable && type) {
                                this.attachTo(observable, methodName, type);
                                constraint.push(observable, type);
                            }
                        }
                        
                        // Call constraint method once so it can "sync" the constraint
                        try {
                            this[methodName]();
                        } catch (err) {
                            dumpStack(err);
                        }
                    }
                }
            }
        },
        
        /** Removes a constraint.
            @param {string} methodName
            @returns {undefined} */
        releaseConstraint: function(methodName) {
            if (methodName) {
                // No need to remove if the constraint is already empty.
                const constraints = this.__cbmn;
                if (constraints) {
                    const constraint = constraints[methodName];
                    if (constraint) {
                        for (let i = constraint.length; i >= 0; i -= 2) {
                            const [observable, type] = constraint.slice(i);
                            this.detachFrom(observable, methodName, type);
                        }
                        constraint.length = 0;
                    }
                }
            }
        },
        
        /** Removes all constraints.
            @returns {undefined} */
        releaseAllConstraints: function() {
            const constraints = this.__cbmn;
            if (constraints) {
                for (const methodName in constraints) this.releaseConstraint(methodName);
            }
        }
    });
})(myt);


(pkg => {
    const consoleWarn = console.warn,
    
        /** Holds references to "global" objects. Fires events when these globals are registered 
            and unregistered.
            
            Events:
                register<key>:object Fired when an object is stored under the key.
                unregister<key>:object Fired when an object is removed from the key.
            
            @class */
        globalRegistry = pkg.global = new JS.Singleton('Global', {
            include: [pkg.Observable],
            
            
            // Constructor /////////////////////////////////////////////////////
            initialize: () => {},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Registers the provided global under the key. Fires a register<key> event. 
                If a global is already registered under the key the existing global is 
                unregistered first.
                @param {string} key
                @param {!Object} v
                @returns {undefined} */
            register: (key, v) => {
                if (globalRegistry.hasOwnProperty(key)) {
                    consoleWarn('Global key in use', key);
                    globalRegistry.unregister(key);
                }
                globalRegistry[key] = v;
                globalRegistry.fireEvent('register' + key, v);
            },
            
            /** Unegisters the global for the provided key. Fires an unregister<key> event if the 
                key exists.
                @param {string} key
                @returns {undefined} */
            unregister: key => {
                if (globalRegistry.hasOwnProperty(key)) {
                    const v = globalRegistry[key];
                    delete globalRegistry[key];
                    globalRegistry.fireEvent('unregister' + key, v);
                } else {
                    consoleWarn('Global key not in use', key);
                }
            }
        });
})(myt);


(pkg => {
    let globalError;
    
    /** Provides global error events and console logging.
        
        Events:
            Error specific events are broadcast. Here is a list of known error types.
                eventLoop: Fired by myt.Observable when an infinite event loop would occur.
        
        Attributes:
            stackTraceLimit:int Sets the size for stack traces.
            consoleLogging:boolean Turns logging to the console on and off.
        
        @class */
    new JS.Singleton('GlobalError', {
        include: [pkg.Observable],
        
        
        // Constructor /////////////////////////////////////////////////////////////
        initialize: function() {
            globalError = this;
            globalError.setStackTraceLimit(50);
            globalError.setConsoleLogging(true);
            pkg.global.register('error', globalError);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////////
        setConsoleLogging: v => {globalError.consoleLogging = v;},
        setStackTraceLimit: v => {Error.stackTraceLimit = globalError.stackTraceLimit = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////////
        /** Broadcasts errors and also logs the error to the console if so configured.
            @param {string} [consoleFuncName] - The name of the function to call on the console. 
                Standard values are:'error', 'warn', 'log' and 'debug'. If not provided no console 
                logging will occur regardless of the value of this.consoleLogging.
            @param {string} [eventType] - The type of the event that will be broadcast. If not 
                provided 'error' will be used.
            @param {*} [msg] - Usually a string, this is additional information that will be 
                provided in the value object of the broadcast event.
            @param {?Error} [err] - A javascript error object from which a stacktrace will 
                be taken. If not provided a stacktrace will be automatically generated.
            @param {?Object} [extraInfo] - An object that will be copied onto the Error object 
                under "extraInfo". This can be used to provide additional context for the Error.
            @returns {undefined} */
        notify: (consoleFuncName, eventType, msg, err, extraInfo) => {
            // Generate Stacktrace
            err ??= new Error(msg ?? eventType);
            const stacktrace = err.stack ?? err.stacktrace;
            globalError.fireEvent(eventType ?? 'error', {msg:msg, stacktrace:stacktrace, ...extraInfo});
            if (globalError.consoleLogging && consoleFuncName) console[consoleFuncName](stacktrace);
        }
    });
})(myt);


(pkg => {
    const GLOBAL = global,
        getComputedStyle = GLOBAL.getComputedStyle,
        DOCUMENT_ELEMENT = document,
        
        mathMax = Math.max,
        
        /*  Gets the z-index of the dom element or, if it does not define a stacking context, 
            the highest z-index of any of the dom element's descendants.
            @param {!Object} elem - A dom element
            @returns {number} - An int */
        getHighestZIndex = elem => {
            // See https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
            const {zIndex, opacity} = getComputedStyle(elem);
            if (zIndex === 'auto') {
                if (parseInt(opacity, 10) === 1) {
                    // No new stacking context.
                    let zIdx = 0;
                    const children = elem.childNodes;
                    let i = children.length;
                    while (i) {
                        const child = children[--i];
                        if (child.nodeType === 1) zIdx = mathMax(zIdx, getHighestZIndex(child));
                    }
                    return zIdx;
                } else {
                    return 0;
                }
            } else {
                return parseInt(zIndex, 10);
            }
        },
        
        /*  Gets an array of ancestor dom elements including the element itself.
            @param {!Object} elem - The dom element to start from.
            @param {?Object} ancestor - The dom element to stop getting ancestors at.
            @returns {!Array} - An array of ancestor dom elements. */
        getAncestorArray = (elem, ancestor) => {
            const ancestors = [];
            while (elem) {
                ancestors.push(elem);
                if (elem === ancestor) break;
                elem = elem.parentNode;
            }
            return ancestors;
        };
    
    /** Provides dom elements for this instance. Typically only a single dom element will exist but 
        some components will make use of two nested elements: an inner dom element and an outer 
        dom element. Also assigns a reference to this DomElementProxy to a property named "model" 
        on the dom elements.
        
        @class */
    const DomElementProxy = pkg.DomElementProxy = new JS.Module('DomElementProxy', {
        // Class Methods ///////////////////////////////////////////////////////
        extend: {
            /** Creates a new dom element.
                @param {string} tagname - The name of the element to create.
                @param {?Object} [styles] - A map of style keys and values to add to the style 
                    property of the new element.
                @param {?Object} [props] - A map of keys and values to add to the new element.
                @returns {!Object} the created element. */
            createElement: (tagname, styles, props) => {
                const elem = DOCUMENT_ELEMENT.createElement(tagname);
                for (const key in props) elem[key] = props[key];
                for (const key in styles) elem.style[key] = styles[key];
                return elem;
            },
            
            /** Tests if a dom element is visible or not.
                @param {!Object} elem - The dom element to check visibility for.
                @returns {boolean} - True if visible, false otherwise. */
            isDomElementVisible: elem => {
                // Special Case: hidden input elements should be considered not visible.
                if (elem.nodeName !== 'INPUT' || elem.type !== 'hidden') {
                    // Walk upwards in the dom until a non-visible element is found or the
                    // document element is reached.
                    while (elem) {
                        if (elem === DOCUMENT_ELEMENT) return true;
                        
                        const {display, visibility} = getComputedStyle(elem);
                        if (display === 'none' || visibility === 'hidden') break;
                        
                        elem = elem.parentNode;
                    }
                }
                return false;
            },
            
            /** Gets the z-index of a dom element relative to an ancestor dom element.
                @param {?Object} elem
                @param {?Object} ancestor
                @returns {number} */
            getZIndexRelativeToAncestor: (elem, ancestor) => {
                if (elem && ancestor) {
                    const ancestors = getAncestorArray(elem, ancestor);
                    let i = ancestors.length - 1;
                    while (i) {
                        const style = getComputedStyle(ancestors[--i]),
                            zIdx = style.zIndex,
                            isAuto = zIdx === 'auto';
                        if (i !== 0 && isAuto && parseInt(style.opacity, 10) === 1) {
                            continue;
                        } else {
                            return isAuto ? 0 : parseInt(zIdx, 10);
                        }
                    }
                }
                return 0;
            },
            
            getAncestorArray: getAncestorArray,
            getHighestZIndex: getHighestZIndex,
            
            /** Gets the x and y position of the dom element relative to the ancestor dom element 
                or the page. Transforms are not supported. Use getTruePosition if you need support 
                for transforms.
                @param {!Object} elem - The dom element to get the position for.
                @param {?Object} [ancestorElem] - The ancestor dom element that if encountered will 
                    halt the page position calculation thus giving the position of elem relative 
                    to ancestorElem.
                @returns {?Object} - An object with 'x' and 'y' keys or undefined if an error 
                    has occurred. */
            getRelativePosition: (elem, ancestorElem) => {
                if (elem) {
                    // elem.nodeName !== 'BODY' test prevents looking at the body which causes 
                    // problems when the document is scrolled on webkit.
                    let x = 0, 
                        y = 0;
                    while (elem && elem.nodeName !== 'BODY' && elem !== ancestorElem) {
                        x += elem.offsetLeft;
                        y += elem.offsetTop;
                        elem = elem.offsetParent;
                        if (elem && elem.nodeName !== 'BODY') {
                            const {borderLeftWidth, borderTopWidth} = getComputedStyle(elem);
                            x += parseInt(borderLeftWidth, 10) - elem.scrollLeft;
                            y += parseInt(borderTopWidth, 10) - elem.scrollTop;
                        }
                    }
                    return {x:x, y:y};
                }
            },
            
            /** Gets the x and y position of the dom element relative to the page with support 
                for transforms.
                @param {!Object} elem - The dom element to get the position for.
                @returns {?Object} - An object with 'x' and 'y' keys or undefined if an error 
                    has occurred. */
            getTruePosition: elem => {
                if (elem) {
                    const pos = elem.getBoundingClientRect();
                    pos.left += GLOBAL.scrollX;
                    pos.top += GLOBAL.scrollY;
                    return pos;
                }
            },
            
            /** Generates a dom event on a dom element. Adapted from:
                    http://stackoverflow.com/questions/6157929/how-to-simulate-mouse-click-using-javascript
                @param {!Object} elem - The dom element to simulate the event on.
                @param {string} eventName - The name of the dom event to generate.
                @param {?Object} [customOpts] - A map of options that will be added onto the dom 
                    event object.
                @returns {undefined} */
            simulateDomEvent: (elem, eventName, customOpts) => {
                if (elem) {
                    const opts = {
                            pointerX:0, pointerY:0, button:0,
                            ctrlKey:false, altKey:false, shiftKey:false, metaKey:false,
                            bubbles:true, cancelable:true
                        },
                        eventMatchers = {
                            'HTMLEvents': /^(?:load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll)$/,
                            'MouseEvents': /^(?:click|dblclick|mouse(?:down|up|over|move|out))$/
                        };
                    
                    if (customOpts) {
                        for (const p in customOpts) opts[p] = customOpts[p];
                    }
                    
                    let eventType;
                    for (const name in eventMatchers) {
                        if (eventMatchers[name].test(eventName)) {
                            eventType = name;
                            break;
                        }
                    }
                    if (!eventType) throw new SyntaxError('Only supports HTMLEvent and MouseEvent interfaces');
                    
                    let domEvent;
                    if (DOCUMENT_ELEMENT.createEvent) {
                        domEvent = DOCUMENT_ELEMENT.createEvent(eventType);
                        if (eventType === 'HTMLEvents') {
                            domEvent.initEvent(eventName, opts.bubbles, opts.cancelable);
                        } else {
                            domEvent.initMouseEvent(
                                eventName, opts.bubbles, opts.cancelable, DOCUMENT_ELEMENT.defaultView,
                                opts.button, opts.pointerX, opts.pointerY, opts.pointerX, opts.pointerY,
                                opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, 
                                opts.button, null
                            );
                        }
                        elem.dispatchEvent(domEvent);
                    } else {
                        opts.clientX = opts.pointerX;
                        opts.clientY = opts.pointerY;
                        domEvent = DOCUMENT_ELEMENT.createEventObject();
                        for (const key in opts) domEvent[key] = opts[key];
                        elem.fireEvent('on' + eventName, domEvent);
                    }
                }
            },
            
            getScrollbarSize: pkg.memoize(() => {
                // Detect if scrollbars take up space or not
                const body = DOCUMENT_ELEMENT.body,
                    elem = DomElementProxy.createElement('div', {width:'100px', height:'100px', overflow:'scroll'});
                body.appendChild(elem);
                const scrollbarSize = elem.offsetWidth - elem.clientWidth;
                body.removeChild(elem);
                return scrollbarSize;
            })
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** Gets the inner dom element. If only one dom element exists then this will be the same 
            as the outer dom element.
            @returns {?Object} */
        getIDE: function() {return this.__iE;},
        
        /** Gets the outer dom element. If only one dom element exists then this will be the same 
            as the inner dom element.
            @returns {?Object} */
        getODE: function() {return this.__oE;},
        
        /** Gets the style attribute of the inner dom element. If only one dom element exists then 
            this will be the same as the outer dom style.
            @returns {?Object} */
        getIDS: function() {return this.__iS;},
        
        /** Gets the style attribute of the outer dom element. If only one dom element exists then 
            this will be the same as the inner dom style.
            @returns {?Object} */
        getODS: function() {return this.__oS;},
        
        /** Sets the dom element(s) to the provided ones. To set the inner and outer dom elements 
            to different dom elements provide an array of two dom elements.
            @param {?Object} v
            @returns {undefined} */
        setDomElement: function(v) {
            const self = this;
            if (Array.isArray(v)) {
                // Support an inner and outer dom element if an array of elements is provided.
                const [outerElem, innerElem] = v;
                self.__oE = outerElem;
                self.__iE = innerElem;
                
                // Store a reference to the dom element style property since it is accessed often.
                self.__iS = innerElem.style;
                self.__oS = outerElem.style;
                
                // Setup a reference from the dom element to this model. This will allow access to 
                // the model from code that uses some other mechanism to select dom elements.
                innerElem.model = outerElem.model = self;
            } else {
                // The inner and outer dom element are the same element since an array of elements
                // was not provided.
                self.__oE = self.__iE = v;
                
                // Store a reference to the dom element style property since it is accessed often.
                self.__iS = self.__oS = v.style;
                
                // Setup a reference from the dom element to this model. This will allow access to 
                // the model from code that uses some other mechanism to select dom elements.
                v.model = self;
            }
        },
        
        /** Removes this DomElementProxy's outer dom element from its parent node.
            @returns {undefined} */
        removeDomElement: function() {
            this.__oE.parentNode.removeChild(this.__oE);
        },
        
        /** Called when this DomElementProxy is destroyed.
            @returns {undefined} */
        disposeOfDomElement: function() {
            delete this.__iE.model;
            delete this.__iS;
            delete this.__iE;
            delete this.__oE.model;
            delete this.__oS;
            delete this.__oE;
        },
        
        /** Sets the dom "class" attribute on the inner dom element.
            @param {string} v - The dom class name.
            @returns {undefined} */
        setDomClass: function(v) {
            this.__iE.className = this.domClass = v;
        },
        
        /** Adds a dom "class" to the existing dom classes on the inner dom element.
            @param {string} v - The dom class to add.
            @returns {undefined} */
        addDomClass: function(v) {
            const existing = this.__iE.className;
            this.setDomClass((existing ? existing + ' ' : '') + v);
        },
        
        /** Removes a dom "class" from the inner dom element.
            @param {string} v - The dom class to remove.
            @returns {undefined} */
        removeDomClass: function(v) {
            const existing = this.__iE.className;
            if (existing) {
                const parts = existing.split(' ');
                let i = parts.length;
                while (i) {
                    if (parts[--i] === v) parts.splice(i, 1);
                }
                this.setDomClass(parts.join(' '));
            }
        },
        
        /** Clears the dom "class" from the inner dom element.
            @returns {undefined} */
        clearDomClass: function() {
            this.setDomClass('');
        },
        
        /** Sets the dom "id" attribute on the inner dom element.
            @param {string} v - The dom id name.
            @returns {undefined} */
        setDomId: function(v) {
            this.__iE.id = this.domId = v;
        },
        
        /** Set the z-index of the outer dom element.
            @param {number} v - The z-index to set.
            @returns {undefined} */
        setZIndex: function(v) {
            this.__oS.zIndex = v;
        },
        
        /** Set an arbitrary CSS style on the inner dom element style.
            @param {string} propertyName - The name of the CSS property to set.
            @param {*} v - The value to set.
            @returns {undefined} */
        setStyleProperty: function(propertyName, v) {
            this.__iS[propertyName] = v;
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Gets the x and y position of the underlying inner dom element relative to the page. 
            Transforms are not supported by default.
            @param {boolean} [transformSupport] If true then transforms applied to the dom elements 
                are supported.
            @returns {?Object} - An object with 'x' and 'y' keys or undefined if an error 
                has occurred. */
        getPagePosition: function(transformSupport) {
            return DomElementProxy['get' + (transformSupport ? 'True' : 'Relative') + 'Position'](this.__iE);
        },
        
        /** Generates a dom event "click" on this DomElementProxy's inner dom element.
            @returns {undefined} */
        simulateClick: function() {
            DomElementProxy.simulateDomEvent(this.__iE, 'click');
        },
        
        /** Gets the highest z-index of the inner dom element.
            @returns {number} - An int */
        getHighestZIndex: function() {
            return getHighestZIndex(this.__iE);
        },
        
        /** Gets the highest z-index of any of the descendant dom elements of the inner dom element 
            of this DomElementProxy.
            @param {boolean} [skipChild] - A dom element to skip over when determining the z-index.
            @returns {number} - An int. */
        getHighestChildZIndex: function(skipChild) {
            const children = this.__iE.childNodes;
            let i = children.length, 
                zIdx = 0;
            while (i) {
                const child = children[--i];
                if (child.nodeType === 1 && child !== skipChild) zIdx = mathMax(zIdx, getHighestZIndex(child));
            }
            return zIdx;
        },
        
        /** Makes this DomElementProxy's outer dom element the one with the highest z-index 
            relative to its sibling dom elements.
            @returns {undefined} */
        makeHighestZIndex: function() {
            this.setZIndex(this.parent.getHighestChildZIndex(this.__iE) + 1);
        },
        
        /** Scrolls the dom element to the provided position or zero if no value is provided.
            @param {number} [value] - The value to scroll to.
            @param {boolean} [scrollInner] - Indicates if the inner dom element should be used 
                instead of the outer dom element.
            @returns {undefined} */
        scrollYTo: function(value, scrollInner) {
            (scrollInner ? this.__iE : this.__oE).scrollTop = value || 0;
        }
    });
})(myt);

(pkg => {
    let globalFocus;
    
    const
        /*  Gets the deepest dom element that is a descendant of the provided dom element or the 
            element itself. */
        getDeepestDescendant = elem => {
            while (elem.lastChild) elem = elem.lastChild;
            return elem;
        },
        
        /*  Traverse forward or backward from the currently focused view. Returns the new view to 
            give focus to, or undefined if there is no view to focus on or an unmanaged dom element 
            will receive focus.
                param: isForward:boolean indicates forward or backward dom traversal.
                param: ignoreFocusTrap:boolean indicates if focus traps should be skipped over 
                    or not. */
        traverse = (isForward, ignoreFocusTrap) => {
            globalFocus.lastTraversalWasForward = isForward;
            
            // Determine root element and starting element for traversal.
            let rootElem = document.body,
                startElem = rootElem,
                activeElem = document.activeElement, 
                elem = startElem,
                model,
                progModel;
            const focusFuncName = isForward ? 'getNextFocus' : 'getPrevFocus';
            
            if (activeElem) {
                elem = startElem = activeElem;
                model = startElem.model;
                model ??= globalFocus.findModelForDomElement(startElem);
                if (model) {
                    const focusTrap = model.getFocusTrap(ignoreFocusTrap);
                    if (focusTrap) rootElem = focusTrap.getIDE();
                }
            }
            
            // Traverse
            while (elem) {
                if (elem.model && elem.model[focusFuncName] &&
                    (progModel = elem.model[focusFuncName]())
                ) {
                    // Programatic traverse
                    elem = progModel.getIDE();
                } else if (isForward) {
                    // Dom traverse forward
                    if (elem.firstChild) {
                        elem = elem.firstChild;
                    } else if (elem === rootElem) {
                        return startElem.model; // TODO: why?
                    } else if (elem.nextSibling) {
                        elem = elem.nextSibling;
                    } else {
                        // Jump up and maybe over since we're at a local deepest last child.
                        while (elem) {
                            elem = elem.parentNode;
                            
                            if (elem === rootElem) {
                                break; // TODO: why?
                            } else if (elem.nextSibling) {
                                elem = elem.nextSibling;
                                break;
                            }
                        }
                    }
                } else {
                    // Dom traverse backward
                    if (elem === rootElem) {
                        elem = getDeepestDescendant(rootElem);
                    } else if (elem.previousSibling) {
                        elem = getDeepestDescendant(elem.previousSibling);
                    } else {
                        elem = elem.parentNode;
                    }
                }
                
                // If we've looped back around return the starting element.
                if (elem === startElem) return startElem.model;
                
                // Check that the element is focusable and return it if it is.
                if (elem.nodeType === 1) {
                    model = elem.model;
                    if (model && model instanceof pkg.View) {
                        if (model.isFocusable()) return model;
                    } else {
                        const nodeName = elem.nodeName;
                        if (nodeName === 'A' || nodeName === 'AREA' || 
                            nodeName === 'INPUT' || nodeName === 'TEXTAREA' || 
                            nodeName === 'SELECT' || nodeName === 'BUTTON'
                        ) {
                            if (!elem.disabled && !isNaN(elem.tabIndex) && 
                                pkg.DomElementProxy.isDomElementVisible(elem)
                            ) {
                                // Make sure the dom element isn't inside a maskFocus
                                model = globalFocus.findModelForDomElement(elem);
                                if (model?.searchAncestorsOrSelf(n => n.maskFocus === true)) {
                                    // Is a masked dom element so ignore.
                                } else {
                                    elem.focus();
                                    globalFocus.focusedDom = elem;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        };
    
    /** Tracks focus and provides global focus events. Registered with myt.global  as 'focus'.
        
        Events:
            focused:View Fired when the focused view changes. The event value is the newly 
                focused view.
        
        Attributes:
            lastTraversalWasForward:boolean indicates if the last traversal was in the forward 
                direction or not. If false this implies the last traversal was in the backward 
                direction. This value is initalized to true.
            focusedView:View the view that currently has focus.
            prevFocusedView:View the view that previously had focus.
            focusedDom:DomElement holds the dom element that has focus when the focus has traversed 
                into a non myt managed area of the dom.
        
        @class */
    /* Dom element types reference:
        ELEMENT_NODE                :1
        ATTRIBUTE_NODE              :2
        TEXT_NODE                   :3
        CDATA_SECTION_NODE          :4
        ENTITY_REFERENCE_NODE       :5
        ENTITY_NODE                 :6
        PROCESSING_INSTRUCTION_NODE :7
        COMMENT_NODE                :8
        DOCUMENT_NODE               :9
        DOCUMENT_TYPE_NODE          :10
        DOCUMENT_FRAGMENT_NODE      :11
        NOTATION_NODE               :12 */
    new JS.Singleton('GlobalFocus', {
        include: [pkg.Observable],
        
        
        // Constructor /////////////////////////////////////////////////////////
        initialize: function() {
            globalFocus = this;
            
            globalFocus.lastTraversalWasForward = true;
            
            pkg.global.register('focus', globalFocus);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** Sets the currently focused view.
            @param {?Object} v
            @returns {undefined} */
        setFocusedView: v => {
            if (globalFocus.focusedView !== v) {
                globalFocus.prevFocusedView = globalFocus.focusedView; // Remember previous focus
                globalFocus.focusedView = v;
                if (v) globalFocus.focusedDom = null; // Wipe this since we have actual focus now.
                globalFocus.fireEvent('focused', v);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called by a FocusObservable when it has received focus.
            @param {!Object} focusable - The FocusObservable that received focus.
            @returns {undefined}. */
        notifyFocus: focusable => {
            if (globalFocus.focusedView !== focusable) globalFocus.setFocusedView(focusable);
        },
        
        /** Called by a FocusObservable when it has lost focus.
            @param {!Object} focusable - The FocusObservable that lost focus.
            @returns {undefined}. */
        notifyBlur: focusable => {
            if (globalFocus.focusedView === focusable) globalFocus.setFocusedView(null);
        },
        
        /** Clears the current focus.
            @returns {undefined} */
        clear: () => {
            if (globalFocus.focusedView) {
                globalFocus.focusedView.blur();
            } else if (globalFocus.focusedDom) {
                globalFocus.focusedDom.blur();
                globalFocus.focusedDom = null;
            }
        },
        
        // Focus Traversal //
        /** Move focus to the next focusable element.
            @param {boolean} ignoreFocusTrap - If true focus traps will be skipped over.
            @returns {undefined} */
        next: ignoreFocusTrap => {
            traverse(true, ignoreFocusTrap)?.focus();
        },
        
        /** Move focus to the previous focusable element.
            @param {boolean} ignoreFocusTrap - If true focus traps will be skipped over.
            @returns {undefined} */
        prev: ignoreFocusTrap => {
            traverse(false, ignoreFocusTrap)?.focus();
        },
        
        /** Finds the closest model for the provided dom element.
            @param {!Object} elem - The dom element to start looking from.
            @returns {?Object} - A myt.View or undefined if not found. */
        findModelForDomElement: elem => {
            while (elem) {
                let model = elem.model;
                if (model && model instanceof pkg.View) return model;
                elem = elem.parentNode;
            }
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        
        G = pkg.global,
        GlobalFocus = G.focus,
        
        makeEmptyEvent = () => ({source:null, type:null, value:null}),
        
        getCodeFromEvent = event => event.value.code,
        
        getSourceViewFromEvent = event => {
            // Assume a myt event but fallback to assuming the event was already a DOM event.
            const domEvent = event.value ?? event;
            return (domEvent.target ?? domEvent.srcElement).model;
        },
        
        /** Generates Key Events and passes them on to one or more event observers. Requires 
            myt.DomObservable as a super mixin.
            
            @class */
        KeyObservable = pkg.KeyObservable = new JSModule('KeyObservable', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** A map of supported key event types. */
                EVENT_TYPES: {
                    keypress:true,
                    keydown:true,
                    keyup:true
                },
                
                /** The common key event that gets reused. */
                EVENT: makeEmptyEvent(),
                
                getKeyFromEvent: event => event.value.key,
                
                /** Gets the code from the provided key event.
                    @param {!Object} event Event value is a dom event.
                    @returns {number} The code from the event. */
                getCodeFromEvent: getCodeFromEvent,
                
                isEnterKeyEvent: event => getCodeFromEvent(event) === G.keys.CODE_ENTER,
                isEscKeyEvent: event => getCodeFromEvent(event) === G.keys.CODE_ESC,
                isShiftKeyEvent: event => G.keys.isShiftCode(getCodeFromEvent(event))
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.DomObservable */
            createDomHandler: function(domObserver, methodName, type) {
                return this.createStandardDomHandler(domObserver, methodName, type, KeyObservable) ?? 
                    this.callSuper(domObserver, methodName, type);
            }
        }),
        
        /** Generates Mouse Events and passes them on to one or more event observers. Also provides 
            the capability to capture contextmenu events and mouse wheel events.
            
            Requires: myt.DomObservable super mixin.
            
            @class */
        MouseObservable = pkg.MouseObservable = new JSModule('MouseObservable', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** A map of supported mouse event types. */
                EVENT_TYPES: {
                    mouseover:true,
                    mouseout:true,
                    mousedown:true,
                    mouseup:true,
                    click:true,
                    dblclick:true,
                    mousemove:true,
                    contextmenu:true,
                    wheel:true
                },
                
                /** The common mouse event that gets reused. */
                EVENT: makeEmptyEvent(),
                
                /** Gets the mouse coordinates from the provided event.
                    @param {!Object} event Event value is a dom event.
                    @returns {!Object} An object with 'x' and 'y' keys containing the x and y 
                        mouse position. */
                getMouseFromEvent: event => ({x:event.value.pageX, y:event.value.pageY}),
                
                getMouseFromEventRelativeToView: (event, view) => {
                    const viewPos = view.getPagePosition(),
                        pos = MouseObservable.getMouseFromEvent(event);
                    pos.x -= viewPos.x;
                    pos.y -= viewPos.y;
                    return pos;
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.DomObservable */
            createDomHandler: function(domObserver, methodName, type) {
                return this.createStandardDomHandler(domObserver, methodName, type, MouseObservable, true) ?? 
                    this.callSuper(domObserver, methodName, type);
            }
        }),
        
        /** Generates Scroll Events and passes them on to one or more event observers.
            
            Requires myt.DomObservable as a super mixin.
            
            @class */
        ScrollObservable = pkg.ScrollObservable = new JSModule('ScrollObservable', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** A map of supported scroll event types. */
                EVENT_TYPES: {
                    scroll:true
                },
                
                /** The common scroll event that gets reused. */
                EVENT: makeEmptyEvent(),
                
                /** Gets the scrollLeft and scrollTop from the event.
                    @param {!Object} event Event value is a dom event.
                    @returns object with an x and y key each containing a number. */
                getScrollFromEvent: event => {
                    const {scrollLeft, scrollTop} = getSourceViewFromEvent(event)?.getIDE();
                    return {x:scrollLeft, y:scrollTop};
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.DomObservable */
            createDomHandler: function(domObserver, methodName, type) {
                return this.createStandardDomHandler(domObserver, methodName, type, ScrollObservable) ?? 
                    this.callSuper(domObserver, methodName, type);
            }
        }),
        
        /** Generates Touch Events and passes them on to one or more event observers.
            
            Requires: myt.DomObservable super mixin.
            
            @class */
        TouchObservable = pkg.TouchObservable = new JSModule('TouchObservable', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** A map of supported touch event types. */
                EVENT_TYPES: {
                    touchstart:true,
                    touchend:true,
                    touchmove:true,
                    touchcancel:true
                },
                
                /** The common touch event that gets reused. */
                EVENT: makeEmptyEvent()
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.DomObservable */
            createDomHandler: function(domObserver, methodName, type) {
                return this.createStandardDomHandler(domObserver, methodName, type, TouchObservable, false) ?? 
                    this.callSuper(domObserver, methodName, type);
            }
        }),
        
        /** Generates focus and blur events and passes them on to one or more event observers. 
            Also provides focus related events to a view. When a view is focused or blurred, 
            myt.global.focus will be notified via the 'notifyFocus' and 'notifyBlur' methods.
            
            Requires myt.DomObservable as a super mixin.
            
            Events:
                focused:object Fired when this view gets focus. The value is this view.
                focus:object Fired when this view gets focus. The value is a dom focus event.
                blur:object Fired when this view loses focus. The value is a dom focus event.
            
            Attributes:
                focused:boolean Indicates if this view has focus or not.
                focusable:boolean Indicates if this view can have focus or not.
                focusIndicator:boolean Indicates if the focus indicator should be shown for this 
                    view or not when it has focus.
            
            Virtual Methods:
                getNextFocus() Implement this method to return the next view that should have 
                    focus. If null is returned or the method is not implemented, normal dom 
                    traversal will occur.
                getPrevFocus() Implement this method to return the prev view that should have 
                    focus. If null is returned or the method is not implemented, normal dom 
                    traversal will occur.
            
            @class */
        // TODO: fire focus and blur events rather than a focused event?
        // FIXME: should we give away focus when we become not visible?
        FocusObservable = pkg.FocusObservable = new JSModule('FocusObservable', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** A map of supported focus event types. */
                EVENT_TYPES: {
                    focus:true,
                    blur:true
                },
                
                /** The common focus/blur event that gets reused. */
                EVENT: makeEmptyEvent()
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.Node */
            initNode: function(parent, attrs) {
                this.focusable = false;
                this.focusIndicator = true;
                
                this.callSuper(parent, attrs);
            },
            
            /** @overrides myt.View */
            destroy: function() {
                this.giveAwayFocus();
                this.callSuper();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setFocused: function(v) {
                if (this.focused !== v) {
                    this.focused = v;
                    if (this.inited) {
                        this.fireEvent('focused', v);
                        if (v) {
                            GlobalFocus.notifyFocus(this);
                        } else {
                            GlobalFocus.notifyBlur(this);
                        }
                    }
                }
            },
            
            setFocusable: function(v) {
                const self = this;
                if (self.focusable !== v) {
                    const wasFocusable = self.focusable;
                    self.focusable = v;
                    
                    if (v) {
                        self.getIDE().tabIndex = 0; // Make focusable. -1 is programmatic only
                        self.attachToDom(self, '__doFocus', 'focus');
                        self.attachToDom(self, '__doBlur', 'blur');
                    } else if (wasFocusable) {
                        self.getIDE().removeAttribute('tabIndex'); // Make unfocusable
                        self.detachFromDom(self, '__doFocus', 'focus');
                        self.detachFromDom(self, '__doBlur', 'blur');
                    }
                    
                    if (self.inited) self.fireEvent('focusable', v);
                }
            },
            
            setFocusIndicator: function(v) {
                if (this.focusIndicator !== v) {
                    this.focusIndicator = v;
                    if (this.focused) {
                        if (v) {
                            this.showFocusIndicator();
                        } else {
                            this.hideFocusIndicator();
                        }
                    }
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Gives the focus to the next focusable element or, if nothing else is focusable, 
                blurs away from this element.
                @returns {undefined} */
            giveAwayFocus: function() {
                if (this.focused) {
                    // Try to go to next focusable element.
                    GlobalFocus.next();
                    
                    // If focus loops around to ourself make sure we do not keep it.
                    if (this.focused) this.blur();
                }
            },
            
            /** Tests if this view is in a state where it can receive focus.
                @returns boolean True if this view is visible, enabled, focusable and not focus 
                    masked, false otherwise. */
            isFocusable: function() {
                return this.focusable && !this.disabled && this.isVisible() && 
                    this.searchAncestorsOrSelf(node => node.maskFocus === true) == null;
            },
            
            /** Calling this method will set focus onto this view if it is focusable.
                @param noScroll:boolean (optional) if true is provided no auto-scrolling will 
                    occur when focus is set.
                @returns {undefined} */
            focus: function(noScroll) {
                if (this.isFocusable()) this.getIDE().focus({preventScroll:noScroll});
            },
            
            /** Removes the focus from this view. Do not call this method directly.
                @private
                @returns {undefined} */
            blur: function() {
                this.getIDE().blur();
            },
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __doFocus: function(event) {
                if (!this.focused) this.setFocused(true);
                this.doFocus();
            },
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __doBlur: function(event) {
                this.doBlur();
                if (this.focused) this.setFocused(false);
            },
            
            /** @returns {undefined} */
            doFocus: function() {
                if (this.focusIndicator) {
                    this.showFocusIndicator();
                } else {
                    this.hideFocusIndicator();
                }
            },
            
            /** @returns {undefined} */
            doBlur: function() {
                if (this.focusIndicator) this.hideFocusIndicator();
            },
            
            /** @returns {undefined} */
            showFocusIndicator: function() {
                // IE
                this.getIDE().hideFocus = false;
                
                // Mozilla and Webkit
                const ids = this.getIDS();
                ids.outlineWidth = 'thin';
                ids.outlineColor = '#8bf';
                ids.outlineStyle = 'solid';
                ids.outlineOffset = '0px';
            },
            
            /** @returns {undefined} */
            hideFocusIndicator: function() {
                this.hideDefaultFocusIndicator();
            },
            
            /** Hides the browser's default focus indicator.
                @returns {undefined}*/
            hideDefaultFocusIndicator: function() {
                // IE
                this.getIDE().hideFocus = true;
                
                // Mozilla and Webkit
                this.getIDS().outlineStyle = 'none';
            },
            
            /** @overrides myt.DomObservable */
            createDomHandler: function(domObserver, methodName, type) {
                if (FocusObservable.EVENT_TYPES[type]) {
                    const self = this;
                    return domEvent => {
                        domEvent ??= window.event;
                        
                        // OPTIMIZATION: prevent extra focus events under special circumstances. 
                        // See myt.VariableLayout for more detail.
                        if (self._ignoreFocus) {
                            domEvent.cancelBubble = true;
                            domEvent.stopPropagation?.();
                            domEvent.preventDefault();
                            return;
                        }
                        
                        // Configure common focus event.
                        const event = FocusObservable.EVENT;
                        event.source = self;
                        event.type = domEvent.type;
                        event.value = domEvent;
                        
                        const allowBubble = domObserver[methodName](event);
                        if (!allowBubble) {
                            domEvent.cancelBubble = true;
                            domEvent.stopPropagation?.();
                        }
                        
                        event.source = undefined;
                    };
                }
                
                return this.callSuper(domObserver, methodName, type);
            }
        }),
        
        /** Generates input events and passes them on to one or more event observers.
            
            Requires myt.DomObservable as a super mixin.
            
            @class */
        InputObservable = pkg.InputObservable = new JSModule('InputObservable', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** A map of supported input event types. */
                EVENT_TYPES: {
                    input:true,
                    select:true,
                    change:true,
                    paste:true
                },
                
                /** The common change/select event that gets reused. */
                EVENT: makeEmptyEvent()
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.DomObservable */
            createDomHandler: function(domObserver, methodName, type) {
                return this.createStandardDomHandler(domObserver, methodName, type, InputObservable) ?? 
                    this.callSuper(domObserver, methodName, type);
            }
        }),
        
        /** Generates drag and drop events and passes them on to one or more event observers.
            
            Requires myt.DomObservable as a super mixin.
            
            @class */
        DragDropObservable = pkg.DragDropObservable = new JSModule('DragDropObservable', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** A map of supported drag and drop event types. */
                EVENT_TYPES: {
                    dragleave:true,
                    dragenter:true,
                    dragover:true,
                    drop:true
                },
                
                /** The common drag and drop event that gets reused. */
                EVENT: makeEmptyEvent()
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.DomObservable */
            createDomHandler: function(domObserver, methodName, type) {
                return this.createStandardDomHandler(domObserver, methodName, type, DragDropObservable, true) ?? 
                    this.callSuper(domObserver, methodName, type);
            }
        });
    
    /** Generates Dom Events and passes them on to one or more event observers.
        Requires myt.DomElementProxy be included when this mixin is included.
        
        Private Attributes:
            __dobsbt:object Stores arrays of myt.DomObservers and method names by event type.
        
        @class */
    pkg.DomObservable = new JSModule('DomObservable', {
        // Methods /////////////////////////////////////////////////////////////
        /** Adds the observer to the list of event recipients for the event type.
            @param {!Object} domObserver - The myt.DomObserver that will be notified when a dom 
                event occurs.
            @param {string} methodName - The method name to call on the dom observer.
            @param {string} type - The type of dom event to register for.
            @param {boolean} [capture] - Indicates if the event registration is during capture or 
                bubble phase. Defaults to false, bubble phase.
            @param {boolean} [passive]
            @returns {boolean} - True if the observer was successfully registered, 
                false otherwise. */
        attachDomObserver: function(domObserver, methodName, type, capture, passive) {
            if (domObserver && methodName && type) {
                capture = !!capture;
                
                const methodRef = this.createDomHandler(domObserver, methodName, type);
                if (methodRef) {
                    const domObserversByType = this.__dobsbt ??= {};
                    
                    // Lazy instantiate dom observers array for type and insert observer.
                    const domObservers = domObserversByType[type];
                    if (domObservers) {
                        // Add dom observer to the end of the list
                        domObservers.push(domObserver, methodName, methodRef, capture);
                    } else {
                        // Create list with observer
                        domObserversByType[type] = [domObserver, methodName, methodRef, capture];
                    }
                    
                    pkg.addEventListener(this.getDomElementForDomObservable(type), type, methodRef, capture, passive);
                    
                    return true;
                }
            }
            return false;
        },
        
        getDomElementForDomObservable: function(type) {
            return this.getIDE();
        },
        
        /** Creates a function that will handle the dom event when it is fired by the browser. 
            Must be implemented by the object this mixin is applied to.
            @param {!Object} domObserver - The myt.DomObserver that must be notified when the dom 
                event fires.
            @param {string} methodName - the name of the function to pass the event to.
            @param {string} type - the type of the event to fire.
            @returns {?Function} - A function to handle the dom event or null if the event is 
                not supported. */
        createDomHandler: (domObserver, methodName, type) => null,
        
        /** Used by the createDomHandler implementations of submixins of myt.DomObservable to 
            implement the standard methodRef.
            @param {!Object} domObserver - The myt.DomObserver that must be notified when the dom 
                event fires.
            @param {string} methodName - The name of the function to pass the event to.
            @param {string} type - The type of the event to fire.
            @param {!Function} observableClass - The JS.Class that has the common event.
            @param {boolean} [preventDefault] - If true the default behavior of the domEvent will 
                be prevented.
            @returns {?Function} - A function to handle the dom event or undefined if the event 
                will not be handled. */
        createStandardDomHandler: function(domObserver, methodName, type, observableClass, preventDefault) {
            if (observableClass.EVENT_TYPES[type]) {
                const self = this, 
                    event = observableClass.EVENT;
                return domEvent => {
                    domEvent ??= window.event;
                    
                    event.source = self;
                    event.type = domEvent.type;
                    event.value = domEvent;
                    
                    // Execute handler function and prevent event bubbling if the handler 
                    // returned false.
                    if (!domObserver[methodName](event)) {
                        domEvent.cancelBubble = true;
                        domEvent.stopPropagation?.();
                        if (preventDefault) domEvent.preventDefault();
                    }
                    
                    event.source = undefined;
                };
            }
        },
        
        /** Removes the observer from the list of dom observers for the event type.
            @param {!Object} domObserver - The myt.DomObserver to unregister.
            @param {string} methodName - The method name to unregister for.
            @param {string} type - The dom event type to unregister for.
            @param {boolean} [capture] - The event phase to unregister for. Defaults to false if 
                not provided.
            @returns {boolean} - True if the observer was successfully unregistered, f
                alse otherwise. */
        detachDomObserver: function(domObserver, methodName, type, capture) {
            if (domObserver && methodName && type) {
                capture = !!capture;
                
                const domObserversByType = this.__dobsbt;
                if (domObserversByType) {
                    const domObservers = domObserversByType[type];
                    if (domObservers) {
                        // Remove dom observer
                        const de = this.getDomElementForDomObservable(type);
                        let retval = false;
                        for (let i = domObservers.length - 4; i >= 0; i -= 4) {
                            const [obs, method, handler, cap] = domObservers.slice(i, i + 4);
                            if (domObserver === obs && methodName === method && capture === cap) {
                                if (de) pkg.removeEventListener(de, type, handler, capture);
                                domObservers.splice(i, 4);
                                retval = true;
                            }
                        }
                        return retval;
                    }
                }
            }
            return false;
        },
        
        /** Detaches all dom observers from this DomObservable.
            @returns {undefined} */
        detachAllDomObservers: function() {
            const domObserversByType = this.__dobsbt;
            if (domObserversByType) {
                for (const [type, domObservers] of Object.entries(domObserversByType)) {
                    for (let i = domObservers.length - 2; i >= 0; i -= 4) { // Offset by 2 so we can easily slice methodRef and capture.
                        const [methodRef, capture] = domObservers.slice(i);
                        pkg.removeEventListener(this.getDomElementForDomObservable(type), type, methodRef, capture);
                    }
                    domObservers.length = 0;
                }
            }
        }
    });
    
    /** Provides a mechanism to remember which DomObservables this DomObserver has attached itself 
        to. This is useful when the instance is being destroyed to automatically cleanup the 
        observer/observable relationships.
        
        When this mixin is used attachment and detachment should be done using the 'attachToDom' 
        and 'detachFromDom' methods of this mixin. If this is not done, it is possible for the 
        relationship between observer and observable to become broken.
        
        Private Attributes:
            __dobt: (Object) Holds arrays of DomObservables by event type.
        
        @class */
    pkg.DomObserver = new JSModule('DomObserver', {
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            getSourceViewFromEvent:getSourceViewFromEvent
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Attaches this DomObserver to the provided DomObservable for the provided type.
            @param {!Object} observable
            @param {string} methodName
            @param {string} type
            @param {boolean} [capture]
            @param {boolean} [passive]
            @returns {undefined} */
        attachToDom: function(observable, methodName, type, capture, passive) {
            if (observable && methodName && type) {
                capture = !!capture;
                
                // Lazy instantiate __dobt map.
                const observables = (this.__dobt ??= {})[type] ??= [];
                
                // Attach this DomObserver to the DomObservable
                if (observable.attachDomObserver(this, methodName, type, capture, passive)) {
                    observables.push(capture, methodName, observable);
                }
            }
        },
        
        /** Detaches this DomObserver from the DomObservable for the event type.
            @param {!Object} observable
            @param {string} methodName
            @param {string} type
            @param {boolean} [capture]
            @returns {boolean} - True if detachment succeeded, false otherwise. */
        detachFromDom: function(observable, methodName, type, capture) {
            if (observable && methodName && type) {
                capture = !!capture;
                
                // No need to detach if observable array doesn't exist.
                const observablesByType = this.__dobt;
                if (observablesByType) {
                    const observables = observablesByType[type];
                    if (observables) {
                        // Remove all instances of this observer/methodName/type/capture 
                        // from the observable
                        let retval = false;
                        for (let i = observables.length - 3; i >= 0; i -= 3) {
                            const [obsCapture, obsMethodName, obsObservable] = observables.slice(i);
                            if (observable === obsObservable && methodName === obsMethodName && capture === obsCapture) {
                                if (observable.detachDomObserver(this, methodName, type, capture)) {
                                    observables.splice(i, 3);
                                    retval = true;
                                }
                            }
                        }
                        
                        // Observable was not found
                        return retval;
                    }
                }
            }
            return false;
        },
        
        /** Detaches this DomObserver from all DomObservables it is attached to.
            @returns {undefined} */
        detachFromAllDomSources: function() {
            const observablesByType = this.__dobt;
            if (observablesByType) {
                for (const [type, observables] of Object.entries(observablesByType)) {
                    for (let i = observables.length - 3; i >= 0; i -= 3) {
                        const [capture, methodName, observable] = observables.slice(i);
                        observable.detachDomObserver(this, methodName, type, capture);
                    }
                    observables.length = 0;
                }
            }
        }
    });
})(myt);


(pkg => {
    let globalKeys;
    
    const 
        {KeyObservable, global:G} = pkg,
        globalFocus = G.focus,
        getCodeFromEvent = KeyObservable.getCodeFromEvent,
        
        /*  A set of codes of the keys currently pressed down. */
        keysDown = new Set(),
        
        isFirefox = BrowserDetect.browser === 'Firefox',
        
        CODE_TAB = 'Tab',
        CODE_SHIFT_LEFT = 'ShiftLeft',
        CODE_SHIFT_RIGHT = 'ShiftRight',
        CODE_ALT_LEFT = 'AltLeft',
        CODE_ALT_RIGHT = 'AltRight',
        CODE_CONTROL_LEFT = 'ControlLeft',
        CODE_CONTROL_RIGHT = 'ControlRight',
        CODE_META_LEFT = isFirefox ? 'OSLeft' : 'MetaLeft',
        CODE_META_RIGHT = isFirefox ? 'OSRight' : 'MetaRight',
        CODE_BACKSPACE = 'Backspace',
        
        
        isShiftCode = code => code === CODE_SHIFT_LEFT || code === CODE_SHIFT_RIGHT,
        isControlCode = code => code === CODE_CONTROL_LEFT || code === CODE_CONTROL_RIGHT,
        isAltCode = code => code === CODE_ALT_LEFT || code === CODE_ALT_RIGHT,
        
        /*  Tests if a key is currently pressed down or not. Returns true if the key is down, 
            false otherwise.
                param code:string the key code to test. */
        isKeyDown = code => keysDown.has(code),
        
        /*  Tests if the 'shift' key is down. */
        isShiftKeyDown = () => isKeyDown(CODE_SHIFT_LEFT) || isKeyDown(CODE_SHIFT_RIGHT),
        
        /*  Tests if the 'control' key is down. */
        isControlKeyDown = () => isKeyDown(CODE_CONTROL_LEFT) || isKeyDown(CODE_CONTROL_RIGHT),
        
        /*  Tests if the 'alt' key is down. */
        isAltKeyDown = () => isKeyDown(CODE_ALT_LEFT) || isKeyDown(CODE_ALT_RIGHT),
        
        /*  Tests if the 'meta'/'command' key is down. */
        isMetaKeyDown = () => isKeyDown(CODE_META_LEFT) || isKeyDown(CODE_META_RIGHT),
        
        ignoreFocusTrap = () => isAltKeyDown(),
        
        shouldPreventDefault = (code, targetElem) => {
            switch (code) {
                case CODE_BACKSPACE: // Backspace
                    // Catch backspace since it navigates the history. Allow it to go through for 
                    // text input elements though.
                    const nodeName = targetElem.nodeName;
                    return !(
                        nodeName === 'TEXTAREA' || 
                        (nodeName === 'INPUT' && (targetElem.type === 'text' || targetElem.type === 'number' || targetElem.type === 'password')) ||
                        (nodeName === 'DIV' && targetElem.contentEditable === 'true' && targetElem.firstChild)
                    );
                case CODE_TAB: // Tab
                    // Tab navigation is handled by the framework.
                    return true;
            }
            return false;
        },
        
        registerEventHandler = (target, action) => {
            for (const eventName of ['keydown','keypress','keyup']) {
                globalKeys[action](target, '__hndl_' + eventName, eventName);
            }
        },
        attach = target => {registerEventHandler(target, 'attachToDom');},
        detach = target => {registerEventHandler(target, 'detachFromDom');};
    
    /** Provides global keyboard events. Registered with myt.global as 'keys'.
        
        Also works with GlobalFocus to navigate the focus hierarchy when the focus traversal keys 
        are used.
        
        Events:
            keydown:string fired when a key is pressed down. The value is the code of the key 
                pressed down.
            keypress:string fired when a key is pressed. The value is the code of the key pressed.
            keyup:string fired when a key is released up. The value is the code of the key 
                released up.
        
        @class */
    new JS.Singleton('GlobalKeys', {
        include: [
            pkg.DomElementProxy,
            pkg.DomObservable,
            pkg.DomObserver,
            KeyObservable,
            pkg.Observable,
            pkg.Observer
        ],
        
        
        // Constructor /////////////////////////////////////////////////////////
        initialize: function() {
            G.register('keys', globalKeys = this);
            
            // Exposed Key Code Constants
            globalKeys.CODE_ENTER = 'Enter'; // Was KeyCode 13
            globalKeys.CODE_ESC = 'Escape'; // Was KeyCode 27
            globalKeys.CODE_SPACE = 'Space'; // Was Keycode 32
            globalKeys.CODE_ARROW_LEFT = 'ArrowLeft'; // Was Keycode 37
            globalKeys.CODE_ARROW_UP = 'ArrowUp'; // Was Keycode 38
            globalKeys.CODE_ARROW_RIGHT = 'ArrowRight'; // Was Keycode 39
            globalKeys.CODE_ARROW_DOWN = 'ArrowDown'; // Was Keycode 40
            globalKeys.CODE_DELETE = 'Delete'; // Was Keycode 46
            globalKeys.CODE_BACKSPACE = CODE_BACKSPACE; // Was Keycode 8
            for (const key of ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']) {
                globalKeys['CODE_' + key] = 'Key' + key;
            }
            for (const key of ['1','2','3','4','5','6','7','8','9','0']) {
                globalKeys['CODE_' + key] = 'Digit' + key;
            }
            
            globalKeys.ARROW_KEYS = [globalKeys.CODE_ARROW_LEFT, globalKeys.CODE_ARROW_UP, globalKeys.CODE_ARROW_RIGHT, globalKeys.CODE_ARROW_DOWN];
            globalKeys.LIST_KEYS = [globalKeys.CODE_ENTER, globalKeys.CODE_SPACE, globalKeys.CODE_ESC, ...globalKeys.ARROW_KEYS];
            
            
            globalKeys.setDomElement(document);
            globalKeys.attachTo(globalFocus, '__hndl_focused', 'focused');
            attach(globalKeys);
            
            // Clear keys down when the window loses focus. This is necessary when using keyboard 
            // shortcusts to switch apps since that will leave a key in the down state even though 
            // it may no longer be when the focus is returned to the page.
            global.onblur = () => {keysDown.clear();};
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        isShiftKeyDown: isShiftKeyDown,
        isControlKeyDown: isControlKeyDown,
        isAltKeyDown: isAltKeyDown,
        isMetaKeyDown: isMetaKeyDown,
        
        isShiftCode: isShiftCode,
        isControlCode: isControlCode,
        isAltCode: isAltCode,
        
        /** Tests if the platform specific "accelerator" key is down. */
        isAcceleratorKeyDown: () => BrowserDetect.os === 'Mac' ? isMetaKeyDown() : isControlKeyDown(),
        
        ignoreFocusTrap: ignoreFocusTrap,
        
        /** Switch what is being listened to as focus changes. By default the document is listened 
            to for key events.
            @private
            @param {!Object} event
            @returns {undefined} */
        __hndl_focused: event => {
            const focused = event.value;
            if (focused) {
                detach(globalKeys);
                attach(focused);
            } else {
                const prevFocused = globalFocus.prevFocusedView;
                if (prevFocused) detach(prevFocused);
                attach(globalKeys);
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __hndl_keydown: event => {
            const code = getCodeFromEvent(event),
                domEvent = event.value;
            if (shouldPreventDefault(code, domEvent.target)) domEvent.preventDefault();
            
            // Keyup events do not fire when command key is down so fire a keyup event immediately. 
            // Not an issue for other meta keys: shift, ctrl and option.
            if (isMetaKeyDown() && !isShiftCode(code) && !isControlCode(code) && !isAltCode(code)) {
                globalKeys.fireEvent('keydown', code);
                globalKeys.fireEvent('keyup', code);
            } else {
                keysDown.add(code);
                
                // Check for 'tab' key and do focus traversal.
                if (code === CODE_TAB) {
                    const ift = ignoreFocusTrap();
                    if (isShiftKeyDown()) {
                        globalFocus.prev(ift);
                    } else {
                        globalFocus.next(ift);
                    }
                }
                
                globalKeys.fireEvent('keydown', code);
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __hndl_keypress: event => {
            globalKeys.fireEvent('keypress', getCodeFromEvent(event));
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __hndl_keyup: event => {
            const code = getCodeFromEvent(event),
                domEvent = event.value;
            if (shouldPreventDefault(code, domEvent.target)) domEvent.preventDefault();
            keysDown.delete(code);
            globalKeys.fireEvent('keyup', code);
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        
        mathMax = Math.max,
        
        adjustListOfViews = (svs, isX, adjAmount, compounded, i=0) => {
            const len = svs.length;
            for (let compoundAdj = adjAmount; i < len; i++) {
                adjustPositionAttrOnChild(svs[i], isX, compoundAdj);
                if (compounded) compoundAdj += adjAmount;
            }
        },
        
        adjustListOfFlows = (flows, adjAmount, compounded, i=0) => {
            const len = flows.length;
            for (let compoundAdj = adjAmount; i < len;) {
                flows[i++].crossPos += compoundAdj;
                if (compounded) compoundAdj += adjAmount;
            }
        },
        
        getChildBasisSize = (child, isWidth) => isWidth ? child.getFlexBasisWidth() : child.getFlexBasisHeight(),
        
        updateSizeAttrOnChild = (child, isWidth, value, isAdjustment) => {
            child[isWidth ? 'setWidthViaFlex' : 'setHeightViaFlex']((isAdjustment ? getChildBasisSize(child, isWidth) : 0) + value);
        },
        
        updatePositionAttrOnChild = (child, isX, value) => {
            child[isX ? 'setXViaFlex' : 'setYViaFlex'](value, false);
        },
        
        adjustPositionAttrOnChild = (child, isX, value) => {
            child[isX ? 'setXViaFlex' : 'setYViaFlex'](value, true);
        },
        
        setFlexboxAttr = (flexbox, attrName, value) => {
            if (flexbox[attrName] !== value) {
                flexbox[attrName] = value;
                if (flexbox.inited) flexbox.fireEvent(attrName, value);
                flexbox.updateFlexboxLayout();
            }
        },
        
        /** Adds support for flex box to a myt.View.
            
            Attributes:
                direction:string
                    Supported values: "row", "rowReverse", "column", "columnReverse".
                wrap:string
                    Supported values: "nowrap", "wrap", "wrapReverse".
                justifyContent:string
                    Supported values: "start", "end", "center", "spaceBetween", "spaceAround", 
                    "spaceEvenly".
                alignItems:string
                    Supported values: "start", "end", "center", "stretch".
                alignContent:string
                    Supported values: "start", "end", "center", "spaceBetween", "spaceAround", 
                    "spaceEvenly", "stretch"
                rowGap:number
                columnGap:number
                
            Private Attributes:
                __flexboxPaused:boolean - Used to prevent flexbox layout updates
                    from occuring.
                __isUpdatingFlexboxLayout:boolean - Prevents infinite loops in the layout function.
            
            @class */
        FlexboxSupport = pkg.FlexboxSupport = new JSModule('FlexboxSupport', {
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                this.__IS_FLEXBOX_SUPPORT = true; // Optimize FlexboxChildSupport.isChildOfFlexbox
                
                this.rowGap = this.columnGap = 0;
                this.direction ??= 'row';
                this.wrap = 'nowrap';
                this.justifyContent = this.alignContent = 'start';
                this.alignItems = 'stretch';
                
                this.callSuper(parent, attrs);
                
                this.updateFlexboxLayout();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides */
            setWidth: function(v) {
                const existing = this.width;
                this.callSuper(v);
                if (existing !== this.width) this.updateFlexboxLayout();
            },
            
            /** @overrides */
            setHeight: function(v) {
                const existing = this.height;
                this.callSuper(v);
                if (existing !== this.height) this.updateFlexboxLayout();
            },
            
            setDirection: function(v) {setFlexboxAttr(this, 'direction', v);},
            setWrap: function(v) {setFlexboxAttr(this, 'wrap', v);},
            setJustifyContent: function(v) {setFlexboxAttr(this, 'justifyContent', v);},
            setAlignItems: function(v) {setFlexboxAttr(this, 'alignItems', v);},
            setAlignContent: function(v) {setFlexboxAttr(this, 'alignContent', v);},
            setRowGap: function(v) {setFlexboxAttr(this, 'rowGap', mathMax(0, v));},
            setColumnGap: function(v) {setFlexboxAttr(this, 'columnGap', mathMax(0, v));},
            
            getWidthForFlexboxLayout: function() {
                return this.width;
            },
            
            getHeightForFlexboxLayout: function() {
                return this.height;
            },
            
            setTotalBasisWidth: function(v) {this.set('totalBasisWidth', v, true);},
            setTotalBasisHeight: function(v) {this.set('totalBasisHeight', v, true);},
            
            ignoreSubviewForFlex: function(sv) {
                return sv && typeof sv.ignoreFlex === 'function' ? sv.ignoreFlex() : true;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            setFlexboxPaused: function(v, noLayoutUpdate) {
                if (this.__flexboxPaused !== v) {
                    this.__flexboxPaused = v;
                    if (!v && !noLayoutUpdate) this.updateFlexboxLayout();
                }
            },
            isFlexboxPaused: function() {return !!this.__flexboxPaused;},
            
            /** @overrides */
            subviewAdded: function(sv) {
                this.callSuper(sv);
                if (sv && !this.ignoreSubviewForFlex(sv)) this.updateFlexboxLayout();
            },
            
            /** @overrides */
            subviewRemoved: function(sv) {
                this.callSuper(sv);
                if (sv && !this.ignoreSubviewForFlex(sv) && !this.isBeingDestroyed) this.updateFlexboxLayout();
            },
            
            /** @overrides */
            doSubviewsReorderedInDom: function(sv) {
                this.callSuper(sv);
                if (!sv || !this.ignoreSubviewForFlex(sv)) this.updateFlexboxLayout();
            },
            
            isOKToUpdateLayout: function() {
                return this.inited && !this.__isUpdatingFlexboxLayout && !this.isFlexboxPaused();
            },
            
            isCompactWidth: () => false,
            isCompactHeight: () => false,
            isCompactOnMainAxis: function(isRowDirection) {
                return isRowDirection ? this.isCompactWidth() : this.isCompactHeight();
            },
            isCompactOnCrossAxis: function(isRowDirection) {
                return isRowDirection ? this.isCompactHeight() : this.isCompactWidth();
            },
            isWrapNotAllowed: function() {
                return this.wrap === 'nowrap';
            },
            
            setUpdateAgain: function(v) {
                this._updateAgain = v;
            },
            isUpdateAgain: function() {
                return this._updateAgain;
            },
            
            updateFlexboxLayout: function() {
                const flexbox = this;
                if (flexbox.isOKToUpdateLayout()) {
                    const children = flexbox.getSubviewsInLexicalOrder().filter(sv => flexbox.ignoreSubviewForFlex(sv) !== true && sv.visible === true),
                        len = children.length;
                    if (len > 0) {
                        flexbox.__isUpdatingFlexboxLayout = true;
                        
                        const direction = flexbox.direction,
                            isRowDirection = direction.startsWith('row'),
                            isNotRowDirection = !isRowDirection,
                            
                            flexboxWidth = flexbox.getWidthForFlexboxLayout(),
                            flexboxHeight = flexbox.getHeightForFlexboxLayout(),
                            
                            mainPositionAttr = isRowDirection ? 'x' : 'y',
                            mainGap = isRowDirection ? flexbox.columnGap : flexbox.rowGap,
                            mainFlexboxSize = isRowDirection ? flexboxWidth : flexboxHeight,
                            
                            crossPositionAttr = isRowDirection ? 'y' : 'x',
                            crossGap = isRowDirection ? flexbox.rowGap : flexbox.columnGap,
                            crossFlexboxSize = isRowDirection ? flexboxHeight : flexboxWidth,
                            
                            noWrap = flexbox.isWrapNotAllowed(),
                            
                            justifyContent = flexbox.justifyContent,
                            alignItems = flexbox.alignItems,
                            alignContent = noWrap ? 'stretch' : flexbox.alignContent;
                        
                        if (direction.endsWith('Reverse')) children.reverse();
                        
                        // Basic Flow: break up the basic flow into an array of items that fit 
                        // within the mainFlexboxSize.
                        let pos = 0,
                            maxPos = 0,
                            crossPos = 0,
                            itemCount = 0,
                            currentFlow = {items:[], shrinkCount:0, shrinkBasis:0, growCount:0, extraSize:0, crossPos:crossPos, crossSize:0};
                        const flows = [currentFlow];
                        
                        for (let i = 0; i < len;) {
                            const child = children[i++],
                                childBasisSize = getChildBasisSize(child, isRowDirection),
                                childShrink = child.getShrink(),
                                childGrow = child.getGrow();
                            
                            if (
                                // We can only make new flows if we're wrapping
                                !noWrap && 
                                
                                // The current flow must have at least 1 item before we will make 
                                // a new flow.
                                currentFlow.items.length > 0 &&
                                
                                // If the next child would overflow then make a new flow
                                pos + (itemCount === 0 ? 0 : mainGap) + childBasisSize > mainFlexboxSize
                            ) {
                                currentFlow.extraSize = mainFlexboxSize - pos;
                                crossPos += currentFlow.crossSize + crossGap;
                                maxPos = mathMax(maxPos, pos);
                                
                                // Make next flow
                                pos = 0;
                                itemCount = 0;
                                currentFlow = {items:[], shrinkCount:0, shrinkBasis:0, growCount:0, extraSize:0, crossPos:crossPos, crossSize:0};
                                flows.push(currentFlow);
                            }
                            
                            if (itemCount !== 0) pos += mainGap;
                            
                            if (childShrink > 0 && childBasisSize > 0) {
                                currentFlow.shrinkCount += childShrink;
                                currentFlow.shrinkBasis += childBasisSize * childShrink;
                            }
                            if (childGrow > 0) currentFlow.growCount += childGrow;
                            currentFlow.crossSize = mathMax(currentFlow.crossSize, getChildBasisSize(child, isNotRowDirection));
                            
                            updatePositionAttrOnChild(child, isRowDirection, pos);
                            updateSizeAttrOnChild(child, isRowDirection, childBasisSize);
                            pos += childBasisSize;
                            
                            currentFlow.items.push(child);
                            itemCount++;
                        }
                        currentFlow.extraSize = mainFlexboxSize - pos;
                        crossPos += currentFlow.crossSize;
                        maxPos = mathMax(maxPos, pos);
                        
                        // Limit extraSize on all flows if the main axis must be compact
                        if (flexbox.isCompactOnMainAxis(isRowDirection)) {
                            let minExtraSize = flows.reduce(
                                (accumulator, currentValue) => {
                                    if (accumulator == null) {
                                        return currentValue.extraSize;
                                    } else {
                                        return Math.min(accumulator, currentValue.extraSize);
                                    }
                                },
                                null
                            );
                            if (minExtraSize !== 0) {
                                for (const flow of flows) flow.extraSize -= minExtraSize;
                            }
                        }
                        
                        // Total Basis Sizes
                        flexbox[isRowDirection ? 'setTotalBasisWidth' : 'setTotalBasisHeight'](maxPos);
                        flexbox[isRowDirection ? 'setTotalBasisHeight' : 'setTotalBasisWidth'](crossPos);
                        
                        // Flip the order of the flows and shift the position of each so that it is
                        // offset from the bottom/right
                        const flowLen = flows.length;
                        if (flowLen > 1 && flexbox.wrap === 'wrapReverse') {
                            for (const flow of flows) flow.crossPos = crossPos - (flow.crossPos + flow.crossSize);
                            flows.reverse();
                        }
                        
                        // Update crossSize for each flow
                        if (!flexbox.isCompactOnCrossAxis(isRowDirection)) {
                            let extraCrossSize = crossFlexboxSize - crossPos;
                            switch (alignContent) {
                                default:
                                case 'start':
                                    // This is the default and requires no change.
                                    break;
                                case 'end':
                                    // Shift every flow over to align with the end
                                    adjustListOfFlows(flows, extraCrossSize, false);
                                    break;
                                case 'center':
                                    // Shift every flow over to align with the center
                                    adjustListOfFlows(flows, extraCrossSize / 2, false);
                                    break;
                                case 'spaceBetween':
                                    // Equal space between each flow and flush to the edges. No need
                                    // to adjust if there is only 1 flow.
                                    if (flowLen > 1) adjustListOfFlows(flows, extraCrossSize / (flowLen - 1), true, 1);
                                    break;
                                case 'spaceAround':
                                    // Equal Space between each flow and half space at the edges.
                                    if (extraCrossSize <= crossGap) {
                                        // Effectively just center it.
                                        adjustListOfFlows(flows, extraCrossSize / 2, false);
                                    } else {
                                        adjustListOfFlows(flows, crossGap / 2, false);
                                        extraCrossSize -= crossGap;
                                        adjustListOfFlows(flows, extraCrossSize / (2*flowLen), true);
                                        adjustListOfFlows(flows, extraCrossSize / (2*flowLen), true, 1);
                                    }
                                    break;
                                case 'spaceEvenly':
                                    // Equal Space between each flow and space at the edges.
                                    if (extraCrossSize <= 2*crossGap) {
                                        // Effectively just center it.
                                        adjustListOfFlows(flows, extraCrossSize / 2, false);
                                    } else {
                                        adjustListOfFlows(flows, crossGap, false);
                                        extraCrossSize -= 2*crossGap;
                                        adjustListOfFlows(flows, extraCrossSize / (flowLen + 1), true);
                                    }
                                    break;
                                case 'stretch':
                                    // Stretch each row to fill the space.
                                    const flowGrowAmount = extraCrossSize / flowLen;
                                    let flowGrowAmountTotal = 0;
                                    for (const flow of flows) {
                                        flow.crossSize += flowGrowAmount;
                                        flow.crossPos += flowGrowAmountTotal;
                                        flowGrowAmountTotal += flowGrowAmount;
                                    }
                                    break;
                            }
                        }
                        
                        for (const flow of flows) {
                            const items = flow.items;
                            let extraSize = flow.extraSize;
                            if (extraSize > 0) {
                                if (flow.growCount > 0) {
                                    // Distribute extraSize using grow.
                                    const amountPerGrow = extraSize / flow.growCount;
                                    let growAmountTotal = 0;
                                    for (const item of items) {
                                        // Shift items as we go so we don't have to loop over the 
                                        // items again.
                                        if (growAmountTotal > 0) adjustPositionAttrOnChild(item, isRowDirection, growAmountTotal);
                                        
                                        const growAmount = item.getGrow() * amountPerGrow;
                                        if (growAmount > 0) {
                                            updateSizeAttrOnChild(item, isRowDirection, growAmount, true);
                                            growAmountTotal += growAmount;
                                        }
                                    }
                                } else {
                                    // Distribute extraSize using justifyContent
                                    const itemLen = items.length;
                                    switch (justifyContent) {
                                        default:
                                        case 'start':
                                            // This is the default and requires no change.
                                            break;
                                        case 'end':
                                            // Shift every item over to align with the end
                                            adjustListOfViews(items, isRowDirection, extraSize, false);
                                            break;
                                        case 'center':
                                            // Shift every item over to align with the center
                                            adjustListOfViews(items, isRowDirection, extraSize / 2, false);
                                            break;
                                        case 'spaceBetween':
                                            // Equal space between each item and flush to the edges. 
                                            // No need to adjust if there is only 1 item.
                                            if (itemLen > 1) adjustListOfViews(items, isRowDirection, extraSize / (itemLen - 1), true, 1);
                                            break;
                                        case 'spaceAround':
                                            // Equal Space between each item and half space at 
                                            // the edges.
                                            if (extraSize <= mainGap) {
                                                // Effectively just center it.
                                                adjustListOfViews(items, isRowDirection, extraSize / 2, false);
                                            } else {
                                                adjustListOfViews(items, isRowDirection, mainGap / 2, false);
                                                extraSize -= mainGap;
                                                adjustListOfViews(items, isRowDirection, extraSize / (2*itemLen), true);
                                                adjustListOfViews(items, isRowDirection, extraSize / (2*itemLen), true, 1);
                                            }
                                            break;
                                        case 'spaceEvenly':
                                            // Equal Space between each item and space at the edges.
                                            if (extraSize <= 2*mainGap) {
                                                // Effectively just center it.
                                                adjustListOfViews(items, isRowDirection, extraSize / 2, false);
                                            } else {
                                                adjustListOfViews(items, isRowDirection, mainGap, false);
                                                extraSize -= 2*mainGap;
                                                adjustListOfViews(items, isRowDirection, extraSize / (itemLen + 1), true);
                                            }
                                            break;
                                    }
                                }
                            } else if (extraSize < 0 && flow.shrinkCount > 0) {
                                // Try to zero out extraSize using shrink.
                                const shrinkBasis = flow.shrinkBasis;
                                let shrinkAmountTotal = 0;
                                // See: https://www.madebymike.com.au/writing/understanding-flexbox/ for math
                                for (const item of items) {
                                    // Shift items as we go so we don't have to loop over the 
                                    // items again.
                                    if (shrinkAmountTotal < 0) adjustPositionAttrOnChild(item, isRowDirection, shrinkAmountTotal);
                                    
                                    const shrinkAmount = (item.getShrink() * getChildBasisSize(item, isRowDirection) / shrinkBasis) * mathMax(extraSize, -shrinkBasis);
                                    if (shrinkAmount < 0) {
                                        updateSizeAttrOnChild(item, isRowDirection, shrinkAmount, true);
                                        shrinkAmountTotal += shrinkAmount;
                                    }
                                }
                            }
                            
                            // Align Items along cross-axis. */
                            let baselineOccurred = false;
                            const {crossSize, crossPos:crossPositionOffset} = flow;
                            for (const item of items) {
                                switch (item.getAlignSelf() || alignItems) {
                                    case 'start':
                                        updatePositionAttrOnChild(item, isNotRowDirection, crossPositionOffset);
                                        updateSizeAttrOnChild(item, isNotRowDirection, getChildBasisSize(item, isNotRowDirection), false);
                                        break;
                                    case 'end':
                                        updatePositionAttrOnChild(item, isNotRowDirection, crossPositionOffset + crossSize - getChildBasisSize(item, isNotRowDirection));
                                        updateSizeAttrOnChild(item, isNotRowDirection, getChildBasisSize(item, isNotRowDirection), false);
                                        break;
                                    case 'center':
                                        updatePositionAttrOnChild(item, isNotRowDirection, crossPositionOffset + (crossSize - getChildBasisSize(item, isNotRowDirection)) / 2);
                                        updateSizeAttrOnChild(item, isNotRowDirection, getChildBasisSize(item, isNotRowDirection), false);
                                        break;
                                    case 'baseline':
                                        baselineOccurred = true;
                                        updatePositionAttrOnChild(item, isNotRowDirection, crossPositionOffset + (crossSize - getChildBasisSize(item, isNotRowDirection)) / 2 + item.getFlexBaselineOffset(isRowDirection));
                                        updateSizeAttrOnChild(item, isNotRowDirection, getChildBasisSize(item, isNotRowDirection), false);
                                        break;
                                    case 'stretch':
                                    default:
                                        updatePositionAttrOnChild(item, isNotRowDirection, crossPositionOffset);
                                        updateSizeAttrOnChild(item, isNotRowDirection, crossSize, false);
                                        break;
                                }
                            }
                            
                            if (baselineOccurred) flexbox.updateFlexboxLayoutBaselineAdjustment(items, isRowDirection, crossPositionOffset);
                        }
                        
                        flexbox.__isUpdatingFlexboxLayout = false;
                        
                        if (flexbox.isUpdateAgain() && !flexbox.__UPDATE_AGAIN_LOOP_PROTECTION) {
                            flexbox.setUpdateAgain(false);
                            flexbox.__UPDATE_AGAIN_LOOP_PROTECTION = true;
                            flexbox.updateFlexboxLayout();
                            flexbox.__UPDATE_AGAIN_LOOP_PROTECTION = false;
                        }
                    } else {
                        flexbox.setTotalBasisWidth(0);
                        flexbox.setTotalBasisHeight(0);
                    }
                }
            },
            
            updateFlexboxLayoutBaselineAdjustment: (items, isRowDirection, crossPositionOffset) => {}
        });
    
    /** Adds support for flex box child behavior to a myt.View.
        
        Attributes:
            grow:number - Supported values: Non-negative numbers.
            alignSelf:string - Supported values: "auto", start", "end", "center", "stretch". The 
                value "auto" can be used to unset this attr.
        
        Private Attributes:
            __ignoreFlex:boolean - When true, this View is ignored by the flexbox parent.
            __basisWidth:number - The preferred width of this View for calculating the size of this 
                View in a flexbox. This value gets set whenever the flexbox layout changes the 
                width of this view so it can be referenced in future layout updates.
            __basisHeight:number - The preferred height of this View for calculating the size of 
                this View in a flexbox. This value gets set whenever the flexbox layout changes the 
                height of this view so it can be referenced in future layout updates.
            __isFlexUpdate:boolean - Prevents clearing of basis size during a flexbox layout update.
        
        @class */
    pkg.FlexboxChildSupport = new JSModule('FlexboxChildSupport', {
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides */
        setVisible: function(v) {
            if (this.visible !== v) {
                this.callSuper(v);
                this.updateFlexboxLayoutFromChild();
            }
        },
        
        /** Provides a hook for subclasses to intervene when the x position is being updated by the 
            flex layout. */
        setXViaFlex(v, isAdj) {
            if (isAdj) v += this.x;
            if (this.x !== v) {
                this.__isFlexUpdate = true;
                this.setX(v);
                this.__isFlexUpdate = false;
            }
        },
        
        /** Provides a hook for subclasses to intervene when the y position is being updated by the 
            flex layout. */
        setYViaFlex(v, isAdj) {
            if (isAdj) v += this.y;
            if (this.y !== v) {
                this.__isFlexUpdate = true;
                this.setY(v);
                this.__isFlexUpdate = false;
            }
        },
        
        /** @overrides */
        setWidth: function(v) {
            const isChanging = this.width !== v;
            if (isChanging && !this.__isFlexUpdate) this.__basisWidth = null;
            this.callSuper(v);
            if (isChanging) this.updateFlexboxLayoutFromChild();
        },
        
        setWidthViaFlex(v) {
            if (this.width !== v) {
                this.__basisWidth ??= this.width;
                
                this.__isFlexUpdate = true;
                this.setWidth(v);
                this.__isFlexUpdate = false;
            }
        },
        
        getFlexBasisWidth: function() {
            return this.__basisWidth ?? this.width;
        },
        
        /** @overrides */
        setHeight: function(v) {
            const isChanging = this.height !== v;
            if (isChanging && !this.__isFlexUpdate) this.__basisHeight = null;
            this.callSuper(v);
            if (isChanging) this.updateFlexboxLayoutFromChild();
        },
        
        setHeightViaFlex(v) {
            if (this.height !== v) {
                this.__basisHeight ??= this.height;
                
                this.__isFlexUpdate = true;
                this.setHeight(v);
                this.__isFlexUpdate = false;
            }
        },
        
        getFlexBasisHeight: function() {
            return this.__basisHeight ?? this.height;
        },
        
        /** Subclasses should override this to provide a more appropriate baseline offset 
            as needed. */
        getFlexBaselineOffset: isRowDirection => 0,
        
        setIgnoreFlex: function(v) {
            if (this.__ignoreFlex !== v) {
                this.__ignoreFlex = v;
                if (this.inited) {
                    this.fireEvent('ignoreFlex', v);
                    if (this.isChildOfFlexbox()) this.parent.updateFlexboxLayout();
                }
            }
        },
        
        ignoreFlex: function() {
            return this.__ignoreFlex;
        },
        
        setGrow: function(v) {
            v = mathMax(0, v);
            if (this.grow !== v) {
                this.grow = v;
                if (this.inited) {
                    this.fireEvent('grow', v);
                    this.updateFlexboxLayoutFromChild();
                }
            }
        },
        
        getGrow: function() {return this.grow;},
        
        setShrink: function(v) {
            v = mathMax(0, v);
            if (this.shrink !== v) {
                this.shrink = v;
                if (this.inited) {
                    this.fireEvent('shrink', v);
                    this.updateFlexboxLayoutFromChild();
                }
            }
        },
        
        getShrink: function() {return this.shrink;},
        
        setAlignSelf: function(v) {
            if (this.alignSelf !== v) {
                this.alignSelf = v;
                if (this.inited) {
                    this.fireEvent('alignSelf', v);
                    this.updateFlexboxLayoutFromChild();
                }
            }
        },
        
        getAlignSelf: function() {
            const alignSelf = this.alignSelf;
            return (alignSelf === 'auto' || alignSelf === '') ? null : alignSelf;
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        isChildOfFlexbox: function() {
            return !!(this.parent && this.parent.__IS_FLEXBOX_SUPPORT);
        },
        
        isFlexUpdateInProgress: function() {return this.__isFlexUpdate;},
        
        updateFlexboxLayoutFromChild: function() {
            if (this.inited && !this.ignoreFlex() && this.isChildOfFlexbox()) {
                if (this.isFlexUpdateInProgress()) {
                    this.parent.setUpdateAgain(true);
                } else {
                    this.parent.updateFlexboxLayout();
                }
            }
        }
    });
})(myt);


(pkg => {
    const consoleLog = console.log,
        
        GETTER_NAMES = new Map(), // Caches getter names.
        SETTER_NAMES = new Map(), // Caches setter names.
        
        generateName = (attrName, prefix) => prefix + attrName.charAt(0).toUpperCase() + attrName.slice(1),
        generateSetterName = attrName => SETTER_NAMES.get(attrName) ?? (SETTER_NAMES.set(attrName, generateName(attrName, 'set')), SETTER_NAMES.get(attrName)),
        generateGetterName = attrName => GETTER_NAMES.get(attrName) ?? (GETTER_NAMES.set(attrName, generateName(attrName, 'get')), GETTER_NAMES.get(attrName)),
        
        doNormalSetters = (self, attrs) => {
            let canFireEvent;
            for (const attrName in attrs) {
                // Optimization: Inlined self.set for performance.
                const value = attrs[attrName],
                    setterName = generateSetterName(attrName);
                if (setterName in self) {
                    // Call a defined setter function.
                    self[setterName](value);
                } else if (self[attrName] !== value) {
                    // Generic Setter
                    self[attrName] = value;
                    if (canFireEvent ??= self.inited !== false && self.fireEvent) self.fireEvent(attrName, value); // !== false allows this to work with non-nodes.
                }
            }
        },
        
        createGetterFunction = (target, attrName) => {
            const getterName = generateGetterName(attrName);
            if (target[getterName]) consoleLog('Overwriting getter', getterName);
            target[getterName] = function() {return this[attrName];};
        },
        
        createSetterFunction = (target, attrName) => {
            const setterName = generateSetterName(attrName);
            if (target[setterName]) consoleLog('Overwriting setter', setterName);
            target[setterName] = function(v) {
                if (this[attrName] !== v) {
                    this[attrName] = v;
                    if (this.inited) this.fireEvent(attrName, v);
                }
            };
        };
    
    /** Provides support for getter and setter functions on an object.
        
        Attributes:
            earlyAttrs:array An array of attribute names that will be set first.
            lateAttrs:array An array of attribute names that will be set last.
        
        @class */
    pkg.AccessorSupport = new JS.Module('AccessorSupport', {
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            /** Generate a setter name for an attribute.
                @returns {string} */
            generateSetterName: generateSetterName,
            
            /** Generate a getter name for an attribute.
                @returns {string} */
            generateGetterName: generateGetterName,
            
            /** Generates a method name by capitalizing the attrName and prepending the prefix.
                @returns {string} */
            generateName: generateName,
            
            /** Creates a standard setter function for the provided attrName on the target. This 
                assumes the target is an myt.Observable.
                @param {!Object} target
                @param {string} attrName
                @returns {undefined} */
            createSetterFunction: createSetterFunction,
            
            /** Creates a standard getter function for the provided attrName on the target.
                @param {!Object} target
                @param {string} attrName
                @returns {undefined} */
            createGetterFunction: createGetterFunction,
            
            createSetterMixin: (propNames, alsoGetters) => {
                const mixin = {};
                for (const propName of propNames) {
                    createSetterFunction(mixin, propName);
                    if (alsoGetters) createGetterFunction(mixin, propName);
                }
                return mixin;
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        appendToEarlyAttrs: function() {(this.earlyAttrs ??= []).push(...arguments);},
        prependToEarlyAttrs: function() {(this.earlyAttrs ??= []).unshift(...arguments);},
        appendToLateAttrs: function() {(this.lateAttrs ??= []).push(...arguments);},
        prependToLateAttrs: function() {(this.lateAttrs ??= []).unshift(...arguments);},
        
        /** Used to quickly extract and set attributes from the attrs object passed to 
            an initializer.
            @param {?Array} attrNames - An array of attribute names.
            @param {?Object} attrs - The attrs Object to extract values from.
            @returns {undefined}. */
        quickSet: function(attrNames, attrs) {
            if (attrNames) {
                for (const attrName of attrNames) {
                    this[attrName] = attrs[attrName];
                    delete attrs[attrName];
                }
            }
        },
        
        /** Calls a setter function for each attribute in the provided map.
            @param {?Object} attrs - A map of attributes to set.
            @returns {undefined}. */
        callSetters: function(attrs) {
            const self = this,
                earlyAttrs = self.earlyAttrs,
                lateAttrs = self.lateAttrs;
            if (earlyAttrs || lateAttrs) {
                // 01% case is when early or later attrs exist.
                
                // Make a shallow copy of attrs since we will be deleting entries from it and we
                // can't guarantee that it won't be reused.
                const attrsCopy = {...attrs};
                
                // Do early setters
                if (earlyAttrs) {
                    const len = earlyAttrs.length;
                    for (let i = 0; i < len;) {
                        const attrName = earlyAttrs[i++];
                        if (attrName in attrsCopy) {
                            self.set(attrName, attrsCopy[attrName]);
                            delete attrsCopy[attrName];
                        }
                    }
                }
                
                // Extract late setters for later execution
                let extractedLateAttrs;
                if (lateAttrs) {
                    extractedLateAttrs = [];
                    const len = lateAttrs.length;
                    for (let i = 0; i < len;) {
                        const attrName = lateAttrs[i++];
                        if (attrName in attrsCopy) {
                            extractedLateAttrs.push(attrName, attrsCopy[attrName]);
                            delete attrsCopy[attrName];
                        }
                    }
                }
                
                doNormalSetters(self, attrsCopy);
                
                // Do late setters
                if (extractedLateAttrs) {
                    const len = extractedLateAttrs.length;
                    for (let i = 0; i < len;) self.set(extractedLateAttrs[i++], extractedLateAttrs[i++]);
                }
            } else {
                // 99% case is just do normal setters.
                doNormalSetters(self, attrs);
            }
        },
        
        /** A generic getter function that can be called to get a value from this object. Will 
            defer to a defined getter if it exists.
            @param {string} attrName - The name of the attribute to get.
            @returns {*} - The attribute value. */
        get: function(attrName) {
            const getterName = generateGetterName(attrName);
            return (typeof this[getterName] === 'function') ? this[getterName]() : this[attrName];
        },
        
        /** A generic setter function that can be called to set a value on this object. Will defer 
            to a defined setter if it exists. The implementation assumes this object is an 
            Observable so it will have a 'fireEvent' method.
            @param {string} attrName - The name of the attribute to set.
            @param {*} v -The value to set.
            @param {boolean} [skipSetter] - If true no attempt will be made to invoke a setter 
                function. Useful when you want to invoke standard setter behavior. Defaults to 
                undefined which is equivalent to false.
            @returns {undefined} */
        set: function(attrName, v, skipSetter) {
            const self = this;
            
            if (!skipSetter) {
                // Try to call a defined setter function.
                const setterName = generateSetterName(attrName);
                if (typeof self[setterName] === 'function') return self[setterName](v);
            }
            
            // Generic Setter
            if (self[attrName] !== v) {
                self[attrName] = v;
                if (self.inited !== false) self?.fireEvent(attrName, v); // !== false allows this to work with non-nodes.
            }
        }
    });
})(myt);


/** Provides a destroy method that can be used as part of an Object creation and destruction 
    lifecycle. When an object is "destroyed" it will have a "destroyed" attribute with a value 
    of true.
    
    Attributes:
        destroyed:boolean Set to true when the object is in the "destroyed" state, 
            undefinded otherwise.
    
    @class */
myt.Destructible = new JS.Module('Destructible', {
    // Methods /////////////////////////////////////////////////////////////////
    /** Destroys this Object. Subclasses must call super.
        @returns {undefined} */
    destroy: function() {
        const self = this;
        if (self.destroyed) {
            console.warn('Already destroyed');
        } else {
            // OPTIMIZATION: Improve garbage collection for JS.Class
            const meta = self.__meta__;
            if (meta) {
                const metaKeys = Object.keys(meta);
                for (let i = metaKeys.length; i > 0;) meta[metaKeys[--i]] = null;
            }
            
            const keys = Object.keys(self);
            for (let i = keys.length; i > 0;) self[keys[--i]] = null;
            
            self.destroyed = true;
        }
    }
});


(pkg => {
    const {Class:JSClass, Module:JSModule} = JS,
        
        consoleWarn = console.warn,
        
        /*  Get the object pool.
            @private
            @param {boolean} lazy - If true a pool will be lazily instantiated.
            @returns {!Object} */
        getObjPool = (abstractPool, lazy) => lazy ? abstractPool.__op ??= [] : abstractPool.__op,
        
        /*  Get the active objects array.
            @private
            @param {boolean} lazy - If true a list will be lazily instantiated.
            @returns {!Array} */
        getActiveObjArray = (trackActivesPool, lazy) => lazy ? trackActivesPool.__actives ??= [] : trackActivesPool.__actives,
        
        makeInstance = (parent, instanceClass, attrs) => parent ? new instanceClass(parent, attrs) : new instanceClass(),
        
        destroyObjectPool = objPool => {
            if (objPool) {
                let i = objPool.length;
                while (i) {
                    const obj = objPool[--i];
                    if (typeof obj.destroy === 'function') obj.destroy();
                }
                objPool.length = 0;
            }
        },
        
        /** Implements an object pool. Subclasses must at a minimum implement the 
            createInstance method.
            
            Private Attributes:
                __op:array The array of objects stored in the pool.
            
            @class */
        AbstractPool = new JSClass('AbstractPool', {
            include: [pkg.Destructible],
            
            
            // Constructor /////////////////////////////////////////////////////
            /** Initialize does nothing.
                @returns {undefined} */
            initialize: () => {},
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.Destructible */
            destroy: function() {
                const objPool = getObjPool(this);
                if (objPool) objPool.length = 0;
                
                this.callSuper();
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Get an instance from the pool.
                The arguments passed in will be passed to the createInstance method. Note: these 
                have no effect if an object already exists in the pool.
                @returns {!Object} */
            getInstance: function() {
                const objPool = getObjPool(this, true);
                return objPool.length ? objPool.pop() : this.createInstance.apply(this, arguments);
            },
            
            /** Creates a new object that can be stored in the pool. The default implementation 
                does nothing.
                @returns {?Object} */
            createInstance: () => null,
            
            /** Puts the object back in the pool. The object will be "cleaned" before it is stored.
                @param {!Object} obj - The object to put in the pool.
                @returns {undefined} */
            putInstance: function(obj) {
                getObjPool(this, true).push(this.cleanInstance(obj));
            },
            
            /** Cleans the object in preparation for putting it back in the pool. The default 
                implementation calls the clean method on the object if it is a function. Otherwise 
                it does nothing.
                @param {!Object} obj - The object to be cleaned.
                @returns {!Object} - The cleaned object. */
            cleanInstance: obj => {
                if (typeof obj.clean === 'function') obj.clean();
                return obj;
            },
            
            /** Calls the destroy method on all object stored in the pool if they have a 
                destroy function.
                @returns {undefined} */
            destroyPooledInstances: function() {
                destroyObjectPool(getObjPool(this));
            }
        }),
        
        /** An implementation of an myt.AbstractPool.
            
            Attributes:
                instanceClass:JS.Class (initializer only) the class to use for new instances. 
                    Defaults to Object.
                instanceParent:myt.Node (initializer only) The node to create new instances on.
            
            @class */
        SimplePool = pkg.SimplePool = new JSClass('SimplePool', AbstractPool, {
            // Constructor /////////////////////////////////////////////////////
            /** Create a new myt.SimplePool
                @param {!Function} instanceClass - The JS.Class to create instances from.
                @param {?Object} [instanceParent] - The place to create instances on. When 
                    instanceClass is an myt.Node this will be the node parent.
                @returns {undefined} */
            initialize: function(instanceClass, instanceParent) {
                this.callSuper();
                
                this.instanceClass = instanceClass ?? Object;
                this.instanceParent = instanceParent;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.AbstractPool
                Creates an instance of this.instanceClass and passes in this.instanceParent as the 
                first argument if it exists.
                arguments[0]:object (optional) the attrs to be passed to a 
                created myt.Node.
                @returns {?Object} */
            createInstance: function() {
                return makeInstance(this.instanceParent, this.instanceClass, arguments[0]);
            }
        }),
        
        /** Tracks which objects are "active". An "active" object is one that has been obtained by 
            the getInstance method.
            
            Private Attributes:
                __actives:array an array of active instances.
            
            @class */
        TrackActives = new JSModule('TrackActives', {
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.Destructible */
            destroy: function() {
                const actives = getActiveObjArray(this);
                if (actives) actives.length = 0;
                
                this.callSuper();
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.AbstractPool */
            getInstance: function() {
                const instance = this.callSuper();
                getActiveObjArray(this, true).push(instance);
                return instance;
            },
            
            /** @overrides myt.AbstractPool */
            putInstance: function(obj) {
                const actives = getActiveObjArray(this);
                let warningType;
                if (actives) {
                    const idx = actives.indexOf(obj);
                    if (idx > -1) {
                        actives.splice(idx, 1);
                        this.callSuper(obj);
                        return;
                    }
                    warningType = 'inactive';
                } else {
                    warningType = 'missing';
                }
                consoleWarn('Tried to put a ' + warningType + ' instance', obj, this);
            },
            
            /** Gets an array of the active instances.
                @param {?Function} [filterFunc] - If provided filters the results.
                @returns {!Array} */
            getActives: function(filterFunc) {
                const actives = getActiveObjArray(this);
                if (actives) {
                    if (filterFunc) {
                        const retval = [],
                            len = actives.length;
                        for (let i = 0; len > i;) {
                            const active = actives[i++];
                            if (filterFunc.call(this, active)) retval.push(active);
                        }
                        return retval;
                    }
                    return actives.slice();
                }
                return [];
            },
            
            /** Puts all the active instances back in the pool.
                @returns {undefined} */
            putActives: function() {
                const actives = getActiveObjArray(this);
                if (actives) {
                    let i = actives.length;
                    while (i) this.putInstance(actives[--i]);
                }
            }
        }),
        
        /** An myt.SimplePool that tracks which objects are "active".
            
            @class */
        TrackActivesPool = pkg.TrackActivesPool = new JSClass('TrackActivesPool', SimplePool, {
            include: [TrackActives]
        });
    
    /** A pool that tracks which objects are "active" and stores objects of different classes in 
        different internal TrackActivesPools.
        
        Private Attributes:
            __pbk:object Stores TrackActivesPools by key.
        
        @class */
    pkg.TrackActivesMultiPool = new JSClass('TrackActivesMultiPool', AbstractPool, {
        // Constructor /////////////////////////////////////////////////////////
        initialize: function(instanceClassesByKey, instanceParent) {
            this.callSuper();
            
            this.instanceClassesByKey = instanceClassesByKey;
            
            const poolsByClassName = this._poolsByClassName = {},
                poolsByKey = this.__pbk = {};
            for (const key in instanceClassesByKey) {
                const klass = instanceClassesByKey[key];
                poolsByKey[key] = poolsByClassName[klass.__displayName] = new TrackActivesPool(klass, instanceParent);
            }
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        destroy: function() {
            const poolsByKey = this.__pbk;
            for (const key in poolsByKey) poolsByKey[key].destroy();
            
            this.callSuper();
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        getInstance: function() {
            const key = arguments[0],
                pool = this.__pbk[key];
            if (pool) {
                return pool.getInstance(arguments);
            } else {
                consoleWarn('No pool for key', key);
            }
        },
        
        putInstance: function(obj) {
            const pool = this._poolsByClassName[obj.klass.__displayName];
            if (pool) {
                pool.putInstance(obj);
            } else {
                consoleWarn('No pool for obj', obj);
            }
        },
        
        destroyPooledInstances: function() {
            const poolsByKey = this.__pbk;
            for (const key in poolsByKey) poolsByKey[key].destroyPooledInstances();
        },
        
        getActives: function(filterFunc) {
            let actives = [];
            const poolsByKey = this.__pbk;
            for (const key in poolsByKey) actives.push(...poolsByKey[key].getActives(filterFunc));
            return actives;
        },
        
        putActives: function() {
            const poolsByKey = this.__pbk;
            for (const key in poolsByKey) poolsByKey[key].putActives();
        }
    });
    
    /** Objects that can be used in an myt.AbstractPool should use this mixin and implement the 
        "clean" method.
        
        @class */
    pkg.Reusable = new JSModule('Reusable', {
        // Methods /////////////////////////////////////////////////////////////
        /** Puts this object back into a default state suitable for storage in an myt.AbstractPool
            @returns {undefined} */
        clean: () => {}
    });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        consoleWarn = console.warn,
        
        /*  Common mixins for Eventable and Node. */
        includedMixins = [pkg.AccessorSupport, pkg.Destructible, pkg.Observable, pkg.Observer],
        
        /*  Common initializer for Eventable and Node. */
        initializer = (self, mixins) => {
            // Apply the instance mixins if provided.
            if (mixins) {
                const len = mixins.length;
                for (let i = 0, mixin; len > i;) {
                    if (mixin = mixins[i++]) {
                        self.extend(mixin);
                    } else {
                        consoleWarn('Missing mixin in', self.klass.__displayName);
                    }
                }
            }
            
            // Mark the instance not initialized yet since the init or initNode function still
            // needs to be called before initialization is complete.
            self.inited = false;
        },
        
        /*  The value that indicates default placement should be used. */
        DEFAULT_PLACEMENT = '*',
        
        /*  Get the closest ancestor of the provided Node or the Node itself for which the matcher 
            function returns true. Returns a Node or undefined if no match is found.
                param node:myt.Node the Node to start searching from.
                param matcher:function the function to test for matching Nodes with. */
        getMatchingAncestorOrSelf = (node, matcherFunc) => {
            if (matcherFunc) {
                while (node) {
                    if (matcherFunc(node)) return node;
                    node = node.parent;
                }
            }
        },
        
        /*  Get the youngest ancestor of the provided Node for which the matcher function returns 
            true. Returns a Node or undefined if no match is found.
                param node:myt.Node the Node to start searching from. This Node is not tested, but 
                    its parent is.
                param matcher:function the function to test for matching Nodes with. */
        getMatchingAncestor = (node, matcherFunc) => getMatchingAncestorOrSelf(node ? node.parent : null, matcherFunc),
        
        /*  Adds a named reference to a subnode.
                param node:Node the node to add the name reference to.
                param nodeToAdd:Node the node to add the name reference for. */
        addNameRef = (node, nodeToAdd) => {
            const name = nodeToAdd.name;
            if (node[name] === undefined) {
                node[name] = nodeToAdd;
            } else {
                consoleWarn('Name in use', name);
            }
        },
        
        /*  Removes a named reference to a subnode.
                param node:Node the node to remove the name reference from.
                param nodeToRemove:Node the node to remove the name reference for. */
        removeNameRef = (node, nodeToRemove) => {
            const name = nodeToRemove.name;
            if (node[name] === nodeToRemove) {
                delete node[name];
            } else {
                consoleWarn('Name not in use', name);
            }
        },
        
        /*  Gets the animation pool if it exists, or lazy instantiates it 
            first if necessary. Returns a myt.TrackActivesPool */
        getAnimPool = node => node.__animPool ??= new pkg.TrackActivesPool(pkg.Animator, node),
        
        /*  Lazy instantiate the references store on a scope object.
            @returns {!Object} */
        getRefs = scope => scope.__REFS ??= {};
        
    /** An object that provides accessors, events and simple lifecycle management. Useful as a 
        light weight alternative to myt.Node when parent child relationships are not needed.
        
        Attributes:
            inited:boolean Set to true after this Eventable has completed initialization.
        
        @class */
    pkg.Eventable = new JSClass('Eventable', {
        include: includedMixins,
        
        
        // Constructor /////////////////////////////////////////////////////////
        /** The standard JSClass initializer function.
            @param {?Object} [attrs] - A map of attribute names and values.
            @param {?Array} [mixins] - A list of mixins to be added onto the new instance.
            @returns {undefined} */
        initialize: function(attrs, mixins) {
            initializer(this, mixins);
            this.init(attrs ?? {});
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** Called during initialization. Calls setter methods and lastly, sets inited to true. 
            Subclasses must callSuper.
            @param {?Object} attrs - A map of attribute names and values.
            @returns {undefined} */
        init: function(attrs) {
            this.callSetters(attrs);
            this.inited = true;
        },
        
        /** @overrides myt.Destructible. */
        destroy: function() {
            this.releaseAllConstraints();
            this.detachFromAllObservables();
            this.detachAllObservers();
            
            this.callSuper();
        }
    });
    
    /** A single node within a tree data structure. A node has zero or one parent node and zero or 
        more child nodes. If a node has no parent it is a 'root' node. If a node has no child nodes 
        it is a 'leaf' node. Parent nodes and parent of parents, etc. are referred to as ancestors. 
        Child nodes and children of children, etc. are referred to as descendants.
        
        Lifecycle management is also provided via the 'initNode', 'destroy' and 
        'destroyAfterOrphaning' methods.
        
        Events:
            parent:myt.Node Fired when the parent is set.
        
        Attributes:
            inited:boolean Set to true after this Node has completed initializing.
            parent:myt.Node The parent of this Node.
            name:string The name of this node. Used to reference this Node from its parent Node.
            isBeingDestroyed:boolean Indicates that this node is in the process of being destroyed. 
                Set to true at the beginning of the destroy lifecycle phase. Undefined before that.
            placement:string The name of the subnode of this Node to add nodes to when setParent is 
                called on the subnode. Placement can be nested using '.' For example 'foo.bar'. The 
                special value of '*' means use the default placement. For example 'foo.*' means 
                place in the foo subnode and then in the default placement for foo.
            defaultPlacement:string The name of the subnode to add nodes to when no placement is 
                specified. Defaults to undefined which means add subnodes directly to this node.
            ignorePlacement:boolean If set to true placement will not be processed for this Node 
                when it is added to a parent Node.
        
        Private Attributes:
            __animPool:array An myt.TrackActivesPool used by the 'animate' method.
            subnodes:array The array of child nodes for this node. Should be accessed through the 
                getSubnodes method.
        
        @class */
    pkg.Node = new JSClass('Node', {
        include: includedMixins,
        
        
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            getMatchingAncestorOrSelf: getMatchingAncestorOrSelf,
            getMatchingAncestor: getMatchingAncestor,
            DEFAULT_PLACEMENT: DEFAULT_PLACEMENT
        },
        
        
        // Constructor /////////////////////////////////////////////////////////
        /** The standard JSClass initializer function. Subclasses should not override this function.
            @param {?Object} [parent] - The myt.Node (or dom element for RootViews) that will be 
                set as the parent of this myt.Node.
            @param {?Object} [attrs] - A map of attribute names and values.
            @param {?Array} [mixins] - A list of mixins to be added onto the new instance.
            @returns {undefined} */
        initialize: function(parent, attrs, mixins) {
            initializer(this, mixins);
            this.initNode(parent, attrs ?? {});
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** Called during initialization. Sets initial state for life cycle attrs, calls setter 
            methods, sets parent and lastly, sets inited to true. Subclasses must callSuper.
            @param {?Object} [parent] - The myt.Node (or dom element for RootViews) the parent of 
                this Node.
            @param {?Object} attrs - A map of attribute names and values.
            @returns {undefined} */
        initNode: function(parent, attrs) {
            this.callSetters(attrs);
            this.setParent(parent);
            this.inited = true;
        },
        
        /** @overrides myt.Destructible. */
        destroy: function() {
            const self = this,
                subs = self.subnodes;
            
            // Allows descendants to know destruction is in process
            self.isBeingDestroyed = true;
            
            // Destroy subnodes depth first
            if (subs) {
                for (let i = subs.length; i > 0;) subs[--i].destroy();
            }
            
            if (self.__animPool) {
                self.stopActiveAnimators();
                self.__animPool.destroy();
            }
            
            if (self.parent) self.setParent();
            
            self.releaseAllConstraints();
            self.detachFromAllObservables();
            self.detachAllObservers();
            
            self.destroyAfterOrphaning();
            
            self.callSuper();
        },
        
        /** Provides a hook for subclasses to do destruction of their internals. This method is 
            called after the parent has been unset. Subclasses must call super.
            @returns {undefined} */
        destroyAfterOrphaning: () => {/* Subclasses to implement as needed. */},
        
        
        // Structural Accessors ////////////////////////////////////////////////
        setPlacement: function(v) {this.placement = v;},
        setDefaultPlacement: function(v) {this.defaultPlacement = v;},
        setIgnorePlacement: function(v) {this.ignorePlacement = v;},
        
        /** Sets the provided Node as the new parent of this Node. This is the most direct method 
            to do reparenting.
            @param {?Object} newParent
            @returns {undefined} */
        setParent: function(newParent) {
            const self = this;
            
            // Use placement if indicated
            if (newParent && !self.ignorePlacement) {
                const placement = self.placement ?? newParent.defaultPlacement;
                if (placement) newParent = newParent.determinePlacement(placement, self);
            }
            
            if (self.parent !== newParent) {
                // Abort if the new parent is in the destroyed life-cycle state.
                if (newParent?.destroyed) return;
                
                // Remove ourselves from our existing parent if we have one.
                const curParent = self.parent;
                if (curParent) {
                    const idx = curParent.getSubnodes().indexOf(self);
                    if (idx > -1) {
                        if (self.name) removeNameRef(curParent, self);
                        curParent.subnodes.splice(idx, 1);
                        curParent.subnodeRemoved(self);
                    }
                }
                
                self.parent = newParent;
                
                // Add ourselves to our new parent
                if (newParent) {
                    newParent.getSubnodes().push(self);
                    if (self.name) addNameRef(newParent, self);
                    newParent.subnodeAdded(self);
                }
                
                // Fire an event
                if (self.inited) self.fireEvent('parent', newParent);
            }
        },
        
        /** The 'name' of a Node allows it to be referenced by name from its parent node. For 
            example a Node named 'foo' that is a child of a Node stored in the variable 'bar' 
            would be referenced like this: bar.foo or bar['foo'].
            @param {string} name
            @returns {undefined} */
        setName: function(name) {
            if (this.name !== name) {
                // Remove "name" reference from parent.
                const p = this.parent;
                if (p && this.name) removeNameRef(p, this);
                
                this.name = name;
                
                // Add "name" reference to parent.
                if (p && name) addNameRef(p, this);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called from setParent to determine where to insert a subnode in the node hierarchy. 
            Subclasses will not typically override this method, but if they do, they probably won't 
            need to call super.
            @param {string} placement - The placement path to use.
            @param {!Object} subnode - The sub myt.Node being placed.
            @returns {!Object} - The Node to place a subnode into. */
        determinePlacement: function(placement, subnode) {
            // Parse "active" placement and remaining placement.
            let idx = placement.indexOf('.'),
                remainder;
            if (idx >= 0) {
                remainder = placement.slice(idx + 1);
                placement = placement.slice(0, idx);
            }
            
            // Evaluate placement of '*' as defaultPlacement.
            if (placement === DEFAULT_PLACEMENT) {
                placement = this.defaultPlacement;
                
                // Default placement may be compound and thus require splitting
                if (placement) {
                    idx = placement.indexOf('.');
                    if (idx >= 0) {
                        remainder = placement.slice(idx + 1) + (remainder ? '.' + remainder : '');
                        placement = placement.slice(0, idx);
                    }
                }
                
                // It's possible that a placement of '*' comes out here if a Node has its 
                // defaultPlacement set to '*'. This should result in a null loc when the code 
                // below runs which will end up returning 'this'.
            }
            
            const loc = this[placement];
            return loc ? (remainder ? loc.determinePlacement(remainder, subnode) : loc) : this;
        },
        
        
        // Tree Methods //
        /** Gets the root Node for this Node. The root Node is the oldest ancestor or self that 
            has no parent.
            @returns {!Object} - The root myt.Node. */
        getRoot: function() {
            return this.parent?.getRoot() ?? this;
        },
        
        /** Checks if this Node is a root Node.
            @returns {boolean} */
        isRoot: function() {
            return this.parent == null;
        },
        
        /** Tests if this Node is a descendant of the provided Node or is the node itself.
            @param {!Object} node - The myt.Node to check for descent from.
            @returns {boolean} */
        isDescendantOf: function(node) {
            const self = this;
            if (node) {
                if (node === self) return true;
                if (self.parent) {
                    // Optimization: use the dom element contains function if both nodes are 
                    // DomElementProxy instances.
                    if (self.getIDE && node.getIDE) return node.getIDE().contains(self.getIDE());
                    return self.parent.isDescendantOf(node);
                }
            }
            return false;
        },
        
        /** Tests if this Node is an ancestor of the provided Node or is the node itself.
            @param {!Object} node - The myt.Node to check for.
            @returns {boolean} */
        isAncestorOf: function(node) {
            return node ? node.isDescendantOf(this) : false;
        },
        
        /** Gets the youngest common ancestor of this Node and the provided Node.
            @param {!Object} node - The myt.Node to look for a common ancestor with.
            @returns {?Object} The youngest common Node or undefined if none exists. */
        getLeastCommonAncestor: function(node) {
            while (node) {
                if (this.isDescendantOf(node)) return node;
                node = node.parent;
            }
        },
        
        /** Find the youngest ancestor Node that is an instance of the class.
            @param {?Function} klass - The Class to search for.
            @returns {?Object} - The myt.Node or undefined if no klass is provided or match found. */
        searchAncestorsForClass: function(klass) {
            if (klass) return this.searchAncestors(node => node instanceof klass);
        },
        
        /** Find the youngest ancestor Node that includes the JS.Module.
            @param {?Object} jsmodule - The JS.Module to search for.
            @returns {?Object} - The myt.Node or undefined if no klass is provided or match found. */
        searchAncestorsForModule: function(jsmodule) {
            if (jsmodule) return this.searchAncestors(node => node.isA(jsmodule));
        },
        
        /** Get the youngest ancestor of this Node for which the matcher function returns true. 
            This is a simple wrapper around myt.Node.getMatchingAncestor(this, matcherFunc).
            @param {!Function} matcherFunc - The function to test for matching Nodes with.
            @returns {?Object} - The myt.Node or undefined if no match is found. */
        searchAncestors: function(matcherFunc) {
            return getMatchingAncestor(this, matcherFunc);
        },
        
        /** Get the youngest ancestor of this Node or the Node itself for which the matcher function 
            returns true. This is a simple wrapper around myt.Node.getMatchingAncestorOrSelf(this, matcherFunc).
            @param {!Function} matcherFunc - The function to test for matching Nodes with.
            @returns {?Object} - The myt.Node or undefined if no match is found. */
        searchAncestorsOrSelf: function(matcherFunc) {
            return getMatchingAncestorOrSelf(this, matcherFunc);
        },
        
        /** Gets an array of ancestor nodes including the node itself. The oldest ancestor will be 
            at the end of the list and the node will be at the front of the list.
            @returns {!Array} - The array of ancestor nodes. */
        getAncestors: function() {
            const ancestors = [];
            let node = this;
            while (node) {
                ancestors.push(node);
                node = node.parent;
            }
            return ancestors;
        },
        
        
        // Subnode Methods //
        /** Gets the subnodes for this Node and does lazy instantiation of the subnodes array.
            @returns {!Array} - An array of subnodes. */
        getSubnodes: function() {
            return this.subnodes ??= [];
        },
        
        /** Called when a subnode is added to this node. Provides a hook for subclasses. No need for
            subclasses to call super. Do not call this method to add a subnode. Instead call setParent.
            @param {!Object} node - The sub myt.Node that was added.
            @returns {undefined} */
        subnodeAdded: node => {},
        
        /** Called when a subnode is removed from this node. Provides a hook for subclasses. No need
            for subclasses to call super. Do not call this method to remove a subnode. Instead 
            call setParent.
            @param {!Object} node - The sub myt.Node that was removed.
            @returns {undefined} */
        subnodeRemoved: node => {},
        
        
        // Animation //
        /** Animates an attribute using the provided parameters.
            @param {!Object} attrs - Attributes that will be passed to the myt.Animator that will 
                be run.
            @returns {?Object} - The Animator being run or undefined if for some reason an animator 
                could not be run. */
        animate: function(attrs) {
            if (attrs) {
                const animPool = getAnimPool(this),
                    // Get an animator from the pool. Use of ignorePlacement ensures the animator 
                    // is directly attached to this node
                    anim = animPool.getInstance({ignorePlacement:true}),
                    callback = attrs.callback;
                delete attrs.callback;
                anim.callSetters(attrs);
                
                // Release the animation when it completes.
                anim.next(success => {animPool.putInstance(anim);});
                if (callback) anim.next(callback);
                
                anim.setRunning(true);
                return anim;
            }
        },
        
        /** Gets an array of the currently running animators that were created by calls to the 
            animate method.
            @param {?Function|string} [filterFunc] - The function that filters which animations get 
                stopped. The filter should return true for functions to be included. If the 
                provided values is a string it will be used as a matching attribute name.
            @returns {!Array} - An array of active animators. */
        getActiveAnimators: function(filterFunc) {
            if (typeof filterFunc === 'string') {
                const attrName = filterFunc;
                filterFunc = anim => anim.attribute === attrName;
            }
            return getAnimPool(this).getActives(filterFunc);
        },
        
        /** Stops all active animations.
            @param {?Function|string} [filterFunc] - The function that filters which animations get 
                stopped. The filter should return true for functions to be stopped. If the provided 
                values is a string it will be used as a matching attribute name.
            @param {boolean} [executeCallbacks] - If true animator 
                callbacks will be executed if they exist.
            @returns {undefined} */
        stopActiveAnimators: function(filterFunc, executeCallbacks=false) {
            const activeAnims = this.getActiveAnimators(filterFunc);
            let i = activeAnims.length;
            if (i > 0) {
                const animPool = getAnimPool(this);
                while (i) {
                    const anim = activeAnims[--i];
                    anim.reset(executeCallbacks);
                    if (!executeCallbacks) animPool.putInstance(anim);
                }
            }
        },
        
        
        // Timing and Delay //
        /** A convienence method to execute a method once on idle.
            @param {string} methodName - The name of the method to execute on this object.
            @returns {undefined} */
        doOnceOnIdle: function(methodName) {
            this.attachTo(pkg.global.idle, methodName, 'idle', true);
        },
        
        
        // Reference Store //
        /*  Use the reference store to hold values in this Node without cluttering up the
            Node's namespace. */
        
        /** Add a reference under a provided name.
            @param {string} name - The name to store the value under.
            @param {*} ref - The value to store.
            @returns {*} */
        addRef: function(name, ref) {
            return getRefs(this)[name] = ref;
        },
        
        /** Get a reference stored under a provided name.
            @param {string} name - The name to get the value for.
            @returns {*} */
        getRef: function(name) {
            return getRefs(this)[name];
        },
        
        /** Remove a reference stored under the provided name and return whatever was stored
            under that name.
            @param {string} name - The name to remove the value for.
            @returns {*} */
        removeRef: function(name) {
            const refs = getRefs(this),
                retval = refs[name];
            delete refs[name];
            return retval;
        }
    });
})(myt);


(pkg => {
    let 
        /*  The global lock counter. Any value greater than zero sets the global lock. */
        globalLockCount = 0,
        
        /*  The global layout locked status. */
        globalLock = false;
    
    const JSClass = JS.Class,
        
        /*  A list of layouts to be updated once the global lock is released. */
        deferredLayouts = [],
        
        /*  Called to set/unset the global lock. Updates all the currently deferred layouts. */
        setGlobalLock = v => {
            if (globalLock !== v) {
                globalLock = v;
                
                if (!v) {
                    let i = deferredLayouts.length;
                    while (i) {
                        const layout = deferredLayouts[--i];
                        layout.__deferredLayout = false;
                        layout.update();
                    }
                    deferredLayouts.length = 0;
                }
            }
        },
        
        /*  Adds a Layout to the list of layouts that will get updated when the global lock 
            is released.
                param layout:myt.Layout the layout to defer an update for. */
        deferLayoutUpdate = layout => {
            // Don't add a layout that is already deferred.
            if (!layout.__deferredLayout) {
                deferredLayouts.push(layout);
                layout.__deferredLayout = true;
            }
        },
        
        /* Implements moveSubviewBefore and moveSubviewAfter for Layout. */
        moveSubview = (layout, sv, target, after) => {
            const curIdx = layout.getSubviewIndex(sv),
                svs = layout.subviews;
            if (curIdx > -1) {
                let targetIdx = layout.getSubviewIndex(target);
                
                // Remove from current index
                svs.splice(curIdx, 1);
                
                if (targetIdx > -1) {
                    // Move before or after the target
                    if (curIdx < targetIdx) --targetIdx;
                    svs.splice(targetIdx + (after ? 1 : 0), 0, sv);
                } else if (after) {
                    // Make last since target was not found
                    svs.push(sv);
                } else {
                    // Make first since target was not found
                    svs.unshift(sv);
                }
            }
        },
        
        setAndUpdate = (layout, attrName, value) => {
            if (layout[attrName] !== value) {
                layout[attrName] = value;
                if (layout.inited) {
                    layout.fireEvent(attrName, value);
                    layout.update();
                }
            }
        },
        
        /** A layout controls the positioning of views within a parent view.
            
            Attributes:
                locked:boolean When true, the layout will not update.
                lockedCounter:number Counter created by myt.ThresholdCounter.
            
            Private Attributes:
                subviews:array An array of Views managed by this layout.
                __deferredLayout:boolean Marks a layout as deferred if the global layout lock is 
                    true during a call to 'canUpdate' on the layout.
            
            @class */
        Layout = pkg.Layout = new JSClass('Layout', pkg.Node, {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** Increments the global lock that prevents all layouts from updating.
                    @returns {undefined} */
                incrementGlobalLock: () => {
                    if (++globalLockCount === 1) setGlobalLock(true);
                },
                
                /** Decrements the global lock that prevents all layouts from updating.
                    @returns {undefined} */
                decrementGlobalLock: () => {
                    if (globalLockCount > 0 && --globalLockCount === 0) setGlobalLock(false);
                }
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                this.subviews = [];
                
                // Start the layout in the locked state.
                this.locked = true;
                this.lockedCounter = 1;
                
                // Remember how initial locking state should be set
                const initiallyLocked = attrs.locked === true;
                delete attrs.locked;
                
                this.callSuper(parent, attrs);
                
                // Unlock if initial locking state calls for it.
                if (!initiallyLocked) this.decrementLockedCounter();
                
                this.update();
            },
            
            /** @overrides */
            destroy: function() {
                this.subviews.length = 0;
                this.callSuper();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides */
            setParent: function(parent) {
                const curParent = this.parent;
                if (curParent !== parent) {
                    // Lock during parent change so that old parent is not updated by the calls to 
                    // removeSubview and addSubview.
                    const wasNotLocked = !this.locked;
                    if (wasNotLocked) this.locked = true;
                    
                    // Stop monitoring parent
                    let svs,
                        i,
                        len;
                    if (curParent) {
                        svs = this.subviews;
                        i = svs.length;
                        while (i) this.removeSubview(svs[--i]);
                        
                        this.detachFrom(curParent, '__hndlPSA', 'subviewAdded');
                        this.detachFrom(curParent, '__hndlPSR', 'subviewRemoved');
                    }
                    
                    this.callSuper(parent);
                    parent = this.parent;
                    
                    // Start monitoring new parent
                    if (parent) {
                        svs = parent.getSubviews();
                        for (i = 0, len = svs.length; len > i;) this.addSubview(svs[i++]);
                        
                        this.attachTo(parent, '__hndlPSA', 'subviewAdded');
                        this.attachTo(parent, '__hndlPSR', 'subviewRemoved');
                    }
                    
                    // Clear temporary lock and update if this happened after initialization.
                    if (wasNotLocked) {
                        this.locked = false;
                        if (this.inited && parent) this.update();
                    }
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Checks if the layout is locked or not. Should be called by the "update" method of 
                each layout to check if it is OK to do the update. If myt.Layout.locked is true (the
                global layout lock) then a deferred layout update will be setup for this Layout. 
                Once the global lock is unlocked this Layout's 'update' method will be invoked.
                @returns {boolean} true if not locked, false otherwise. */
            canUpdate: function() {
                if (globalLock) {
                    deferLayoutUpdate(this);
                    return false;
                }
                return !this.locked;
            },
            
            /** Updates the layout. Subclasses should call canUpdate to check lock state before 
                trying to do anything.
                @returns {undefined} */
            update: () => {},
            
            // Subview Methods //
            /** Checks if this Layout has the provided View in the subviews array.
                @param {?Object} sv - The myt.View to check for.
                @returns true if the subview is found, false otherwise. */
            hasSubview: function(sv) {
                return this.subviews.includes(sv);
            },
            
            /** Gets the index of the provided View in the subviews array.
                @param {?Object} sv - The myt.View to check for.
                @returns {number} - The index of the subview or -1 if not found. */
            getSubviewIndex: function(sv) {
                return this.subviews.indexOf(sv);
            },
            
            /** Adds the provided View to the subviews array of this Layout.
                @param {?Object} sv - The myt.View to add to this layout.
                @returns {undefined} */
            addSubview: function(sv) {
                if (!this.ignore(sv)) {
                    this.subviews.push(sv);
                    this.startMonitoringSubview(sv);
                    if (!this.locked) this.update();
                }
            },
            
            /** Subclasses should implement this method to start listening to events from the 
                subview that should trigger the update method.
                @param {?Object} sv - The myt.View to start monitoring for changes.
                @returns {undefined} */
            startMonitoringSubview: sv => {},
            
            /** Calls startMonitoringSubview for all views. Used by Layout implementations when a 
                change occurs to the layout that 
                requires refreshing all the subview monitoring.
                @returns {undefined} */
            startMonitoringAllSubviews: function() {
                const svs = this.subviews;
                let i = svs.length;
                while (i) this.startMonitoringSubview(svs[--i]);
            },
            
            /** Removes the provided View from the subviews array of this Layout.
                @param {?Object} sv - The myt.View to remove from this layout.
                @returns the index of the removed subview or -1 if not removed. */
            removeSubview: function(sv) {
                if (this.ignore(sv)) return -1;
                
                const idx = this.getSubviewIndex(sv);
                if (idx > -1) {
                    this.stopMonitoringSubview(sv);
                    this.subviews.splice(idx, 1);
                    if (!this.locked) this.update();
                }
                return idx;
            },
            
            /** Subclasses should implement this method to stop listening to events from the 
                subview that would trigger the update method. This should remove all listeners that 
                were setup in startMonitoringSubview.
                @param {?Object} sv - The myt.View to stop monitoring for changes.
                @returns {undefined} */
            stopMonitoringSubview: sv => {},
            
            /** Calls stopMonitoringSubview for all views. Used by Layout implementations when a 
                change occurs to the layout that requires refreshing all the subview monitoring.
                @returns {undefined} */
            stopMonitoringAllSubviews: function() {
                const svs = this.subviews;
                let i = svs.length;
                while (i) this.stopMonitoringSubview(svs[--i]);
            },
            
            /** Checks if a subview can be added to this Layout or not. The default implementation 
                returns the 'ignoreLayout' attributes of the subview.
                @param {?Object} sv - The myt.View to check.
                @returns {boolean} true means the subview will be skipped, false otherwise. */
            ignore: sv => sv.ignoreLayout,
            
            /** If our parent adds a new subview we should add it.
                @private
                @param {!Object} event
                @returns {undefined} */
            __hndlPSA: function(event) {
                const value = event.value;
                if (value.parent === this.parent) this.addSubview(value);
            },
            
            /** If our parent removes a subview we should remove it.
                @private
                @param {!Object} event
                @returns {undefined} */
            __hndlPSR: function(event) {
                const value = event.value;
                if (value.parent === this.parent) this.removeSubview(value);
            },
            
            // Subview ordering //
            /** Sorts the subviews array according to the provided sort function.
                @param {?Function} sortFunc - The sort function to sort the subviews with.
                @returns {undefined} */
            sortSubviews: function(sortFunc) {
                this.subviews.sort(sortFunc);
            },
            
            /** Moves the subview before the target subview in the order the subviews are layed 
                out. If no target subview is provided, or it isn't in the layout the subview will 
                be moved to the front of the list.
                @param {?Object} sv
                @param {?Object} target
                @returns {undefined} */
            moveSubviewBefore: function(sv, target) {
                moveSubview(this, sv, target, false);
            },
            
            /** Moves the subview after the target subview in the order the subviews are layed out. 
                If no target subview is provided, or it isn't in the layout the subview will be 
                moved to the back of the list.
                @param {?Object} sv
                @param {?Object} target
                @returns {undefined} */
            moveSubviewAfter: function(sv, target) {
                moveSubview(this, sv, target, true);
            }
        }),
        
        /** A layout that sets the target attribute name to the target value for each subview.
            
            Events:
                targetAttrName:string
                targetValue:*
            
            Attributes:
                targetAttrName:string the name of the attribute to set on each subview.
                targetValue:* the value to set the attribute to.
                setterName:string the name of the setter method to call on the subview for the 
                    targetAttrName. This value is updated when setTargetAttrName is called.
            
            @class */
        ConstantLayout = pkg.ConstantLayout = new JSClass('ConstantLayout', Layout, {
            // Accessors ///////////////////////////////////////////////////////
            setTargetAttrName: function(v) {
                this.setterName = pkg.AccessorSupport.generateSetterName(v);
                setAndUpdate(this, 'targetAttrName', v);
            },
            
            setTargetValue: function(v) {setAndUpdate(this, 'targetValue', v);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides */
            update: function() {
                if (this.canUpdate()) {
                    const setterName = this.setterName, 
                        value = this.targetValue, 
                        svs = this.subviews, 
                        len = svs.length; 
                    if (setterName) for (let i = 0; len > i;) svs[i++][setterName](value);
                }
            }
        }),
        
        /** An extension of ConstantLayout that allows for variation based on the index and 
            subview. An updateSubview method is provided that can be overriden to provide 
            variable behavior.
            
            Events:
                collapseParent:boolean
                reverse:boolean
            
            Attributes:
                collapseParent:boolean If true the updateParent method will be called. The 
                    updateParent method will typically resize the parent to fit the newly layed 
                    out child views. Defaults to false.
                reverse:boolean If true the layout will position the items in the opposite order. 
                    For example, right to left instead of left to right. Defaults to false.
            
            @class */
        VariableLayout = pkg.VariableLayout = new JSClass('VariableLayout', ConstantLayout, {
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                this.collapseParent = this.reverse = false;
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setCollapseParent: function(v) {setAndUpdate(this, 'collapseParent', v);},
            setReverse: function(v) {setAndUpdate(this, 'reverse', v);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides */
            update: function() {
                if (this.canUpdate()) {
                    // Prevent inadvertent loops
                    this.incrementLockedCounter();
                    
                    this.doBeforeUpdate();
                    
                    const setterName = this.setterName, 
                        svs = this.subviews, 
                        len = svs.length;
                    let value = this.targetValue,
                        i, 
                        count = 0;
                    
                    if (this.reverse) {
                        i = len;
                        while (i) {
                            const sv = svs[--i];
                            if (this.skipSubview(sv)) continue;
                            value = this.updateSubview(++count, sv, setterName, value);
                        }
                    } else {
                        i = 0;
                        while (len > i) {
                            const sv = svs[i++];
                            if (this.skipSubview(sv)) continue;
                            value = this.updateSubview(++count, sv, setterName, value);
                        }
                    }
                    
                    this.doAfterUpdate();
                    
                    if (this.collapseParent && !this.parent.isBeingDestroyed) {
                        this.updateParent(setterName, value);
                    }
                    
                    this.decrementLockedCounter();
                }
            },
            
            /** Called by update before any processing is done. Gives subviews a chance to do any 
                special setup before update is processed.
                @returns {undefined} */
            doBeforeUpdate: () => {/* Subclasses to implement as needed. */},
            
            /** Called by update after any processing is done but before the optional collapsing of 
                parent is done. Gives subviews a chance to do any special teardown after update 
                is processed.
                @returns {undefined} */
            doAfterUpdate: () => {/* Subclasses to implement as needed. */},
            
            /** Provides a default implementation that calls update when the visibility of a 
                subview changes.
                @overrides myt.Layout
                @param {?Object} sv
                @returns {undefined} */
            startMonitoringSubview: function(sv) {
                this.attachTo(sv, 'update', 'visible');
            },
            
            /** Provides a default implementation that calls update when the visibility of a 
                subview changes.
                @overrides myt.Layout
                @param {?Object} sv
                @returns {undefined} */
            stopMonitoringSubview: function(sv) {
                this.detachFrom(sv, 'update', 'visible');
            },
            
            /** Called for each subview in the layout.
                @param {number} count - The number of subviews that have been layed out including 
                    the current one. i.e. count will be 1 for the first subview layed out.
                @param {!Object} sv - The sub myt.View being layed out.
                @param {string} setterName - The name of the setter method to call.
                @param {*} value - The layout value.
                @returns {*} - The value to use for the next subview. */
            updateSubview: (count, sv, setterName, value) => {
                sv[setterName](value);
                return value;
            },
            
            /** Called for each subview in the layout to determine if the view should be positioned 
                or not. The default implementation returns true if the subview is not visible.
                @param {?Object} sv - The sub myt.View to test.
                @returns {boolean} true if the subview should be skipped during layout updates. */
            skipSubview: sv => !sv.visible,
            
            /** Called if the collapseParent attribute is true. Subclasses should implement this if 
                they want to modify the parent view.
                @param {string} setterName - The name of the setter method to call on the parent.
                @param {*} value - The value to set on the parent.
                @returns {undefined} */
            updateParent: (setterName, value) => {/* Subclasses to implement as needed. */}
        }),
        
        /** An extension of VariableLayout that positions views along an axis using an inset, 
            outset and spacing value.
            
            Events:
                spacing:number
                outset:number
            
            Attributes:
                axis:string The orientation of the layout. An alias for setTargetAttrName.
                inset:number Padding before the first subview that gets positioned. An alias for 
                    setTargetValue.
                spacing:number Spacing between each subview.
                outset:number Padding at the end of the layout. Only gets used if collapseParent 
                    is true.
                noAddSubviewOptimization:boolean Turns the optimization to suppress layout updates 
                    when a subview is added off/on. Defaults to undefined which is equivalent to 
                    false and thus leaves the optimization on.
            
            @class */
        SpacedLayout = pkg.SpacedLayout = new JSClass('SpacedLayout', VariableLayout, {
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.VariableLayout */
            initNode: function(parent, attrs) {
                const self = this;
                
                self.targetAttrName = self.axis = 'x';
                self.setterName = 'setX';
                self.measureAttrName = 'boundsWidth';
                self.measureAttrBaseName = 'width';
                self.parentSetterName = 'setWidth';
                self.targetValue = self.spacing = self.inset = self.outset = 0;
                
                self.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.ConstantLayout */
            setTargetAttrName: function(v) {
                if (this.targetAttrName !== v) {
                    const isY = v === 'y',
                        inited = this.inited;
                    if (inited) this.stopMonitoringAllSubviews();
                    this.measureAttrName = isY ? 'boundsHeight' : 'boundsWidth';
                    this.measureAttrBaseName = isY ? 'height' : 'width';
                    this.parentSetterName = isY ? 'setHeight' : 'setWidth';
                    if (inited) this.startMonitoringAllSubviews();
                    this.callSuper(v);
                }
            },
            
            setNoAddSubviewOptimization: function(v) {this.noAddSubviewOptimization = v;},
            setAxis: function(v) {this.setTargetAttrName(this.axis = v);},
            setInset: function(v) {this.setTargetValue(this.inset = v);},
            
            setSpacing: function(v) {setAndUpdate(this, 'spacing', v);},
            setOutset: function(v) {setAndUpdate(this, 'outset', v);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.Layout */
            addSubview: function(sv) {
                // OPTIMIZATION: Skip the update call that happens during subview add. The 
                // boundsWidth/boundsHeight events will be fired immediately after and are a more 
                // appropriate time to do the update.
                const isLocked = this.locked; // Remember original locked state.
                if (!this.noAddSubviewOptimization) this.locked = true; // Lock the layout so no updates occur.
                this.callSuper(sv);
                this.locked = isLocked; // Restore original locked state.
            },
            
            /** @overrides myt.VariableLayout */
            startMonitoringSubview: function(sv) {
                this.attachTo(sv, 'update', this.measureAttrName);
                this.callSuper(sv);
            },
            
            /** @overrides myt.VariableLayout */
            stopMonitoringSubview: function(sv) {
                this.detachFrom(sv, 'update', this.measureAttrName);
                this.callSuper(sv);
            },
            
            /** @overrides myt.ConstantLayout */
            updateSubview: function(count, sv, setterName, value) {
                const size = sv[this.measureAttrName];
                sv[setterName](value + (size - sv[this.measureAttrBaseName])/2.0); // Adj for transform
                return value + size + this.spacing;
            },
            
            /** @overrides myt.VariableLayout */
            updateParent: function(setterName, value) {
                this.parent[this.parentSetterName](value + this.outset - this.spacing);
            }
        });
    
    /** An extension of SpacedLayout that resizes one or more views to fill in any remaining space. 
        The resizable subviews should not have a transform applied to it. The non-resized views may 
        have transforms applied to them.
        
        @class */
    pkg.ResizeLayout = new JSClass('ResizeLayout', SpacedLayout, {
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.VariableLayout */
        setCollapseParent: v => {/* collapseParent attribute is unused in ResizeLayout. */},
        
        /** @overrides myt.SpacedLayout */
        setTargetAttrName: function(v) {
            if (this.targetAttrName !== v) {
                if (this.inited) {
                    const isX = v === 'x';
                    this.stopMonitoringParent(isX ? 'height' : 'width');
                    this.startMonitoringParent(isX ? 'width' : 'height');
                }
                
                this.callSuper(v);
            }
        },
        
        /** @overrides myt.Layout */
        setParent: function(parent) {
            if (this.parent !== parent) {
                const dim = this.targetAttrName === 'x' ? 'width' : 'height';
                if (this.parent) this.stopMonitoringParent(dim);
                
                this.callSuper(parent);
                
                if (this.parent) this.startMonitoringParent(dim);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called when monitoring of width/height should start on our parent.
            @param {string} attrName - The name of the attribute to start monitoring.
            @returns {undefined} */
        startMonitoringParent: function(attrName) {
            this.attachTo(this.parent, 'update', attrName);
        },
        
        /** Called when monitoring of width/height should stop on our parent.
            @param {string} attrName - The name of the attribute to stop monitoring.
            @returns {undefined} */
        stopMonitoringParent: function(attrName) {
            this.detachFrom(this.parent, 'update', attrName);
        },
        
        /** @overrides myt.VariableLayout */
        doBeforeUpdate: function() {
            // Get size to fill
            const measureAttrName = this.measureAttrName,
                measureAttrBaseName = this.measureAttrBaseName,
                svs = this.subviews;
            
            // Calculate minimum required size
            let remainder = this.parent[measureAttrBaseName] - this.targetValue - this.outset,
                i = svs.length, 
                count = 0, 
                resizeSum = 0;
            while (i) {
                const sv = svs[--i];
                if (this.skipSubview(sv)) continue;
                ++count;
                if (sv.layoutHint > 0) {
                    resizeSum += sv.layoutHint;
                } else {
                    remainder -= sv[measureAttrName];
                }
            }
            
            if (count !== 0) {
                remainder -= (count - 1) * this.spacing;
                
                // Store for update
                this.remainder = remainder;
                this.resizeSum = resizeSum;
                this.scalingFactor = remainder / resizeSum;
                this.resizeSumUsed = this.remainderUsed = 0;
                this.measureSetter = measureAttrName === 'boundsWidth' ? 'setWidth' : 'setHeight';
            }
        },
        
        /** @overrides myt.SpacedLayout */
        updateSubview: function(count, sv, setterName, value) {
            const hint = sv.layoutHint;
            if (hint > 0) {
                this.resizeSumUsed += hint;
                
                const size = this.resizeSum === this.resizeSumUsed ? 
                    this.remainder - this.remainderUsed : 
                    Math.round(hint * this.scalingFactor);
                
                this.remainderUsed += size;
                sv[this.measureSetter](size);
            }
            return this.callSuper(count, sv, setterName, value);
        },
        
        /** @overrides myt.SpacedLayout */
        startMonitoringSubview: function(sv) {
            // Don't monitor width/height of the "stretchy" subviews since this layout changes them.
            if (!(sv.layoutHint > 0)) this.attachTo(sv, 'update', this.measureAttrName);
            this.attachTo(sv, 'update', 'visible');
        },
        
        /** @overrides myt.SpacedLayout */
        stopMonitoringSubview: function(sv) {
            // Don't monitor width/height of the "stretchy" subviews since this layout changes them.
            if (!(sv.layoutHint > 0)) this.detachFrom(sv, 'update', this.measureAttrName);
            this.detachFrom(sv, 'update', 'visible');
        },
        
        /** @overrides myt.SpacedLayout */
        updateParent: (setterName, value) => {/* No resizing of parent since this view expands to fill the parent. */}
    });
    
    /** An extension of VariableLayout that also aligns each view vertically or horizontally.
        
        Events:
            align:string
        
        Attributes:
            align:string Determines which way the views are aligned. Allowed values are 'left', 
                'center', 'right' and 'top', 'middle', 'bottom'. Defaults to 'middle'.
        
        @class */
    pkg.AlignedLayout = new JSClass('AlignedLayout', VariableLayout, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.VariableLayout */
        initNode: function(parent, attrs) {
            const self = this;
            
            self.align = 'middle';
            self.targetAttrName = 'y';
            self.setterName = 'setY';
            self.measureAttrName = 'boundsHeight';
            self.measureAttrBaseName = 'height';
            self.parentSetterName = 'setHeight';
            self.targetValue = 0;
            
            self.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.ConstantLayout */
        setTargetAttrName: function(v) {
            if (this.targetAttrName !== v) {
                const isY = v === 'y',
                    inited = this.inited;
                if (inited) this.stopMonitoringAllSubviews();
                this.measureAttrName = isY ? 'boundsHeight' : 'boundsWidth';
                this.measureAttrBaseName = isY ? 'height' : 'width';
                this.parentSetterName = isY ? 'setHeight' : 'setWidth';
                if (inited) this.startMonitoringAllSubviews();
                this.callSuper(v);
            }
        },
        
        setAlign: function(v) {
            if (this.align !== v) {
                this.align = v;
                
                // Update orientation but don't trigger an update since we already call update at 
                // the end of this setter.
                const isLocked = this.locked;
                this.locked = true;
                this.setTargetAttrName((v === 'middle' || v === 'bottom' || v === 'top') ? 'y' : 'x');
                this.locked = isLocked;
                
                if (this.inited) {
                    this.fireEvent('align', v);
                    this.update();
                }
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.VariableLayout */
        startMonitoringSubview: function(sv) {
            this.attachTo(sv, 'update', this.measureAttrName);
            this.callSuper(sv);
        },
        
        /** @overrides myt.VariableLayout */
        stopMonitoringSubview: function(sv) {
            this.detachFrom(sv, 'update', this.measureAttrName);
            this.callSuper(sv);
        },
        
        /** Determine the maximum subview width/height according to the axis.
            @overrides myt.VariableLayout */
        doBeforeUpdate: function() {
            const measureAttrName = this.measureAttrName, 
                svs = this.subviews;
            let value = 0, 
                i = svs.length;
            while (i) {
                const sv = svs[--i];
                if (this.skipSubview(sv)) continue;
                value = value > sv[measureAttrName] ? value : sv[measureAttrName];
            }
            
            this.setTargetValue(value);
        },
        
        /** @overrides myt.VariableLayout */
        updateSubview: function(count, sv, setterName, value) {
            switch (this.align) {
                case 'center': case 'middle':
                    sv[setterName]((value - sv[this.measureAttrName]) / 2);
                    break;
                case 'right': case 'bottom':
                    sv[setterName](value - sv[this.measureAttrName]);
                    break;
                default:
                    sv[setterName](0);
            }
            return value;
        },
        
        /** @overrides myt.VariableLayout */
        updateParent: function(setterName, value) {
            this.parent[this.parentSetterName](value);
        }
    });
    
    /** An extension of VariableLayout that positions views along an axis using an inset, outset 
        and spacing value. Views will be wrapped when they overflow the available space.
        
        Supported Layout Hints:
            break:string Will force the subview to start a new line/column.
        
        @class */
    pkg.WrappingLayout = new JSClass('WrappingLayout', VariableLayout, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.VariableLayout */
        initNode: function(parent, attrs) {
            const self = this;
            
            self.targetAttrName = self.axis = 'x';
            self.setterName = 'setX';
            self.otherSetterName = 'setY';
            self.measureAttrName = 'boundsWidth';
            self.measureAttrBaseName = 'width';
            self.otherMeasureAttrName = 'boundsHeight';
            self.otherMeasureAttrBaseName = 'height';
            self.parentSetterName = 'setHeight';
            self.targetValue = self.spacing = self.inset = self.outset = self.lineSpacing = self.lineInset = self.lineOutset = 0;
            
            self.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.ConstantLayout */
        setTargetAttrName: function(v) {
            if (this.targetAttrName !== v) {
                const isY = v === 'y',
                    inited = this.inited;
                
                if (inited) this.stopMonitoringAllSubviews();
                
                this.measureAttrName = isY ? 'boundsHeight' : 'boundsWidth';
                const mabn = this.measureAttrBaseName = isY ? 'height' : 'width';
                this.otherMeasureAttrName = isY ? 'boundsWidth' : 'boundsHeight';
                const omabn = this.otherMeasureAttrBaseName = isY ? 'width' : 'height';
                this.parentSetterName = isY ? 'setWidth' : 'setHeight';
                this.otherSetterName = isY ? 'setX' : 'setY';
                
                if (inited) {
                    this.startMonitoringAllSubviews();
                    this.stopMonitoringParent(omabn);
                    this.startMonitoringParent(mabn);
                }
                this.callSuper(v);
            }
        },
        
        /** @overrides myt.Layout */
        setParent: function(parent) {
            if (this.parent !== parent) {
                const isY = this.targetAttrName === 'y';
                if (this.parent) this.stopMonitoringParent(isY ? 'height' : 'width');
                this.callSuper(parent);
                if (this.parent) this.startMonitoringParent(isY ? 'height' : 'width');
            }
        },
        
        setAxis: function(v) {this.setTargetAttrName(this.axis = v);},
        setInset: function(v) {this.setTargetValue(this.inset = v);},
        
        setSpacing: function(v) {setAndUpdate(this, 'spacing', v);},
        setOutset: function(v) {setAndUpdate(this, 'outset', v);},
        setLineSpacing: function(v) {setAndUpdate(this, 'lineSpacing', v);},
        setLineInset: function(v) {setAndUpdate(this, 'lineInset', v);},
        setLineOutset: function(v) {setAndUpdate(this, 'lineOutset', v);},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called when monitoring of width/height should start on our parent.
            @param {string} measureAttrName - The name of the attribute to start monitoring.
            @returns {undefined} */
        startMonitoringParent: function(measureAttrName) {
            this.attachTo(this.parent, 'update', measureAttrName);
        },
        
        /** Called when monitoring of width/height should stop on our parent.
            @param {string} measureAttrName - The name of the attribute to stop monitoring.
            @returns {undefined} */
        stopMonitoringParent: function(measureAttrName) {
            this.detachFrom(this.parent, 'update', measureAttrName);
        },
        
        /** @overrides myt.Layout */
        startMonitoringSubview: function(sv) {
            this.attachTo(sv, 'update', this.measureAttrName);
            this.attachTo(sv, 'update', this.otherMeasureAttrName);
            this.callSuper(sv);
        },
        
        /** @overrides myt.Layout */
        stopMonitoringSubview: function(sv) {
            this.detachFrom(sv, 'update', this.measureAttrName);
            this.detachFrom(sv, 'update', this.otherMeasureAttrName);
            this.callSuper(sv);
        },
        
        
        /** @overrides myt.VariableLayout */
        doBeforeUpdate: function() {
            // The number of lines layed out.
            this.lineCount = 1;
            
            // The maximum size achieved by any line.
            this.maxSize = 0;
            
            // Track the maximum size of a line. Used to determine how much to update linePos by 
            // when wrapping occurs.
            this.lineSize = 0;
            
            // The position for each subview in a line. Gets updated for each new line of subviews.
            this.linePos = this.lineInset;
            
            // The size of the parent view. Needed to determine when to wrap. The outset is already 
            // subtracted as a performance optimization.
            this.parentSizeLessOutset = this.parent[this.measureAttrName] - this.outset;
        },
        
        /** @overrides myt.ConstantLayout */
        updateSubview: function(count, sv, setterName, value) {
            const size = sv[this.measureAttrName],
                otherSize = sv[this.otherMeasureAttrName];
            
            if (value + size > this.parentSizeLessOutset || sv.layoutHint === 'break') {
                // Check for overflow
                value = this.targetValue; // Reset to inset.
                this.linePos += this.lineSize + this.lineSpacing;
                this.lineSize = otherSize;
                
                ++this.lineCount;
            } else if (otherSize > this.lineSize) {
                // Update line size if this subview is larger
                this.lineSize = otherSize;
            }
            
            sv[this.otherSetterName](this.linePos + (otherSize - sv[this.otherMeasureAttrBaseName])/2.0); // adj is for transform
            sv[setterName](value + (size - sv[this.measureAttrBaseName])/2.0); // adj is for transform
            
            // Track max size achieved during layout.
            this.maxSize = Math.max(this.maxSize, value + size + this.outset);
            
            return value + size + this.spacing;
        },
        
        /** @overrides myt.VariableLayout */
        updateParent: function(setterName, value) {
            // Collapse in the other direction
            this.parent[this.parentSetterName](this.linePos + this.lineSize + this.lineOutset);
        }
    });
    
    /*  Create locked counter functions for the myt.Layout class. */
    pkg.createFixedThresholdCounter(Layout, 1, 'locked');
})(myt);


(pkg => {
    const mathRound = Math.round,
        DomElementProxy = pkg.DomElementProxy,
        
        rectContainsPoint = pkg.Geometry.rectContainsPoint,
        
        getDomStyle = (view, isInnerElem) => isInnerElem ? view.getIDS() : view.getODS(),
        
        /*  Preserves focus and scroll position during dom updates. Focus can get lost in webkit 
            when an element is removed from the dom.
                param viewBeingRemoved:myt.View
                param wrapperFunc:function a function to execute that manipulates the dom in some 
                    way, typically a remove followed by an insert. */
        retainFocusDuringDomUpdate = (viewBeingRemoved, wrappedFunc) => {
            const restoreFocus = pkg.global.focus.focusedView, 
                elem = viewBeingRemoved.getIDE();
            if (restoreFocus === viewBeingRemoved || restoreFocus?.isDescendantOf(viewBeingRemoved)) {
                restoreFocus._ignoreFocus = true;
            }
            
            // Also maintain scrollTop/scrollLeft since those also get reset when a dom element is 
            // removed. Note: descendant elements with scroll positions won't get maintained.
            const {scrollTop, scrollLeft} = elem;
            
            wrappedFunc();
            
            if (restoreFocus) {
                restoreFocus._ignoreFocus = false;
                restoreFocus.focus(true);
            }
            
            // Restore scrollTop/scrollLeft
            elem.scrollTop = scrollTop;
            elem.scrollLeft = scrollLeft;
        },
        
        /*  Removes the outer dom element for a view from the dom while a function is executed.
            This is used for performance gains when deemed worthwhile.
                param viewBeingRemoved:myt.View
                param wrapperFunc:function
                param retainFocus:boolean */
        doWhileRemovedFromDom = (viewBeingRemoved, wrappedFunc, retainFocus) => {
            const outerElem = viewBeingRemoved.getODE(),
                parentElem = outerElem.parentNode;
            if (parentElem) {
                const doubleWrapped = () => {
                    const nextDe = outerElem.nextElementSibling;
                    // Remove this dom element from the dom
                    parentElem.removeChild(outerElem);
                    wrappedFunc();
                    // Put this dom element back in the dom
                    parentElem.insertBefore(outerElem, nextDe);
                };
                if (retainFocus) {
                    retainFocusDuringDomUpdate(viewBeingRemoved, doubleWrapped);
                } else {
                    doubleWrapped();
                }
            } else {
                // No parent element so just execute the function.
                wrappedFunc();
            }
        },
        
        /*  Implements isBehind and isInFrontOf methods. Returns a boolean indicating front or 
            behind respective to the "front" param.
                param firstView:View The view to check position for
                param view:View The view to check the position of the first view against.
                param front:boolean indicates if this is the isInFrontOf test or not.
                param checkZIndex:boolean If true z-index will first be used to check if the view 
                    is in front or not. */
        comparePosition = (firstView, secondView, front, checkZIndex) => {
            if (secondView && typeof secondView === 'object') {
                if (checkZIndex) {
                    const commonAncestorElem = firstView.getLeastCommonAncestor(secondView)?.getIDE();
                    if (commonAncestorElem) {
                        const getZIndexRelativeToAncestor = DomElementProxy.getZIndexRelativeToAncestor,
                            inverter = front ? -1 : 1, // Reverse comparison order if so directed.
                            zIdx = inverter * getZIndexRelativeToAncestor(firstView.getODE(), commonAncestorElem),
                            otherZIdx = inverter * getZIndexRelativeToAncestor(secondView.getODE(), commonAncestorElem);
                        if (zIdx < otherZIdx) {
                            return true;
                        } else if (otherZIdx < zIdx) {
                            return false;
                        }
                        // Fall through to dom comparison since z-indices are equal.
                    }
                }
                
                // DOCUMENT_POSITION_DISCONNECTED 1
                // DOCUMENT_POSITION_PRECEDING 2
                // DOCUMENT_POSITION_FOLLOWING 4
                // DOCUMENT_POSITION_CONTAINS 8
                // DOCUMENT_POSITION_CONTAINED_BY 16
                // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC 32
                const rel = firstView.getODE().compareDocumentPosition(secondView.getODE());
                return front ? rel === 2 || rel === 10 : rel === 4 || rel === 20;
            } else {
                return false;
            }
        },
        
        /*  Calculates the effective scale for the provided view and all its ancestors. Returns the 
            effective scale for the provided view. */
        calculateEffectiveScale = view => {
            const ancestorsAndSelf = view.getAncestors();
            let i = ancestorsAndSelf.length, 
                effectiveScaleX = 1,
                effectiveScaleY = 1;
            while (i) {
                const ancestor = ancestorsAndSelf[--i];
                effectiveScaleX *= ancestor.scaleX || 1;
                effectiveScaleY *= ancestor.scaleY || 1;
                ancestor.__effectiveScaleX = effectiveScaleX;
                ancestor.__effectiveScaleY = effectiveScaleY;
            }
            return {scaleX:effectiveScaleX, scaleY:effectiveScaleY};
        },
        
        isPointVisible = (view, x, y) => {
            const ode = view.getODE();
            if (rectContainsPoint(x, y, 0, 0, ode.offsetWidth * view.__effectiveScaleX, ode.offsetHeight * view.__effectiveScaleY)) {
                let parent;
                if (parent = view.parent) {
                    const pIde = parent.getIDE();
                    return isPointVisible(
                        parent, 
                        x + (ode.offsetLeft - pIde.scrollLeft) * parent.__effectiveScaleX, 
                        y + (ode.offsetTop - pIde.scrollTop) * parent.__effectiveScaleY
                    );
                }
                return true;
            }
            return false;
        },
        
        teardownAlignConstraint = view => {
            switch (view.align) {
                case 'center': view.releaseConstraint('__doAlignCenter'); break;
                case 'right': view.releaseConstraint('__doAlignRight'); break;
                case 'left':
                default: // Do nothing
            }
        },
        
        setupAlignConstraint = view => {
            const parent = view.parent;
            if (parent) {
                switch (view.align) {
                    case 'center':
                        view.constrain('__doAlignCenter', [view, 'width', view, 'alignOffset', parent, 'width']);
                        break;
                    case 'right':
                        view.constrain('__doAlignRight', [view, 'width', view, 'alignOffset', parent, 'width']);
                        break;
                    case 'left':
                        view.setX(view.alignOffset || 0);
                        break;
                    default: // Do nothing
                }
            }
        },
        
        teardownValignConstraint = view => {
            switch (view.valign) {
                case 'middle': view.releaseConstraint('__doValignMiddle'); break;
                case 'bottom': view.releaseConstraint('__doValignBottom'); break;
                case 'top':
                default: // Do nothing
            }
        },
        
        setupValignConstraint = view => {
            const parent = view.parent;
            if (parent) {
                switch (view.valign) {
                    case 'middle':
                        view.constrain('__doValignMiddle', [view, 'height', view, 'valignOffset', parent, 'height']);
                        break;
                    case 'bottom':
                        view.constrain('__doValignBottom', [view, 'height', view, 'valignOffset', parent, 'height']);
                        break;
                    case 'top':
                        view.setY(view.valignOffset || 0);
                        break;
                    default: // Do nothing
                }
            }
        };
    
    /** A Node that can be viewed. Instances of view are typically backed by an absolutely 
        positioned div element.
        
        Events:
            domClass:string Fired when the domClass setter is called.
            domId:string Fired when the domId setter is called.
            align:string
            alignOffset:number
            valign:string
            valignOffset:number
            x:number
            y:number
            width:number (suppressable)
            height:number (suppressable)
            boundsWidth:number Fired when the bounds width of the view changes.
            boundsHeight:number Fired when the bounds height of the view changes.
            textColor:string
            bgColor:string
            opacity:number
            overflow:string
            visible:boolean
            cursor:string
            subviewAdded:myt.View Fired when a subview is added to this view.
            subviewRemoved:myt.View Fired when a subview is removed from this view.
            layoutAdded:myt.Layout Fired when a layout is added to this view.
            layoutRemoved:myt.Layout Fired when a layout is removed from this view.
        
        Attributes:
            tagName:string Determines the name of the DOM element to create for this instance. This 
                is not a normal attribute. It is only used during initialization and it will be 
                deleted from the attrs object upon use. If no tagName is provided "div" will be used.
            focusTrap:boolean Determines if focus traversal can move above this view or not. The 
                default is undefined which is equivalent to false. Can be ignored using a key 
                modifier. The key modifier is typically 'option'.
            focusCage:boolean Determines if focus traversal can move above this view or not. The 
                default is undefined which is equivalent to false. This is the same as focusTrap 
                except it can't be ignored using a key modifier.
            maskFocus:boolean Prevents focus from traversing into this view or any of its subviews. 
                The default is undefined which is equivalent to false.
            ignoreLayout:boolean Determines if this view should be included in layouts or not. 
                Default is undefined which is equivalent to false.
            layoutHint:* A value that indicates this view is treated as "special" by the layout. 
                The interpretation of this value is up to the layout managing the view.
            align:string Aligns the view horizontally within its parent. Supported values are: 
                'left', 'center', 'right' and ''. The default is undefined which is equivalent to ''.
            alignOffset:number A pixel offset to use when aligning a view.
            valign:string Aligns the view vertically within its parent. Supported values are: 'top', 
                'middle', 'bottom' and ''. The default is undefined which is equivalent to ''.
            valignOffset:number A pixel offset to use when valigning a view.
            x:number The x-position of this view in pixels. Defaults to 0.
            y:number The y-position of this view in pixels. Defaults to 0.
            width:number The width of this view in pixels. Defaults to 0.
            height:number the height of this view in pixels. Defaults to 0.
            boundsWidth:number (read only) The actual bounds of the view in the x-dimension. This 
                value is in pixels relative to the RootView and thus compensates for rotation 
                and scaling.
            boundsHeight:number (read only) The actual bounds of the view in the y-dimension. This 
                value is in pixels relative to the RootView and thus compensates for rotation 
                and scaling.
            textColor:string The color used for text. Will be inherited by descendant views if they 
                don't themselves set textColor or if they set textColor to 'inherit'. Defaults to 
                undefined which is equivalent to 'inherit'.
            bgColor:string The background color of this view. Use a value of 'transparent' to make 
                this view transparent. Defaults to 'transparent'.
            opacity:number The opacity of this view. The value should be a number between 0 and 1. 
                Defaults to 1.
            overflow:string Determines how descendant content overflows the bounds. Allowed values: 
                'visible', 'hidden', 'scroll', 'auto', 'autoy', 'autox' and 'inherit'. Defaults to 
                undefined which is equivalent to 'visible'.
            visible:boolean Makes this view visible or not. The default value is true which means 
                visbility is inherited from the parent view.
            cursor:string Determines what cursor to show when moused over the view. Allowed values: 
                'auto', 'move', 'no-drop', 'col-resize', 'all-scroll', 'pointer', 'not-allowed', 
                'row-resize', 'crosshair', 'progress', 'e-resize', 'ne-resize', 'default', 'text', 
                'n-resize', 'nw-resize', 'help', 'vertical-text', 's-resize', 'se-resize', 
                'inherit', 'wait', 'w-resize', 'sw-resize'. Defaults to undefined which is 
                equivalent to 'auto'.
            pointerEvents:string Determines if this view responds to pointer events or not. 
                Supported values: 'none', 'auto' and 'inherit'. Defaults to undefined which is 
                equivalent to 'auto'.
            outlineWidth:number The width of the CSS outline. If a value equivalent to false is 
                provided 0 will be used.
            outlineStyle:string The CSS outline style. If null or undefined is provided 'none' will 
                be used. Supported values: 'none', 'dotted', 'dashed', 'solid', 'double', 'groove', 
                'ridge', 'inset', 'outset', 'inherit'.
            outlineColor:string Sets the color of the CSS outline. If null or undefined is provided 
                '#000' will be used.
            borderWidth:number The width of the CSS border. If a value equivalent to false is 
                provided 0 will be used.
            borderStyle:string The CSS border style. If null or undefined is provided 'none' will 
                be used. Supported values: 'none', 'dotted', 'dashed', 'solid', 'double', 'groove', 
                'ridge', 'inset', 'outset', 'inherit'.
            borderColor:string Sets the color of the CSS border. If null or undefined is provided 
                '#000' will be used.
            tooltip:string Sets a tooltip for this view. The basic implementation uses the dom 
                element's title property. For a richer tooltip display use myt.TooltipMixin.
        
        Private Attributes:
            subviews:array The array of child myt.Views for this view. Should be accessed through 
                the getSubviews method.
            layouts:array The array of child myt.Layouts for this view. Should be accessed through 
                the getLayouts method.
        
        @class */
    pkg.View = new JS.Class('View', pkg.Node, {
        include: [
            DomElementProxy, 
            pkg.DomObservable, 
            pkg.DomObserver, 
            pkg.ScrollObservable, 
            pkg.FocusObservable, 
            pkg.KeyObservable, 
            pkg.MouseObservable
        ],
        
        
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            retainFocusDuringDomUpdate: retainFocusDuringDomUpdate,
            doWhileRemovedFromDom: doWhileRemovedFromDom
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.Node */
        initNode: function(parent, attrs) {
            const self = this;
            
            self.x = self.y = self.width = self.height = 0;
            self.opacity = 1;
            self.visible = true;
            
            if (attrs.tagName) {
                self.tagName = attrs.tagName;
                delete attrs.tagName;
            }
            self.setDomElement(self.createOurDomElement(parent));
            
            // Necessary since x and y of 0 won't update the dom element style so this gets things 
            // initialized correctly. Without this RootViews will have an incorrect initial 
            // position for x or y of 0. This is also necessary if the parent of this View uses CSS
            // based padding.
            const ods = self.getODS();
            ods.left = ods.top = '0px';
            
            self.callSuper(parent, attrs);
            
            // Must be done after the dom element is inserted so that calls to 
            // getBoundingClientRect will work.
            self.__updateBounds(self.width, self.height);
        },
        
        /** Creates the dom element we will be a proxy for. Called during View initialization. 
            Gives subclasses a change to change how the view is backed. This implementation also 
            looks for a this.tagName property which it will use as the name for the dom element 
            that gets created. If no this.tagName property is found "div" will be used.
            @param {!Object} parent - The dom element that will be the parent of the newly created 
                dom element.
            @returns {!Object} a dom element */
        createOurDomElement: function(parent) {
            const elem = document.createElement(this.tagName ?? 'div');
            elem.style.position = 'absolute';
            
            // Make dom elements easier to location via selectors
            elem.className = this.klass.__cssClassName ??= 'myt-' + this.klass.__displayName.split('.').join('-');
            
            return elem;
        },
        
        /** @overrides myt.Node */
        destroyAfterOrphaning: function() {
            this.callSuper();
            
            this.detachFromAllDomSources();
            this.detachAllDomObservers();
            this.disposeOfDomElement();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.Node */
        setParent: function(parent) {
            const self = this;
            if (self.parent !== parent) {
                if (self.inited) {
                    teardownAlignConstraint(self);
                    teardownValignConstraint(self);
                }
                self.callSuper(parent);
                if (self.align) setupAlignConstraint(self);
                if (self.valign) setupValignConstraint(self);
            }
        },
        
        /** Does lazy instantiation of the subviews array.
            @returns {!Array} */
        getSubviews: function() {
            return this.subviews ??= [];
        },
        
        /** Get an array of the subviews in the lexical order of the dom.
            @returns {!Array} */
        getSubviewsInLexicalOrder: function() {
            const self = this,
                retval = [],
                children = self.getIDE().children,
                len = children.length;
            for (let i = 0; i < len;) {
                const sv = children[i++].model;
                if (sv?.parent === self) retval.push(sv);
            }
            return retval;
        },
        
        /** Gets the views that are this view's siblings.
            @returns {!Array} of myt.View or undefined if this view is orphaned. */
        getSiblingViews: function() {
            if (this.parent) {
                // Using filter ensures we have a copy of the subviews since we will modify it and 
                // do not want to modify the original array. Remove ourselves from the subviews 
                // since we only want siblings.
                return this.parent.getSubviews().filter(sv => sv !== this);
            }
        },
        
        // Focus Attributes //
        setFocusTrap: function(v) {this.focusTrap = v;},
        setFocusCage: function(v) {this.focusCage = v;},
        setMaskFocus: function(v) {this.maskFocus = v;},
        
        // Layout Attributes //
        setLayoutHint: function(v) {this.layoutHint = v;},
        
        /** Does lazy instantiation of the layouts array.
            @returns {!Array} */
        getLayouts: function() {
            return this.layouts ??= [];
        },
        
        getFirstLayout: function() {
            return this.getLayouts()[0];
        },
        
        setIgnoreLayout: function(v) {
            const self = this;
            if (self.ignoreLayout !== v) {
                // Add or remove ourselves from any layouts on our parent.
                const ready = self.inited && self.parent;
                let layouts,
                    i;
                if (v) {
                    if (ready) {
                        layouts = self.parent.getLayouts();
                        i = layouts.length;
                        while (i) layouts[--i].removeSubview(self);
                    }
                    self.ignoreLayout = v;
                } else {
                    self.ignoreLayout = v;
                    if (ready) {
                        layouts = self.parent.getLayouts();
                        i = layouts.length;
                        while (i) layouts[--i].addSubview(self);
                    }
                }
            }
        },
        
        // Dom Selector Attributes //
        /** @overrides myt.DomElementProxy */
        setDomClass: function(v) {
            if (this.domClass !== v) {
                this.callSuper(v);
                if (this.inited) this.fireEvent('domClass', v);
            }
        },
        
        /** @overrides myt.DomElementProxy */
        setDomId: function(v) {
            if (this.domId !== v) {
                this.callSuper(v);
                if (this.inited) this.fireEvent('domId', v);
            }
        },
        
        // Alignment Attributes //
        setAlignOffset: function(v) {
            if (this.alignOffset !== v) {
                this.alignOffset = v;
                if (this.inited) this.fireEvent('alignOffset', v);
                if (this.parent && this.align === 'left') this.setX(v);
            }
        },
        
        setAlign: function(v) {
            if (this.align !== v) {
                if (this.inited) teardownAlignConstraint(this);
                this.align = v;
                if (this.inited) {
                    this.fireEvent('align', v);
                    setupAlignConstraint(this);
                }
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doAlignCenter: function(event) {
            this.setX(mathRound((this.parent.width - this.width) / 2) + (this.alignOffset || 0));
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doAlignRight: function(event) {
            this.setX(this.parent.width - this.width - (this.alignOffset || 0));
        },
        
        setValignOffset: function(v) {
            if (this.valignOffset !== v) {
                this.valignOffset = v;
                if (this.inited) this.fireEvent('valignOffset', v);
                if (this.parent && this.valign === 'top') this.setY(v);
            }
        },
        
        setValign: function(v) {
            if (this.valign !== v) {
                if (this.inited) teardownValignConstraint(this);
                this.valign = v;
                if (this.inited) {
                    this.fireEvent('valign', v);
                    setupValignConstraint(this);
                }
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doValignMiddle: function(event) {
            this.setY(mathRound((this.parent.height - this.height) / 2) + (this.valignOffset || 0));
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doValignBottom: function(event) {
            this.setY(this.parent.height - this.height - (this.valignOffset || 0));
        },
        
        // Visual Attributes //
        setX: function(v) {
            if (this.x !== v) {
                this.x = v;
                if (this.visible) this.getODS().left = v + 'px';
                if (this.inited) this.fireEvent('x', v);
            }
        },
        
        setY: function(v) {
            if (this.y !== v) {
                this.y = v;
                if (this.visible) this.getODS().top = v + 'px';
                if (this.inited) this.fireEvent('y', v);
            }
        },
        
        setWidth: function(v) {
            // Dom elements don't support negative width
            if (0 > v) v = 0;
            
            if (this.width !== v) {
                this.width = v;
                this.getODS().width = v + 'px';
                if (this.inited) {
                    this.__updateBounds(v, this.height);
                    this.fireEvent('width', v);
                }
            }
        },
        
        setHeight: function(v) {
            // Dom elements don't support negative height
            if (0 > v) v = 0;
            
            if (this.height !== v) {
                this.height = v;
                this.getODS().height = v + 'px';
                if (this.inited) {
                    this.__updateBounds(this.width, v);
                    this.fireEvent('height', v);
                }
            }
        },
        
        setDomMinWidth: function(v, isInnerElem) {
            getDomStyle(this, isInnerElem).minWidth = v != null ? v + 'px' : null;
        },
        
        getDomMinWidth: function(isInnerElem) {
            const minWidth = getDomStyle(this, isInnerElem).minWidth;
            return minWidth != null ? Number.parseInt(minWidth) : null;
        },
        
        setDomMinHeight: function(v, isInnerElem) {
            getDomStyle(this, isInnerElem).minHeight = v != null ? v + 'px' : null;
        },
        
        getDomMinHeight: function(isInnerElem) {
            const minHeight = getDomStyle(this, isInnerElem).minHeight;
            return minHeight != null ? Number.parseInt(minHeight) : null;
        },
        
        setTextColor: function(v) {
            if (this.textColor !== v) {
                this.textColor = v;
                this.getODS().color = v || 'inherit';
                if (this.inited) this.fireEvent('textColor', v);
            }
        },
        
        setBgColor: function(v) {
            if (this.bgColor !== v) {
                this.getODS().backgroundColor = this.bgColor = v;
                if (this.inited) this.fireEvent('bgColor', v);
            }
        },
        
        /** Used by myt.Animator to determine if an attribute is a color attribute or not.
            @param {string} attrName
            @returns {boolean} */
        isColorAttr: attrName => attrName === 'bgColor' || attrName === 'textColor',
        
        setOpacity: function(v) {
            if (this.opacity !== v) {
                this.getODS().opacity = this.opacity = v;
                if (this.inited) this.fireEvent('opacity', v);
            }
        },
        
        setOverflow: function(v) {
            const existing = this.overflow;
            if (existing !== v) {
                this.overflow = v;
                
                const ids = this.getIDS();
                if (v === 'autox') {
                    ids.overflowX = 'auto';
                    ids.overflowY = 'hidden';
                } else if (v === 'autoy') {
                    ids.overflowY = 'auto';
                    ids.overflowX = 'hidden';
                } else {
                    if (existing === 'autox' || existing === 'autoy') ids.overflowX = ids.overflowY = null;
                    ids.overflow = v || 'visible';
                }
                
                if (this.inited) this.fireEvent('overflow', v);
            }
        },
        
        setVisible: function(v) {
            const self = this;
            if (self.visible !== v) {
                self.visible = v;
                
                const ods = self.getODS();
                ods.visibility = v ? 'inherit' : 'hidden';
                
                // Move invisible elements to a very negative location so they won't effect 
                // scrollable area. Ideally we could use display:none but we can't because that 
                // makes measuring bounds not work.
                ods.left = v ? self.x + 'px' : '-100000px';
                ods.top = v ? self.y + 'px' : '-100000px';
                
                if (self.inited) self.fireEvent('visible', v);
            }
        },
        
        setPointerEvents: function(v) {
            if (this.pointerEvents !== v) {
                this.pointerEvents = v;
                this.getODS().pointerEvents = v || 'auto';
                if (this.inited) this.fireEvent('pointerEvents', v);
            }
        },
        
        setCursor: function(v) {
            if (this.cursor !== v) {
                this.cursor = v;
                this.getODS().cursor = v || 'auto';
                if (this.inited) this.fireEvent('cursor', v);
            }
        },
        
        /** Updates the boundsWidth and boundsHeight attributes.
            @private
            @param {number} w - the boundsWidth to set.
            @param {number} h - the boundsHeight to set.
            @returns {undefined} */
        __updateBounds: function(w, h) {
            if (this.boundsWidth !== w) this.fireEvent('boundsWidth', this.boundsWidth = w);
            if (this.boundsHeight !== h) this.fireEvent('boundsHeight', this.boundsHeight = h);
        },
        
        // Outlines
        /** Sets outlineWidth, outlineStyle and outlineColor via a single array. If a value 
            equivalent to false is provided the outline will be suppressed.
            @param {?Array} v - An array where index 0 is outlineWidth, index 1 is outline style 
                and index 2 is outlineColor.
            @returns {undefined} */
        setOutline: function(v) {
            const [width, style, color] = v ?? [];
            this.setOutlineWidth(width);
            this.setOutlineStyle(style);
            this.setOutlineColor(color);
        },
        
        setOutlineWidth: function(v) {
            this.getODS().outlineWidth = (this.outlineWidth = v || 0) + 'px';
        },
        
        setOutlineStyle: function(v) {
            this.getODS().outlineStyle = this.outlineStyle = v || 'none';
        },
        
        setOutlineColor: function(v) {
            this.getODS().outlineColor = this.outlineColor = v || '#000';
        },
        
        // Borders
        /** Sets borderWidth, borderStyle and borderColor via a single array. If a value equivalent 
            to false is provided the border will be suppressed.
            @param {?Array} v - An array where index 0 is borderWidth, index 1 is border style and 
                index 2 is borderColor.
            @returns {undefined} */
        setBorder: function(v) {
            const [width, style, color] = v ?? [];
            this.setBorderWidth(width);
            this.setBorderStyle(style);
            this.setBorderColor(color);
        },
        
        setBorderWidth: function(v) {
            this.getODS().borderWidth = (this.borderWidth = v || 0) + 'px';
        },
        
        setBorderStyle: function(v) {
            this.getODS().borderStyle = this.borderStyle = v || 'none';
        },
        
        setBorderColor: function(v) {
            this.getODS().borderColor = this.borderColor = v || '#000';
        },
        
        // Edge treatements
        /** A convienence method to set rounded corners on an element.
            @param {number} radius - The radius of the corners.
            @returns {undefined} */
        setRoundedCorners: function(radius) {
            this.getODS().borderRadius = radius + 'px';
        },
        
        /** A convienence method to round the top left corner.
            @param {number} radius - The radius of the corner.
            @returns {undefined} */
        setRoundedTopLeftCorner: function(radius) {
            this.getODS().borderTopLeftRadius = radius + 'px';
        },
        
        /** A convienence method to round the top right corner.
            @param {number} radius - The radius of the corner.
            @returns {undefined} */
        setRoundedTopRightCorner: function(radius) {
            this.getODS().borderTopRightRadius = radius + 'px';
        },
        
        /** A convienence method to round the bottom left corner.
            @param {number} radius - The radius of the corner.
            @returns {undefined} */
        setRoundedBottomLeftCorner: function(radius) {
            this.getODS().borderBottomLeftRadius = radius + 'px';
        },
        
        /** A convienence method to round the bottom right corner.
            @param {number} radius - The radius of the corner.
            @returns {undefined} */
        setRoundedBottomRightCorner: function(radius) {
            this.getODS().borderBottomRightRadius = radius + 'px';
        },
        
        /** Sets the CSS boxShadow property.
            @param {?Array} v - An array where index 0 is the horizontal shadow offset, index 1 is 
                the vertical shadow offset, index 2 is the blur amount, and index 3 is the color.
            @returns {undefined} */
        setBoxShadow: function(v) {
            const [horizontalShadowOffset, verticalShadowOffset, blurAmt, color] = v ?? [];
            this.getODS().boxShadow = v ? (horizontalShadowOffset || 0) + 'px ' + (verticalShadowOffset || 0) + 'px ' + (blurAmt || 7) + 'px ' + (color || '#000') : 'none';
        },
        
        /** Sets the CSS liner-gradient or radial-gradient property. Setting this property will 
            take the place of any bgColor used in the view.
            @param {?Array} v - An array where:
                index 0: is the gradient type: linear or radial
                index 1: is the geometry of the gradient.
                    radial: The value "cover" / "farthest-corner" or "contain" / "closest-side"
                    linear: A number will be interpreted as the degrees or a string must be one of: 
                        top, top right, right, bottom  right, bottom, bottom left, left, top left
                index 3+: Are the color stops which must be a valid CSS color. If the first and 
                    second color stops will default to the textColor and bgColor properties of this 
                    view if not provided. Use of the rgba(0-255,0-255,0-255,0-1) syntax is a good 
                    way to designate colors since it will let you use an opacity. For a more 
                    comprehensive description of how to specify color stops 
                    see: https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient
            @returns {undefined} */
        setGradient: function(v) {
            const self = this,
                ods = self.getODS();
            if (v) {
                // Determine type
                let type = v[0];
                if (type === 'linear' || type === 'radial') {
                    v.shift();
                } else {
                    type = 'linear';
                }
                
                // Determine geometry of the gradient
                let geometry = v[0];
                if (type === 'radial') {
                    if (geometry === undefined) {
                        geometry = 'closest-side';
                    } else {
                        v.shift();
                    }
                    
                    let shape = v[0];
                    if (shape === undefined) {
                        shape = 'circle';
                    } else {
                        switch (shape) {
                            case 'circle':
                            case 'ellipse':
                                break;
                            default:
                                console.warn('Unexpected radial gradient shape', shape);
                                shape = 'circle';
                        }
                        v.shift();
                    }
                    
                    let origin = v[0];
                    if (origin === undefined) {
                        origin = 'center';
                    } else {
                        origin = origin.replaceAll('middle', 'center');
                        v.shift();
                    }
                    
                    geometry = shape + ' ' + geometry + ' at ' + origin;
                } else {
                    if (typeof geometry === 'number') {
                        geometry = geometry + 'deg';
                        v.shift();
                    } else if (geometry) {
                        geometry = 'to ' + geometry;
                        v.shift();
                    } else {
                        geometry = '0deg';
                    }
                }
                
                // Use colors that may have already been configured if less than 2 color stops 
                // are provided
                const pushColor = color => {
                    v.push(color && color !== 'inherit' ? color : 'transparent');
                };
                if (v.length < 2) pushColor(self.textColor);
                if (v.length < 2) pushColor(self.bgColor);
                
                ods.background = type + '-gradient(' + geometry + ',' + v.join(',') + ')';
            } else {
                ods.background = 'none';
            }
            
            // Wipe the bgColor property since setting style.background replaces the bgColor.
            self.bgColor = undefined;
        },
        
        /** Sets the tooltip.
            @param {string} v
            @return {undefined} */
        setTooltip: function(v) {
            if (this.tooltip !== v) {
                this.tooltip = this.getODE().title = v;
                if (this.inited) this.fireEvent('tooltip', v);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Checks that this view is visible and each view in the parent chain up to the RootView is 
            also visible. Dom elements are not explicitly checked. If you need to check dom elements 
            as well, use myt.DomElementProxy.isDomElementVisible.
            @returns {boolean} true if this view is visible, false otherwise. */
        isVisible: function() {
            return this.searchAncestorsOrSelf(v => !v.visible) == null;
        },
        
        /** Finds the youngest ancestor (or self) that is a focusTrap or focusCage.
            @param {boolean} ignoreFocusTrap - Indicates focusTraps should be ignored.
            @returns {?Object} a View with focusTrap set to true or undefined if not found. */
        getFocusTrap: function(ignoreFocusTrap) {
            return this.searchAncestorsOrSelf(v => v.focusCage || (v.focusTrap && !ignoreFocusTrap));
        },
        
        /** @overrides myt.Node
            Calls this.subviewAdded if the added subnode is a myt.View.
            @param {!Object} node
            @returns {undefined}
            
            @fires subviewAdded event with the provided Node if it's a View. 
            @fires layoutAdded event with the provided node if it's a Layout. */
        subnodeAdded: function(node) {
            if (node instanceof pkg.View) {
                this.getIDE().appendChild(node.getODE());
                this.getSubviews().push(node);
                this.fireEvent('subviewAdded', node);
                this.subviewAdded(node);
            } else if (node instanceof pkg.Layout) {
                this.getLayouts().push(node);
                this.fireEvent('layoutAdded', node);
                this.layoutAdded(node);
            }
        },
        
        /** @overrides myt.Node
            Calls this.subviewRemoved if the remove subnode is a myt.View.
            @param {!Object} node
            @returns {undefined}
            
            @fires subviewRemoved event with the provided Node if it's a View and removal succeeds. 
            @fires layoutRemoved event with the provided Node if it's a Layout and removal 
                succeeds. */
        subnodeRemoved: function(node) {
            let idx;
            if (node instanceof pkg.View) {
                idx = this.getSubviewIndex(node);
                if (idx > -1) {
                    this.fireEvent('subviewRemoved', node);
                    node.removeDomElement();
                    this.subviews.splice(idx, 1);
                    this.subviewRemoved(node);
                }
            } else if (node instanceof pkg.Layout) {
                idx = this.getLayoutIndex(node);
                if (idx > -1) {
                    this.fireEvent('layoutRemoved', node);
                    this.layouts.splice(idx, 1);
                    this.layoutRemoved(node);
                }
            }
        },
        
        // Subviews //
        /** Checks if this View has the provided View in the subviews array.
            @param {!Object} sv - The myt.View to look for.
            @returns {boolean} true if the subview is found, false otherwise. */
        hasSubview: function(sv) {
            return this.getSubviews().includes(sv);
        },
        
        /** Gets the index of the provided View in the subviews array.
            @param {!Object} sv - The myt.View to look for.
            @returns {number} the index of the subview or -1 if not found. */
        getSubviewIndex: function(sv) {
            return this.getSubviews().indexOf(sv);
        },
        
        /** Called when a View is added to this View. Do not call this method to add a View. 
            Instead call setParent.
            @param {!Object} sv - The myt.View that was added.
            @returns {undefined} */
        subviewAdded: sv => {},
        
        /** Called when a View is removed from this View. Do not call this method to remove a View. 
            Instead call setParent.
            @param {!Object} sv - The myt.View that was removed.
            @returns {undefined} */
        subviewRemoved: sv => {},
        
        /** Gets the next sibling view based on lexical ordering of dom elements.
            @returns {?Object} - The next sibling myt.View or undefined if none exists. */
        getNextSibling: function() {
            if (this.parent) return this.getODE().nextElementSibling?.model;
        },
        
        /** Gets the previous sibling view.
            @returns {?Object} - The previous sibling myt.View or undefined if none exists. */
        getPrevSibling: function() {
            if (this.parent) return this.getODE().previousElementSibling?.model;
        },
        
        /** Destroy all subviews of this View.
            @param {?Function} [filterFunc] - An optional function used to filter which subviews
                will be destroyed. The function is provided the subview and must return true if
                the subview should be destroyed. When no filter function is provided all subviews
                will be destroyed.
            @returns {undefined} */
        destroyAllSubviews: function(filterFunc) {
            const svs = this.getSubviews();
            for (let i = svs.length; i > 0;) {
                const sv = svs[--i];
                if (!filterFunc || filterFunc(sv)) sv.destroy();
            }
        },
        
        // Layouts //
        /** Checks if this View has the provided Layout in the layouts array.
            @param {!Object} layout - The myt.Layout to look for.
            @returns {boolean} true if the layout is found, false otherwise. */
        hasLayout: function(layout) {
            return this.getLayouts().includes(layout);
        },
        
        /** Gets the index of the provided Layout in the layouts array.
            @param {!Object} layout - The myt.Layout to look for.
            @returns {number} the index of the layout or -1 if not found. */
        getLayoutIndex: function(layout) {
            return this.getLayouts().indexOf(layout);
        },
        
        /** Called when a Layout is added to this View. Do not call this method to add a Layout. 
            Instead call setParent.
            @param {!Object} layout - The myt.Layout that was added.
            @returns {undefined} */
        layoutAdded: layout => {},
        
        /** Called when a Layout is removed from this View. Do not call this method to remove a 
            Layout. Instead call setParent.
            @param {!Object} layout - The myt.Layout that was removed.
            @returns {undefined} */
        layoutRemoved: layout => {},
        
        // Dom-Ordering //
        /** Test if the provided view is behind this view. The view to test can be anywhere in 
            the document.
            @param {!Object} view - The myt.View to check.
            @param {boolean} [checkZIndex] - If true z-index will first be used to check if the 
                view is behind or not.
            @returns {boolean} true if the view is behind this view, false otherwise. */
        isBehind: function(view, checkZIndex) {
            return comparePosition(this, view, false, checkZIndex);
        },
        
        /** Test if the provided view is front of this view. The view to test can be anywhere in 
            the document.
            @param {!Object} view - The myt.View to check.
            @param {boolean} [checkZIndex] - If true z-index will first be used to check if the 
                view is in front or not.
            @returns {boolean} true if the view is in front of this view, false otherwise. */
        isInFrontOf: function(view, checkZIndex) {
            return comparePosition(this, view, true, checkZIndex);
        },
        
        /** Brings this view to the front.
            @returns {undefined} */
        bringToFront: function() {
            this.parent.bringSubviewToFront(this);
        },
        
        /** Sends this view to the back.
            @returns {undefined} */
        sendToBack: function() {
            this.parent.sendSubviewToBack(this);
        },
        
        /** Sends this view behind the provided sibling view.
            @param {!Object} sv
            @param {?Object} [layout] - An optional layout that will also get updated.
            @returns {undefined} */
        sendBehind: function(sv, layout) {
            this.parent.sendSubviewBehind(this, sv, layout);
        },
        
        /** Sends this view in front of the provided sibling view.
            @param {!Object} sv
            @param {?Object} [layout] - An optional layout that will also get updated.
            @returns {undefined} */
        sendInFrontOf: function(sv, layout) {
            this.parent.sendSubviewInFrontOf(this, sv, layout);
        },
        
        /** Called whenever the subviews are reordered in the DOM using one of the reordering 
            functions of myt.View.
            @param {?Object} sv The subview that was reorderd or null if no specific subview can 
                be determined.
            @returns {undefined} */
        doSubviewsReorderedInDom: sv => {/* Subclasses to implement. */},
        
        /** Sends the provided subview to the back.
            @param {!Object} sv - The subview of this view to bring to front.
            @returns {undefined} */
        bringSubviewToFront: function(sv) {
            const self = this;
            if (sv?.parent === self) {
                const innerElem = self.getIDE(),
                    svOde = sv.getODE();
                if (svOde !== innerElem.lastElementChild) {
                    retainFocusDuringDomUpdate(sv, () => {
                        innerElem.appendChild(svOde);
                        self.doSubviewsReorderedInDom(sv);
                    });
                }
            }
        },
        
        /** Sends the provided subview to the back.
            @param {?Object} sv - The sub myt.View of this myt.View to send to back.
            @returns {undefined} */
        sendSubviewToBack: function(sv) {
            const self = this;
            if (sv?.parent === self) {
                const innerElem = self.getIDE(),
                    firstElementChild = innerElem.firstElementChild,
                    svOde = sv.getODE();
                if (svOde !== firstElementChild) {
                    retainFocusDuringDomUpdate(sv, () => {
                        innerElem.insertBefore(svOde, firstElementChild);
                        self.doSubviewsReorderedInDom(sv);
                    });
                }
            }
        },
        
        /** Sends the subview behind the existing subview.
            @param {!Object} sv - The sub myt.View to send behind the existing myt.View.
            @param {?Object} existing - The sub myt.View to send the other sub myt.View behind.
            @param {?Object} [layout] - An optional layout that will also get updated.
            @returns {undefined} */
        sendSubviewBehind: function(sv, existing, layout) {
            layout?.moveSubviewBefore(sv, existing);
            const self = this;
            if (sv?.parent === self && existing?.parent === self) {
                const svOde = sv.getODE(),
                    existingOde = existing.getODE();
                if (svOde !== existingOde.previousElementSibling) {
                    const innerElem = self.getIDE();
                    retainFocusDuringDomUpdate(sv, () => {
                        innerElem.insertBefore(svOde, existingOde);
                        self.doSubviewsReorderedInDom(sv);
                    });
                }
            }
            layout?.update();
        },
        
        /** Sends the subview in front of the existing subview.
            @param {!Object} sv - the subview to send in front of the existing view.
            @param {!Object} existing - the subview to send the other subview in front of.
            @param {?Object} [layout] - An optional layout that will also get updated.
            @returns {undefined} */
        sendSubviewInFrontOf: function(sv, existing, layout) {
            layout?.moveSubviewAfter(sv, existing);
            const self = this;
            if (sv?.parent === self && existing?.parent === self) {
                const svOde = sv.getODE(),
                    existingOdeNextElementSibling = existing.getODE().nextElementSibling;
                if (svOde !== existingOdeNextElementSibling) {
                    const innerElem = self.getIDE();
                    retainFocusDuringDomUpdate(sv, () => {
                        // Relies on insertBefore behavior: If existingOdeNextElementSibling is 
                        // nullish, then svOde is inserted at the end of innerElem's child nodes.
                        innerElem.insertBefore(svOde, existingOdeNextElementSibling);
                        self.doSubviewsReorderedInDom(sv);
                    });
                }
            }
            layout?.update();
        },
        
        /** Sorts the subviews array according to the provided sort function. Also rearranges the 
            dom elements so that focus navigation and z-ordering get updated.
            @param {!Function} sortFunc - The sort function to sort the subviews with.
            @returns {undefined} */
        sortSubviews: function(sortFunc) {
            // Sort subviews
            const self = this,
                svs = self.getSubviews();
            
            // OPTIMIZATION: Check if the svs are already sorted. If they're not then we will
            // resort and reorder the DOM. This occurs frequently enough that it is worth doing.
            if (pkg.isNotSorted(svs, sortFunc)) {
                svs.sort(sortFunc);
                
                // Rearrange the DOM to match the new sort order.
                doWhileRemovedFromDom(self, () => {
                    // Copy the dom elements in the correct order to a document fragment and 
                    // then add that fragment back to the dom.
                    const fragment = document.createDocumentFragment(),
                        len = svs.length;
                    for (let i = 0; len > i;) fragment.appendChild(svs[i++].getODE());
                    self.getIDE().appendChild(fragment);
                }, true);
                
                self.doSubviewsReorderedInDom(null);
            }
        },
        
        // Hit Testing //
        /** Checks if the provided location is inside this view or not.
            @param {number} locX - the x position to test.
            @param {number} locY - the y position to test.
            @param {?Object} [referenceFrameDomElem] - The dom element the locX and locY are 
                relative to. If not provided the page is assumed.
            @returns {boolean} True if the location is inside this view, false if not. */
        containsPoint: function(locX, locY, referenceFrameDomElem) {
            const outerElem = this.getODE();
            if (!outerElem) return false;
            const {x, y} = DomElementProxy.getRelativePosition(outerElem, referenceFrameDomElem);
            return rectContainsPoint(locX, locY, x, y, this.width, this.height);
        },
        
        /** Checks if the provided location is visible on this view and is not masked by the 
            bounding box of the view or any of its ancestor views.
            @param {number} locX
            @param {number} locY
            @returns {boolean} true if visible, false otherwise. */
        isPointVisible: function(locX, locY) {
            const {x, y} = this.getPagePosition(true);
            calculateEffectiveScale(this);
            return isPointVisible(this, locX - x, locY - y);
        },
        
        /** Tests if this View intersects with the provided sibling view. Transformations are not
            taken into account.
            @param {?Object} sibling - The sibling View to test against.
            @returns {boolean} indicating if the sibling View is indeed a sibling and that it
                intersects with this View. */
        intersectsWithSibling: function(sibling) {
            return sibling.parent === this.parent && !(
                sibling.x > this.x + this.width || 
                sibling.x + sibling.width < this.x || 
                sibling.y > this.y + this.height || 
                sibling.y + sibling.height < this.y
            );
        },
        
        getEffectiveScale: function() {
            return calculateEffectiveScale(this);
        },
        
        getEffectiveScaleX: function() {
            return calculateEffectiveScale(this).scaleX;
        },
        
        getEffectiveScaleY: function() {
            return calculateEffectiveScale(this).scaleY;
        }
    });
})(myt);


(pkg => {
    const
        updateBounds = view => {view.__updateBounds(view.width, view.height);},
        
        /*  Sets the 'transformOrigin' style property of the provided style property map.
                param view:View the view to modify.
                param v:string the transformOrigin to set. */
        setTransformOrigin = (view, v) => {
            view.getODS().transformOrigin = v || '50% 50% 0';
        },
        
        /*  Adds an entry to the 'transform' style property of the provided style property map.
                param view:View - The view to add the transform to.
                param type:string - The type of transform: 'rotate', 'scaleX', 'scaleY', 'skewX', 
                    'skewY'.
                param v:string the style value to set. */
        addTransform = (view, type, v) => {
            const cur = removeTransform(view, type);
            view.getODS().transform = cur + (cur.length === 0 ? '' : ' ') + type + '(' + v + ')';
        },
        
        /*  Removes an entry from the 'transform' style property of the provided style property 
            map. Returns the new transform value after the removal has been applied.
                param view:View the view ro remove the transform from.
                param type:string the type of transform: 'rotate', 'scaleX', 'scaleY', 'skewX', 
                    'skewY'. */
        removeTransform = (view, type) => {
            const ods = view.getODS(),
                value = ods.transform;
            
            if (!value || value.length === 0) return '';
            
            const parts = value.split(' ');
            let i = parts.length;
            while (i) {
                if (parts[--i].startsWith(type)) {
                    parts.splice(i, 1);
                    break;
                }
            }
            
            return ods.transform = parts.join(' ');
        },
        
        applyScale = (view, axis, v) => {
            if (v == null) {
                removeTransform(view, axis);
            } else {
                addTransform(view, axis, v || 1); // Also converts 0 to 1.
            }
        };
        
    /** Adds CSS3 transform support to a View.
        
        Events:
            transformOrigin:string
            rotation:number
            scaleX:number
            scaleY:number
            skewX:number
            skewY:number
        
        Attributes:
            transformOrigin:string The origin point for transforms.
            rotation:number The rotation in degrees.
            scale:number (write only) Sets the scale for the view in both the x and y dimension to 
                the same value. A value of 1 is no scaling, 0.5 is 50%, 2 is 200%, etc. Note: The 
                setters for scaleX and scaleY are not called.
            scaleX:number The scale for the view in the x-dimension. A value of 1 is no scaling, 
                0.5 is 50%, 2 is 200%, etc.
            scaleY:number The scale for the view in the y-dimension. A value of 1 is no scaling, 
                0.5 is 50%, 2 is 200%, etc.
            skewX:number Sets the horizontal skew in degrees.
            skewY:number Sets the vertical skew in degrees.
        
        @class */
    pkg.TransformSupport = new JS.Module('TransformSupport', {
        // Accessors ///////////////////////////////////////////////////////////
        setTransformOrigin: function(v) {
            if (this.transformOrigin !== v) {
                this.transformOrigin = v;
                setTransformOrigin(this, v);
                if (this.inited) {
                    updateBounds(this);
                    this.fireEvent('transformOrigin', v);
                }
            }
        },
        
        setRotation: function(v) {
            if (this.rotation !== v) {
                this.rotation = v;
                addTransform(this, 'rotate', (v || 0) + 'deg');
                if (this.inited) {
                    updateBounds(this);
                    this.fireEvent('rotation', v);
                }
            }
        },
        
        setScale: function(v) {
            const doUpdateX = this.scaleX !== v,
                doUpdateY = this.scaleY !== v;
            if (doUpdateX) applyScale(this, 'scaleX', this.scaleX = v);
            if (doUpdateY) applyScale(this, 'scaleY', this.scaleY = v);
            if (this.inited) {
                if (doUpdateX || doUpdateY) updateBounds(this);
                if (doUpdateX) this.fireEvent('scaleX', v);
                if (doUpdateY) this.fireEvent('scaleY', v);
            }
        },
        
        setScaleX: function(v) {
            if (this.scaleX !== v) {
                applyScale(this, 'scaleX', this.scaleX = v);
                if (this.inited) {
                    updateBounds(this);
                    this.fireEvent('scaleX', v);
                }
            }
        },
        
        setScaleY: function(v) {
            if (this.scaleY !== v) {
                applyScale(this, 'scaleY', this.scaleY = v);
                if (this.inited) {
                    updateBounds(this);
                    this.fireEvent('scaleY', v);
                }
            }
        },
        
        setSkewX: function(v) {
            if (this.skewX !== v) {
                this.skewX = v;
                addTransform(this, 'skewX', v || 0);
                if (this.inited) {
                    updateBounds(this);
                    this.fireEvent('skewX', v);
                }
            }
        },
        
        setSkewY: function(v) {
            if (this.skewY !== v) {
                this.skewY = v;
                addTransform(this, 'skewY', v || 0);
                if (this.inited) {
                    updateBounds(this);
                    this.fireEvent('skewY', v);
                }
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides
            @private */
        __updateBounds: function(width, height) {
            const {rotation, scaleX, scaleY} = this,
                notScaled = (scaleX == null || scaleX === 1) && (scaleY == null || scaleY === 1);
            if (notScaled && (rotation == null || rotation === 0 || rotation === 180)) {
                // Do nothing
            } else if (notScaled && (rotation === 90 || rotation === 270)) {
                // Swap x and y.
                ({width:height, height:width} = this);
            } else {
                ({width, height} = this.getODE().getBoundingClientRect());
            }
            this.callSuper(width, height);
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        
        setWidth = (view, value) => {
            if (value === 'auto') {
                view.__hasSetWidth = false;
                view.getODS().width = 'auto';
                view.sizeViewToDom();
            } else {
                view.__hasSetWidth = true;
                return true; // Tells callee to callSuper
            }
        },
        
        setHeight = (view, value) => {
            if (value === 'auto') {
                view.__hasSetHeight = false;
                view.getODS().height = 'auto';
                view.sizeViewToDom();
            } else {
                view.__hasSetHeight = true;
                return true; // Tells callee to callSuper
            }
        },
        
        sizeWidth = view => {
            if (!view.__hasSetWidth) {
                // Bounding rect doesn't factor in scaling so we need to calculate this ourselves.
                const w = view.getODE().offsetWidth / view.getEffectiveScaleX();
                
                // Circumvent setter
                if (view.width !== w) {
                    view.width = w;
                    if (view.inited) view.__updateBounds(w, view.height);
                    view.fireEvent('width', w);
                }
            }
        },
        
        sizeHeight = view => {
            if (!view.__hasSetHeight) {
                // Bounding rect doesn't factor in scaling so we need to calculate this ourselves.
                const h = view.getODE().offsetHeight / view.getEffectiveScaleY();
                
                // Circumvent setter
                if (view.height !== h) {
                    view.height = h;
                    if (view.inited) view.__updateBounds(view.width, h);
                    view.fireEvent('height', h);
                }
            }
        };
    
    /** A mixin that sizes the view to the width and height of the dom element.
        
        Attributes:
            width:number:string If a number the behavior is defined by the superclass. If a string 
                value of 'auto' is provided sizing to the dom will occur. Using 'auto' allows the 
                original SizeToDom behavior to be restored after an explicit width has been set.
            height:number:string If a number the behavior is defined by the superclass. If a string 
                value of 'auto' is provided sizing to the dom will occur. Using 'auto' allows the 
                original SizeToDom behavior to be restored after an explicit height has been set.
        
        Private Attributes:
            __hasSetWidth:boolean Indicates the an explicit width has been set so that width should 
                be used rather than sizing to the dom element.
            __hasSetHeight:boolean Indicates the an explicit height has been set so that height 
                should be used rather than sizing to the dom element.
        
        @class */
    pkg.SizeToDom = new JSModule('SizeToDom', {
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            sizeWidth:sizeWidth,
            sizeHeight:sizeHeight
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            this.sizeViewToDom();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.View */
        setWidth: function(v) {
            if (setWidth(this, v)) this.callSuper(v);
        },
        
        /** @overrides myt.View */
        setHeight: function(v) {
            if (setHeight(this, v)) this.callSuper(v);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Call this method after any change to the width or height of the dom element would 
            have occurred.
            @returns {undefined} */
        sizeViewToDom: function() {
            sizeWidth(this);
            sizeHeight(this);
        }
    });
    
    /** A variation of myt.SizeToDom that sizes the view to the width of the dom element only.
        
        Attributes:
            width:number:string If a number the behavior is defined by the superclass. If a string 
                value of 'auto' is provided sizing to the dom will occur. Using 'auto' allows the 
                original SizeToDom behavior to be restored after an explicit width has been set.
        
        Private Attributes:
            __hasSetWidth:boolean Indicates the an explicit width has been set so that width should 
                be used rather than sizing to the dom element.
        
        @class */
    pkg.SizeWidthToDom = new JSModule('SizeWidthToDom', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            this.sizeViewToDom();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.View */
        setWidth: function(v) {
            if (setWidth(this, v)) this.callSuper(v);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Call this method after any change to the width of the dom element would have occurred.
            @returns {undefined} */
        sizeViewToDom: function() {
            sizeWidth(this);
        }
    });
    
    /** A variation of myt.SizeToDom that sizes the view to the height of the dom element only.
        
        Attributes:
            height:number:string If a number the behavior is defined by the superclass. If a string 
                value of 'auto' is provided sizing to the dom will occur. Using 'auto' allows the 
                original SizeToDom behavior to be restored after an explicit height has been set.
        
        Private Attributes:
            __hasSetHeight:boolean Indicates the an explicit height has been set so that height 
                should be used rather than sizing to the dom element.
        
        @class */
    pkg.SizeHeightToDom = new JSModule('SizeHeightToDom', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            this.sizeViewToDom();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.View */
        setHeight: function(v) {
            if (setHeight(this, v)) this.callSuper(v);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Call this method after any change to the height of the dom element would have occurred.
            @returns {undefined} */
        sizeViewToDom: function() {
            sizeHeight(this);
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        
        /*  A private setter function that provides a common implementation for most of this 
            setters in the TextSupport mixin.
            @param {string|number} v
            @param {string} attrName
            @param {string|number} defaultValue
            @returns {undefined} */
        setAndSizeViewToDom = (textView, v, attrName, defaultValue) => {
            if (textView[attrName] !== v) {
                textView[attrName] = v;
                textView.getIDS()[attrName] = v || defaultValue || 'inherit';
                if (textView.inited) {
                    textView.fireEvent(attrName, v);
                    textView.sizeViewToDom();
                }
            }
        };
    
    /** Adds support for text display to a View.
        
        Requires:
            myt.SizeToDom super mixin.
        
        Events:
            text:string
            textOverflow:string
            textAlign:string
            whiteSpace:string
            overflowWrap:string
            wordWrap:string
            textIndent:string
            textTransform:string
            textDecoration:string
            lineHeight:string
            letterSpacing:string
            wordSpacing:string
            fontFamily:string
            fontStyle:string
            fontVariant:string
            fontWeight:string
            fontSize:string
        
        Attributes:
            text:string|event(string) The text to be displayed. The value will be assigned to the 
                inner html of the div.
            textOverflow:string How text will be treated when it overflows the bounds. Supported 
                values: 'ellipsis', 'clip', 'inherit'.
            textAlign:string How text will be aligned within the bounds. Supported values: 'left', 
                'right', 'center', 'justify', 'inherit'.
            whiteSpace:string How white space is handled. Supported values: 'normal', 'nowrap', 
                'pre', 'pre-wrap', 'pre-line', 'break-spaces', inherit'.
            wordWrap:string How line wrapping is done. Supported values: 'anywhere', 'break-word', 
                'normal'.
            textIndent:string How text gets indented. Supported values: '20px', '10%', 'inherit'.
            textTransform:string Transformation performed on the text during display. Supported 
                values: 'none', 'capitalize', 'uppercase', 'lowercase', 'inherit'.
            textDecoration:string Visual decoration to the text. Supported values: 'none', 
                'underline', 'overline', 'line-through', 'blink', 'inherit'.
            lineHeight:string The height of individual lines of text. Supported values: 'normal', 
                '1.5', '22px', '150%', 'inherit'.
            letterSpacing:string Spacing between letters. Supported values: 'normal', '3px', 
                'inherit'.
            wordSpacing:string Spacing between words. Supported values: 'normal', '3px', 'inherit'.
            fontFamily:string The name of a font to use. The value will be assigned to the font 
                family CSS parameter.
            fontStyle:string Styling applied to the text. Supported values: 'normal', 'italic', 
                'oblique', 'inherit'.
            fontVariant:string The font variant. Supported values: 'normal', 'small-caps', 'inherit'.
            fontWeight:string The font weight. Supported values: 'normal', 'bold', 'bolder', 
                'lighter', '100-900', 'inherit'.
            fontSize:string The size of the font. Supported values: 'normal, '14px', '14pt', 
                'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 
                'smaller', 'larger', '75%', 'inherit'.
            userUnselectable:boolean If set to true the CSS property user-select will be set to 
                'none' thus making text selection not work. Furthermore, the cursor will be set to 
                the default so it no longer appears as an i-beam.
        
        @class */
    pkg.TextSupport = new JSModule('TextSupport', {
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.View */
        setWidth: function(v) {
            this.callSuper(v);
            
            // Height can change with width change when wrapping occurs.
            if (v !== 'auto') {
                const ws = this.whiteSpace;
                if (ws === 'normal' || ws === 'pre-line' || ws === 'pre-wrap' || ws === 'break-spaces') {
                    this.sizeViewToDom();
                }
            }
        },
        
        setText: function(v) {
            if (!v) v = '';
            v = this.valueFromEvent(v);
            
            if (this.text !== v) {
                // Use innerHTML rather than textContent since this allows us to embed 
                // formatting markup.
                this.getIDE().innerHTML = this.text = v;
                if (this.inited) {
                    this.fireEvent('text', v);
                    this.sizeViewToDom();
                }
            }
        },
        
        // Text Attributes
        setTextOverflow: function(v) {
            if (this.textOverflow !== v) {
                this.textOverflow = v;
                this.getIDS().textOverflow = v || 'inherit';
                if (this.inited) this.fireEvent('textOverflow', v);
            }
        },
        
        setTextAlign: function(v) {
            if (this.textAlign !== v) {
                this.textAlign = v;
                this.getIDS().textAlign = v || 'inherit';
                if (this.inited) this.fireEvent('textAlign', v);
            }
        },
        
        setWhiteSpace: function(v) {setAndSizeViewToDom(this, v, 'whiteSpace');},
        setWordWrap: function(v) {setAndSizeViewToDom(this, v, 'wordWrap', 'normal');},
        setTextIndent: function(v) {setAndSizeViewToDom(this, v, 'textIndent');},
        setTextTransform: function(v) {setAndSizeViewToDom(this, v, 'textTransform');},
        setTextDecoration: function(v) {setAndSizeViewToDom(this, v, 'textDecoration');},
        setLineHeight: function(v) {setAndSizeViewToDom(this, v, 'lineHeight');},
        setLetterSpacing: function(v) {setAndSizeViewToDom(this, v, 'letterSpacing');},
        setWordSpacing: function(v) {setAndSizeViewToDom(this, v, 'wordSpacing');},
        
        // Font Attributes
        setFontFamily: function(v) {setAndSizeViewToDom(this, v, 'fontFamily');},
        setFontStyle: function(v) {setAndSizeViewToDom(this, v, 'fontStyle');},
        setFontVariant: function(v) {setAndSizeViewToDom(this, v, 'fontVariant');},
        setFontWeight: function(v) {setAndSizeViewToDom(this, v, 'fontWeight');},
        setFontSize: function(v) {setAndSizeViewToDom(this, v, 'fontSize');},
        
        setUserUnselectable: function(v) {
            if (this.userUnselectable !== v) {
                this.userUnselectable = v;
                this[v ? 'addDomClass' : 'removeDomClass']('mytUnselectable');
                if (this.cursor === 'default' || this.cursor === 'text') this.setCursor(v ? 'default' : 'text');
                if (this.inited) this.fireEvent('userUnselectable', v);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Configures the attributes for this Text so that an ellipsis will be displayed. To 
            actually see an ellipsis, an explicit width should be set on the Text so that overflow 
            will occur.
            @returns {undefined} */
        enableEllipsis: function() {
            this.setWhiteSpace('nowrap');
            this.setOverflow('hidden');
            this.setTextOverflow('ellipsis');
        },
        
        /** Turns ellipsis off by setting overflow to 'visible'. Other CSS related changes for 
            ellipsis are not undone such as whiteSpace and textOverflow.
            @returns {undefined} */
        disableEllipsis: function() {
            this.setOverflow('visible');
        },
        
        /** Turns on a text shadow.
            @param {number} [x] - The x offset in pixels of the shadow. Defaults to 0 if 
                not provided.
            @param {number} [y] - The y offset in pixels of the shadow. Defaults to 0 if 
                not provided.
            @param {number} [blur] - The bluriness in pixels of the shadow. Defaults to 2 if 
                not provided.
            @param {string} [color] - The color of the shadow. Defaults to '#000' if not provided.
            @returns {undefined} */
        showTextShadow: function(x, y, blur, color) {
            this.getIDS().textShadow = 
                (x || 0) + 'px ' + 
                (y || 0) + 'px ' + 
                (blur != null ? blur : 2) + 'px ' + 
                (color || '#000');
        },
        
        /** Turns off a text shadow.
            @returns {undefined} */
        hideTextShadow: function() {
            this.getIDS().textShadow = 'none';
        }
    });
    
    const setPaddingAndSizeViewToDom = (textView, v, side) => {
            const attrName = 'padding' + side;
            v = Math.max(v, 0);
            
            if (textView[attrName] !== v) {
                textView[attrName] = v;
                textView.getIDS()[attrName] = v + 'px';
                textView.fireEvent(attrName, v);
                if (side === 'Left' || side === 'Right') {
                    updateDomWidthForPadding(textView);
                } else {
                    updateDomHeightForPadding(textView);
                }
            }
        },
        
        updateDomWidthForPadding = textView => {
            if (textView.__hasSetWidth) {
                textView.getODS().width = textView.width - (textView.paddingLeft || 0) - (textView.paddingRight || 0) + 'px';
                if (textView.inited) textView.sizeViewToDom();
            }
        },
        
        updateDomHeightForPadding = textView => {
            if (textView.__hasSetHeight) {
                textView.getODS().height = textView.height - (textView.paddingTop || 0) - (textView.paddingBottom || 0) + 'px';
                if (textView.inited) textView.sizeViewToDom();
            }
        };
    
    /** Adds support for padded text display to a View.
        
        Requires:
            myt.TextSupport super mixin.
        
        Events:
            paddingTop:number
            paddingLeft:number
            paddingBottom:number
            paddingRight:number
        
        Attributes:
            paddingTop:number The padding above the text.
            paddingRight:number The padding to the right of the text.
            paddingBottom:number The padding to the left of the text.
            paddingLeft:number The padding below the text.
        
        @class */
    pkg.PaddedTextSupport = new JSModule('PaddedTextSupport', {
        setWidth: function(v) {
            this.callSuper(v);
            updateDomWidthForPadding(this);
        },
        
        setHeight: function(v) {
            this.callSuper(v);
            updateDomHeightForPadding(this);
        },
        
        // Padding Attributes
        setPadding: function(v) {
            let top,
                right,
                bottom,
                left;
            if (!v) v = 0;
            if (typeof v === 'object') {
                top = v.top || 0;
                right = v.right || 0;
                bottom = v.bottom || 0;
                left = v.left || 0;
            } else {
                top = right = bottom = left = v;
            }
            
            this.setPaddingTop(top);
            this.setPaddingRight(right);
            this.setPaddingBottom(bottom);
            this.setPaddingLeft(left);
        },
        setPaddingTop: function(v) {setPaddingAndSizeViewToDom(this, v, 'Top');},
        setPaddingRight: function(v) {setPaddingAndSizeViewToDom(this, v, 'Right');},
        setPaddingBottom: function(v) {setPaddingAndSizeViewToDom(this, v, 'Bottom');},
        setPaddingLeft: function(v) {setPaddingAndSizeViewToDom(this, v, 'Left');}
    });
})(myt);


(pkg => {
    const 
        /*  Stores widths and heights of images by URL so we don't have to reload them to 
            get sizes. */
        sizeCache = {},
        
        /*  Tracks requests to get the width and height of an image. Used to prevent multiple 
            requests being made for the same image URL. */
        openQueryCache = {},
        
        getSizeFromCache = imgUrl => sizeCache[imgUrl],
        
        /*  Loads an image to measure its size. */
        loadImageAndMeasureIt = imageView => {
            const imgUrl = imageView.imageUrl;
            if (imageView.calculateNaturalSize && imgUrl) {
                const cachedSize = getSizeFromCache(imgUrl);
                if (cachedSize) {
                    // Cache hit
                    imageView.setNaturalWidth(cachedSize.width);
                    imageView.setNaturalHeight(cachedSize.height);
                } else {
                    // Cache miss
                    let openQuery = openQueryCache[imgUrl];
                    if (!openQuery) {
                        // Lazy instantiate the open query array.
                        openQueryCache[imgUrl] = openQuery = [];
                        
                        // Start a size query
                        const img = new Image();
                        img.onerror = err => {
                            // Notify all ImageSupport instances that are waiting for a natural 
                            // size that an error has occurred.
                            const openQueries = openQueryCache[imgUrl];
                            if (openQueries) {
                                let i = openQueries.length;
                                while (i) openQueries[--i].setImageLoadingError(true);
                                
                                // Cleanup
                                openQueries.length = 0;
                                delete openQueryCache[imgUrl];
                            }
                        };
                        img.onload = () => {
                            // Notify all ImageSupport instances that are waiting for a 
                            // natural size.
                            const w = img.width,
                                h = img.height,
                                openQueries = openQueryCache[imgUrl];
                            if (openQueries) {
                                let i = openQueries.length;
                                while (i) {
                                    const imageSupportInstance = openQueries[--i];
                                    if (imageSupportInstance.imageUrl === imgUrl) {
                                        imageSupportInstance.setNaturalWidth(w);
                                        imageSupportInstance.setNaturalHeight(h);
                                    }
                                }
                                
                                // Cleanup
                                openQueries.length = 0;
                                delete openQueryCache[imgUrl];
                            }
                            
                            // Store size in cache.
                            sizeCache[imgUrl] = {width:w, height:h};
                        };
                        img.src = imgUrl;
                    }
                    
                    openQuery.push(imageView);
                }
            }
        };
    
    /** Adds support for image display to a View.
        
        Events:
            imageUrl:string
            imageSize:string
            imageRepeat:string
            imagePosition:string
            imageAttachment:string
            calculateNaturalSize:boolean
            naturalWidth:number
            naturalHeight:number
            useNaturalSize:boolean
            imageLoadingError:boolean
        
        Attributes:
            imageUrl:string The URL to load the image data from.
            imageSize:string Determines the size of the image. Allowed values are: 'auto', 'cover', 
                'contain', absolute ('20px 10px') and percentage ('100% 50%').
            imageRepeat:string Determines if an image is repeated or not. Allowed values: 'repeat', 
                'repeat-x', 'repeat-y', 'no-repeat', 'inherit'. Defaults to 'no-repeat'.
            imagePosition:string Determines where an image is positioned.
            imageAttachment:string Determines how an image is attached to the view. Allowed values 
                are: 'scroll', 'fixed', 'inherit'. The default value is 'scroll'.
            calculateNaturalSize:boolean Determines if the natural size should be automatically 
                calculated or not. Defaults to undefined which is equivalent to false.
            naturalWidth:number The natural width of the image. Only set if calculateNaturalWidth 
                is true.
            naturalHeight:number The natural height of the image. Only set if calculateNaturalWidth 
                is true.
            useNaturalSize:boolean If true this image view will be sized to the naturalWidth and 
                naturalHeight and calculateNaturalSize will be set to true.
            imageLoadingError:boolean Gets set to true when an error occurs loading the image. The 
                image will be loaded whenever the calculateNaturalSize attribute is set to true.
        
        @class */
    pkg.ImageSupport = new JS.Module('ImageSupport', {
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            getSizeFromCache: getSizeFromCache
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.Node */
        initNode: function(parent, attrs) {
            attrs.imageRepeat ??= 'no-repeat';
            attrs.imageAttachment ??= 'scroll';
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setImageUrl: function(v) {
            if (this.imageUrl !== v) {
                this.imageUrl = v;
                this.getIDS().backgroundImage = v ? 'url("' + v + '")' : 'none';
                if (this.inited) {
                    this.fireEvent('imageUrl', v);
                    this.setNaturalWidth();
                    this.setNaturalHeight();
                    
                    // Collapse size if no url and we are using natural size
                    if (!v && this.useNaturalSize) {
                        this.setWidth(0);
                        this.setHeight(0);
                    }
                }
                loadImageAndMeasureIt(this);
            }
        },
        
        setImageLoadingError: function(v) {this.set('imageLoadingError', v, true);},
        
        setImageSize: function(v) {
            if (this.imageSize !== v) {
                this.imageSize = v;
                this.getIDS().backgroundSize = v || 'auto';
                if (this.inited) this.fireEvent('imageSize', v);
            }
        },
        
        setImageRepeat: function(v) {
            if (this.imageRepeat !== v) {
                this.getIDS().backgroundRepeat = this.imageRepeat = v;
                if (this.inited) this.fireEvent('imageRepeat', v);
            }
        },
        
        setImagePosition: function(v) {
            if (this.imagePosition !== v) {
                this.getIDS().backgroundPosition = this.imagePosition = v;
                if (this.inited) this.fireEvent('imagePosition', v);
            }
        },
        
        setImageAttachment: function(v) {
            if (this.imageAttachment !== v) {
                this.getIDS().backgroundAttachment = this.imageAttachment = v;
                if (this.inited) this.fireEvent('imageAttachment', v);
            }
        },
        
        setCalculateNaturalSize: function(v) {
            if (this.calculateNaturalSize !== v) {
                this.calculateNaturalSize = v;
                if (this.inited) this.fireEvent('calculateNaturalSize', v);
                loadImageAndMeasureIt(this);
            }
        },
        
        setNaturalWidth: function(v) {
            if (this.naturalWidth !== v) {
                this.naturalWidth = v;
                if (this.inited) this.fireEvent('naturalWidth', v);
                if (this.useNaturalSize && v) this.setWidth(v);
            }
        },
        
        setNaturalHeight: function(v) {
            if (this.naturalHeight !== v) {
                this.naturalHeight = v;
                if (this.inited) this.fireEvent('naturalHeight', v);
                if (this.useNaturalSize && v) this.setHeight(v);
            }
        },
        
        setUseNaturalSize: function(v) {
            if (this.useNaturalSize !== v) {
                this.useNaturalSize = v;
                if (this.inited) this.fireEvent('useNaturalSize', v);
                
                // Sync width and height
                if (v) {
                    if (this.naturalWidth) this.setWidth(this.naturalWidth);
                    if (this.naturalHeight) this.setHeight(this.naturalHeight);
                }
                
                // Turn on calculation of natural size if we're going to use natural size.
                if (v && !this.calculateNaturalSize) this.setCalculateNaturalSize(true);
            }
        }
    });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        {View, SizeToDom} = pkg;
    
    /** A base class for flexbox views.
        
        @class */
    pkg.Flexbox = new JSClass('Flexbox', View, {
        include: [pkg.FlexboxSupport]
    });
    
    /** A view for an iframe. This component also listens to global mousedown and mouseup events 
        and turns off point-events so that the iframe will interfere less with mouse behavior in 
        the parent document.
        
        Events:
            src:string
        
        Attributes:
            src:string The URL to an HTML document to load into the iframe.
        
        Private Attributes:
            __restorePointerEvents:string The value of pointerEvents before a mousedown occurs. 
                Used as part of turning off pointer-events so that the iframe messes less with 
                mouse behavior in the parent document.
        
        @class */
    pkg.Frame = new JSClass('Frame', View, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            attrs.tagName ??= 'iframe';
            
            this.callSuper(parent, attrs);
            
            const GlobalMouse = pkg.global.mouse;
            this.attachToDom(GlobalMouse, '__doMouseDown', 'mousedown', true);
            this.attachToDom(GlobalMouse, '__doMouseUp', 'mouseup', true);
        },
        
        /** @overrides myt.View */
        createOurDomElement: function(parent) {
            const elements = this.callSuper(parent),
                innerElem = Array.isArray(elements) ? elements[1] : elements;
            innerElem.style.border = '0px';
            return elements;
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setSrc: function(v) {
            if (this.src !== v) {
                this.src = this.getIDE().src = v;
                if (this.inited) this.fireEvent('src', v);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doMouseDown: function(event) {
            this.__restorePointerEvents = this.pointerEvents;
            this.setPointerEvents('none');
            return true;
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doMouseUp: function(event) {
            this.setPointerEvents(this.__restorePointerEvents);
            return true;
        }
    });
    
    /** Displays HTML markup and resizes the view to fit the markup.
        
        Attributes:
            html:string The HTML to insert into the view.
        
        @class */
    pkg.Markup = new JSClass('Markup', View, {
        include: [SizeToDom],
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setHtml: function(v) {
            const self = this;
            if (self.html !== v) {
                self.getIDE().innerHTML = self.html = v;
                if (self.inited) {
                    self.fireEvent('html', v);
                    self.sizeViewToDom();
                }
            }
        }
    });
    
    /** Displays text content.
        
        @class */
    pkg.Text = new JSClass('Text', View, {
        include: [SizeToDom, pkg.TextSupport],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            attrs.whiteSpace ??= 'nowrap';
            attrs.userUnselectable ??= true;
            
            this.callSuper(parent, attrs);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Measures the width of this element as if the wrapping was set to 'nowrap'. The dom 
            element is manipulated directly so that no events get fired.
            @returns number the unwrapped width of this text view. */
        measureNoWrapWidth: function() {
            const self = this,
                hasSetWidth = self.__hasSetWidth,
                oldWidth = self.width;
            
            if (!hasSetWidth && self.whiteSpace === 'nowrap') return oldWidth;
            
            // Temporarily set wrapping to 'nowrap', take measurement and then restore wrapping.
            const ids = self.getIDS(),
                oldValue = ids.whiteSpace;
            if (hasSetWidth) ids.width = 'auto';
            ids.whiteSpace = 'nowrap';
            const measuredWidth = self.getODE().getBoundingClientRect().width; // Use getBoundingClientRect to support fractional widths
            ids.whiteSpace = oldValue;
            if (hasSetWidth) ids.width = oldWidth;
            return measuredWidth;
        }
    });
    
    /** Displays padded text content.
        
        @class */
    pkg.PaddedText = new JSClass('PaddedText', pkg.Text, {
        include: [pkg.PaddedTextSupport]
    });
    
    /** A view that displays an image. By default useNaturalSize is set to true so the Image will 
        take on the size of the image data.
        
        @class */
    pkg.Image = new JSClass('Image', View, {
        include: [pkg.ImageSupport],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            attrs.useNaturalSize ??= true;
            
            this.callSuper(parent, attrs);
        }
    });
    
    /** A view that keeps the first subview added to it always in the back. Subclasses such as 
        Canvas and Annulus will make use of this feature to allow the appearance of subview 
        support for HTML elements that ordinarily do not allow sub elements.
        
        @class */
    pkg.BackView = new JSClass('BackView', View, {
        /** @overrides
            Prevent views from being sent behind the first subview added to this view. This allows 
            us to add child views that will always stay in front. */
        sendSubviewToBack: function(sv) {
            if (sv.parent === this) {
                const ide = this.getIDE(),
                    firstChild = ide.childNodes[1],
                    svOde = sv.getODE();
                if (svOde !== firstChild) {
                    const removedElem = ide.removeChild(svOde);
                    if (removedElem) ide.insertBefore(removedElem, firstChild);
                }
            }
        }
    });
})(myt);


(pkg => {
    const mathRound = Math.round,
        
        setupPercentOfParentWidthConstraint = stp => {
            if (stp.parent && stp.percentOfParentWidth >= 0) stp.syncTo(stp.parent, '__doPOPW', 'width');
        },
        
        teardownPercentOfParentWidthConstraint = stp => {
            if (stp.percentOfParentWidth >= 0) stp.detachFrom(stp.parent, '__doPOPW', 'width');
        },
        
        setupPercentOfParentHeightConstraint = stp => {
            if (stp.parent && stp.percentOfParentHeight >= 0) stp.syncTo(stp.parent, '__doPOPH', 'height');
        },
        
        teardownPercentOfParentHeightConstraint = stp => {
            if (stp.percentOfParentHeight >= 0) stp.detachFrom(stp.parent, '__doPOPH', 'height');
        };
    
    /** A mixin that sizes a view to a percentage of its parent view.
        
        This is the inverse of a layout since the child is responsible for sizing itself to the 
        parent rather than in a layout where the layout positions and sizes the children.
        
        Events:
            percentOfParentWidthOffset:number
            percentOfParentHeightOffset:number
            percentOfParentWidth:number
            percentOfParentHeight:number
            
        Attributes:
            percentOfParentWidthOffset:number An additional offset used to adjust the width of the 
                parent. Defaults to undefined which is equivalent to 0.
            percentOfParentHeightOffset:number An additional offset used to adjust the height of 
                the parent. Defaults to undefined which is equivalent to 0.
            percentOfParentWidth:number The percent of the parent views width to size this views 
                width to. Should be a number between 0 and 100 or a negative value which means 
                don't do resizing. Defaults to undefined which is equivalent to a negative value.
            percentOfParentHeight:number The percent of the parent views height to size this views 
                height to. Should be a number between 0 and 100 or a negative value which means 
                don't do resizing. Defaults to undefined which is equivalent to a negative value.
        
        @class */
    pkg.SizeToParent = new JS.Module('SizeToParent', {
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.View */
        setParent: function(parent) {
            if (this.parent !== parent) {
                if (this.inited) {
                    teardownPercentOfParentWidthConstraint(this);
                    teardownPercentOfParentHeightConstraint(this);
                }
                this.callSuper(parent);
                setupPercentOfParentWidthConstraint(this);
                setupPercentOfParentHeightConstraint(this);
            }
        },
        
        setPercentOfParentWidthOffset: function(v) {
            if (this.percentOfParentWidthOffset !== v) {
                this.percentOfParentWidthOffset = v;
                if (this.inited) {
                    this.fireEvent('percentOfParentWidthOffset', v);
                    this.__doPOPW();
                }
            }
        },
        
        setPercentOfParentWidth: function(v) {
            if (this.percentOfParentWidth !== v) {
                if (this.inited) teardownPercentOfParentWidthConstraint(this);
                this.percentOfParentWidth = v;
                if (this.inited) this.fireEvent('percentOfParentWidth', v);
                setupPercentOfParentWidthConstraint(this);
            }
        },
        
        setPercentOfParentHeightOffset: function(v) {
            if (this.percentOfParentHeightOffset !== v) {
                this.percentOfParentHeightOffset = v;
                if (this.inited) {
                    this.fireEvent('percentOfParentHeightOffset', v);
                    this.__doPOPH();
                }
            }
        },
        
        setPercentOfParentHeight: function(v) {
            if (this.percentOfParentHeight !== v) {
                if (this.inited) teardownPercentOfParentHeightConstraint(this);
                this.percentOfParentHeight = v;
                if (this.inited) this.fireEvent('percentOfParentHeight', v);
                setupPercentOfParentHeightConstraint(this);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doPOPW: function(event) {
            this.setWidth((this.percentOfParentWidthOffset || 0) + mathRound(this.parent.width * (this.percentOfParentWidth / 100)));
            // Force width event if not inited yet so that align constraint in myt.View will work.
            if (!this.inited) this.fireEvent('width', this.width);
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doPOPH: function(event) {
            this.setHeight((this.percentOfParentHeightOffset || 0) + mathRound(this.parent.height * (this.percentOfParentHeight / 100)));
            // Force height event if not inited yet so that valign constraint in myt.View will work.
            if (!this.inited) this.fireEvent('height', this.height);
        }
    });
})(myt);


(pkg => {
    let globalRootViewRegistry;
    
    /* Holds an array of RootViews. */
    const roots = [];
    
    /** Provides events when a new myt.RootView is created or destroyed.
        Registered in myt.global as 'roots'.
        
        Events:
            rootAdded:RootView Fired when a RootView is added. The value is the added RootView.
            rootRemoved:RootView Fired when a RootView is removed. The value is the removed RootView.
        
        @class */
    new JS.Singleton('GlobalRootViewRegistry', {
        include: [pkg.Observable],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initialize: function() {
            pkg.global.register('roots', globalRootViewRegistry = this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** Gets the list of global root views.
            @returns {!Array} of RootViews. */
        getRoots: () => roots,
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Add a rootable to the global list of root views.
            @param {!Object} r - The RootView to add.
            @returns {undefined} */
        addRoot: r => {
            roots.push(r);
            globalRootViewRegistry.fireEvent('rootAdded', r);
        },
        
        /** Remove a rootable from the global list of root views.
            @param {!Object} rootToRemove - The RootView to remove.
            @returns {undefined} */
        removeRoot: rootToRemove => {
            const idx = roots.indexOf(rootToRemove);
            if (idx > -1) {
                roots.splice(idx, 1);
                globalRootViewRegistry.fireEvent('rootRemoved', rootToRemove);
            }
        }
    });
})(myt);


(pkg => {
    const 
        {addEventListener, removeEventListener, global:{roots}} = pkg,
        
        /** Allows a view to act as a "root" for a view hierarchy. A "root" view is backed by a 
            dom element from the page rather than a dom element created by the view.
            
            Attributes:
                keepDomElementWhenDestroyed:boolean Indicates the dom element backing this view 
                    must not be destroyed when this view is destroyed. Defaults to undefined which 
                    is equivalent to false.
            
            @class */
        RootView = pkg.RootView = new JS.Module('RootView', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** Prevents default drag/drop behavior.
                    @param {!Obect} view - The myt.View the view to suppress default dragover and 
                        drop on.
                    @returns {undefined} */
                setupCaptureDrop: view => {
                    const ide = view.getIDE(),
                        cdf = view.__captureDrop = event => {event.preventDefault();};
                    addEventListener(ide, 'drop', cdf);
                    addEventListener(ide, 'dragover', cdf);
                },
                
                /** Cleanup dom listeners for drag/drop.
                    @param {!Obect} view - The myt.View the view that had suppressed default 
                        dragover and drop on.
                    @returns {undefined} */
                teardownCaptureDrop: view => {
                    const ide = view.getIDE(), 
                        cdf = view.__captureDrop;
                    removeEventListener(ide, 'drop', cdf);
                    removeEventListener(ide, 'dragover', cdf);
                }
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.callSuper(parent, attrs);
                
                // Establish a stacking context
                this.setZIndex(0);
                
                // Set a css class to allow scoping of CSS rules
                this.addDomClass('myt');
                
                roots.addRoot(this);
                
                RootView.setupCaptureDrop(this);
            },
            
            /** @overrides myt.View */
            createOurDomElement: function(parent) {
                // If no parent is provided create a new dom element
                if (!parent) {
                    parent = this.callSuper(parent);
                    pkg.getElement().appendChild(parent);
                }
                
                // A root view has a dom element provided as the parent. We use that as 
                // our dom element.
                return parent;
            },
            
            /** @overrides myt.View */
            destroy: function() {
                RootView.teardownCaptureDrop(this);
                
                roots.removeRoot(this);
                if (!this.keepDomElementWhenDestroyed) this.removeDomElement();
                this.callSuper();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setKeepDomElementWhenDestroyed: function(keepDomElementWhenDestroyed) {
                this.keepDomElementWhenDestroyed = keepDomElementWhenDestroyed;
            },
            
            /** @overrides myt.Node */
            setParent: parent => {/* A root view has no parent view so do nothing. */},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.View */
            bringToFront: function() {
                // Attempt to manipulate dom above root node.
                const ide = this.getIDE(),
                    parentNode = ide.parentNode;
                if (ide !== parentNode.lastChild) {
                    const removedElem = parentNode.removeChild(ide);
                    if (removedElem) parentNode.appendChild(removedElem);
                }
            },
            
            /** @overrides myt.View */
            sendToBack: function() {
                // Attempt to manipulate dom above root node.
                const ide = this.getIDE(),
                    parentNode = ide.parentNode;
                if (ide !== parentNode.firstChild) {
                    const removedElem = parentNode.removeChild(ide);
                    if (removedElem) parentNode.insertBefore(removedElem, parentNode.firstChild);
                }
            },
            
            /** @overrides myt.View */
            sendBehind: function(otherRootView, ignoredLayout) {
                // Attempt to manipulate dom above root node.
                const ide = this.getIDE(),
                    otherIde = otherRootView.getIDE(),
                    parentNode = ide.parentNode;
                if (otherIde.parentNode === parentNode) {
                    const removedElem = parentNode.removeChild(ide);
                    if (removedElem) parentNode.insertBefore(removedElem, otherIde);
                }
            },
            
            /** @overrides myt.View */
            sendInFrontOf: function(otherRootView, ignoredLayout) {
                // Attempt to manipulate dom above root node.
                if (otherRootView.getIDE().parentNode === this.getIDE().parentNode) {
                    this.sendBehind(otherRootView, ignoredLayout);
                    otherRootView.sendBehind(this, ignoredLayout);
                }
            }
        });
})(myt);


(pkg => {
    let 
        /*  The ID of the last idle event in the browser. */
        timerId,
        
        /*  The millis of the last idle event fired. */
        lastTime,
        
        /*  Indicates if idle events are currently being fired or not. */
        running = false;
    
    const {requestAnimationFrame, cancelAnimationFrame} = window,
        
        /*  The idle event object that gets reused. */
        EVENT = {},
        
        /*  The function that gets executed on idle. */
        idleFunc = time => {
            timerId = requestAnimationFrame(idleFunc);
            time = Math.round(time);
            if (lastTime !== -1) {
                EVENT.delta = time - lastTime;
                EVENT.time = time;
                globalIdle.fireEvent('idle', EVENT);
            }
            lastTime = time;
        },
        
        /** Provides idle events. Registered with myt.global as 'idle'.
            
            Events:
                idle:object Fired when a browser idle event occurs. The event value is an 
                    object containing:
                        delta: The time in millis since the last idle evnet.
                        time: The time in millis of this idle event.
            
            @class */
        globalIdle = new JS.Singleton('GlobalIdle', {
            include: [pkg.Observable],
            
            
            // Constructor /////////////////////////////////////////////////////
            initialize: function() {
                pkg.global.register('idle', this);
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.Observable */
            attachObserver: (observer, methodName, type) => {
                const retval = globalIdle.callSuper(observer, methodName, type);
                
                // Start firing idle events
                if (!running && globalIdle.hasObservers('idle')) {
                    running = true;
                    lastTime = -1;
                    timerId = requestAnimationFrame(idleFunc);
                }
                
                return retval;
            },
            
            /** @overrides myt.Observable */
            detachObserver: (observer, methodName, type) => {
                const retval = globalIdle.callSuper(observer, methodName, type);
                
                // Stop firing idle events
                if (running && !globalIdle.hasObservers('idle')) {
                    cancelAnimationFrame(timerId);
                    running = false;
                }
                
                return retval;
            }
        });
})(myt);


(pkg => {
    let globalWindowResize,
        
        /*  The clientWidth of the window.document.body. */
        clientWidth,
        
        /*  The clientHeight of the window.document.body. */
        clientHeight;
    
    const G = pkg.global,
        globalIdle = G.idle,
        doc = window.document;
    
    /** Provides events when the window's body is resized. Registered with myt.global 
        as 'windowResize'.
        
        Events:
            resize:object Fired when the window.document.body is resized. The type is 'resize' and 
                the value is an object containing:
                    w:number the new window.document.body clientWidth.
                    h:number the new window.document.body clientHeight.
        
        @class */
    new JS.Singleton('GlobalWindowResize', {
        include: [pkg.Observable, pkg.Observer],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initialize: function() {
            globalWindowResize = this;
            
            // We need to wait for the body to exist.
            globalWindowResize.attachTo(globalIdle, '__setup', 'idle');
            G.register('windowResize', globalWindowResize);
        },
        
        /** @private */
        __setup: ignoredEvent => {
            const body = doc.body;
            if (body) {
                globalWindowResize.detachFrom(globalIdle, '__setup', 'idle');
                new ResizeObserver(() => {
                    globalWindowResize.fireEvent('resize', {w:clientWidth = body.clientWidth, h:clientHeight = body.clientHeight});
                }).observe(body);
            }
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** Gets the window.document.body's clientWidth.
            @returns {number} - The current width of the window.document.body. */
        getWidth: () => clientWidth ??= doc.body.clientWidth,
        
        /** Gets the window.document.body's clientHeight.
            @returns {number} - The current height of the window.document.body. */
        getHeight: () => clientHeight ??= doc.body.clientHeight
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        GlobalWindowResize = pkg.global.windowResize,
        
        mathMax = Math.max,
        
        handleResize = sizeToWindow => {
            const dim = sizeToWindow.resizeDimension;
            if (dim === 'both' || dim === 'width') sizeToWindow.setWidth(mathMax(sizeToWindow.minWidth, GlobalWindowResize.getWidth()));
            if (dim === 'both' || dim === 'height') sizeToWindow.setHeight(mathMax(sizeToWindow.minHeight, GlobalWindowResize.getHeight()));
        },
        
        /** A mixin that sizes a RootView to the window width, height or both.
            
            Attributes:
                resizeDimension:string The dimension to resize in. Supported values are 'width', 
                    'height' and 'both'. Defaults to 'both'.
                minWidth:number the minimum width below which this view will not resize its width. 
                    Defaults to 0.
                minWidth:number the minimum height below which this view will not resize its 
                    height. Defaults to 0.
            
            @class */
        SizeToWindow = pkg.SizeToWindow = new JSModule('SizeToWindow', {
            include: [pkg.RootView],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                this.minWidth = this.minHeight = 0;
                attrs.resizeDimension ??= 'both';
                
                this.attachTo(GlobalWindowResize, '__hndlResize', 'resize');
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setResizeDimension: function(v) {
                if (this.resizeDimension !== v) {
                    this.resizeDimension = v;
                    handleResize(this);
                }
            },
            
            setMinWidth: function(v) {
                if (this.minWidth !== v) {
                    this.minWidth = v;
                    handleResize(this);
                }
            },
            
            setMinHeight: function(v) {
                if (this.minHeight !== v) {
                    this.minHeight = v;
                    handleResize(this);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @private
                @param {!Object} ignoredEvent
                @returns {undefined} */
            __hndlResize: function(ignoredEvent) {
                handleResize(this);
            }
        });
    
    /** A mixin that sizes a RootView to the window width.
        
        @class */
    pkg.SizeToWindowWidth = new JSModule('SizeToWindowWidth', {
        include: [SizeToWindow],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.SizeToWindow */
        initNode: function(parent, attrs) {
            attrs.resizeDimension ??= 'width';
            this.callSuper(parent, attrs);
        }
    });
    
    /** A mixin that sizes a RootView to the window height.
        
        @class */
    pkg.SizeToWindowHeight = new JSModule('SizeToWindowHeight', {
        include: [SizeToWindow],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.SizeToWindow */
        initNode: function(parent, attrs) {
            attrs.resizeDimension ??= 'height';
            this.callSuper(parent, attrs);
        }
    });
})(myt);


(pkg => {
    const math = Math,
        {min:mathMin, max:mathMax} = math,
        
        cleanChannelValue = value => mathMin(255, mathMax(0, math.round(value))),
        toHex = value => cleanChannelValue(value).toString(16).padStart(2, '0'),
        rgbToHex = (red, green, blue, prependHash) => (prependHash ? '#' : '') + toHex(red) + toHex(green) + toHex(blue),
        getRedChannel = value => (0xff0000 & value) >> 16,
        getGreenChannel = value => (0x00ff00 & value) >> 8,
        getBlueChannel = value => (0x0000ff & value),
        makeColorFromNumber = value => new Color(getRedChannel(value), getGreenChannel(value), getBlueChannel(value)),
        makeColorNumberFromChannels = (red, green, blue) => (cleanChannelValue(red) << 16) + (cleanChannelValue(green) << 8) + cleanChannelValue(blue),
        toUnitRange = (num, max) => {
            if (typeof num === 'string') {
                if (num.endsWith('%')) {
                    num = parseFloat(num.slice(0, -1)) * max / 100;
                } else {
                    return 0;
                }
            }
            num = mathMin(max, mathMax(0, num)) / max;
            return math.abs(1 - num) < 0.000001 ? 1 : num;
        },
        
        rgbToHsv = (r, g, b) => {
            r = toUnitRange(r, 255);
            g = toUnitRange(g, 255);
            b = toUnitRange(b, 255);
            
            const max = mathMax(r, g, b),
                diff = max - mathMin(r, g, b);
            if (diff === 0) {
                // achromatic
                return {h:0, s:0, v:max};
            } else {
                let h;
                switch (max) {
                    case r:
                        h = (g - b) / diff + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / diff + 2;
                        break;
                    case b:
                        h = (r - g) / diff + 4;
                        break;
                }
                return {h:h * 60, s:max === 0 ? 0 : diff / max, v:max};
            }
        },
        
        hsvToRgb = (h, s, v) => {
            h = toUnitRange(h, 360) * 6;
            s = toUnitRange(s, 100);
            v = toUnitRange(v, 100);
            
            const i = math.floor(h),
                f = h - i,
                p = v * (1 - s),
                q = v * (1 - f * s),
                t = v * (1 - (1 - f) * s),
                mod = i % 6,
                red = [v, q, p, p, t, v][mod],
                green = [t, v, v, q, p, p][mod],
                blue = [p, p, t, v, v, q][mod];
            
            return {red:red * 255, green:green * 255, blue:blue * 255};
        },
        
        /** Models a color as individual color channels.
            
            Attributes:
                red:int The red channel. Will be an integer between 0 and 255.
                green:int The green channel. Will be an integer between 0 and 255.
                blue:int The blue channel. Will be an integer between 0 and 255.
            
            @class */
        Color = pkg.Color = new JS.Class('Color', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                toUnitRange:toUnitRange,
                rgbToHsv:rgbToHsv,
                hsvToRgb:hsvToRgb,
                
                /** Converts a number or string representation of a number to a two character 
                    hex string.
                    @param {number|string} value - The number or string to convert.
                    @returns {string} A two character hex string such as: '0c' or 'c9'. */
                toHex: toHex,
                
                /** Converts red, green, and blue color channel numbers to a six character 
                    hex string.
                    @param {number} red - The red color channel.
                    @param {number} green - The green color channel.
                    @param {number} blue - The blue color channel.
                    @param {boolean} [prependHash] - If true a '#' character will be prepended to 
                        the return value.
                    @returns {string} Something like: '#ff9c02' or 'ff9c02' */
                rgbToHex: rgbToHex,
                
                /** Limits a channel value to integers between 0 and 255.
                    @param {number} value - The channel value to clean up.
                    @returns {number} */
                cleanChannelValue: cleanChannelValue,
                
                /** Gets the red channel from a "color" number.
                    @param {string} value
                    @returns {number} */
                getRedChannel: getRedChannel,
                
                /** Gets the green channel from a "color" number.
                    @param {string} value
                    @returns {number} */
                getGreenChannel: getGreenChannel,
                
                /** Gets the blue channel from a "color" number.
                    @param {string} value
                    @returns {number} */
                getBlueChannel: getBlueChannel,
                
                /** Creates an myt.Color from a "color" number.
                    @param {string} value
                    @returns {!Object} myt.Color */
                makeColorFromNumber: makeColorFromNumber,
                
                /** Creates an myt.Color from an html color string.
                    @param {string} value - A hex string representation of a color, such 
                        as '#ff339b'.
                    @returns {!Object} a myt.Color or undefined if no color could be parsed. */
                makeColorFromHexString: value => {
                    if (value) {
                        if (value.startsWith('#')) value = value.slice(1);
                        
                        switch (value.length) {
                            case 0: value += '0'; // Append "0" to missing channels.
                            case 1: value += '0'; // Append "0" to missing channels.
                            case 2: value += '0'; // Append "0" to missing channels.
                            case 3:
                            case 4:
                            case 5:
                                // Process as: R G B ignored
                                const [r, g, b] = value;
                                return new Color(
                                    parseInt(r + r, 16),
                                    parseInt(g + g, 16),
                                    parseInt(b + b, 16)
                                );
                            case 6:
                                // Process as RR GG BB
                                return makeColorFromNumber(parseInt(value, 16));
                            default:
                                // Process as RR GG BB ignored
                                return makeColorFromNumber(parseInt(value.slice(0,6), 16));
                        }
                    }
                },
                
                /** Creates an myt.Color from hue, saturation and value parameters.
                    @param {number} h - The hue. A number from 0 to 360.
                    @param {number} s - The saturation. A number from 0 to 100.
                    @param {number} v - The value. A number from 0 to 100.
                    @returns {!Object} myt.Color */
                makeColorFromHSV: (h, s, v) => {
                    const {red, green, blue} = hsvToRgb(h, s, v);
                    return new Color(red, green, blue);
                },
                
                /** Returns the lighter of the two provided colors.
                    @param {number} a - A color number.
                    @param {number} b - A color number.
                    @returns {number} The number that represents the lighter color. */
                getLighterColor: (a, b) => makeColorFromNumber(a).isLighterThan(makeColorFromNumber(b)) ? a : b,
                
                /** Creates an RGB "color" number from the provided color channels.
                    @param {number} red - The red channel
                    @param {number} green - The green channel
                    @param {number} blue - The blue channel
                    @returns {number} */
                makeColorNumberFromChannels: makeColorNumberFromChannels,
                
                /** Creates a new myt.Color object that is a blend of the two provided colors.
                    @param {!Object} fromColor - The first myt.Color to blend.
                    @param {!Objecdt} toColor - The second myt.Color to blend.
                    @param {number} percent - The blend percent between the two colors where 0 is 
                        the fromColor and 1.0 is the toColor.
                    @returns {!Object} myt.Color */
                makeBlendedColor: (fromColor, toColor, percent) => new Color(
                    fromColor.red + (percent * (toColor.red - fromColor.red)),
                    fromColor.green + (percent * (toColor.green - fromColor.green)),
                    fromColor.blue + (percent * (toColor.blue - fromColor.blue))
                )
            },
            
            
            // Constructor /////////////////////////////////////////////////////
            /** Create a new Color.
                @param {number} red - The red channel
                @param {number} green - The green channel
                @param {number} blue - The blue channel
                @returns {undefined} */
            initialize: function(red, green, blue) {
                this.setRed(red);
                this.setGreen(green);
                this.setBlue(blue);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** Sets the red channel value.
                @param {number} red
                @return {undefined} */
            setRed: function(red) {
                this.red = cleanChannelValue(red);
            },
            
            /** Sets the green channel value.
                @param {number} green
                @return {undefined} */
            setGreen: function(green) {
                this.green = cleanChannelValue(green);
            },
            
            /** Sets the blue channel value.
                @param {number} blue
                @return {undefined} */
            setBlue: function(blue) {
                this.blue = cleanChannelValue(blue);
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Gets the numerical representation of this color.
                @returns {number} The number that represents this color. */
            getColorNumber: function() {
                return (this.red << 16) + (this.green << 8) + this.blue;
            },
            
            /** Gets the hex string representation of this color.
                @returns {string} A hex color such as '#a0bbcc'. */
            getHtmlHexString: function() {
                return rgbToHex(this.red, this.green, this.blue, true);
            },
            
            /** Gets an HSV representation of this Color.
                @returns {!Object} With keys h, s and v. */
            getHSV: function() {
                return rgbToHsv(this.red, this.green, this.blue);
            },
            
            /** Tests if this color is lighter than the provided color.
                @param {!Object} c - The myt.Color to compare to.
                @returns {boolean} True if this color is lighter, false otherwise. */
            isLighterThan: function(c) {
                const diff = this.getDiffFrom(c);
                
                // Sum channel diffs to determine lightest color. A negative diff means a 
                // lighter color.
                return 0 > (diff.red + diff.green + diff.blue);
            },
            
            /** Gets an object holding color channel diffs.
                @param {!Object} c - The myt.Color to diff from.
                @returns {!Object} containing the diffs for the red, green and blue channels. */
            getDiffFrom: function(c) {
                return {
                    red: c.red - this.red,
                    green: c.green - this.green,
                    blue: c.blue - this.blue
                };
            },
            
            /** Applies the provided diff object to this color.
                @param {!Object} diff - The color diff to apply.
                @returns {!Object} - This myt.Color for method chaining. */
            applyDiff: function(diff) {
                return this.add(diff);
            },
            
            /** Adds the provided color to this color.
                @param {!Object} c - The myt.Color to add.
                @returns {!Object} - This myt.Color for method chaining. */
            add: function(c) {
                this.setRed(this.red + c.red);
                this.setGreen(this.green + c.green);
                this.setBlue(this.blue + c.blue);
                return this;
            },
            
            /** Subtracts the provided color from this color.
                @param {!Object} c - The myt.Color to subtract.
                @returns {!Object} - This myt.Color for method chaining. */
            subtract: function(c) {
                this.setRed(this.red - c.red);
                this.setGreen(this.green - c.green);
                this.setBlue(this.blue - c.blue);
                return this;
            },
            
            /** Multiplys this color by the provided scalar.
                @param {number} s - The scaler to multiply by.
                @returns {!Object} - This myt.Color for method chaining. */
            multiply: function(s) {
                this.setRed(this.red * s);
                this.setGreen(this.green * s);
                this.setBlue(this.blue * s);
                return this;
            },
            
            /** Divides this color by the provided scalar.
                @param {number} s - The scaler to divide by.
                @returns {!Object} - This myt.Color for method chaining. */
            divide: function(s) {
                this.setRed(this.red / s);
                this.setGreen(this.green / s);
                this.setBlue(this.blue / s);
                return this;
            },
            
            /** Clones this Color.
                @returns {!Object} - A copy of this myt.Color. */
            clone: function() {
                return new Color(this.red, this.green, this.blue);
            },
            
            /** Determine if this color has the same value as another color.
                @param {?Object} obj - The color object to test against.
                @returns {boolean} True if this color has the same color values as this provided 
                    color, false otherwise. */
            equals: function(obj) {
                return obj === this || (obj?.isA?.(Color) && 
                    obj.red === this.red && 
                    obj.green === this.green && 
                    obj.blue === this.blue);
            }
        });
})(myt);


(pkg => {
    const {max:mathMax, sin:mathSin, cos:mathCos, pow:mathPow, sqrt:mathSqrt, PI} = Math,
        
        TWO_PI = 2 * PI,
        HALF_PI = PI / 2,
        
        globalIdle = pkg.global.idle,
        
        makeColorFromHexString = pkg.Color.makeColorFromHexString,
        
        easingFunctions = {
            linear:t => t,
            
            inQuad:t => t*t,
            outQuad:t => -t*(t-2),
            inOutQuad:t => (t*=2) < 1 ? t*t/2 : -((--t)*(t-2) - 1)/2,
            
            inCubic:t => t*t*t,
            outCubic:t => (t=t-1)*t*t + 1,
            inOutCubic:t => (t*=2) < 1 ? t*t*t/2 : ((t-=2)*t*t + 2)/2,
            
            inQuart:t => t*t*t*t,
            outQuart:t => -((t=t-1)*t*t*t - 1),
            inOutQuart:t => (t*=2) < 1 ? t*t*t*t/2 : -((t-=2)*t*t*t - 2)/2,
            
            inQuint:t => t*t*t*t*t,
            outQuint:t => (t=t-1)*t*t*t*t + 1,
            inOutQuint:t => (t*=2) < 1 ? t*t*t*t*t/2 : ((t-=2)*t*t*t*t + 2)/2,
            
            inSine:t => -mathCos(t * HALF_PI) + 1,
            outSine:t => mathSin(t * HALF_PI),
            inOutSine:t => -(mathCos(t * PI) - 1)/2,
            
            inCirc:t => -(mathSqrt(1 - t*t) - 1),
            outCirc:t => mathSqrt(1 - (t=t-1)*t),
            inOutCirc:t => (t*=2) < 1 ? -(mathSqrt(1 - t*t) - 1)/2: (mathSqrt(1 - (t-=2)*t) + 1)/2,
            
            inExpo:t => t === 0 ? 0 : mathPow(2, 10 * (t - 1)),
            outExpo:t => t === 1 ? 1 : (-mathPow(2, -10 * t) + 1),
            inOutExpo:t => {
                if (t === 0 || t === 1) return t;
                if ((t*=2) < 1) return mathPow(2, 10 * (t - 1))/2;
                return (-mathPow(2, -10 * --t) + 2)/2;
            },
            
            inElastic:t => {
                if (t === 0 || t === 1) return t;
                const p = 0.3;
                return -(mathPow(2, 10 * (t -= 1)) * mathSin((t * 1 - p/4) * TWO_PI / p));
            },
            outElastic:t => {
                if (t === 0 || t === 1) return t;
                const p = 0.3;
                return mathPow(2,-10 * t) * mathSin((t * 1 - p/4) * TWO_PI / p) + 1;
            },
            inOutElastic:t => {
                if (t === 0 || t === 1) return t;
                const p = 0.45;
                if ((t*=2) < 1) return -(mathPow(2, 10 * (t-=1)) * mathSin((t * 1 - p/4) * TWO_PI / p))/2;
                return mathPow(2, -10 * (t-=1)) * mathSin((t * 1 - p/4) * TWO_PI/p)/2 + 1;
            },
            
            inBack:(t, s=1.70158) => (t/=1) * t * ((s+1)*t - s),
            outBack:(t, s=1.70158) => (t=t/1-1) * t * ((s+1)*t + s) + 1,
            inOutBack:(t, s=1.70158) => (t*=2) < 1 ? (t*t*(((s*=(1.525))+1)*t - s))/2 : ((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2)/2,
            
            inBounce:t => 1 - easingFunctions.outBounce(1-t),
            outBounce:t => {
                if (t < (1/2.75)) {
                    return 7.5625*t*t;
                } else if (t < (2/2.75)) {
                    return 7.5625*(t-=(1.5/2.75))*t + 0.75;
                } else if (t < (2.5/2.75)) {
                    return 7.5625*(t-=(2.25/2.75))*t + 0.9375;
                }
                return 7.5625*(t-=(2.625/2.75))*t + 0.984375;
            },
            inOutBounce:t => (t*=2) < 1 ? easingFunctions.inBounce(t)/2 : (easingFunctions.outBounce(t-1) + 1)/2
        },
        
        DEFAULT_EASING = easingFunctions.inOutQuad,
        
        getTarget = animator => animator.target ?? animator.parent,
        
        getColorValue = (from, to, motionValue, relative, value) => {
            const fromColor = makeColorFromHexString(from),
                toColor = makeColorFromHexString(to),
                colorObj = relative ? makeColorFromHexString(value) : fromColor;
            colorObj.setRed(colorObj.red + ((toColor.red - fromColor.red) * motionValue));
            colorObj.setGreen(colorObj.green + ((toColor.green - fromColor.green) * motionValue));
            colorObj.setBlue(colorObj.blue + ((toColor.blue - fromColor.blue) * motionValue));
            return colorObj.getHtmlHexString();
        },
        
        reset = animator => {
            animator.__tmpFrom = false;
            animator.__loopCnt = animator.reverse ? animator.repeat - 1 : 0;
            animator.__prog = animator.reverse ? animator.duration : 0;
        },
        
        advance = (animator, timeDiff) => {
            const {running, paused, reverse, duration, repeat, __prog:oldProgress, easingFunction, callback} = animator;
            if (running && !paused) {
                // An animation in reverse is like time going backward.
                if (reverse) timeDiff *= -1;
                
                // Determine how much time to move forward by.
                let progress = oldProgress + timeDiff;
                
                // Check for overage
                let remainderTime = 0;
                if (progress > duration) {
                    remainderTime = progress - duration;
                    progress = duration;
                    
                    // Increment loop count and halt looping if necessary
                    if (++animator.__loopCnt === repeat) remainderTime = 0;
                } else if (0 > progress) {
                    // Reverse case
                    remainderTime = -progress; // Flip reverse time back to forward time
                    progress = 0;
                    
                    // Decrement loop count and halt looping if necessary
                    if (0 > --animator.__loopCnt && repeat > 0) remainderTime = 0;
                }
                
                const target = getTarget(animator);
                if (target) {
                    // Update Target
                    const {relative, attribute:attr, __isColorAnim, __loopCnt, to} = animator,
                        progressPercent = mathMax(0, progress / duration), 
                        oldProgressPercent = mathMax(0, oldProgress / duration);
                    
                    // Determine what "from" to use if none was provided.
                    if (animator.from == null) {
                        animator.__tmpFrom = true;
                        animator.from = relative ? (__isColorAnim ? '#000' : 0) : target.get(attr);
                    }
                    
                    const motionValue = easingFunction(progressPercent) - (relative ? easingFunction(oldProgressPercent) : 0),
                        from = animator.from,
                        value = relative ? target.get(attr) : from;
                    target.set(attr, __isColorAnim ? getColorValue(from, to, motionValue, relative, value) : value + ((to - from) * motionValue));
                    
                    if (
                        (!reverse && __loopCnt === repeat) || // Forward check
                        (reverse && 0 > __loopCnt && repeat > 0) // Reverse check
                    ) {
                        // Stop animation since loop count exceeded repeat count.
                        animator.setRunning(false);
                        callback?.call(animator, true);
                    } else if (remainderTime > 0) {
                        // Advance again if time is remaining. This occurs when the timeDiff 
                        // provided was greater than the animation duration and the animation loops.
                        animator.fireEvent('repeat', __loopCnt);
                        animator.__prog = reverse ? duration : 0;
                        advance(animator, remainderTime);
                    } else {
                        animator.__prog = progress;
                    }
                } else {
                    console.log('No target for animator', animator);
                    animator.setRunning(false);
                    callback?.call(animator, false);
                }
            }
        };
    
    /** Changes the value of an attribute on a target over time.
        
        Events:
            running:boolean Fired when the animation starts or stops.
            paused:boolean Fired when the animation is paused or unpaused.
            reverse:boolean
            easingFunction:function
            from:number
            to:number
            repeat:Fired when the animation repeats. The value is the current loop count.
            
        Attributes:
            attribute:string The attribute to animate.
            target:object The object to animate the attribute on. The default is the parent of 
                this node.
            from:number The starting value of the attribute. If not specified the current value 
                on the target will be used.
            to:number The ending value of the attribute.
            duration:number The length of time the animation will run in millis. The default 
                value is 1000.
            easingFunction:string/function Controls the rate of animation.
                string: See http://easings.net/ for more info. One of the following:
                        linear, 
                        inQuad, outQuad, inOutQuad(default), 
                        inCubic, outCubic, inOutCubic, 
                        inQuart, outQuart, inOutQuart, 
                        inQuint, outQuint, inOutQuint, 
                        inSine, outSine, inOutSine,
                        inExpo ,outExpo, inOutExpo, 
                        inCirc, outCirc, inOutCirc,
                        inElastic ,outElastic, inOutElastic, 
                        inBack, outBack, inOutBack, 
                        inBounce, outBounce, inOutBounce
                
                function: A function that determines the rate of change of the attribute. The 
                    arguments to the easing function are:
                        t: Animation progress in millis
                        c: Value change (to - from)
                        d: Animation duration in millis
            relative:boolean Determines if the animated value is set on the target (false), or 
                added to the exiting value on the target (true). Note that this means the 
                difference between the from and to values will be "added" to the existing 
                value on the target. The default value is false.
            repeat:number The number of times to repeat the animation. 
                If negative the animation will repeat forever. The default value is 1.
            reverse:boolean If true, the animation is run in reverse.
            running:boolean Indicates if the animation is currently running. The default value 
                is false.
            paused:boolean Indicates if the animation is temporarily paused. The default value 
                is false.
            callback:function A function that gets called when the animation completes. A 
                boolean value is passed into the function and will be true if the animation 
                completed successfully or false if not.
        
        Private Attributes:
            __loopCnt:number the loop currently being run.
            __prog:number the number of millis currently used during the current animation loop.
            __tmpFrom:boolean Indicates no "from" was set on the animator so we will have to 
                generate one when needed. We want to reset back to undefined after the animation 
                completes so that subsequent calls to start the animation will behave the same.
            __isColorAnim:boolean Indicates this animator is animating a color attribute.
        
        @class */
    pkg.Animator = new JS.Class('Animator', pkg.Node, {
        include: [pkg.Reusable],
        
        
        // Class Methods and Attributes ////////////////////////////////////
        extend: {
            /** An object containing easign functions. */
            easings: easingFunctions
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////
        /** @overrides myt.Node */
        initNode: function(parent, attrs) {
            const self = this;
            
            self.duration = 1000;
            self.relative = self.reverse = self.running = self.paused = false;
            self.repeat = 1;
            self.easingFunction = DEFAULT_EASING;
            
            self.callSuper(parent, attrs);
            
            reset(self);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////
        setRunning: function(v) {
            const self = this;
            if (self.running !== v) {
                self.running = v;
                if (self.inited) self.fireEvent('running', v);
                
                if (!self.paused) {
                    if (v) {
                        // Determine if we are animating a color or not. We do this by checking
                        // an isColorAttr function on the animation target if it exists.
                        const target = getTarget(self);
                        self.__isColorAnim = (target && typeof target.isColorAttr === 'function') ? target.isColorAttr(self.attribute) : undefined;
                    } else {
                        if (self.__tmpFrom) self.from = undefined;
                        reset(self);
                    }
                    self[v ? 'attachTo' : 'detachFrom'](globalIdle, '__updateAnim', 'idle');
                }
            }
        },
        
        setPaused: function(v) {
            const self = this;
            if (self.paused !== v) {
                self.paused = v;
                if (self.inited) self.fireEvent('paused', v);
                if (self.running) self[v ? 'detachFrom' : 'attachTo'](globalIdle, '__updateAnim', 'idle');
            }
        },
        
        setReverse: function(v) {
            this.set('reverse', v, true);
            if (this.inited && !this.running) reset(this);
        },
        
        setRepeat: function(v) {
            this.set('repeat', v, true);
            if (this.inited && !this.running) reset(this);
        },
        
        setDuration: function(v) {
            this.set('duration', v, true);
            if (this.inited && !this.running) reset(this);
        },
        
        setEasingFunction: function(v) {
            // Lookup easing function if a string is provided.
            if (typeof v === 'string') v = easingFunctions[v];
            
            this.set('easingFunction', v ?? DEFAULT_EASING, true);
        },
        
        setFrom: function(v) {this.set('from', v, true);},
        setTo: function(v) {this.set('to', v, true);},
        setCallback: function(v) {this.callback = v;},
        
        
        // Methods /////////////////////////////////////////////////////////
        /** A convienence method to set the callback to run when the animator stops running. If 
            a callback already exists the provided callback will be executed after (but not 
            after the existing animator completes) the existing one.
            @param {!Function} callback - The function to run.
            @param {boolean} [replace] - If true the existing callback will be replaced with 
                the new callback.
            @returns {undefined} */
        next: function(callback, replace) {
            const self = this,
                existingCallback = self.callback;
            if (existingCallback && !replace) {
                self.setCallback(success => {
                    existingCallback.call(self, success);
                    callback.call(self, success);
                });
            } else {
                self.setCallback(callback);
            }
        },
        
        /** Puts the animator back to an initial configured state.
            @param {boolean} [executeCallback] - If true and the callback exists, the callback 
                will be executed.
            @returns {undefined} */
        reset: function(executeCallback) {
            const self = this;
            
            reset(self);
            
            self.setRunning(false);
            self.setPaused(false);
            
            if (executeCallback) self.callback?.call(self, false);
        },
        
        /** @overrides myt.Reusable */
        clean: function() {
            const self = this;
            
            self.to = self.from = self.attribute = self.callback = undefined;
            self.duration = 1000;
            self.relative = self.reverse = false;
            self.repeat = 1;
            self.easingFunction = DEFAULT_EASING;
            
            self.reset(false);
        },
        
        /** @private
            @param {!Object} idleEvent
            @returns {undefined} */
        __updateAnim: function(idleEvent) {
            advance(this, idleEvent.value.delta);
        }
    });
})(myt);


(pkg => {
    const isArray = Array.isArray,
        
        /*  Indicates a synchronous transition. */
        SYNC = 'sync',
        
        /*  Indicates an asynchronous transition. */
        ASYNC = 'async',
        
        /*  Indicates the transition was successfull. */
        SUCCEEDED = 1,
        
        /*  Indicates the transition was cancelled before the state 
            change occurred. */
        CANCELLED = 2,
        
        /*  Indicates an asynchronous transition is in progress. */
        PENDING = 3,
        
        /*  Indicates the transition was invalid in some way. */
        INVALID = 4,
        
        /* Indicates no transition exists for the current state. */
        NO_TRANSITION = 5,
        
        /*  Special state name that holds transitions for all states. */
        WILDCARD = '*',
        
        resetTransitionProgress = stateMachine => {
            stateMachine.__additionalArgs = [];
            stateMachine.__pendingTransition = '';
            stateMachine.__transDestinationState = '';
            stateMachine.__transStage = 'leaveState';
        },
        
        doTheTransition = (stateMachine, args) => {
            // Don't allow another transition if one is already in 
            // progress. Instead, defer them until after the current 
            // transition completes.
            if (stateMachine.__transInProgress) {
                let deferredTransitions = stateMachine.__deferredTransitions;
                deferredTransitions ??= stateMachine.__deferredTransitions = [];
                deferredTransitions.unshift(args);
            } else {
                stateMachine.__transInProgress = true;
                
                const async = args.shift(),
                    transitionName = args.shift();
                
                // Invalid to start a transition if one is still pending.
                if (stateMachine.__pendingTransition) return PENDING;
                
                // Do not allow transition from the terminal states
                if (stateMachine.isFinished()) {
                    stateMachine.__transInProgress = false;
                    return NO_TRANSITION;
                }
                
                let to = stateMachine.map[stateMachine.current][transitionName];
                to ??= stateMachine.map[WILDCARD][transitionName];
                if (to) {
                    stateMachine.__pendingTransition = transitionName;
                    stateMachine.__transDestinationState = to;
                    stateMachine.__additionalArgs = args;
                    return stateMachine.resumeTransition(async);
                } else {
                    stateMachine.__transInProgress = false;
                    return NO_TRANSITION;
                }
            }
        },
        
        doDeferredTransitions = stateMachine => {
            stateMachine.__transInProgress = false;
            
            const deferredTransitions = stateMachine.__deferredTransitions;
            if (deferredTransitions) {
                while (deferredTransitions.length > 0) doTheTransition(stateMachine, deferredTransitions.pop());
            }
        };
    
    /** An implementation of a finite state machine.
        
        Events:
            start + transition name: Fired when a transition starts.
            start: Fired when a transition starts after the named start event.
            leave + state name: Fired when a state is left.
            leave: Fired when a state is left after the named leave event.
            enter + state name: Fired when a state is entered.
            enter: Fired when a state is entered after the named enter event.
            end + transition name: Fired when a transition ends.
            end: Fired when a transition ends after the named end event.
            finished: Fired when the state machine has transitioned into the
                terminal state if one is defined.
        
        Attributes:
            map:object A map of state names to transition maps.
            current:string The name of the current state.
            initial:string The name of the state to start with.
            terminal:string The name of the final state from which no other
                transitions are allowed.
        
        Private Attributes:
            __transInProgress:boolean Indicates that a transition is 
                currently under way.
            __pendingTransition:string The name of the transition that is 
                currently under way.
            __additionalArgs:array An array of additional args passed into the
                doTransition or doAsyncTransition methods.
            __transDestinationState: The state the currently running 
                transition is transitioning to
            __transStage:string The stage of the current transition. Allowed
                values are 'leaveState' and 'enterState'.
            __deferredTransitions:array An array of transitions that will be
                performed after the current one completes.
        
        @class */
    pkg.StateMachine = new JS.Class('StateMachine', pkg.Node, {
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            /** The transition was successfull. */
            SUCCEEDED:SUCCEEDED,
            /** The transition was cancelled before the state change 
                occurred. */
            CANCELLED:CANCELLED,
            /** An asynchronous transition is in progress. */
            PENDING:PENDING,
            /** The transition was invalid in some way. */
            INVALID:INVALID,
            /** No transition exists for the current state. */
            NO_TRANSITION:NO_TRANSITION
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            this.map = {};
            this.map[WILDCARD] = {};
            
            this.current = this.initial = this.terminal = '';
            resetTransitionProgress(this);
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setInitialState: function(v) {
            if (this.current === '') {
                // Get optional args if v is an array
                let args;
                if (isArray(v)) {
                    args = v;
                    v = args.shift();
                } else {
                    args = [];
                }
                
                this.current = this.initial = v;
                this.doEnterState('', '', v, args);
                const eventValue = {name:'', from:'', to:v, args:args};
                this.fireEvent('enter' + v, eventValue);
                this.fireEvent('enter', eventValue);
                if (this.isFinished()) this.fireEvent('finished', eventValue);
            }
        },
        
        setTerminalState: function(v) {
            this.terminal = v;
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        addTransitions: function(transitions) {
            for (const transition of transitions) this.addTransition(...transition);
        },
        
        addTransition: function(transitionName, from, to) {
            if (from) {
                from = isArray(from) ? from : [from];
            } else {
                from = [WILDCARD];
            }
            
            const map = this.map;
            let i = from.length;
            while (i) (map[from[--i]] ??= {})[transitionName] = to;
        },
        
        doTransition: function(...args) {
            args.unshift(SYNC);
            return doTheTransition(this, args);
        },
        
        doAsyncTransition: function(...args) {
            args.unshift(ASYNC);
            return doTheTransition(this, args);
        },
        
        resumeTransition: function(async) {
            const transitionName = this.__pendingTransition;
            
            // Invalid to resume a transition if none is pending.
            if (!transitionName) return INVALID;
            
            const current = this.current,
                to = this.__transDestinationState,
                args = this.__additionalArgs,
                eventValue = {name:transitionName, from:current, to:to, args:args},
                fireEvent = this.fireEvent.bind(this);
            
            switch (this.__transStage) {
                case 'leaveState':
                    const result = this.doLeaveState(transitionName, current, to, args);
                    if (result === false) {
                        resetTransitionProgress(this);
                        doDeferredTransitions(this);
                        return CANCELLED;
                    } else if (result === ASYNC || async === ASYNC) {
                        this.__transStage = 'enterState';
                        fireEvent('start' + transitionName, eventValue);
                        fireEvent('start', eventValue);
                        fireEvent('leave' + current, eventValue);
                        fireEvent('leave', eventValue);
                        doDeferredTransitions(this); // FIXME: Is there a bug here if a transition starts in the middle of an async transition?
                        return PENDING;
                    } else {
                        fireEvent('start' + transitionName, eventValue);
                        fireEvent('start', eventValue);
                        fireEvent('leave' + current, eventValue);
                        fireEvent('leave', eventValue);
                        // Synchronous so fall through to 'enterState' case.
                    }
                case 'enterState':
                    this.current = to;
                    resetTransitionProgress(this);
                    this.doEnterState(transitionName, current, to, args);
                    fireEvent('enter' + to, eventValue);
                    fireEvent('enter', eventValue);
                    fireEvent('end' + transitionName, eventValue);
                    fireEvent('end', eventValue);
                    if (this.isFinished()) fireEvent('finished', eventValue);
            }
            
            doDeferredTransitions(this);
            return SUCCEEDED;
        },
        
        doLeaveState: (transitionName, from, to, args) => {/* Subclasses to implement as needed. */},
        
        doEnterState: (transitionName, from, to, args) => {/* Subclasses to implement as needed. */},
        
        isFinished: function() {
            return this.is(this.terminal);
        },
        
        isStarting: function() {
            return this.is(this.initial);
        },
        
        is: function(stateName) {
            if (isArray(stateName)) {
                return stateName.includes(this.current);
            } else {
                return this.current === stateName;
            }
        },
        
        can: function(transitionName) {
            if (this.map[this.current][transitionName] !== undefined) {
                return true;
            } else {
                return this.map[WILDCARD][transitionName] !== undefined;
            }
        }
    });
})(myt);


(pkg => {
    const sortFunction = (a, b) => a.replicationIndex - b.replicationIndex,
        
        /*  @param {!Array} layouts
            @returns {undefined} */
        lockLayouts = layouts => {
            let i = layouts.length;
            while (i) layouts[--i].incrementLockedCounter();
        },
        
        /*  @param {!Array} layouts
            @param {boolean} update
            @returns {undefined} */
        unlockLayouts = (layouts, update) => {
            let i = layouts.length;
            while (i) {
                const layout = layouts[--i];
                layout.decrementLockedCounter();
                if (update) layout.update();
            }
        },
        
        /*  @param {!Object} replicator
            @returns {undefined} */
        setupPool = replicator => {
            destroyOldPool(replicator);
            
            // Create new pool
            const template = replicator.template;
            if (template) replicator.__pool = new pkg.TrackActivesPool(template, replicator.parent);
        },
        
        /*  @param {!Object} replicator
            @returns {undefined} */
        destroyOldPool = replicator => {
            // Destroy old pool and instances.
            const pool = replicator.__pool;
            if (pool) {
                // Lock layouts before modifying instances
                const layouts = replicator.parent.getLayouts();
                lockLayouts(layouts);
                
                pool.putActives();
                pool.destroyPooledInstances();
                
                unlockLayouts(layouts, false);
                
                pool.destroy();
            }
        };
    
    /** Objects that can be replicated should include this mixin and implemment the replicate 
        method. The myt.Reusable mixin is also included and the clean method should also be 
        implemented. The methods replicate and clean should perform setup and teardown of the 
        object respectively.
        
        Attributes:
            replicationData:* The data provided during replication.
            replicationIndex:number The replication index provided during replication.
        
        @class */
    pkg.Replicable = new JS.Module('Replicable', {
        include: [pkg.Reusable],
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called to configure the replicable object with data. Subclasses should call super.
            @param {?Object} data - The data being replicated for this instance.
            @param {number} idx - The index of the data in the replicated list.
            @returns {undefined} */
        replicate: function(data, idx) {
            this.replicationData = data;
            this.replicationIndex = idx;
        },
        
        // FIXME: Make this a mixin?
        /** Notifies this object that something happened.
            @param {string} key - The name of the message
            @param {*} value - The value of the message.
            @returns {undefined} */
        notify: (key, value) => {},
        
        /** @overrides myt.Reusable
            Subclasses should call super. */
        clean: function() {
            this.replicationData = null;
            this.replicationIndex = -1;
        },
        
        /** Called by an myt.Replicator to check if this replicable needs to be updated or not.
            @param {!Object} data - The data being replicated for this instance.
            @param {number} idx - The index of the data in the replicated list.
            @returns {boolean} - True if the provided data is already set on this replicable, 
                false otherwise. */
        alreadyHasReplicationData: function(data, idx) {
            // FIXME: Use deepEquals on replicationData?
            return idx === this.replicationIndex && data === this.replicationData;
        }
    });

    /** Creates instances using a template class and an array of data items.
        
        Attributes:
            template:JS.Class The template to replicate for each entry in the data set.
            data:array The data to replicate the template for.
        
        Private Attributes:
            __pool:myt.TrackActivesPool The pool that holds the myt.Replicable instances.
        
        @class */
    pkg.Replicator = new JS.Class('Replicator', pkg.Node, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            
            setupPool(this);
            this.doReplication();
        },
        
        /** @overrides */
        destroy: function() {
            destroyOldPool(this);
            this.callSuper();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setTemplate: function(v) {
            // Make sure template class is an myt.Replicable
            this.template = v.includes(pkg.Replicable) ? v : null;
            if (!this.template) pkg.dumpStack('Template not replicable');
            
            if (this.inited) {
                setupPool(this);
                this.doReplication();
            }
        },
        
        setData: function(v) {
            this.data = v;
            if (this.inited) this.doReplication();
        },
        
        getActiveReplicants: function() {
            return this.__pool.getActives();
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Performs replication.
            @returns {undefined} */
        doReplication: function() {
            const pool = this.__pool;
            let layouts;
            if (pool) {
                // Lock layouts before modifying instances
                layouts = this.parent.getLayouts();
                lockLayouts(layouts);
                
                // Walk actives comparing against data
                const data = this.data, 
                    dataLen = data ? data.length : 0,
                    actives = pool.getActives(), 
                    activesLen = actives.length, 
                    unused = [];
                let i = activesLen, 
                    active,
                    replicationIndex;
                
                actives.sort(sortFunction);
                
                while (i) {
                    active = actives[--i];
                    replicationIndex = active.replicationIndex;
                    if (replicationIndex >= dataLen ||
                        !active.alreadyHasReplicationData(data[replicationIndex], replicationIndex)
                    ) {
                        unused[replicationIndex] = active;
                    }
                }
                
                // Put away all unused actives
                i = unused.length;
                while (i) {
                    active = unused[--i];
                    if (active) pool.putInstance(active);
                }
                
                // Replicate on unused data and data that was beyond the length of the actives list
                for (i = 0; dataLen > i; ++i) {
                    if (i >= activesLen || unused[i] != null) pool.getInstance().replicate(data[i], i);
                }
                
                // Sort layout subviews so the layout reflects the data list order.
                i = layouts.length;
                while (i) layouts[--i].sortSubviews(sortFunction);
                
                unlockLayouts(layouts, true);
            }
        },
        
        // FIXME: Make this a mixin?
        /** Sends a message to each active myt.Replicable.
            @param {string} key - The name of the message
            @param {*} value - The value of the message.
            @returns {undefined} */
        notify: function(key, value) {
            const pool = this.__pool;
            if (pool) {
                const actives = pool.getActives();
                let i = actives.length;
                while (i) actives[--i].notify(key, value);
            }
        }
    });
})(myt);


(pkg => {
    const JSSingleton = JS.Singleton,
        doc = document,
        {
            DomElementProxy, DomObservable, 
            global:{register}
        } = pkg;
    
    /** Provides global mouse events by listening to mouse events on the document. Registered with 
        myt.global as 'mouse'.
        
        @class */
    new JSSingleton('GlobalMouse', {
        include: [DomElementProxy, DomObservable, pkg.MouseObservable],
        
        
        // Constructor /////////////////////////////////////////////////////////
        initialize: function() {
            this.setDomElement(doc);
            register('mouse', this);
        }
    });
    
    /** Provides global touch events by listening to touch events on the the document. 
        Registered with myt.global as 'touch'.
        
        @class */
    new JSSingleton('GlobalTouch', {
        include: [DomElementProxy, DomObservable, pkg.TouchObservable],
        
        
        // Constructor /////////////////////////////////////////////////////////
        initialize: function() {
            this.setDomElement(doc);
            register('touch', this);
        }
    });
})(myt);


(pkg => {
    let fireGlobalDragManagerEvent,
        
        /*  The view currently being dragged. */
        dragView,
        
        /*  The view currently being dragged over. */
        overView;
        
    const
        /*  The list of myt.AutoScrollers currently registered for notification when drags start 
            and stop. */
        autoScrollers = [],
        
        /*  The list of myt.DropTargets currently registered for notification when drag and drop 
            events occur. */
        dropTargets = [],
        
        setOverView = v => {
            const existingOverView = overView;
            if (existingOverView !== v) {
                if (existingOverView) {
                    existingOverView.notifyDragLeave(dragView);
                    if (!dragView.destroyed) dragView.notifyDragLeaving(existingOverView);
                    fireGlobalDragManagerEvent('dragLeave', existingOverView);
                }
                
                overView = v;
                
                if (v) {
                    v.notifyDragEnter(dragView);
                    if (!dragView.destroyed) dragView.notifyDragEntering(v);
                    fireGlobalDragManagerEvent('dragEnter', existingOverView);
                }
            }
        },
        
        setDragView = v => {
            let existingDragView = dragView;
            if (existingDragView !== v) {
                dragView = v;
                
                if (v) {
                    existingDragView = v;
                    
                    for (const target of filterList(existingDragView, dropTargets)) {
                        target.notifyDragStart(existingDragView);
                    }
                    for (const target of filterList(existingDragView, autoScrollers)) {
                        target.notifyAutoScrollerDragStart(existingDragView);
                    }
                    fireGlobalDragManagerEvent('startDrag', v);
                } else {
                    for (const target of filterList(existingDragView, dropTargets)) {
                        target.notifyDragStop(existingDragView);
                    }
                    for (const target of filterList(existingDragView, autoScrollers)) {
                        target.notifyAutoScrollerDragStop(existingDragView);
                    }
                    fireGlobalDragManagerEvent('stopDrag', v);
                }
            }
        },
        
        /*  Filters the provided array of myt.DragGroupSupport items for the provided myt.Dropable. 
            Returns an array of the matching list items.
            @param {!Object} dropable
            @param {!Array} list
            @returns {!Array} */
        filterList = (dropable, list) => {
            if (dropable.destroyed) {
                return [];
            } else if (dropable.isAnyDragGroup()) {
                // Dropable can be anything in the list will accept it.
                return list;
            } else {
                const retval = [],
                    dragGroups = dropable.getDragGroups();
                let i = list.length;
                while (i) {
                    const item = list[--i];
                    if (item.isAnyDropGroup()) {
                        // List item will is any drop group so all Dropables are valid.
                        retval.push(item);
                    } else {
                        const targetGroups = item.getDropGroups();
                        for (const dragGroup in dragGroups) {
                            if (targetGroups[dragGroup]) {
                                retval.push(item);
                                break;
                            }
                        }
                    }
                }
                return retval;
            }
        };
    
    /** Provides global drag and drop functionality.
        
        Events:
            dragLeave:myt.DropTarget Fired when a myt.Dropable is dragged out of the drop target.
            dragEnter:myt.DropTarget Fired when a myt.Dropable is dragged over the drop target.
            startDrag:object Fired when a drag starts. Value is the object being dragged.
            stopDrag:object Fired when a drag ends. Value is the object that is no longer 
                being dragged.
            drop:object Fired when a drag ends over a drop target. The value is an array containing 
                the dropable at index 0 and the drop target at index 1.
        
        @class */
    new JS.Singleton('GlobalDragManager', {
        include: [pkg.Observable],
        
        
        // Constructor /////////////////////////////////////////////////////////
        initialize: function() {
            pkg.global.register('dragManager', this);
            fireGlobalDragManagerEvent = this.fireEvent.bind(this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        getDragView: () => dragView,
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Registers the provided auto scroller to receive notifications.
            @param {!Object} autoScroller - The myt.AutoScroller to register.
            @returns {undefined} */
        registerAutoScroller: autoScroller => {
            autoScrollers.push(autoScroller);
        },
        
        /** Unregisters the provided auto scroller.
            @param {!Object} autoScroller - The myt.AutoScroller to unregister.
            @returns {undefined} */
        unregisterAutoScroller: autoScroller => {
            const idx = autoScrollers.indexOf(autoScroller);
            if (idx > -1) autoScrollers.splice(idx, 1);
        },
        
        /** Registers the provided drop target to receive notifications.
            @param {!Object} dropTarget - The myt.DropTarget to register.
            @returns {undefined} */
        registerDropTarget: dropTarget => {
            dropTargets.push(dropTarget);
        },
        
        /** Unregisters the provided drop target.
            @param {!Object} dropTarget - The myt.DropTarget to unregister.
            @returns {undefined} */
        unregisterDropTarget: dropTarget => {
            const idx = dropTargets.indexOf(dropTarget);
            if (idx > -1) dropTargets.splice(idx, 1);
        },
        
        /** Called by a myt.Dropable when a drag starts.
            @param {!Object} dropable - The myt.Dropable that started the drag.
            @returns {undefined} */
        startDrag: dropable => {
            setDragView(dropable);
        },
        
        /** Called by a myt.Dropable when a drag stops.
            @param {!Object} event -The mouse event that triggered the stop drag.
            @param {!Object} dropable - The myt.Dropable that stopped being dragged.
            @param {boolean} isAbort
            @returns {undefined} */
        stopDrag: (event, dropable, isAbort) => {
            dropable.notifyDropped(overView, isAbort);
            if (!isAbort) overView?.notifyDrop(dropable);
            
            setOverView();
            setDragView();
            
            if (overView && !isAbort) fireGlobalDragManagerEvent('drop', [dropable, overView]);
        },
        
        /** Called by a myt.Dropable during dragging.
            @param {!Object} event - The mousemove event for the drag update.
            @param {!Object} dropable - The myt.Dropable that is being dragged.
            @returns {undefined} */
        updateDrag: (event, dropable) => {
            // Get the frontmost myt.DropTarget that is registered with this manager and is under 
            // the current mouse location and has a matching drag group.
            const filteredDropTargets = filterList(dropable, dropTargets);
            let i = filteredDropTargets.length,
                topDropTarget;
            
            if (i > 0) {
                const {pageX:mouseX, pageY:mouseY} = event.value;
                while (i) {
                    const dropTarget = filteredDropTargets[--i];
                    if (dropTarget.willAcceptDrop(dropable) &&
                        dropable.willPermitDrop(dropTarget) &&
                        dropTarget.isPointVisible(mouseX, mouseY) && 
                        (!topDropTarget || dropTarget.isInFrontOf(topDropTarget))
                    ) {
                        topDropTarget = dropTarget;
                    }
                }
            }
            
            setOverView(topDropTarget);
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        
        {mouse:GlobalMouse, keys:GlobalKeys, idle:GlobalIdle} = pkg.global,
        
        NO_KEY_DOWN = '',
        
        getCodeFromEvent = event => pkg.KeyObservable.getCodeFromEvent(event),
        getMouseFromEvent = event => pkg.MouseObservable.getMouseFromEvent(event);
    
    /** Adds the capability for an myt.View to be "activated". A doActivated method is added that 
        gets called when the view is "activated".
        
        @class */
    pkg.Activateable = new JSModule('Activateable', {
        // Methods /////////////////////////////////////////////////////////////
        /** Called when this view should be activated.
            @returns {undefined} */
        doActivated: () => {/* Subclasses to implement as needed. */}
    });
    
    /** Adds an udpateUI method that should be called to update the UI. Various mixins will rely on 
        the updateUI method to trigger visual updates.
        
        @class */
    pkg.UpdateableUI = new JSModule('UpdateableUI', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            
            // Call updateUI one time after initialization is complete to give this View a chance 
            // to update itself.
            this.updateUI();
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Updates the UI whenever a change occurs that requires a visual update. Subclasses 
            should implement this as needed.
            @returns {undefined} */
        updateUI: () => {/* Subclasses to implement as needed. */}
    });
    
    /** Adds the capability to be "disabled" to an myt.Node. When an myt.Node is disabled the user 
        should typically not be able to interact with it.
        
        When disabled becomes true an attempt will be made to give away the focus using 
        myt.FocusObservable's giveAwayFocus method.
        
        Events:
            disabled:boolean Fired when the disabled attribute is modified via setDisabled.
        
        Attributes:
            disabled:boolean Indicates that this component is disabled.
        
        @class */
    pkg.Disableable = new JSModule('Disableable', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.disabled ??= false;
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setDisabled: function(v) {
            v = this.valueFromEvent(v);
            if (this.disabled !== v) {
                this.disabled = v;
                if (this.inited) this.fireEvent('disabled', v);
                
                this.doDisabled();
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called after the disabled attribute is set. Default behavior attempts to give away 
            focus and calls the updateUI method of myt.UpdateableUI if it is defined.
            @returns {undefined} */
        doDisabled: function() {
            if (this.inited) {
                // Give away focus if we become disabled and this instance is a FocusObservable
                if (this.disabled) this.giveAwayFocus?.();
                this.updateUI?.();
            }
        }
    });
    
    /** Provides keyboard handling to "activate" the component when a key is pressed down or 
        released up. By default, when a keyup event occurs for an activation key and this view is 
        not disabled, the "doActivated" method will get called.
        
        Requires: myt.Activateable, myt.Disableable, myt.KeyObservable and myt.FocusObservable 
            super mixins.
        
        Attributes:
            activationKeys:array of chars The keys that when keyed down will activate this 
                component. Note: The value is not copied so modification of the array outside the 
                scope of this object will effect behavior.
            activateKeyDown:string the key code of the activation key that is currently down. This 
                will be empty string when no key is down.
            repeatKeyDown:boolean Indicates if doActivationKeyDown will be called for repeated 
                keydown events or not. Defaults to false.
        
        @class */
    pkg.KeyActivation = new JSModule('KeyActivation', {
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            /** The default activation keys are enter and spacebar. */
            ACTIVATION_KEYS: [GlobalKeys.CODE_ENTER, GlobalKeys.CODE_SPACE],
            NO_KEY_DOWN: NO_KEY_DOWN
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            const self = this;
            
            self.activateKeyDown = NO_KEY_DOWN;
            
            attrs.activationKeys ??= pkg.KeyActivation.ACTIVATION_KEYS;
            
            self.callSuper(parent, attrs);
            
            self.attachToDom(self, '__hndlKeyDown', 'keydown');
            self.attachToDom(self, '__hndlKeyPress', 'keypress');
            self.attachToDom(self, '__hndlKeyUp', 'keyup');
            self.attachToDom(self, '__doDomBlur', 'blur');
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setActivationKeys: function(v) {this.activationKeys = v ?? [];},
        setRepeatKeyDown: function(v) {this.repeatKeyDown = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __hndlKeyDown: function(event) {
            if (!this.disabled) {
                if (this.activateKeyDown === NO_KEY_DOWN || this.repeatKeyDown) {
                    const code = getCodeFromEvent(event);
                    if (this.activationKeys.includes(code)) {
                        if (this.activateKeyDown === code) {
                            this.doActivationKeyDown(code, true);
                        } else {
                            this.activateKeyDown = code;
                            this.doActivationKeyDown(code, false);
                        }
                        event.value.preventDefault();
                    }
                }
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __hndlKeyPress: function(event) {
            if (!this.disabled) {
                const code = getCodeFromEvent(event);
                if (this.activateKeyDown === code && this.activationKeys.includes(code)) {
                    event.value.preventDefault();
                }
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __hndlKeyUp: function(event) {
            if (!this.disabled) {
                const code = getCodeFromEvent(event);
                if (this.activateKeyDown === code && this.activationKeys.includes(code)) {
                    this.activateKeyDown = NO_KEY_DOWN;
                    this.doActivationKeyUp(code);
                    event.value.preventDefault();
                }
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doDomBlur: function(event) {
            if (!this.disabled) {
                const keyThatWasDown = this.activateKeyDown;
                if (keyThatWasDown !== NO_KEY_DOWN) {
                    this.activateKeyDown = NO_KEY_DOWN;
                    this.doActivationKeyAborted(keyThatWasDown);
                }
            }
        },
        
        /** Called when an activation key is pressed down. Default implementation does nothing.
            @param code:string - The key code that is down.
            @param isRepeat:boolean - Indicates if this is a key repeat event or not.
            @returns {undefined} */
        doActivationKeyDown: (code, isRepeat) => {/* Subclasses to implement as needed. */},
        
        /** Called when an activation key is release up. This executes the "doActivated" method 
            by default. 
            @param code:string - The keycode that is up.
            @returns {undefined} */
        doActivationKeyUp: function(code) {
            this.doActivated();
        },
        
        /** Called when focus is lost while an activation key is down. Default implementation 
            does nothing.
            @param code:string - The keycode that is down.
            @returns {undefined} */
        doActivationKeyAborted: code => {/* Subclasses to implement as needed. */}
    });
    
    pkg.ArrowKeyActivation = new JSModule('KeyActivation', {
        /** @overrides myt.KeyActivation. */
        doActivationKeyDown: function(code, isRepeat) {
            switch (code) {
                case GlobalKeys.CODE_ARROW_LEFT: 
                    if (this.doKeyArrowLeftOrUp(true, isRepeat)) return;
                    break;
                case GlobalKeys.CODE_ARROW_UP: 
                    if (this.doKeyArrowLeftOrUp(false, isRepeat)) return;
                    break;
                case GlobalKeys.CODE_ARROW_RIGHT: 
                    if (this.doKeyArrowRightOrDown(true, isRepeat)) return;
                    break;
                case GlobalKeys.CODE_ARROW_DOWN: 
                    if (this.doKeyArrowRightOrDown(false, isRepeat)) return;
                    break;
            }
            
            this.callSuper(code, isRepeat);
        },
        
        /** Called when the Left or Up arrow key triggers a down event.
            @param {boolean} isLeft - Indicates if the Left or Up key triggered the event.
            @param isRepeat:boolean Indicates if this is a key repeat event or not.
            @returns {boolean} If true doActivationKeyDown will not callSuper. */
        doKeyArrowLeftOrUp: (isLeft, isRepeat) => {/* Subclasses to implement as needed. */},
        
        /** Called when the Right or Down arrow key triggers a down event.
            @param {boolean} isRight - Indicates if the Right or Down key triggered the event.
            @param isRepeat:boolean - Indicates if this is a key repeat event or not.
            @returns {boolean} If true doActivationKeyDown will not callSuper. */
        doKeyArrowRightOrDown: (isRight, isRepeat) => {/* Subclasses to implement as needed. */}
    }),
    
    /** Provides a 'mouseOver' attribute that tracks mouse over/out state. Also provides a 
        mechanism to smoothe over/out events so only one call to 'doSmoothMouseOver' occurs per 
        idle event.
        
        Requires myt.Disableable and myt.MouseObservable super mixins.
        
        Attributes:
            mouseOver:boolean Indicates if the mouse is over this view or not.
        
        Private Attributes:
            __attachedToOverIdle:boolean Used by the code that smoothes out mouseover events. 
                Indicates that we are registered with the idle event.
            __lastOverIdleValue:boolean Used by the code that smoothes out mouseover events. 
                Stores the last mouseOver value.
            __disabledOver:boolean Tracks mouse over/out state while a view is disabled. This 
                allows correct restoration of mouseOver state if a view becomes enabled while the 
                mouse is already over it.
        
        @class */
    pkg.MouseOver = new JSModule('MouseOver', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.mouseOver ??= false;
            
            this.callSuper(parent, attrs);
            
            this.attachToDom(this, 'doMouseOver', 'mouseover');
            this.attachToDom(this, 'doMouseOut', 'mouseout');
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setMouseOver: function(v) {
            if (this.mouseOver !== v) {
                this.mouseOver = v;
                // No event needed
                
                // Smooth out over/out events by delaying until the next idle event.
                if (this.inited && !this.__attachedToOverIdle) {
                    this.__attachedToOverIdle = true;
                    this.attachTo(GlobalIdle, '__doMouseOverOnIdle', 'idle');
                }
            }
        },
        
        /** @overrides myt.Disableable */
        setDisabled: function(v) {
            this.callSuper(v);
            
            if (this.disabled) {
                // When disabling make sure exposed mouseOver is not true. This helps prevent 
                // unwanted behavior of a disabled view such as a disabled button looking like it 
                // is moused over.
                if (this.mouseOver) {
                    this.__disabledOver = true;
                    this.setMouseOver(false);
                }
            } else {
                // Restore exposed mouse over state when enabling
                if (this.__disabledOver) this.setMouseOver(true);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @private
            @returns {undefined} */
        __doMouseOverOnIdle: function() {
            this.detachFrom(GlobalIdle, '__doMouseOverOnIdle', 'idle');
            this.__attachedToOverIdle = false;
            
            // Only call doSmoothOver if the over/out state has changed since the last time it 
            // was called.
            const isOver = this.mouseOver;
            if (this.__lastOverIdleValue !== isOver) {
                this.__lastOverIdleValue = isOver;
                this.doSmoothMouseOver(isOver);
            }
        },
        
        /** Called when mouseOver state changes. This method is called after an event filtering 
            process has reduced frequent over/out events originating from the dom.
            @param {boolean} isOver
            @returns {undefined} */
        doSmoothMouseOver: function(isOver) {
            if (this.inited) this.updateUI?.();
        },
        
        /** Called when the mouse is over this view. Subclasses must call super.
            @param {!Object} event
            @returns {undefined} */
        doMouseOver: function(event) {
            this.__disabledOver = true;
            
            if (!this.disabled) this.setMouseOver(true);
        },
        
        /** Called when the mouse leaves this view. Subclasses must call super.
            @param {!Object} event
            @returns {undefined} */
        doMouseOut: function(event) {
            this.__disabledOver = false;
            
            if (!this.disabled) this.setMouseOver(false);
        }
    });
    
    /** Provides a 'mouseDown' attribute that tracks mouse up/down state.
        
        Requires: myt.MouseOver, myt.Disableable, myt.MouseObservable super mixins.
        
        Suggested: myt.UpdateableUI and myt.Activateable super mixins.
        
        Attributes:
            mouseDown:boolean Indicates if the mouse is down or not.
        
        @class */
    pkg.MouseDown = new JSModule('MouseDown', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.mouseDown ??= false;
            
            this.callSuper(parent, attrs);
            
            this.attachToDom(this, 'doMouseDown', 'mousedown');
            this.attachToDom(this, 'doMouseUp', 'mouseup');
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setMouseDown: function(v) {
            if (this.mouseDown !== v) {
                this.mouseDown = v;
                // No event needed
                if (this.inited) {
                    if (v && this.isFocusable()) this.focus(true);
                    this.updateUI?.();
                }
            }
        },
        
        /** @overrides myt.Disableable */
        setDisabled: function(v) {
            // When about to disable the view make sure mouseDown is not true. This helps prevent 
            // unwanted activation of a disabled view.
            if (v && this.mouseDown) this.setMouseDown(false);
            
            this.callSuper(v);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.MouseOver */
        doMouseOver: function(event) {
            this.callSuper(event);
            if (this.mouseDown) this.detachFromDom(GlobalMouse, 'doMouseUp', 'mouseup', true);
        },
        
        /** @overrides myt.MouseOver */
        doMouseOut: function(event) {
            this.callSuper(event);
            
            // Wait for a mouse up anywhere if the user moves the mouse out of the view while the 
            // mouse is still down. This allows the user to move the mouse in and out of the view 
            // with the view still behaving as moused down.
            if (!this.disabled && this.mouseDown) this.attachToDom(GlobalMouse, 'doMouseUp', 'mouseup', true);
        },
        
        /** Called when the mouse is down on this view. Subclasses must call super.
            @param {!Object} event
            @returns {undefined} */
        doMouseDown: function(event) {
            if (this.disabled) {
                this.doMouseDownWhenDisabled();
            } else {
                this.setMouseDown(true);
            }
        },
        
        /** Called by the doMouseDown function when this View is currently disabled:true. Note that
            the mouseDown attribute of this View will not be true when this function is called.
            @returns {undefined} */
        doMouseDownWhenDisabled: () => {/* Subclasses to implement as needed. */},
        
        /** Called when the mouse is up on this view. Subclasses must call super.
            @param {!Object} event
            @returns {undefined} */
        doMouseUp: function(event) {
            // Cleanup global mouse listener since the mouseUp occurred 
            // outside the view.
            if (!this.mouseOver) this.detachFromDom(GlobalMouse, 'doMouseUp', 'mouseup', true);
            
            if (!this.disabled && this.mouseDown) {
                this.setMouseDown(false);
                
                // Only do mouseUpInside if the mouse is actually over the view. This means the 
                // user can mouse down on a view, move the mouse out and then mouse up and not 
                // "activate" the view.
                if (this.mouseOver) this.doMouseUpInside(event);
            }
        },
        
        /** Called when the mouse is up and we are still over the view. Executes the "doActivated" 
            method by default.
            @param {!Object} event
            @returns {undefined} */
        doMouseUpInside: function(event) {
            this.doActivated?.();
        }
    });
    
    /** Provides both MouseOver and MouseDown mixins as a single mixin.
        
        @class */
    pkg.MouseOverAndDown = new JSModule('MouseOverAndDown', {
        include: [pkg.MouseOver, pkg.MouseDown]
    });
    
    pkg.MouseEventsBubbleUp = new JSModule('MouseEventsBubbleUp', {
        doMouseOver: function(event) {this.callSuper(event); return true;},
        doMouseOut: function(event) {this.callSuper(event); return true;},
        doMouseDown: function(event) {this.callSuper(event); return true;},
        doMouseUp: function(event) {this.callSuper(event); return true;}
    });
    
    /** Makes an myt.View draggable via the mouse.
        
        Also suppresses context menus since the mouse down to open it causes bad behavior since a 
        mouseup event is not always fired.
        
        Events:
            isDragging:boolean Fired when the isDragging attribute is modified via setIsDragging.
        
        Attributes:
            allowAbort:boolean Allows a drag to be aborted by the user by pressing the "esc" key. 
                Defaults to undefined which is equivalent to false.
            isDraggable:boolean Configures the view to be draggable or not. The default value 
                is true.
            distanceBeforeDrag:number The distance, in pixels, before a mouse down and drag is 
                considered a drag action. Defaults to 0.
            isDragging:boolean Indicates that this view is currently being dragged.
            draggableAllowBubble:boolean Determines if mousedown and mouseup dom events handled by 
                this component will bubble or not. Defaults to true.
            dragOffsetX:number The x amount to offset the position during dragging. Defaults to 0.
            dragOffsetY:number The y amount to offset the position during dragging. Defaults to 0.
            dragInitX:number Stores initial mouse x position during dragging.
            dragInitY:number Stores initial mouse y position during dragging.
            centerOnMouse:boolean If true this draggable will update the dragInitX and dragInitY to 
                keep the view centered on the mouse. Defaults to undefined which is equivalent 
                to false.
        
        Private Attributes:
            __lastMousePosition:object The last position of the mouse during dragging.
        
        @class */
    pkg.Draggable = new JSModule('Draggable', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            const self = this;
            
            self.isDraggable = self.isDragging = false;
            self.draggableAllowBubble = true;
            self.distanceBeforeDrag = self.dragOffsetX = self.dragOffsetY = 0;
            
            // Will be set after init since the draggable subview probably doesn't exist yet.
            let isDraggable = true;
            if (attrs.isDraggable != null) {
                isDraggable = attrs.isDraggable;
                delete attrs.isDraggable;
            }
            
            self.callSuper(parent, attrs);
            
            self.setIsDraggable(isDraggable);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setIsDraggable: function(v) {
            const self = this;
            if (self.isDraggable !== v) {
                self.isDraggable = v;
                // No event needed.
                
                let func;
                if (v) {
                    func = self.attachToDom;
                } else if (self.inited) {
                    func = self.detachFromDom;
                }
                
                if (func) {
                    const dragviews = self.getDragViews();
                    let i = dragviews.length;
                    while (i) {
                        const dragview = dragviews[--i];
                        func.call(self, dragview, '__doMouseDown', 'mousedown');
                        func.call(self, dragview, '__doContextMenu', 'contextmenu');
                    }
                }
            }
        },
        
        setIsDragging: function(v) {
            this.set('isDragging', v, true);
        },
        
        setDragOffsetX: function(v, suppressUpdate) {
            if (this.dragOffsetX !== v) {
                this.dragOffsetX = v;
                if (this.inited && this.isDragging && !suppressUpdate) this.reRequestDragPosition();
            }
        },
        
        setDragOffsetY: function(v, suppressUpdate) {
            if (this.dragOffsetY !== v) {
                this.dragOffsetY = v;
                if (this.inited && this.isDragging && !suppressUpdate) this.reRequestDragPosition();
            }
        },
        
        setDistanceBeforeDrag: function(v) {this.distanceBeforeDrag = v;},
        setDraggableAllowBubble: function(v) {this.draggableAllowBubble = v;},
        setCenterOnMouse: function(v) {this.centerOnMouse = v;},
        setAllowAbort: function(v) {this.allowAbort = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @returns {!Array} - An array of views that can be moused down on to start the drag. 
            Subclasses should override this to return an appropriate list of views. By default this 
            view is returned thus making the entire view capable of starting a drag. */
        getDragViews: function() {
            return [this];
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doContextMenu: event => {/* Do nothing so the context menu event is suppressed. */},
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doMouseDown: function(event) {
            const self = this,
                pos = getMouseFromEvent(event),
                ode = self.getODE();
            self.dragInitX = pos.x - ode.offsetLeft;
            self.dragInitY = pos.y - ode.offsetTop;
            
            self.attachToDom(GlobalMouse, '__doMouseUp', 'mouseup', true);
            if (self.distanceBeforeDrag > 0) {
                self.attachToDom(GlobalMouse, '__doDragCheck', 'mousemove', true);
            } else {
                self.startDrag(event);
            }
            
            event.value.preventDefault();
            return self.draggableAllowBubble;
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doMouseUp: function(event) {
            if (this.isDragging) {
                this.stopDrag(event, false);
            } else {
                this.detachFromDom(GlobalMouse, '__doMouseUp', 'mouseup', true);
                this.detachFromDom(GlobalMouse, '__doDragCheck', 'mousemove', true);
            }
            return this.draggableAllowBubble;
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __watchForAbort: function(event) {
            if (event.value === GlobalKeys.CODE_ESC) this.stopDrag(event, true);
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doDragCheck: function(event) {
            const self = this,
                pos = getMouseFromEvent(event),
                distance = pkg.Geometry.measureDistance(pos.x, pos.y, self.dragInitX + self.x, self.dragInitY + self.y);
            if (distance >= self.distanceBeforeDrag) {
                self.detachFromDom(GlobalMouse, '__doDragCheck', 'mousemove', true);
                self.startDrag(event);
            }
        },
        
        /** Active until stopDrag is called. The view position will be bound to the mouse position. 
            Subclasses typically call this onmousedown for subviews that allow dragging the view.
            @param {!Object} event - The event the mouse event when the drag started.
            @returns {undefined} */
        startDrag: function(event) {
            const self = this;
            
            if (self.centerOnMouse) {
                self.syncTo(self, '__updateDragInitX', 'width');
                self.syncTo(self, '__updateDragInitY', 'height');
            }
            
            if (self.allowAbort) self.attachTo(GlobalKeys, '__watchForAbort', 'keyup');
            
            self.setIsDragging(true);
            self.attachToDom(GlobalMouse, 'updateDrag', 'mousemove', true);
            self.updateDrag(event);
        },
        
        /** Called on every mousemove event while dragging.
            @param {!Object} event
            @returns {undefined} */
        updateDrag: function(event) {
            this.__lastMousePosition = getMouseFromEvent(event);
            this.reRequestDragPosition();
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __updateDragInitX: function(event) {
            this.dragInitX = this.width / 2 * (this.scaleX || 1);
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __updateDragInitY: function(event) {
            this.dragInitY = this.height / 2 * (this.scaleY || 1);
        },
        
        /** Stop the drag. (see startDrag for more details)
            @param {!Object} event - The event that ended the drag.
            @param {boolean} isAbort - Indicates if the drag ended normally or was aborted.
            @returns {undefined} */
        stopDrag: function(event, isAbort) {
            const self = this;
            self.detachFromDom(GlobalMouse, '__doMouseUp', 'mouseup', true);
            self.detachFromDom(GlobalMouse, 'updateDrag', 'mousemove', true);
            if (self.centerOnMouse) {
                self.detachFrom(self, '__updateDragInitX', 'width');
                self.detachFrom(self, '__updateDragInitY', 'height');
            }
            if (self.allowAbort) self.detachFrom(GlobalKeys, '__watchForAbort', 'keyup');
            self.setIsDragging(false);
        },
        
        /** Repositions the view to the provided values. The default implementation is to directly 
            set x and y. Subclasses should override this method when it is necessary to constrain 
            the position.
            @param {number} x - the new x position.
            @param {number} y - the new y position.
            @returns {undefined} */
        requestDragPosition: function(x, y) {
            if (!this.disabled) {
                this.setX(x);
                this.setY(y);
            }
        },
        
        reRequestDragPosition: function() {
            const self = this,
                pos = self.__lastMousePosition;
            self.requestDragPosition(
                pos.x - self.dragInitX + self.dragOffsetX, 
                pos.y - self.dragInitY + self.dragOffsetY
            );
        }
    });
})(myt);


(pkg => {
    const {Class:JSClass, Module:JSModule} = JS,
        
        {View, KeyActivation} = pkg,
        
        defaultDisabledOpacity = 0.5,
        defaultFocusShadowPropertyValue = [0, 0, 7, '#666'],
        
        /** Provides button functionality to an myt.View. Most of the functionality comes from the 
            mixins included by this mixin. This mixin resolves issues that arise when the various 
            mixins are used together.
            
            By default myt.Button instances are focusable.
            
            Private Attributes:
                __restoreCursor:string The cursor to restore to when the button is no 
                    longer disabled.
            
            @class */
        Button = pkg.Button = new JSModule('Button', {
            include: [
                pkg.Activateable, 
                pkg.UpdateableUI, 
                pkg.Disableable, 
                pkg.MouseOverAndDown, 
                KeyActivation
            ],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** The default focus shadow. */
                FOCUS_SHADOW: defaultFocusShadowPropertyValue,
                
                /** The default disabled state opacity. */
                DISABLED_OPACITY: defaultDisabledOpacity
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                attrs.focusable ??= true;
                attrs.cursor ??= 'pointer';
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.FocusObservable */
            setFocused: function(v) {
                const self = this,
                    existing = self.focused;
                self.callSuper(v);
                if (self.inited && self.focused !== existing) self.updateUI();
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.KeyActivation. */
            doActivationKeyDown: function(code, isRepeat) {
                // Prevent unnecessary UI updates when the activation key is repeating.
                if (!isRepeat) this.updateUI();
            },
            
            /** @overrides myt.KeyActivation. */
            doActivationKeyUp: function(code) {
                this.callSuper(code);
                this.updateUI();
            },
            
            /** @overrides myt.KeyActivation. */
            doActivationKeyAborted: function(code) {
                this.callSuper(code);
                this.updateUI();
            },
            
            /** @overrides myt.UpdateableUI. */
            updateUI: function() {
                const self = this;
                
                if (self.disabled) {
                    // Remember the cursor to change back to, but don't re-remember if we're 
                    // already remembering one.
                    self.__restoreCursor ??= self.cursor;
                    self.setCursor('not-allowed');
                    self.drawDisabledState();
                } else {
                    const rc = self.__restoreCursor;
                    if (rc) {
                        self.setCursor(rc);
                        self.__restoreCursor = null;
                    }
                    
                    if (self.activateKeyDown !== KeyActivation.NO_KEY_DOWN || self.mouseDown) {
                        self.drawActiveState();
                    } else if (self.focused) {
                        self.drawFocusedState();
                    } else if (self.mouseOver) {
                        self.drawHoverState();
                    } else {
                        self.drawReadyState();
                    }
                }
            },
            
            /** Draw the UI when the component has focus. The default implementation 
                calls drawHoverState.
                @returns {undefined} */
            drawFocusedState: function() {
                this.drawHoverState();
            },
            
            /** Draw the UI when the component is on the verge of being interacted with. For mouse 
                interactions this corresponds to the over state.
                @returns {undefined} */
            drawHoverState: () => {/* Subclasses to implement as needed. */},
            
            /** Draw the UI when the component has a pending activation. For mouse interactions 
                this corresponds to the down state.
                @returns {undefined} */
            drawActiveState: () => {/* Subclasses to implement as needed. */},
            
            /** Draw the UI when the component is ready to be interacted with. For mouse 
                interactions this corresponds to the enabled state when the mouse is not over 
                the component.
                @returns {undefined} */
            drawReadyState: () => {/* Subclasses to implement as needed. */},
            
            /** Draw the UI when the component is in the disabled state.
                @returns {undefined} */
            drawDisabledState: () => {/* Subclasses to implement as needed. */},
            
            /** @overrides myt.FocusObservable */
            showFocusIndicator: function() {
                this.hideDefaultFocusIndicator();
            },
            
            /** @overrides myt.FocusObservable */
            hideFocusIndicator: function() {
                this.hideDefaultFocusIndicator();
            }
        }),
        
        /** A mixin that provides activeColor, hoverColor and readyColor attributes to fill 
            the view.
            
            Attributes:
                activeColor:string A color string such as '#ff0000' or 'transparent'. Used when the 
                    button is in the active state.
                hoverColor:string A color string such as '#ff0000' or 'transparent'. Used when the 
                    button is in the hover state.
                readyColor:string A color string such as '#ff0000' or 'transparent'. Used when the 
                    button is in the ready or disabled state.
            
            @class */
        SimpleButtonStyle = pkg.SimpleButtonStyle = new JSModule('SimpleButtonStyle', {
            include: [Button],
            
            
            // Accessors ///////////////////////////////////////////////////////
            setActiveColor: function(v) {
                if (this.activeColor !== v) {
                    this.activeColor = v;
                    // No event needed
                    if (this.inited) this.updateUI();
                }
            },
            
            setHoverColor: function(v) {
                if (this.hoverColor !== v) {
                    this.hoverColor = v;
                    // No event needed
                    if (this.inited) this.updateUI();
                }
            },
            
            setReadyColor: function(v) {
                if (this.readyColor !== v) {
                    this.readyColor = v;
                    // No event needed
                    if (this.inited) this.updateUI();
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.Button */
            drawDisabledState: function() {
                this.draw(this.readyColor, defaultDisabledOpacity);
            },
            
            /** @overrides myt.Button */
            drawHoverState: function() {
                this.draw(this.hoverColor);
            },
            
            /** @overrides myt.Button */
            drawActiveState: function() {
                this.draw(this.activeColor);
            },
            
            /** @overrides myt.Button */
            drawReadyState: function() {
                this.draw(this.readyColor);
            },
            
            draw: function(color, opacity=1) {
                this.setOpacity(opacity);
                this.setBgColor(color);
            }
        }),
        
        /** An myt.Button that makes use of activeColor, hoverColor and readyColor attributes to 
            fill the button.
            
            @class */
        SimpleButton = pkg.SimpleButton = new JSClass('SimpleButton', View, {
            include: [SimpleButtonStyle],
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.activeColor = this.hoverColor = this.readyColor = 'transparent';
                
                this.callSuper(parent, attrs);
            }
        });
    
    /** A simple button with support for text and a tooltip. Adds a text element to the inside of 
        the button.
        
        Events:
            inset:number
            outset:number
            text:string
            shrinkToFit:boolean
            textY:number|string
        
        Attributes:
            inset:number The left padding before the text. Defaults to 0.
            outset:number The right padding after the text. Defaults to 0.
            text:string The text to display on the button.
            shrinkToFit:boolean When true the button will be as narrow as possible to fit the text, 
                inset and outset. When false the button will be as wide as the set width. Defaults 
                to false.
            textY:number|string The y offset for the text. If a string it must be a valign 
                value: 'top', 'middle' or 'bottom'.
            textView:myt.Text A reference to the child text view.
        
        Private Attributes:
            __updateContentLoopBlock:boolean Used in __updateContent to prevent infinite loops.
        
        @class */
    pkg.SimpleTextButton = new JSClass('SimpleTextButton', SimpleButton, {
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            const self = this;
            
            self.inset = self.outset = 0;
            
            attrs.shrinkToFit ??= false;
            attrs.height ??= 24;
            attrs.textY ??= 'middle';
            
            self.callSuper(parent, attrs);
            
            // Build UI
            const textY = self.textY,
                textAttrs = {
                    whiteSpace: self.shrinkToFit ? 'nowrap' : 'normal', 
                    text:self.text,
                    domClass:'myt-Text mytButtonText'
                };
            if (typeof textY === 'string') {
                textAttrs.valign = textY;
            } else {
                textAttrs.y = textY;
            }
            const textView = self.textView = new pkg.Text(self, textAttrs);
            
            // Setup the constraint after adoption since the textView won't have been sized to the 
            // dom until it's added in.
            self.constrain('__updateContent', [
                self, 'inset', self, 'outset',
                self, 'width', self, 'shrinkToFit',
                textView, 'visible', textView, 'width',
                textView, 'height', textView, 'y'
            ]);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setInset: function(v) {
            this.set('inset', this.valueFromEvent(v), true);
        },
        
        setOutset: function(v) {
            this.set('outset', this.valueFromEvent(v), true);
        },
        
        setText: function(v) {
            if (this.text !== v) {
                this.text = v;
                if (this.inited) {
                    this.textView.setText(v);
                    this.fireEvent('text', v);
                }
            }
        },
        
        setShrinkToFit: function(v) {
            const self = this;
            if (self.shrinkToFit !== v) {
                self.shrinkToFit = v;
                if (self.inited) {
                    self.textView.setWhiteSpace(v ? 'nowrap' : 'normal');
                    self.fireEvent('shrinkToFit', v);
                }
            }
        },
        
        setTextY: function(v) {
            const self = this;
            if (self.textY !== v) {
                self.textY = v;
                if (self.inited) {
                    const textView = self.textView;
                    self.fireEvent('textY', v);
                    if (typeof v === 'string') {
                        textView.setValign(v);
                    } else {
                        textView.setValign('');
                        textView.setY(v);
                    }
                }
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        __updateContent: function(v) {
            const self = this;
            if (!self.__updateContentLoopBlock && !self.destroyed) {
                const {inset, outset, textView} = self;
                self.__updateContentLoopBlock = true;
                textView.setX(inset);
                if (self.shrinkToFit) {
                    self.setWidth(inset + (textView.visible && self.text ? textView.width : 0) + outset);
                } else {
                    textView.setWidth(self.width - inset - outset);
                }
                self.__updateContentLoopBlock = false;
            }
        }
    });
    
    /** A minimalist button that uses a single View with TextSupport.
        
        @class */
    pkg.TextButton = new JSClass('TextButton', pkg.PaddedText, {
        include: [SimpleButtonStyle],
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            attrs.focusIndicator ??= false;
            attrs.roundedCorners ??= 3;
            attrs.textAlign ??= 'center';
            attrs.paddingTop ??= 1;
            attrs.height ??= 23 - (attrs.paddingTop ?? 0);
            attrs.activeColor ??= '#ddd';
            attrs.hoverColor ??= '#eee';
            attrs.readyColor ??= '#fff';
            
            this.callSuper(parent, attrs);
        }
    });
})(myt);


(pkg => {
    const consoleWarn = console.warn,
        
        {focus:GlobalFocus, mouse:GlobalMouse, windowResize} = pkg.global,
        
        panelsByPanelId = {}, // A map of FloatingPanel instances by panel ID.
        
        getFloatingPanel = panelId => panelsByPanelId[panelId],
        
        /** Enables a view to act as the anchor point for a FloatingPanel.
            
            Events:
                floatingAlign:string
                floatingValign:string
                floatingAlignOffset:number
                floatingValignOffset:number
            
            Attributes:
                floatingPanelId:string If defined this is the panel ID that will be used by default 
                    in the various methods that require a panel ID.
                floatingAlign:string:number The horizontal alignment for panels shown by this 
                    anchor. If the value is a string it is an alignment identifier relative to this 
                    anchor. If the value is a number it is an absolute position in pixels. Allowed 
                    values: 'outsideLeft', 'insideLeft', 'insideRight', 'outsideRight' or a number.
                floatingValign:string:number The vertical alignment for panels shown by this anchor.
                    If the value is a string it is an alignment identifier relative to this anchor.
                    If the value is a number it is an absolute position in pixels. Allowed values: 
                    'outsideTop', 'insideTop', 'insideBottom', 'outsideBottom' or a number.
                floatingAlignOffset:number The number of pixels to offset the panel position 
                    by horizontally.
                floatingValignOffset:number The number of pixels to offset the panel position 
                    by vertically.
                lastFloatingPanelShown:myt.FloatingPanel A reference to the last floating panel 
                    shown by this anchor.
                keepInWindow:boolean - Indicates if the floating panel must be kept within the
                    bounds of the HTML document. Defaults to false.
                keepInWindowBorder:number - Extra space to take into account when checking if the
                    FloatingPanel would not be kept within the window.
            
            @class */
        FloatingPanelAnchor = pkg.FloatingPanelAnchor = new JS.Module('FloatingPanelAnchor', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                getFloatingPanel:getFloatingPanel
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.floatingAlign = 'insideLeft';
                this.floatingValign = 'outsideBottom';
                this.keepInWindow = false;
                this.floatingAlignOffset = this.floatingValignOffset = this.keepInWindowBorder = 0;
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setLastFloatingPanelShown: function(v) {this.lastFloatingPanelShown = v;},
            setLastFloatingPanelId: function(v) {this.floatingPanelId = v;},
            
            setFloatingAlign: function(v) {this.set('floatingAlign', v, true);},
            setFloatingValign: function(v) {this.set('floatingValign', v, true);},
            setFloatingAlignOffset: function(v) {this.set('floatingAlignOffset', v, true);},
            setFloatingValignOffset: function(v) {this.set('floatingValignOffset', v, true);},
            
            setKeepInWindow: function(v) {this.set('keepInWindow', v, true);},
            setKeepInWindowBorder: function(v) {this.set('keepInWindowBorder', v, true);},
            
            
            // Methods /////////////////////////////////////////////////////////
            createFloatingPanel: function(panelId, panelClass, panelInitAttrs) {
                panelId = panelId ?? this.floatingPanelId;
                panelInitAttrs = panelInitAttrs ?? {};
                panelInitAttrs.panelId = panelId;
                return panelsByPanelId[panelId] = new panelClass(null, panelInitAttrs);
            },
            
            getFloatingPanel: function(panelId) {
                return getFloatingPanel(panelId ?? this.floatingPanelId);
            },
            
            toggleFloatingPanel: function(panelId) {
                const fp = this.getFloatingPanel(panelId ??= this.floatingPanelId);
                if (fp?.isShown()) {
                    this.hideFloatingPanel(panelId);
                } else {
                    this.showFloatingPanel(panelId);
                }
            },
            
            showFloatingPanel: function(panelId) {
                const fp = this.getFloatingPanel(panelId ?? this.floatingPanelId);
                if (fp) {
                    fp.show(this);
                    this.setLastFloatingPanelShown(fp);
                }
            },
            
            hideFloatingPanel: function(panelId) {
                const fp = this.getFloatingPanel(panelId ?? this.floatingPanelId);
                if (fp) {
                    fp.hide();
                    this.setLastFloatingPanelShown();
                }
            },
            
            /** Called when a floating panel has been shown for this anchor.
                @param {!Object} panel - The myt.FloatingPanel that is now shown.
                @returns {undefined} */
            notifyPanelShown: function(panel) {
                // Subclasses to implement as needed.
                this.callSuper?.();
            },
            
            /** Called when a floating panel has been hidden for this anchor.
                @param {!Object} panel - The myt.FloatingPanel that is now hidden.
                @returns {undefined} */
            notifyPanelHidden: function(panel) {
                // Subclasses to implement as needed.
                this.callSuper?.();
            },
            
            /** Called by the FloatingPanel to determine where to position itself horizontally. By 
                default this returns the floatingAlign attribute. Subclasses and instances should 
                override this if panel specific behavior is needed.
                @param {?Object} panel - The panel being positioned.
                @returns {string|number} - An alignment identifer or absolute position. */
            getFloatingAlignForPanel: function(panel) {
                return this.floatingAlign;
            },
            
            /** Called by the FloatingPanel to determine where to position itself vertically. By 
                default this returns the floatingAlign attribute. Subclasses and instances should 
                override this if panel specific behavior is needed.
                @param {?Object} panel - The panel being positioned.
                @returns {string|number} - An alignment identifer or absolute position. */
            getFloatingValignForPanel: function(panel) {
                return this.floatingValign;
            },
            
            /** Called by the FloatingPanel to determine where to position itself horizontally. By 
                default this returns the floatingAlignOffset attribute. Subclasses and instances 
                should override this if panel specific behavior is needed.
                @param {?Object} panel - The panel being positioned.
                @returns {number} the offset to use. */
            getFloatingAlignOffsetForPanel: function(panel) {
                return this.floatingAlignOffset;
            },
            
            /** Called by the FloatingPanel to determine where to position itself vertically. By 
                default this returns the floatingValignOffset attribute. Subclasses and instances 
                should override this if panel specific behavior is needed.
                @param {?Object} panel - The panel being positioned.
                @returns {number} the offset to use. */
            getFloatingValignOffsetForPanel: function(panel) {
                return this.floatingValignOffset;
            },
            
            /** @overrides myt.FocusObservable
                @returns {!Object} The last floating panel shown if it exists and can be shown. 
                    Otherwise it returns the default. */
            getNextFocus: function() {
                const last = this.lastFloatingPanelShown;
                if (last?.isShown()) return last;
                return this.callSuper?.();
            },
            
            /** Called by the floating panel owned by this anchor to determine where to go to next 
                after leaving the panel in the forward direction.
                @param {string} panelId
                @returns {!Object} */
            getNextFocusAfterPanel: function(panelId) {
                return this;
            },
            
            /** Called by the floating panel owned by this anchor to determine where to go to next 
                after leaving the panel in the backward direction.
                @param {string} panelId
                @returns {!Object} */
            getPrevFocusAfterPanel: function(panelId) {
                return this;
            }
        });
    
    /** A panel that floats above everything else.
        
        Attributes:
            owner:myt.FloatingPanelAnchor The anchor that currently "owns" this panel.
            panelId:string The unique ID for this panel instance.
            hideOnMouseDown:boolean If true this panel will be hidden when a mousedown occurs 
                outside the panel. True by default.
            ignoreOwnerForHideOnMouseDown:boolean If true the owner view for this panel will also 
                be ignored for mousedown events. True by default.
            ignoreOwnerForHideOnBlur:boolean If true the owner view for this panel will also be 
                ignored for blur events. True by default.
            hideOnBlur:boolean If true this panel will be hidden when a focus traverses outside 
                the panel. True by default.
        
        @class */
    pkg.FloatingPanel = new JS.Class('FloatingPanel', pkg.View, {
        include: [pkg.RootView],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            this.ignoreOwnerForHideOnMouseDown = this.ignoreOwnerForHideOnBlur = this.hideOnBlur = this.hideOnMouseDown = true;
            
            attrs.visible = attrs.focusIndicator = false;
            
            // Ensure the focus starts and ends with the panel
            attrs.focusable = attrs.focusCage = true;
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setOwner: function(v) {this.owner = v;},
        setPanelId: function(v) {this.panelId = v;},
        setIgnoreOwnerForHideOnMouseDown: function(v) {this.ignoreOwnerForHideOnMouseDown = v;},
        setHideOnBlur: function(v) {this.hideOnBlur = v;},
        setHideOnMouseDown: function(v) {this.hideOnMouseDown = v;},
        
        setWidth: function(v) {
            const oldValue = this.width;
            this.callSuper(v);
            if (this.isShown() && (oldValue !== this.width) && this.owner?.keepInWindow) {
                this.updateLocationX(this.owner);
            }
        },
        
        setHeight: function(v) {
            const oldValue = this.height;
            this.callSuper(v);
            if (this.isShown() && (oldValue !== this.height) && this.owner?.keepInWindow) {
                this.updateLocationY(this.owner);
            }
        },
        
        // Methods /////////////////////////////////////////////////////////////
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doMouseDown: function(event) {
            const v = event.value, 
                px = v.pageX, 
                py = v.pageY;
            if (!this.containsPoint(px, py) && 
                (this.ignoreOwnerForHideOnMouseDown ? !this.owner.containsPoint(px, py) : true)
            ) {
                this.doMouseDownOutside(true);
            }
            return true;
        },
        
        /** Called when a mousedown occurs outside the floating panel. The default behavior is to 
            hide the panel. This gives subclasses a chance to provide different behavior.
            @param ignoreRestoreFocus:boolean (Optional) If true the restoreFocus method will not 
                be called. Defaults to undefined which is equivalent to false.
            @returns {undefined} */
        doMouseDownOutside: function(ignoreRestoreFocus) {
            if (this.hideOnMouseDown) this.hide(ignoreRestoreFocus);
        },
        
        /** @overrides myt.FocusObservable
            Intercepts focus on this panel and refocuses to the "best" view. When focus enters the 
            panel we give focus to the first focusable descendant of the panel. When leaving we ask 
            the panel anchor where to give focus. */
        focus: function(noScroll) {
            if (this.owner && this.isAncestorOf(GlobalFocus.focusedView)) {
                this.owner[(GlobalFocus.lastTraversalWasForward ? 'getNext' : 'getPrev') + 'FocusAfterPanel'](this.panelId).focus(noScroll);
            } else {
                const ffv = this.getFirstFocusableDescendant();
                if (ffv === this) {
                    // Process normally since focus is actually being set on the panel.
                    this.callSuper(noScroll);
                } else {
                    ffv.focus(noScroll);
                }
            }
        },
        
        /** Gets the view to give focus to when this panel gets focus. Should be a descendant of 
            the floating panel or the panel itself. Returns this floating panel by default.
            @returns myt.View: The view to give focus to. */
        getFirstFocusableDescendant: function() {
            return this;
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doFocusChange: function(event) {
            const v = event.value;
            if (v && !this.isAncestorOf(v)) this.doLostFocus();
        },
        
        /** Called when focus moves out of the floating panel. Hides the floating panel by default.
            @returns {undefined} */
        doLostFocus: function() {
            if (this.hideOnBlur) {
                if (this.ignoreOwnerForHideOnBlur && GlobalFocus.focusedView === this.owner) return;
                
                this.hide(true);
            }
        },
        
        /** Determines if this floating panel is being "shown" or not. Typically this means the 
            floating panel is visible.
            @returns {boolean} True if this panel is shown, otherwise false. */
        isShown: function() {
            return this.visible;
        },
        
        /** Shows the floating panel for the provided myt.FloatingPanelAnchor.
            @param panelAnchor:myt.FloatingPanelAnchor The floating panel anchor to show the 
                panel for.
            @returns {undefined} */
        show: function(panelAnchor) {
            if (!this.isShown()) {
                this.bringToFront();
                this.updateLocation(panelAnchor);
                this.setVisible(true);
                
                this.owner.notifyPanelShown(this);
                
                this.attachToDom(GlobalMouse, '__doMouseDown', 'mousedown', true);
                this.attachTo(GlobalFocus, '__doFocusChange', 'focused');
            }
        },
        
        /** Hides the floating panel for the provided myt.FloatingPanelAnchor.
            @param ignoreRestoreFocus:boolean (Optional) If true the restoreFocus method will not 
                be called. Defaults to undefined which is equivalent to false.
            @returns {undefined} */
        hide: function(ignoreRestoreFocus) {
            if (this.isShown()) {
                this.detachFromDom(GlobalMouse, '__doMouseDown', 'mousedown', true);
                this.detachFrom(GlobalFocus, '__doFocusChange', 'focused');
                
                this.setVisible(false);
                this.owner.notifyPanelHidden(this);
                if (!ignoreRestoreFocus) this.restoreFocus();
                this.setOwner();
            }
        },
        
        /** Sends the focus back to the owner. Can be overridden to send the focus elsewhere.
            @returns {undefined} */
        restoreFocus: function() {
            this.owner?.focus();
        },
        
        /** Updates the x and y position of the floating panel for the provided floating 
            panel anchor.
            @param panelAnchor:myt.FloatingPanelAnchor The anchor to update the location for.
            @returns {undefined} */
        updateLocation: function(panelAnchor) {
            this.setOwner(panelAnchor);
            this.updateLocationX(panelAnchor);
            this.updateLocationY(panelAnchor);
        },
        
        updateLocationX: function(panelAnchor) {
            const align = panelAnchor.getFloatingAlignForPanel(this),
                type = typeof align;
            let x;
            if (type === 'string') {
                x = panelAnchor.getPagePosition().x + panelAnchor.getFloatingAlignOffsetForPanel(this);
                switch (align) {
                    case 'outsideRight': x += panelAnchor.width; break;
                    case 'insideRight': x += panelAnchor.width - this.width; break;
                    case 'outsideLeft': x -= this.width; break;
                    case 'insideLeft': break;
                    default: consoleWarn('Invalid align value', type, align);
                }
                
                if (panelAnchor.keepInWindow) {
                    const diff = x + this.width + (panelAnchor.keepInWindowBorder || 0) - windowResize.getWidth();
                    if (diff > 0) x -= diff;
                }
            } else if (type === 'number') {
                // Absolute position
                x = align;
            } else {
                consoleWarn('Invalid align type', type, align);
            }
            this.setX(x);
        },
        
        updateLocationY: function(panelAnchor) {
            const valign = panelAnchor.getFloatingValignForPanel(this),
                type = typeof valign;
            let y;
            if (type === 'string') {
                y = panelAnchor.getPagePosition().y + panelAnchor.getFloatingValignOffsetForPanel(this);
                switch (valign) {
                    case 'outsideBottom': y += panelAnchor.height; break;
                    case 'insideBottom': y += panelAnchor.height - this.height; break;
                    case 'outsideTop': y -= this.height; break;
                    case 'insideTop': break;
                    default: consoleWarn('Invalid valign value', type, valign);
                }
                
                if (panelAnchor.keepInWindow) {
                    const diff = y + this.height + (panelAnchor.keepInWindowBorder || 0) - windowResize.getHeight();
                    if (diff > 0) y -= diff;
                }
            } else if (type === 'number') {
                // Absolute position
                y = valign;
            } else {
                consoleWarn('Invalid valign type', type, valign);
            }
            this.setY(y);
        }
    });
})(myt);


(pkg => {
    const {Class:JSClass, Module:JSModule} = JS,
        
        math = Math,
        
        {View, global:G} = pkg,
        GlobalFocus = G.focus,
        GlobalKeys = G.keys,
        {LIST_KEYS, CODE_ESC} = GlobalKeys,
        
        updateItems = listView => {
            const cfg = listView.itemConfig ?? [],
                cfgLen = cfg.length,
                {items, defaultItemClass, fixedWidth} = listView,
                itemsLen = items.length,
                isFixedWidth = fixedWidth > 0,
                contentView = listView.getContentView(), 
                layouts = contentView.getLayouts();
            let i = 0;
            
            // Lock layouts during reconfiguration
            for (const layout of layouts) layout.incrementLockedCounter();
            
            // Performance: Remove from dom while doing inserts
            View.doWhileRemovedFromDom(contentView, () => {
                // Reconfigure list
                const itemAttrs = {listView:listView};
                if (isFixedWidth) {
                    itemAttrs.width = fixedWidth;
                    itemAttrs.enableEllipsis = true;
                }
                for (; cfgLen > i; ++i) {
                    const cfgItem = cfg[i],
                        cfgClass = cfgItem.klass ?? defaultItemClass,
                        cfgAttrs = cfgItem.attrs ?? {};
                    let item = items[i];
                    
                    // Destroy existing item if it's the wrong class
                    if (item && !item.isA(cfgClass)) {
                        item.destroy();
                        item = null;
                    }
                    
                    // Create a new item if no item exists
                    item ??= items[i] = new cfgClass(contentView, {...itemAttrs});
                    
                    // Apply config to item
                    if (item) {
                        item.callSetters(cfgAttrs);
                        
                        // Create an item index to sort the layout subviews on. This is necessary when 
                        // the class of list items change so that the newly created items don't end up 
                        // out of order.
                        item.__LAYOUT_IDX = i;
                    }
                }
            });
            
            let minWidth;
            if (isFixedWidth) {
                minWidth = fixedWidth;
            } else {
                // Measure width. Must be in dom at this point.
                minWidth = listView.minWidth;
                for (i = 0; cfgLen > i;) {
                    const item = items[i++];
                    item.syncToDom();
                    minWidth = math.max(minWidth, item.getMinimumWidth());
                }
            }
            
            // Delete any remaining items
            for (; itemsLen > i;) items[i++].destroy();
            items.length = cfgLen;
            
            // Resize items and contentView
            if (!isFixedWidth) {
                for (i = 0; cfgLen > i;) listView.updateItemWidth(items[i++], minWidth);
            }
            listView.updateContentWidth(contentView, minWidth);
            
            // Unlock layouts and update
            for (const layout of layouts) {
                layout.sortSubviews((a, b) => a.__LAYOUT_IDX - b.__LAYOUT_IDX);
                layout.decrementLockedCounter();
                layout.update();
            }
        },
        
        /** Defines the interface list view items must support.
            
            Attributes:
                listView:myt.ListView The list view this item is managed by.
            
            @class */
        ListViewItemMixin = pkg.ListViewItemMixin = new JSModule('ListViewItemMixin', {
            // Accessors ///////////////////////////////////////////////////////
            setListView: function(v) {this.listView = v;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Subclasses and/or implementations must implement this method. Should return the 
                minimum width the list item needs to display itself.
                @returns number */
            getMinimumWidth: () => 0,
            
            /** Part of a performance optimization. Called from updateItems after the items have 
                been inserted into the dom. Now we can actually measure text width. */
            syncToDom: () => {}
        });
    
    /** A floating panel that contains a list of items.
        
        Events:
            maxHeight:number
        
        Attributes:
            minWidth:number The minimum width for the list. The list will size itself to fit the 
                maximum width of the items in the list or this value whichever is larger. 
                Defaults to 0.
            maxHeight:number The maximum height of the list view in pixels. If set to -1 no max 
                height will be used.
            defaultItemClass:JS.Class The class to use for list items if one is not provided in 
                the config. Defaults to myt.ListViewItem.
            itemConfig:array An array of configuration information for the items in the list.
            items:array The array of items in the list.
        
        @class */
    pkg.ListView = new JSClass('ListView', pkg.FloatingPanel, {
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            this.items = [];
            this.maxHeight = -1;
            this.minWidth = 0;
            
            attrs.defaultItemClass ??= pkg.ListViewItem;
            attrs.overflow ??= 'autoy';
            attrs.bgColor ??= '#ccc';
            attrs.boxShadow ??= pkg.Button.FOCUS_SHADOW;
            
            this.callSuper(parent, attrs);
            
            updateItems(this);
            this.buildLayout(this.getContentView());
        },
        
        /** Allows subclasses to specify their own layout. For example a multi-column layout using 
            a WrappingLayout is possible. */
        buildLayout: contentView => {
            new pkg.SpacedLayout(contentView, {axis:'y', spacing:1, collapseParent:true});
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setMinWidth: function(v) {this.minWidth = v;},
        setDefaultItemClass: function(v) {this.defaultItemClass = v;},
        setItemConfig: function(v) {
            this.itemConfig = v;
            if (this.inited) updateItems(this);
        },
        
        /** Get the view that will contain list content.
            @returns {!Object} myt.View */
        getContentView: function() {
            return this;
        },
        
        setMaxHeight: function(v) {
            if (this.maxHeight !== v) {
                this.maxHeight = v;
                if (this.inited) {
                    this.fireEvent('maxHeight', v);
                    this.setHeight(this.height);
                }
            }
        },
        
        /** @overrides myt.View */
        setHeight: function(v) {
            // Limit height if necessary
            this.callSuper(this.maxHeight >= 0 ? math.min(this.maxHeight, v) : v);
            if (this.inited && this.owner) this.updateLocationY(this.owner);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** ListViewItems should call this method when they are activated. The default 
            implementation invokes doItemActivated on the ListViewAnchor.
            @param {!Object} itemView
            @returns {undefined} */
        doItemActivated: function(itemView) {
            this?.owner.doItemActivated(itemView);
        },
        
        /** @overrides myt.FloatingPanel */
        getFirstFocusableDescendant: function() {
            return this.getFirstFocusableItem() ?? this.callSuper();
        },
        
        getFirstFocusableItem: function() {
            return this.items.find(item => item.isFocusable());
        },
        
        getLastFocusableItem: function() {
            return this.items.findLast(item => item.isFocusable());
        },
        
        focusToLastItem: function() {
            this.getLastFocusableItem()?.focus();
        },
        
        focusToFirstItem: function() {
            this.getFirstFocusableItem()?.focus();
        },
        
        updateItemWidth: (item, width) => {
            item.setWidth(width);
        },
        
        updateContentWidth: (contentView, width) => {
            contentView.setWidth(width);
        }
    });
    
    /** The anchor for an myt.ListView.
        
        Attributes:
            listViewClass:JS.Class The class of list view to create. Defaults to myt.ListView.
            listViewAttrs:object The initialization attributes for the listViewClass.
            itemConfig:array An array of configuration parameters for the items in the list.
        
        @class */
    pkg.ListViewAnchor = new JSModule('ListViewAnchor', {
        include: [pkg.FloatingPanelAnchor, pkg.ArrowKeyActivation],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            attrs.listViewClass ??= pkg.ListView;
            attrs.listViewAttrs ??= {};
            attrs.itemConfig ??= [];
            
            // Assume this will be mixed onto something that implements myt.KeyActivation since 
            // it probably will.
            attrs.activationKeys ??= LIST_KEYS;
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setListViewClass: function(v) {this.listViewClass = v;},
        setListViewAttrs: function(v) {this.listViewAttrs = v;},
        setItemConfig: function(v) {this.itemConfig = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides */
        getFloatingValignForPanel: function(panel) {
            const self = this,
                panelHeight = panel.height,
                heightAbove = self.getPagePosition().y,
                heightBelow = G.windowResize.getHeight() - self.getPagePosition().y - self.height,
                diffAbove = heightAbove - panelHeight,
                diffBelow = heightBelow - panelHeight,
                moreHeightAbove = heightAbove > heightBelow;
            
            let valign = self.floatingValign;
            switch (valign) {
                case 'outsideBottom':
                    if (diffBelow < 0 && moreHeightAbove) valign = 'outsideTop';
                    break;
                case 'insideBottom':
                    if (diffBelow < 0 && moreHeightAbove) valign = 'insideTop';
                    break;
                case 'outsideTop':
                    if (diffAbove < 0 && !moreHeightAbove) valign = 'outsideBottom';
                    break;
                case 'insideTop':
                    if (diffAbove < 0 && !moreHeightAbove) valign = 'insideBottom';
                    break;
            }
            return valign;
        },
        
        /** Called by the list view when an item is activated. By default it hides the list view.
            @param {!Object} itemView
            @returns {undefined} */
        doItemActivated: function(itemView) {
            this.hideFloatingPanel();
        },
        
        /** @overrides myt.FloatingPanelAnchor */
        getFloatingPanel: function(panelId) {
            return this.callSuper(panelId) ?? this.createFloatingPanel(panelId, this.listViewClass, this.listViewAttrs);
        },
        
        /** @overrides myt.FloatingPanelAnchor */
        showFloatingPanel: function(panelId) {
            const fp = this.getFloatingPanel(panelId);
            if (fp) {
                fp.setItemConfig(this.itemConfig);
                this.callSuper(panelId);
            }
        },
        
        /** @overrides myt.KeyActivation. */
        doActivationKeyDown: function(code, isRepeat) {
            // Close for escape key.
            if (code === CODE_ESC) {
                this.hideFloatingPanel();
            } else {
                // Select first/last if the list view is already open
                this.callSuper(code, isRepeat);
            }
        },
        
        /** @overrides myt.ArrowKeyActivation. */
        doKeyArrowLeftOrUp: function(isLeft, isRepeat) {
            this.focusToLastItem();
        },
        
        /** @overrides myt.ArrowKeyActivation. */
        doKeyArrowRightOrDown: function(isRight, isRepeat) {
            this.focusToFirstItem();
        },
        
        /** @overrides myt.KeyActivation. */
        doActivationKeyUp: function(code) {
            // Abort for escape key.
            if (code !== CODE_ESC) {
                this.callSuper(code);
                
                // Select first/last after list view is open.
                switch (code) {
                    case GlobalKeys.CODE_ARROW_LEFT:
                    case GlobalKeys.CODE_ARROW_UP:
                        this.focusToLastItem();
                        break;
                    case GlobalKeys.CODE_ARROW_RIGHT:
                    case GlobalKeys.CODE_ARROW_DOWN:
                        this.focusToFirstItem();
                        break;
                }
            }
        },
        
        focusToLastItem: function() {
            const fp = this.getFloatingPanel();
            if (fp?.isShown()) fp.focusToLastItem();
        },
        
        focusToFirstItem: function() {
            const fp = this.getFloatingPanel();
            if (fp?.isShown()) fp.focusToFirstItem();
        },
        
        // List Manipulation
        /** Updates an attr of an itemConfig entry with a matching value.
            @param {*} value
            @param {string} attrName
            @param {*} attrValue
            @returns {?Object} - The entry if a match was found, otherwise undefined. */
        updateEntryAttr: function(value, attrName, attrValue) {
            const entry = this.getEntryByValue(value);
            if (entry) entry.attrs[attrName] = attrValue;
            return entry;
        },
        
        /** Gets the first itemConfig entry with an attrs.value exactly equal to the provided value.
            @param {*} value
            @returns {?Object} - The itemConfig entry or undefined if no match found. */
        getEntryByValue: function(value) {
            return this.itemConfig.find(entry => entry?.attrs && entry.attrs.value === value);
        }
    });
    
    /** An item in an myt.ListView
        
        @class */
    pkg.ListViewItem = new JSClass('ListViewItem', pkg.TextButton, {
        include: [ListViewItemMixin, pkg.ArrowKeyActivation],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            attrs.activeColor ??= '#bbb';
            attrs.hoverColor ??= '#fff';
            attrs.readyColor ??= '#eee';
            attrs.paddingLeft ??= 8;
            attrs.paddingRight ??= 8;
            attrs.textAlign ??= 'left';
            attrs.roundedCorners ??= 0;
            attrs.activationKeys ??= LIST_KEYS;
            attrs.focusIndicator ??= true;
            
            const enableEllipsis = this.__enableEllipsis = attrs.enableEllipsis;
            delete attrs.enableEllipsis;
            
            this.callSuper(parent, attrs);
            
            this.addDomClass('mytButtonText');
            if (enableEllipsis) this.enableEllipsis();
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.TextSupport */
        setText: function(v) {
            this.callSuper(v);
            if (this.__enableEllipsis) this.setTooltip(this.text);
        },
        
        /** @overrides myt.ListViewItemMixin */
        syncToDom: function() {
            this.getIDS().width = 'auto';
            this.sizeViewToDom();
        },
        
        /** @overrides myt.ListViewItemMixin */
        getMinimumWidth: function() {
            return math.ceil(this.measureNoWrapWidth());
        },
        
        /** @overrides myt.Button */
        doActivated: function() {
            this.listView.doItemActivated(this);
        },
        
        /** @overrides myt.KeyActivation. */
        doActivationKeyDown: function(code, isRepeat) {
            if (code === CODE_ESC) {
                this.listView.owner.hideFloatingPanel();
            } else {
                this.callSuper(code, isRepeat);
            }
        },
        
        /** @overrides myt.ArrowKeyActivation. */
        doKeyArrowLeftOrUp: function(isLeft, isRepeat) {
            GlobalFocus.prev();
        },
        
        /** @overrides myt.ArrowKeyActivation. */
        doKeyArrowRightOrDown: function(isRight, isRepeat) {
            GlobalFocus.next();
        }
    });
    
    /** A separator item in an myt.ListView
        
        @class */
    pkg.ListViewSeparator = new JSClass('ListViewSeparator', View, {
        include: [ListViewItemMixin],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            attrs.height ??= 1;
            attrs.bgColor ??= '#666';
            
            this.callSuper(parent, attrs);
        }
    });
})(myt);


(pkg => {
    const AccessorSupport = pkg.AccessorSupport,
        generateSetterName = AccessorSupport.generateSetterName,
        
        /*  A data structure of groups stored as a map of maps. First level is attribute name 
            second level is group ID. */
        BAGsByAttrName = {},
        
        /** Manages a boolean attribute on a collection of Nodes. Ensures that no more than one of 
            the Nodes has the attribute set to true at one time.
            
            Events:
                attrName:string
                groupId:string
                trueNode:myt.Node
            
            Attributes:
                attrName:string The name of the boolean attribute to monitor and update.
                groupId:string The unqiue ID of the group.
                trueNode:myt.Node The node that is currently true. Will be null if no node is true.
            
            Private Attributes:
                __nodes:array A list of the currently registered nodes.
            
            @class */
        BAG = pkg.BAG = new JS.Class('BAG', {
            include: [AccessorSupport, pkg.Destructible, pkg.Observable],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** Gets a BAG for the attribute name and group ID.
                    @param attrName:string the name of the attribute to monitor.
                    @param groupId:string the unique ID of the group.
                    @returns the BAG or undefined if not found */
                getGroup: (attrName, groupId) => {
                    if (attrName && groupId) {
                        const groupIdMap = BAGsByAttrName[attrName] ??= {};
                        return groupIdMap[groupId] ??= new BAG(attrName, groupId);
                    }
                },
                
                /** Removes a BAG for the attribute name and group id.
                    @param attrName:string the name of the attribute to monitor.
                    @param groupId:string the unique ID of the group.
                    @returns the removed BAG or undefined if no BAG was removed. */
                removeGroup: (attrName, groupId) => {
                    if (attrName && groupId) {
                        const groupIdMap = BAGsByAttrName[attrName];
                        if (groupIdMap) {
                            const group = groupIdMap[groupId];
                            if (group) delete groupIdMap[groupId];
                            return group;
                        }
                    }
                }
            },
            
            
            // Constructor /////////////////////////////////////////////////////
            initialize: function(attrName, groupId) {
                this.__nodes = [];
                this.trueNode = null;
                
                this.attrName = attrName;
                this.groupId = groupId;
            },
        
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.Destructible */
            destroy: function() {
                if (this.trueNode) this.setTrueNode(null);
                
                if (this.__nodes.length === 0) BAG.removeGroup(this.attrName, this.groupId);
                
                this.__nodes.length = 0;
                this.detachAllObservers();
                this.callSuper();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setGroupId: function(v) {this.set('groupId', v, true);},
            setAttrName: function(v) {this.set('attrName', v, true);},
            setTrueNode: function(v) {this.set('trueNode', v, true);},
            getNodes: function() {return this.__nodes;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Registeres a node with this group.
                @param node:myt.Node the node to register with this group.
                @returns {undefined} */
            register: function(node) {
                if (node && !this.isRegistered(node)) {
                    this.__nodes.push(node);
                    
                    // If node is true then update for this.
                    if (node[this.attrName]) this.setTrue(node);
                }
            },
            
            /** Unregisteres a node from this group.
                @param node:myt.Node the node to unregister from this group.
                @returns {undefined} */
            unregister: function(node) {
                if (node) {
                    const nodes = this.__nodes,
                        idx = nodes.indexOf(node);
                    if (idx > -1) nodes.splice(idx, 1);
                    
                    if (this.trueNode === node) this.setTrueNode(null);
                    
                    if (nodes.length === 0) this.destroy();
                }
            },
            
            /** Sets the attribute to true on the provided registered node and sets it to false on 
                all other registered nodes.
                @param node:myt.Node the node to set the attribute to true on.
                @returns {undefined} */
            setTrue: function(node) {
                if (node && this.trueNode !== node && this.isRegistered(node)) {
                    const attrName = this.attrName,
                        setterName = generateSetterName(attrName),
                        nodes = this.__nodes;
                    let i = nodes.length;
                    
                    this.setTrueNode(node);
                    
                    while (i) {
                        const n = nodes[--i];
                        if (node === n) {
                            if (!n[attrName]) n[setterName](true);
                        } else {
                            if (n[attrName]) n[setterName](false);
                        }
                    }
                    
                }
            },
            
            /** Sets the attribute to false on the provided registered node.
                @param node:myt.Node the node to set the attribute to false on.
                @returns {undefined} */
            setFalse: function(node) {
                if (node && this.trueNode === node) {
                    node[generateSetterName(this.attrName)](false);
                    this.setTrueNode(null);
                }
            },
            
            /** Checks if a node is already registered or not.
                @param node:myt.Node the node to test.
                @returns {undefined} */
            isRegistered: function(node) {
                return this.__nodes.includes(node);
            }
        });
    
    /** Provides the capability for a Node to participate in a BAG.
        
        Private Attributes:
            __bags:array A list of BAGs this node is a member of.
        
        @class */
    pkg.BAGMembership = new JS.Module('BAGMembership', {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.Node */
        initNode: function(parent, attrs) {
            this.__bags = [];
            
            this.callSuper(parent, attrs);
        },
        
        /** @overrides myt.Node */
        destroy: function() {
            const groups = this.__bags;
            let i = groups.length;
            while (i) {
                const group = groups[--i];
                this.removeFromBAG(group.attrName, group.groupId);
            }
            
            this.callSuper();
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        isRegisteredWithBAG: function(group) {
            return this.__bags.includes(group);
        },
        
        getBAG: (attrName, groupId) => BAG.getGroup(attrName, groupId),
        
        /** Adds this node to the BAG for the groupId and attribute name.
            @param attrName:string
            @param groupId:string
            @returns {undefined} */
        addToBAG: function(attrName, groupId) {
            const group = this.getBAG(attrName, groupId);
            if (!this.isRegisteredWithBAG(group)) {
                this.__bags.push(group);
                group.register(this);
                
                // Monitor attribute
                if (!this.isAttachedTo(this, '__updateForBAG', attrName)) {
                    this.attachTo(this, '__updateForBAG', attrName);
                }
            }
        },
        
        /** Removes this node from the BAG for the groupId and attribute name.
            @param attrName:string
            @param groupId:string
            @returns {undefined} */
        removeFromBAG: function(attrName, groupId) {
            const group = this.getBAG(attrName, groupId);
            if (this.isRegisteredWithBAG(group)) {
                const groups = this.__bags;
                let i = groups.length,
                    detach = true;
                while (i) {
                    const g = groups[--i];
                    if (g === group) {
                        groups.splice(i, 1);
                        group.unregister(this);
                    } else if (g.attrName === attrName) {
                        // Don't detach if another group is listening to the same attr.
                        detach = false;
                    }
                }
                
                if (detach) this.detachFrom(this, '__updateForBAG', attrName);
            }
        },
        
        /** Called whenever an event for the attrName is fired.
            @private 
            @param {!Object} event
            @returns {undefined} */
        __updateForBAG: function(event) {
            for (const bag of this.__bags) {
                if (bag.attrName === event.type) bag[event.value ? 'setTrue' : 'setFalse'](this);
            }
        }
    });
})(myt);


(pkg => {
    const BAGAttrName = 'selected',
        
        updateUI = radio => {
            const label = radio.label || '';
            radio.setText(
                '<i class="far fa-' + (radio.selected === true ? 'dot-' : '') + 'circle"></i>' +
                (label.length > 0 ? ' ' : '') + label
            );
        },
        
        /*  Search the radio group for a matching node and make that one the true node.
            @param {!Object} radio
            @param {*} value
            @returns {undefined} */
        updateGroupValue = (radio, value) => {
            const bag = getBooleanAttributeGroup(radio);
            if (bag) {
                const nodes = bag.getNodes();
                let i = nodes.length;
                while (i) {
                    const node = nodes[--i];
                    if (node.optionValue === value) {
                        bag.setTrue(node);
                        break;
                    }
                }
            }
        },
        
        getBooleanAttributeGroup = radio => radio.getBAG(BAGAttrName, radio.groupId);
    
    /** A radio component.
        
        Attributes:
            label:string
            radioStyle:string Determines what style of radio to display. Supported values are 
                "solid" and "outline".
        
        @class */
    pkg.Radio = new JS.Class('Radio', pkg.Text, {
        include: [pkg.SimpleButtonStyle, pkg.BAGMembership],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            attrs.selected ??= false;
            attrs.groupId ??= pkg.generateGuid();
            attrs.focusIndicator ??= false;
            attrs.activeColor ??= 'inherit';
            attrs.hoverColor ??= 'inherit';
            attrs.readyColor ??= 'inherit';
            
            const value = attrs.value;
            delete attrs.value;
            
            this.callSuper(parent, attrs);
            
            this.setValue(value);
            
            if (this.selected) getBooleanAttributeGroup(this)?.setTrue(this);
            
            pkg.FontAwesome.registerForNotification(this);
            
            updateUI(this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setOptionValue: function(v) {
            this.set('optionValue', v, true);
        },
        
        /** Sets the value of the radio group. Calling this method on any radio button in the group 
            should have the same effect.
            @param {*} v
            @returns {undefined} */
        setValue: function(v) {
            if (this.inited) updateGroupValue(this, v);
        },
        
        /** Gets the value of the 'selected' radio button in the group.
            @returns {*} The value of the selected radio button or null if no selected radio could 
                be found. */
        getValue: function() {
            // Get selected radio
            const bag = getBooleanAttributeGroup(this),
                selectedRadio = bag ? bag.trueNode : null;
            return selectedRadio ? selectedRadio.optionValue : null;
        },
        
        setSelected: function(v) {
            if (this.selected !== v) {
                this.selected = v;
                if (this.inited) {
                    this.fireEvent(BAGAttrName, v);
                    updateUI(this);
                }
            }
        },
    
        setGroupId: function(v) {
            if (this.groupId !== v) {
                const oldGroupId = this.groupId;
                this.groupId = v;
                if (oldGroupId) this.removeFromBAG(BAGAttrName, oldGroupId);
                if (v) this.addToBAG(BAGAttrName, v);
                if (this.inited) this.fireEvent('groupId', v);
            }
        },
        
        setLabel: function(v) {
            if (this.label !== v) {
                this.set('label', v, true);
                if (this.inited) updateUI(this);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.Button */
        doActivated: function() {
            if (!this.selected) this.setValue(this.optionValue);
        },
        
        /** @overrides myt.SimpleButtonStyle */
        draw: function(color, opacity=1) {
            this.setOpacity(opacity);
            this.setTextColor(color);
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        GlobalKeys = pkg.global.keys,
        
        /** Makes an object selectable.
            
            Events:
                selected:boolean
            
            Attributes:
                selected:boolean Indicates the object is selected.
            
            @class */
        Selectable = pkg.Selectable = new JSModule('Selectable', {
            // Accessors ///////////////////////////////////////////////////////
            setSelected: function(v) {
                v = this.valueFromEvent(v);
                if (this.selected !== v) {
                    this.selected = v;
                    if (this.inited) this.fireEvent?.('selected', v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Checks if this object is selected.
                @returns {boolean} */
            isSelected: function() {
                return !!this.selected;
            },
            
            /** Checks if the provided myt.SelectionManager can select this object. Returns true 
                by default.
                @param {!Object} selectionManager
                @returns {boolean} */
            canSelect: selectionManager => true,
            
            /** Checks if the provided myt.SelectionManager can deselect this object. Returns true 
                by default.
                @param {!Object} selectionManager
                @returns {boolean} */
            canDeselect: selectionManager => true
        }),
        
        /** Manages the selection of one or more items.
            
            Events:
                itemSelected:object Fired when an item is selected. The event value is the 
                    selected item.
                itemDeselected:object Fired when an item is deselected. The event value is the 
                    deselected item.
                selectedCount:number Fired when the number of selected items changes.
            
            Attributes:
                itemSelectionId:string The name of the property on items that is used to 
                    differentiate them from each other for selection. The default value is 'id'.
                maxSelected:number The maximum number of items that can be selected. If -1 is 
                    provided the count is unlimited. If 1 is provided attempts to select when an 
                    item is already selected will result in the existing selection being cleared 
                    and the the new item being selected. Defaults to -1.
                selectedCount:number The number of selected items.
            
            Private Attributes:
                __selected:object A map of selected items by itemSelectionId.
                __lastSelectedItem:object A reference to the last item that was selected. If this 
                    item is deselected this will get set to null.
            
            @class */
        SelectionManager = pkg.SelectionManager = new JSModule('SelectionManager', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** Determines if we are in "add" mode for selection such that selections will only 
                    be increased not reduced. Typically this means the shift key is down.
                    @returns {boolean} true if in add mode, false otherwise. */
                isAddMode: () => GlobalKeys.isShiftKeyDown(),
                
                /** Determines if we are in "toggle" mode for selection such that selections can be 
                    added to or removed from incrementally. Typically this means the control or 
                    command key is down.
                    @returns {boolean} true if in add mode, false otherwise. */
                isToggleMode: () => GlobalKeys.isAcceleratorKeyDown()
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.__selected = {};
                this.__lastSelectedItem = null;
                
                attrs.selectedCount = 0;
                
                attrs.itemSelectionId ??= 'id';
                attrs.maxSelected ??= -1;
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setItemSelectionId: function(v) {this.itemSelectionId = v;},
            setMaxSelected: function(v) {this.maxSelected = v;},
            
            setSelectedCount: function(v) {
                if (this.selectedCount !== v) {
                    this.selectedCount = v;
                    if (this.inited) this.fireEvent('selectedCount', v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** A wrapper around myt.SelectionManager.isAddMode.
                @returns {boolean} */
            isAddMode: () => SelectionManager.isAddMode(),
            
            /** A wrapper around myt.SelectionManager.isToggleMode.
                @returns {boolean} */
            isToggleMode: () => SelectionManager.isToggleMode(),
            
            /** Gets the currently selected items.
                @returns {!Array} The selected items. */
            getSelected: function() {
                return Object.values(this.__selected);
            },
            
            /** Selects the provided item.
                @param {!Object} item - The item to select.
                @returns {undefined} */
            select: function(item) {
                if (item && !this.isSelectedItem(item) && this.canSelectItem(item)) {
                    item.setSelected(true);
                    this.__selected[item[this.itemSelectionId]] = item;
                    this.setSelectedCount(this.selectedCount + 1);
                    
                    this.__lastSelectedItem = item;
                    
                    this.doSelected(item);
                    this.fireEvent('itemSelected', item);
                }
            },
            
            /** Called when an item is selected.
                @param {!Objectd} item - The newly selected myt.Selectable..
                @returns {undefined} */
            doSelected: item => {},
            
            /** Selects the item with the provided item selection ID.
                @param {string} itemSelectionId
                @returns {undefined} */
            selectById: function(itemSelectionId) {
                this.select(this.getSelectableItem(itemSelectionId));
            },
            
            /** Checks if the item can be selected.
                @param {!Object} item - The item to test.
                @returns {boolean} True if selection is allowed, false otherwise. */
            canSelectItem: function(item) {
                const {maxSelected, selectedCount} = this;
                
                if (maxSelected === 0) {
                    return false;
                } else if (maxSelected === 1) {
                    // Deselect current selection if necessary
                    if (selectedCount > 0) {
                        this.deselectAll();
                        if (this.selectedCount > 0) return false;
                    }
                } else if (maxSelected > 1) {
                    if (selectedCount >= maxSelected) return false;
                }
                
                return item.canSelect(this);
            },
            
            /** Selects all items that can be selected.
                @returns {undefined} */
            selectAll: function() {
                const items = this.getSelectableItems();
                let i = items.length;
                while (i) this.select(items[--i]);
            },
            
            /** Deselects the provided item.
                @param {!Object} item - The item to deselect.
                @returns {undefined} */
            deselect: function(item) {
                if (this.isSelectedItem(item) && this.canDeselectItem(item)) {
                    item.setSelected(false);
                    delete this.__selected[item[this.itemSelectionId]];
                    this.setSelectedCount(this.selectedCount - 1);
                    
                    if (this.__lastSelectedItem === item) this.__lastSelectedItem = null;
                    
                    this.doDeselected(item);
                    this.fireEvent('itemDeselected', item);
                }
            },
            
            /** Called when an item is deselected.
                @param {!Object} item - The newly deselected myt.Selectable.
                @returns {undefined} */
            doDeselected: item => {},
            
            /** Deselects the item with the provided item selection ID.
                @param {string} itemSelectionId
                @returns {undefined} */
            deselectById: function(itemSelectionId) {
                this.deselect(this.getSelectableItem(itemSelectionId));
            },
            
            /** Checks if the item can be deselected.
                @param {!Object} item
                @returns {boolean}true if deselection is allowed, false otherwise. */
            canDeselectItem: function(item) {
                return item.canDeselect(this);
            },
            
            /** Deselects all selected items.
                @returns {undefined} */
            deselectAll: function() {
                const items = this.__selected;
                for (const key in items) this.deselect(items[key]);
            },
            
            /** Checks if the item is selected.
                @param {!Objecdt} item - The item to test.
                @returns {boolean} */
            isSelectedItem: item => item ? item.isSelected() : false,
            
            /** Checks if all selectable items are selected.
                @returns {boolean} */
            areAllSelected: function() {
                return this.selectedCount === this.getSelectableItems().length;
            },
            
            /** Gets a list of items that are potentially selectable by this manager. By default 
                assumes this is an myt.View and returns all myt.Selectable subviews.
                @returns {!Array} */
            getManagedItems: function() {
                const retval = [], 
                    svs = this.getSubviews();
                let i = svs.length;
                while (i) {
                    const sv = svs[--i];
                    if (sv.isA(Selectable)) retval.push(sv);
                }
                return retval;
            },
            
            /** Gets a list of items that can currently be selected by this manager.
                @returns {!Array} */
            getSelectableItems: function() {
                const items = this.getManagedItems();
                let i = items.length;
                while (i) {
                    if (!items[--i].canSelect(this)) items.splice(i, 1);
                }
                return items;
            },
            
            /** Gets a selectable item with the the provided selection item ID.
                @param {string} itemSelectionId
                @returns {?Object} - The myt.Selectable or undefined if not found. */
            getSelectableItem: function(itemSelectionId) {
                const items = this.getSelectableItems(),
                    selectionAttr = this.itemSelectionId;
                let i = items.length;
                while (i) {
                    const item = items[--i];
                    if (item[selectionAttr] === itemSelectionId) return item;
                }
            }
        });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        {View, SizeToParent} = pkg,
        
        STATE_EXPANDED = 'expanded',
        STATE_EXPANDING = 'expanding',
        STATE_COLLAPSED = 'collapsed',
        STATE_COLLAPSING = 'collapsing',
        
        /** A tab slider component.
            
            Events:
                expansionState:string Fired when the tab slider changes expansion state.
            
            Attributes:
                tabId:string The unique ID for this tab slider relative to the tab slider container 
                    that manages this tab slider.
                tabContainer:myt.TabSliderContainer The tab slider container that manages this tab.
                buttonClass:JS.Class The class to use for the button portion of the tab slider. 
                    Defaults to myt.SimpleButton.
                fillColorSelected:color The color of the button when selected.
                fillColorHover:color The color of the button when moused over.
                fillColorActive:color The color of the button while active.
                fillColorReady:color The color of the button when ready for interaction.
                buttonHeight:number The height of the button portion of the tab slider. Defaults 
                    to 30.
                minContainerHeight:number The minimum height of the content container inside this 
                    tab slider. This is the minimum height when expanded. Defaults to 100.
                expansionState:string Indicates the expansion state of the tab slider. Supported 
                    values are: 'expanded', 'expanding', 'collapsed' and 'collapsing'. Defaults 
                    to 'collapsed'.
            
            @class */
        TabSlider = pkg.TabSlider = new JSClass('TabSlider', View, {
            include: [pkg.Selectable, pkg.Disableable, SizeToParent],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                STATE_EXPANDED:STATE_EXPANDED,
                STATE_EXPANDING:STATE_EXPANDING,
                STATE_COLLAPSED:STATE_COLLAPSED,
                STATE_COLLAPSING:STATE_COLLAPSING
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                let initiallySelected;
                
                attrs.defaultPlacement = 'wrapper.container';
                attrs.percentOfParentWidth = 100;
                attrs.expansionState = STATE_COLLAPSED;
                
                attrs.tabId ??= pkg.generateGuid();
                attrs.tabContainer ??= parent;
                attrs.selected ??= false;
                attrs.buttonClass ??= pkg.SimpleButton;
                attrs.zIndex ??= 0;
                attrs.buttonHeight ??= 30;
                attrs.fillColorSelected ??= '#666';
                attrs.fillColorHover ??= '#eee';
                attrs.fillColorActive ??= '#ccc';
                attrs.fillColorReady ??= '#fff';
                attrs.minContainerHeight ??= 100;
                attrs.layoutPaddingY ??= 0;
                
                // Selection must be done via the select method on the tabContainer
                if (attrs.selected) {
                    initiallySelected = true;
                    delete attrs.selected;
                }
                
                self.callSuper(parent, attrs);
                
                self.button = new self.buttonClass(self, {
                    ignorePlacement:true, zIndex:1,
                    height:self.buttonHeight,
                    focusIndicator:true,
                    groupId:self.parent.parent.groupId,
                    percentOfParentWidth:100,
                    hoverColor:self.fillColorHover,
                    activeColor:self.fillColorActive,
                    readyColor:self.fillColorReady
                }, [SizeToParent, {
                    /** @overrides myt.Button */
                    doActivated: () => {
                        const tc = self.tabContainer;
                        if (self.isSelected() && tc.maxSelected !== 1) {
                            tc.deselect(self);
                        } else {
                            tc.select(self);
                        }
                    },
                    
                    /** @overrides myt.Button. */
                    updateUI: function() {
                        this.callSuper();
                        if (self.selected && self.tabContainer.maxSelected !== -1) this.setBgColor(self.fillColorSelected);
                        self.notifyButtonRedraw();
                    }
                }]);
                
                const wrapper = self.wrapper = new View(self, {
                    ignorePlacement:true,
                    y:self.buttonHeight, 
                    visible:false, maskFocus:true,
                    overflow:'hidden', percentOfParentWidth:100
                }, [SizeToParent, {
                    setHeight: function(v) {
                        this.callSuper(Math.round(v));
                    },
                    setWidth: function(v) {
                        this.callSuper(v);
                        if (this.inited) this.container.setWidth(v);
                    }
                }]);
                
                self._wrapperLayout = new pkg.SizeToChildren(wrapper.container = new View(wrapper), {axis:'y', paddingY:self.layoutPaddingY});
                
                self.constrain('__updateHeight', [wrapper, 'y', wrapper, 'height']);
                
                if (initiallySelected) self.tabContainer.select(self);
                if (attrs.disabled === true) self.setDisabled(true);
                
                self.setHeight(self.getCollapsedHeight());
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.Selectable */
            setSelected: function(v) {
                this.callSuper(v);
                this.button?.updateUI();
            },
            
            setTabId: function(v) {this.tabId = v;},
            setTabContainer: function(v) {this.tabContainer = v;},
            
            setLayoutPaddingY: function(v) {
                this.layoutPaddingY = v;
                if (this.inited) this._wrapperLayout.setPaddingY(v);
            },
            
            setMinContainerHeight: function(v) {this.minContainerHeight = v;},
            setButtonClass: function(v) {this.buttonClass = v;},
            setFillColorSelected: function(v) {this.fillColorSelected = v;},
            setFillColorHover: function(v) {this.fillColorHover = v;},
            setFillColorActive: function(v) {this.fillColorActive = v;},
            setFillColorReady: function(v) {this.fillColorReady = v;},
            
            setButtonHeight: function(v) {
                if (this.buttonHeight !== v) {
                    this.buttonHeight = v;
                    if (this.button) {
                        this.button.setHeight(v);
                        this.wrapper.setY(v);
                    }
                }
            },
            
            setExpansionState: function(v) {
                if (this.expansionState !== v) {
                    this.expansionState = v;
                    if (this.inited) this.fireEvent('expansionState', v);
                    
                    const wrapper = this.wrapper;
                    if (wrapper) {
                        if (v === STATE_EXPANDED) {
                            wrapper.setMaskFocus(false);
                            wrapper.setOverflow('auto');
                        } else if (v === STATE_EXPANDING) {
                            wrapper.setVisible(true);
                        } else if (v === STATE_COLLAPSED) {
                            wrapper.setVisible(false);
                        } else if (v === STATE_COLLAPSING) {
                            wrapper.setMaskFocus(true);
                            wrapper.setOverflow('hidden');
                        }
                    }
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.Disableable */
            doDisabled: function() {
                this.button?.setDisabled(this.disabled);
            },
            
            /** Called whenever the button is redrawn. Gives subclasses/instances a chance to do 
                additional things when the button is redrawn.
                @returns {undefined} */
            notifyButtonRedraw: () => {},
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __updateHeight: function(event) {
                this.setHeight(this.wrapper.y + this.wrapper.height);
            },
            
            /** Should only be called from the TabSliderContainer.
                @private */
            expand: function(targetHeight) {
                const self = this,
                    wrapper = self.wrapper,
                    to = targetHeight - self.getCollapsedHeight();
                
                self.setExpansionState(STATE_EXPANDING);
                
                wrapper.stopActiveAnimators();
                
                if (wrapper.height !== to) {
                    const duration = self.tabContainer.duration;
                    if (duration === 1) {
                        wrapper.setHeight(to);
                        self.setExpansionState(STATE_EXPANDED);
                    } else {
                        wrapper.animate({
                            attribute:'height', to:to, duration:duration
                        }).next(success => {self.setExpansionState(STATE_EXPANDED);});
                    }
                } else {
                    self.setExpansionState(STATE_EXPANDED);
                }
            },
            
            /** Should only be called from the TabSliderContainer.
                @private */
            collapse: function() {
                const self = this,
                    wrapper = self.wrapper;
                
                self.setExpansionState(STATE_COLLAPSING);
                
                wrapper.stopActiveAnimators();
                
                if (wrapper.height !== 0) {
                    const duration = self.tabContainer.duration;
                    if (duration === 1) {
                        wrapper.setHeight(0);
                        self.setExpansionState(STATE_COLLAPSED);
                    } else {
                        wrapper.animate({
                            attribute:'height', to:0, duration:duration
                        }).next(success => {self.setExpansionState(STATE_COLLAPSED);});
                    }
                } else {
                    self.setExpansionState(STATE_COLLAPSED);
                }
            },
            
            /** Gets the height of the tab slider when it is collapsed. Will be the height of the 
                button portion of the tab slider.
                @returns number */
            getCollapsedHeight: function() {
                return this.buttonHeight;
            },
            
            /** Gets the minimum height. Will be the smaller of the preferred height or the 
                buttonHeight + minContainerHeight. Thus, if the content is smaller than the 
                minContainerHeight extra space will not be shown.
                @returns number */
            getMinimumExpandedHeight: function() {
                return Math.min(this.getPreferredExpandedHeight(), this.buttonHeight + this.minContainerHeight);
            },
            
            /** Gets the preferred height that would allow the container to be shown without 
                vertical scrollbars.
                @returns number */
            getPreferredExpandedHeight: function() {
                return this.buttonHeight + this.wrapper.container.height;
            }
        }),
        
        /** A tab slider with a text label.
            
            Attributes:
                labelTextColorChecked:color
                labelTextColor:color
                text:string The text for the tab slider.
            
            @class */
        TextTabSlider = pkg.TextTabSlider = new JSClass('TextTabSlider', TabSlider, {
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                attrs.labelTextColorChecked ??= '#fff';
                attrs.labelTextColor ??= '#333';
                
                this.callSuper(parent, attrs);
                
                this.button.label = new pkg.Text(this.button, {
                    domClass:'myt-Text mytTextTabSliderLabel', ignorePlacement:true,
                    text:this.text, align:'center', valign:'middle', 
                    textColor:this.__getTextColor()
                });
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setLabelTextColorChecked: function(v) {this.labelTextColorChecked = v;},
            setLabelTextColor: function(v) {this.labelTextColor = v;},
            
            setText: function(v) {
                if (this.text !== v) {
                    this.text = v;
                    this.button?.label?.setText(v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.TabSlider */
            notifyButtonRedraw: function() {
                this.button.label?.setTextColor(this.__getTextColor());
            },
            
            /** @private
                @returns {string} */
            __getTextColor: function() {
                return (this.selected && this.tabContainer.maxSelected !== -1) ? this.labelTextColorChecked : this.labelTextColor;
            }
        }),
        
        /** A mixin that allows myt.TabSliders to be added to a view.
            
            Attributes:
                spacing:number The spacing between tab sliders. Defaults to
                    myt.TabSliderContainer.SPACING which is 1.
                duration:number The length of time for the animation.
            
            @class */
        TabSliderContainer = pkg.TabSliderContainer = new JS.Module('TabSliderContainer', {
            include: [pkg.SelectionManager],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                SPACING:1
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                
                self._tabSliders = [];
                
                attrs.defaultPlacement = 'container';
                
                attrs.spacing ??= TabSliderContainer.SPACING;
                attrs.overflow ??= 'autoy';
                attrs.itemSelectionId ??= 'tabId';
                attrs.maxSelected ??= 1;
                attrs.duration ??= 500;
                
                self.updateLayout = pkg.debounce(self.updateLayout);
                
                self.callSuper(parent, attrs);
                
                const container = self.container = new View(self, {
                    ignorePlacement:true, percentOfParentWidth:100
                }, [SizeToParent, {
                    /** @overrides myt.View */
                    subnodeAdded: function(node) {
                        this.callSuper(node);
                        if (node instanceof TabSlider) {
                            self._tabSliders.push(node);
                            self.attachTo(node, 'updateLayout', 'selected');
                        }
                    },
                    
                    /** @overrides myt.View */
                    subnodeRemoved: function(node) {
                        if (node instanceof TabSlider) {
                            const tabSliders = self._tabSliders,
                                idx = tabSliders.indexOf(node);
                            if (idx > -1) {
                                self.detachFrom(node, 'updateLayout', 'selected');
                                tabSliders.splice(idx, 1);
                            }
                        }
                        this.callSuper(node);
                    }
                }]);
                container.layout = new pkg.SpacedLayout(container, {axis:'y', spacing:self.spacing, collapseParent:true});
                
                self.attachTo(self, 'updateLayout', 'height');
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setSpacing: function(v) {
                if (this.spacing !== v) {
                    this.spacing = v;
                    this.layout?.setSpacing(v);
                }
            },
            
            setDuration: function(v) {this.duration = v;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @param {!Object} ignoredEvent
                @param {number} [temporaryDuration]
                @returns {undefined} */
            updateLayout: function(ignoredEvent, temporaryDuration) {
                const tabSliders = this._tabSliders,
                    tabSlidersLen = tabSliders.length;
                let i = tabSlidersLen, 
                    min = 0, 
                    preferred = 0, 
                    visCount = 0;
                
                while (i) {
                    const tabSlider = tabSliders[--i];
                    if (tabSlider.visible) {
                        ++visCount;
                        if (tabSlider.selected) {
                            min += tabSlider.getMinimumExpandedHeight();
                            preferred += tabSlider.getPreferredExpandedHeight();
                        } else {
                            const collapsedHeight = tabSlider.getCollapsedHeight();
                            min += collapsedHeight;
                            preferred += collapsedHeight;
                        }
                    }
                }
                
                const layout = this.container.layout,
                    layoutOverage = layout.inset + layout.outset + layout.spacing * (visCount - 1);
                min += layoutOverage;
                preferred += layoutOverage;
                
                const h = this.height,
                    minIsOver = min > h,
                    preferredIsOver = preferred > h,
                    existingDuration = this.duration;
                let overage = preferred - h;
                
                if (temporaryDuration > 0) this.setDuration(temporaryDuration);
                
                i = tabSlidersLen;
                while (i) {
                    const tabSlider = tabSliders[--i];
                    if (tabSlider.visible) {
                        if (tabSlider.selected) {
                            let newVal;
                            if (minIsOver) {
                                newVal = tabSlider.getMinimumExpandedHeight();
                            } else if (preferredIsOver) {
                                const tabPreferred = tabSlider.getPreferredExpandedHeight(),
                                    tabMin = tabSlider.getMinimumExpandedHeight();
                                
                                newVal = tabPreferred - overage;
                                if (tabMin > newVal) {
                                    overage -= tabPreferred - tabMin;
                                    newVal = tabMin;
                                } else {
                                    overage = 0;
                                }
                            } else {
                                newVal = tabSlider.getPreferredExpandedHeight();
                            }
                            tabSlider.expand(newVal);
                        } else {
                            tabSlider.collapse();
                        }
                    }
                }
                
                // Restore duration
                if (temporaryDuration > 0) this.setDuration(existingDuration);
            }
        });
})(myt);


(pkg => {
    const 
        updateTextColor = tab => {
            tab.textView.setTextColor(tab.selected ? tab.labelTextSelectedColor : tab.labelTextColor);
        },
        
        updateCornerRadius = tab => {
            const cornerKeys = [];
            switch (tab.tabContainer.location) {
                case 'top': cornerKeys.push('TopLeft','TopRight'); break;
                case 'bottom': cornerKeys.push('BottomLeft','BottomRight'); break;
                case 'left': cornerKeys.push('TopLeft','BottomLeft'); break;
                case 'right': cornerKeys.push('TopRight','BottomRight'); break;
            }
            for (const cornerKey of cornerKeys) tab['setRounded' + cornerKey + 'Corner'](tab.cornerRadius || 0);
        },
        
        /** A simple tab component.
            
            Requires:
                myt.Activateable
            
            Attributes:
                tabId:string The unique ID of this tab relative to its tab container.
                tabContainer:myt.TabContainer The tab container that manages this tab.
                edgeColor:color
                edgeSize:number
                selectedColor:color
                
                labelTextColorSelected:color The color to use for the label text when this tab 
                    is selected.
                cornerRadius:number Passed into the drawing config to determine if a rounded corner 
                    is drawn or not. Defaults to 6.
            
            @class */
        Tab = pkg.Tab = new JS.Class('Tab', pkg.SimpleTextButton, {
            include: [pkg.Selectable],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                INSET: 8,
                OUTSET: 8
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                attrs.tabId ??= pkg.generateGuid();
                attrs.tabContainer ??= parent;
                
                // Selection must be done via the select method on the tabContainer
                let initiallySelected;
                if (attrs.selected) {
                    initiallySelected = true;
                    delete attrs.selected;
                }
                
                // myt.SimpleTextButton
                attrs.inset ??= Tab.INSET;
                attrs.outset ??= Tab.OUTSET;
                
                // myt.Tab
                attrs.selectedColor ??= '#fff';
                attrs.hoverColor ??= '#eee';
                attrs.activeColor ??= '#aaa';
                attrs.readyColor ??= '#ccc';
                attrs.labelTextSelectedColor ??= '#333';
                
                // Other
                attrs.height ??= 24;
                attrs.focusIndicator ??= false;
                attrs.cornerRadius ??= 6;
                
                this.callSuper(parent, attrs);
                
                if (initiallySelected) this.tabContainer.select(this);
                
                updateCornerRadius(this);
                updateTextColor(this);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setTabId: function(v) {this.tabId = v;},
            setTabContainer: function(v) {this.tabContainer = v;},
            setSelectedColor: function(v) {this.selectedColor = v;},
            setLabelTextColor: function(v) {this.labelTextColor = v;},
            
            setCornerRadius: function(v) {
                this.cornerRadius = v;
                if (this.inited) updateCornerRadius(this);
            },
            
            setLabelTextSelectedColor: function(v) {
                this.labelTextSelectedColor = v;
                if (this.inited && this.selected) this.textView.setTextColor(v);
            },
            
            setSelected: function(v) {
                this.callSuper(v);
                if (this.inited) {
                    this.updateUI();
                    updateTextColor(this);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.Button. */
            updateUI: function() {
                this.callSuper();
                if (this.selected) this.setBgColor(this.selectedColor);
            },
            
            /** @overrides myt.Activateable */
            doActivated: function() {
                if (!this.selected) this.tabContainer.select(this);
            }
        }),
        
        /** A mixin that allows myt.Tabs to be added to a view.
            
            Attributes:
                layout:myt.SpacedLayout The layout for the tabs.
                location:string The location of the tabs relative to the container. Supported 
                    values are: 'top', 'bottom', 'left' and 'right'. Defaults to 'top'.
                spacing:number The spacing between tabs. Defaults to 1.
                inset:number The inset for the layout. Defaults to 0.
            
            @class */
        TabContainer = pkg.TabContainer = new JS.Module('TabContainer', {
            include: [pkg.SelectionManager],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                SPACING:1,
                INSET:0
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.__tabs = [];
                
                attrs.spacing ??= TabContainer.SPACING;
                attrs.inset ??= TabContainer.INSET;
                attrs.location ??= 'top';
                attrs.itemSelectionId ??= 'tabId';
                attrs.maxSelected ??= 1;
                
                const collapse = attrs.collapse ?? true;
                delete attrs.collapse;
                
                this.callSuper(parent, attrs);
                
                this.layout = new pkg.SpacedLayout(this, {
                    axis:this.location === 'left' || this.location === 'right' ? 'y' : 'x',
                    spacing:this.spacing,
                    inset:this.inset,
                    collapseParent:collapse
                });
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setLocation: function(v) {this.location = v;},
            
            setSpacing: function(v) {
                if (this.spacing !== v) {
                    this.spacing = v;
                    this.layout?.setSpacing(v);
                }
            },
            
            setInset: function(v) {
                if (this.inset !== v) {
                    this.inset = v;
                    this.layout?.setInset(v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            getFirstTab: function() {
                return this.__tabs[0];
            },
            
            /** Gets the currently selected tab.
                @returns myt.Tab or undefined if no tab is selected. */
            getSelectedTab: function() {
                return this.getSelected()[0];
            },
            
            /** @overrides myt.View */
            subnodeAdded: function(node) {
                this.callSuper(node);
                if (node.isA(Tab)) {
                    this.__tabs.push(node);
                    
                    switch (this.location) {
                        case 'top':
                            node.setValign('bottom');
                            break;
                        case 'bottom':
                            node.setValign('top');
                            break;
                        case 'left':
                            node.setAlign('right');
                            break;
                        case 'right':
                            node.setAlign('left');
                            break;
                    }
                }
            },
            
            /** @overrides myt.View */
            subnodeRemoved: function(node) {
                if (node.isA(Tab)) {
                    const tabs = this.__tabs,
                        idx = tabs.indexOf(node);
                    if (idx > -1) tabs.splice(idx, 1);
                }
                this.callSuper(node);
            }
        });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        mathMin = Math.min,
        isArray = Array.isArray,
        
        {
            SizeToDom, View, Disableable, KeyObservable,
            Button:{FOCUS_SHADOW}, 
            global:{keys:GlobalKeys}
        } = pkg,
        
        setEditableTextAttr = (editableText, v, propName) => {
            if (editableText[propName] !== v) {
                editableText[propName] = v;
                editableText.getIDS()[propName] = v + 'px';
                if (editableText.inited) {
                    editableText.fireEvent(propName, v);
                    editableText.sizeViewToDom();
                }
            }
        },
        
        setDomAttr = (inputView, attrName, value) => {
            if (inputView[attrName] !== value) {
                inputView.getIDE()[attrName] = inputView[attrName] = value;
                if (inputView.inited) inputView.fireEvent(attrName, value);
            }
        },
        
        /** A wrapper around a native HTML input element.
            
            Events:
                value:* Fired when the setValue setter is called.
            
            Attributes:
                value:* the current value of the input element.
                inputType:string (read only) the type of the input element to create. Changing this 
                    value after initialization will modify the type of the underlying dom element 
                    and is not generally supported. 
                    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type
                    for more info and a list of allowed values.
            
            @class */
        NativeInputWrapper = pkg.NativeInputWrapper = new JSClass('NativeInputWrapper', View, {
            include: [Disableable, pkg.InputObservable],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.View */
            initNode: function(parent, attrs) {
                attrs.tagName ??= 'input';
                attrs.focusable ??= true;
                
                this.callSuper(parent, attrs);
                
                // Set a css class to allow scoping of CSS rules
                this.addDomClass('mytNativeInput');
            },
            
            /** @overrides myt.View */
            createOurDomElement: function(parent) {
                const elements = this.callSuper(parent);
                if (this.inputType) (isArray(elements) ? elements[1] : elements).type = this.inputType;
                return elements;
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.Disableable */
            setDisabled: function(v) {
                if (this.disabled !== v) {
                    this.getIDE().disabled = v;
                    this.callSuper(v);
                }
            },
            
            setValue: function(v) {
                if (this.value !== v) {
                    this.value = v;
                    this.setDomValue(v);
                    if (this.inited) this.fireEvent('value', v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Gets the value from the DOM.
                @returns * The value */
            getDomValue: function() {
                return this.getIDE().value;
            },
            
            /** Sets the value on the DOM.
                @param v:* The value to set.
                @returns {undefined} */
            setDomValue: function(v) {
                const ide = this.getIDE();
                if (ide.value !== v) ide.value = v;
            }
        }),
        
        /** An option in a native HTML select element.
            
            Events:
                value:*
                label:string
            
            Attributes:
                value:* the value of the option.
                label:string the text label for the option.
            
            @class */
        InputSelectOption = pkg.InputSelectOption = new JSClass('InputSelectOption', View, {
            include: [Disableable, pkg.Selectable],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.Input */
            createOurDomElement: parent => document.createElement('option'),
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrideds myt.Selectable */
            setSelected: function(v) {
                v = this.valueFromEvent(v);
                const ide = this.getIDE();
                if (ide.selected !== v) ide.selected = v;
            },
            
            /** @overrides myt.Disableable */
            setDisabled: function(v) {
                if (this.disabled !== v) {
                    this.getIDE().disabled = v;
                    this.callSuper(v);
                }
            },
            
            setValue: function(v) {setDomAttr(this, 'value', v);},
            
            setLabel: function(v) {
                if (this.label !== v) {
                    this.getIDE().textContent = this.label = v;
                    if (this.inited) this.fireEvent('label', v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrideds myt.Selectable */
            isSelected: function() {
                return this.getIDE().selected;
            },
            
            /** @overrideds myt.Selectable */
            canSelect: function(selectionManager) {
                return !this.disabled && !this.getIDE().selected && this.parent === selectionManager;
            },
            
            /** @overrideds myt.Selectable */
            canDeselect: function(selectionManager) {
                return !this.disabled && this.getIDE().selected && this.parent === selectionManager;
            }
        }),
        
        /** A base class for input:text and textarea components.
            
            Events:
                spellcheck:boolean
                maxLength:int
                placeholder:string
            
            Attributes:
                spellcheck:boolean Turns browser spellchecking on and off. Defaults to false.
                maxLength:int Sets a maximum number of input characters. Set to a negative number 
                    to turn off max length. Defaults to undefined which is equivalent to a 
                    negative number.
                allowedChars:string Each character in the string is an allowed input character. If 
                    not set or empty all characters are allowed. Defaults to undefined.
                placeholder:string Text that will be shown if the value is empty.
            
            Private Attributes:
                _selRange:object Stores the start and end of the selection.
            
            @class */
        BaseInputText = pkg.BaseInputText = new JSClass('BaseInputText', NativeInputWrapper, {
            include: [pkg.TextSupport],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.NativeInputWrapper */
            initNode: function(parent, attrs) {
                const self = this;
                
                attrs.bgColor ??= 'transparent';
                attrs.spellcheck ??= false;
                
                self.callSuper(parent, attrs);
                
                self.attachToDom(self, '__syncToDom', 'input');
                
                // Allow filtering of input
                self.attachToDom(self, '__filterInputPress', 'keypress');
                self.attachToDom(self, '__filterInput', 'keyup');
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.TextSupport
                Alias setText to setValue. */
            setText: function(v) {
                this.callSuper(v);
                this.setValue(v);
            },
            
            setSpellcheck: function(v) {setDomAttr(this, 'spellcheck', v);},
            setMaxLength: function(v) {setDomAttr(this, 'maxLength', v == null || v < 0 ? undefined : v);},
            setAllowedChars: function(v) {this.allowedChars = v;},
            setPlaceholder: function(v) {setDomAttr(this, 'placeholder', v);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.FocusObservable */
            showFocusIndicator: function() {
                this.hideDefaultFocusIndicator();
                this.setBoxShadow(FOCUS_SHADOW);
            },
            
            /** @overrides myt.FocusObservable */
            hideFocusIndicator: function() {
                this.hideDefaultFocusIndicator();
                this.setBoxShadow();
            },
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __filterInput: function(event) {
                this.setDomValue(this.filterInput(this.getDomValue()));
            },
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __filterInputPress: function(event) {
                // Filter for allowed characters
                const domEvent = event.value,
                    allowedChars = this.allowedChars;
                if (allowedChars && !allowedChars.includes(KeyObservable.getKeyFromEvent(event))) domEvent.preventDefault();
                
                this.filterInputPress(domEvent);
            },
            
            /** A hook for subclasses/instances to do input filtering. The default implementation 
                returns the value unchanged.
                @param {string} v - the current value of the form element.
                @returns {string} The new value of the form element. */
            filterInput: v => v,
            
            /** A hook for subclasses/instances to do input filtering during key press. The default 
                implementation does nothing.
                @param {!Object} domEvent - The dom key press event.
                @returns {undefined} */
            filterInputPress: domEvent => {/* Subclasses to implement as needed. */},
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __syncToDom: function(event) {
                this.setValue(this.getDomValue());
            },
            
            /** Gets the location of the caret.
                @returns {number} An integer. */
            getCaretPosition: function() {
                // IE Support
                if (document.selection) {
                    const selection = document.selection.createRange();
                    selection.moveStart('character', -this.getDomValue().length);
                    return selection.text.length;
                }
                
                return this.getIDE().selectionStart || 0;
            },
            
            /** Sets the caret and selection.
                @param start:int the start of the selection or location of the caret if no end 
                    is provided.
                @param end:int (optional) the end of the selection.
                @returns {undefined} */
            setCaretPosition: function(start, end) {
                if (end == null || start === end) {
                    // Don't update if the current position already matches.
                    if (this.getCaretPosition() === start) return;
                    
                    end = start;
                }
                const elem = this.getIDE();
                
                if (elem.setSelectionRange) {
                    elem.setSelectionRange(start, end);
                } else if (elem.createTextRange) {
                    const range = elem.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            },
            
            /** Sets the caret to the start of the text input.
                @returns {undefined} */
            setCaretToStart: function() {
                this.setCaretPosition(0);
            },
            
            /** Sets the caret to the end of the text input.
                @returns {undefined} */
            setCaretToEnd: function() {
                this.setCaretPosition(this.getDomValue().length);
            },
            
            // Selection //
            /** Selects all the text in the input element.
                @returns {undefined} */
            selectAll: function() {
                this.getIDE().select();
            },
            
            getSelection: function() {
                const ide = this.getIDE();
                return {
                    start:ide.selectionStart,
                    startElem:ide,
                    end:ide.selectionEnd,
                    endElem:ide
                };
            },
            
            setSelection: function(selection) {
                if (selection) this.setCaretPosition(selection.start, selection.end);
            },
            
            saveSelection: function(selection) {
                this._selRange = selection || this.getSelection() || this._selRange;
            },
            
            restoreSelection: function() {
                this.setSelection(this._selRange);
            }
        }),
        
        /** A view that accepts single line user text input.
            
            @class */
        InputText = pkg.InputText = new JSClass('InputText', BaseInputText, {
            include: [pkg.SizeHeightToDom],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.Input */
            initNode: function(parent, attrs) {
                this.inputType = attrs.password === true ? 'password' : 'text';
                
                this.callSuper(parent, attrs);
                
                this.setCaretToEnd();
            },
            
            // Accessors ///////////////////////////////////////////////////////
            setPassword: function(v) {
                this.set('password', v, true);
                if (this.inited) this.getIDE().type = v ? 'password' : 'text';
            }
        });
    
    /** Text content that can be edited.
        
        Events:
            contentEditable:boolean
            minWidth:number
        
        Attributes:
            contentEditble:boolean Makes the text editable or not.
            minWidth:number The minimum width for the component. Defaults to undefined which is 
                effectively 0.
            minHeight:number The minimum height for the component. Defaults to undefined which is 
                effectively 0.
        
        @class */
    pkg.EditableText = new JSClass('EditableText', BaseInputText, {
        include: [SizeToDom],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.BaseInputText */
        initNode: function(parent, attrs) {
            const self = this;
            
            attrs.tagName ??= 'div';
            attrs.inputType = null;
            
            attrs.whiteSpace ??= 'pre';
            attrs.contentEditable ??= true;
            
            self.callSuper(parent, attrs);
            
            self.attachToDom(self, '__cleanInput', 'keydown');
            self.attachToDom(self, '__userInteraction', 'keyup');
            self.attachToDom(self, '__userInteraction', 'mouseup');
            
            self.setCaretToEnd();
        },
        
        
        // Attributes //////////////////////////////////////////////////////////
        setMinWidth: function(v) {setEditableTextAttr(this, v, 'minWidth');},
        setMinHeight: function(v) {setEditableTextAttr(this, v, 'minHeight');},
        setPadding: function(v) {
            this.setPaddingTop(v);
            this.setPaddingRight(v);
            this.setPaddingBottom(v);
            this.setPaddingLeft(v);
        },
        setPaddingTop: function(v) {setEditableTextAttr(this, v, 'paddingTop');},
        setPaddingRight: function(v) {setEditableTextAttr(this, v, 'paddingRight');},
        setPaddingBottom: function(v) {setEditableTextAttr(this, v, 'paddingBottom');},
        setPaddingLeft: function(v) {setEditableTextAttr(this, v, 'paddingLeft');},
        setContentEditable: function(v) {setDomAttr(this, 'contentEditable', v);},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.BaseInputText */
        filterInputPress: function(domEvent) {
            // Implement maxLength
            const maxLength = this.maxLength;
            if (maxLength >= 0 && this.getCharacterCount() === maxLength) domEvent.preventDefault();
            
            this.callSuper(domEvent);
        },
        
        /** @overrides myt.NativeInputWrapper */
        getDomValue: function() {
            return this.getIDE().innerHTML;
        },
        
        /** @overrides myt.NativeInputWrapper */
        setDomValue: function(v) {
            const ide = this.getIDE();
            if (ide.innerHTML !== v) {
                ide.innerHTML = v;
                this.sizeViewToDom();
                this.restoreSelection();
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __cleanInput: function(event) {
            // Prevent enter key from inserting a div
            if (KeyObservable.isEnterKeyEvent(event)) {
                event.value.preventDefault();
                
                // Instead, insert a linefeed if wrapping is allowed.
                if (this.whitespace !== 'nowrap') {
                    document.execCommand('insertHTML', false, this.isCaretAtEnd() ? '\n\n' : '\n');
                }
            }
        },
        
        /** @overrides myt.BaseInputText */
        __syncToDom: function(event) {
            this.callSuper(event);
            
            this.saveSelection();
            this.sizeViewToDom();
            this.restoreSelection();
        },
        
        // Caret handling
        getCharacterCount: function() {
            return this.getIDE().firstChild?.length ?? 0;
        },
        
        isCaretAtEnd: function() {
            return this.getCaretPosition() === this.getCharacterCount();
        },
        
        /** @overrides myt.BaseInputText */
        getCaretPosition: function() {
            return this.getSelection()?.end ?? 0;
        },
        
        /** @overrides myt.BaseInputText */
        setCaretPosition: function(start, end) {
            if (end == null || start === end) {
                // Don't update if the current position already matches.
                if (this.getCaretPosition() === start) return;
                
                end = start;
            }
            this.saveSelection({
                start:start,
                startElem:this.getIDE().firstChild,
                end:end,
                endElem:this.getIDE().firstChild
            });
        },
        
        // Selection handling
        /** @overrides myt.FocusObservable */
        doFocus: function() {
            this.callSuper();
            this.restoreSelection();
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __userInteraction: function(event) {
            this.saveSelection();
            return true;
        },
        
        /** @overrides myt.BaseInputText */
        getSelection: function() {
            let range;
            if (window.getSelection) {
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    // Sometimes when deleting we get an unexpected node
                    if (sel.extentNode === this.getIDE()) return;
                    
                    range = sel.getRangeAt(0);
                }
            } else if (document.selection) {
                range = document.selection.createRange();
            }
            
            return {
                start:range ? range.startOffset : 0,
                startElem:range ? range.startContainer : this.getIDE().firstChild,
                end:range ? range.endOffset : 0,
                endElem:range ? range.endContainer : this.getIDE().firstChild
            };
        },
        
        /** @overrides myt.BaseInputText */
        setSelection: function(selection) {
            if (selection) {
                const {startElem, endElem} = selection;
                if (startElem && startElem.parentNode && endElem && endElem.parentNode) {
                    const range = document.createRange();
                    range.setStart(startElem, mathMin(selection.start, startElem.length));
                    range.setEnd(endElem, mathMin(selection.end, endElem.length));
                    
                    if (window.getSelection) {
                        const sel = window.getSelection();
                        if (sel.rangeCount > 0) sel.removeAllRanges();
                        sel.addRange(range);
                    } else if (document.selection) {
                        range.select();
                    }
                }
            }
        }
    });
    
    /** A view that accepts multi line user text input.
        
        Events:
            resize:string
            wrap:string
        
        Attributes:
            resize:string Sets how the textarea can be resized. Defaults to 'none'. Supported 
                values: 'none', 'both', 'horizontal', 'vertical'.
            wrap:string Sets how text will wrap. Defaults to 'soft'. Allowed values: 'off', 
                'hard', 'soft'.
        
        @class */
    pkg.InputTextArea = new JSClass('InputTextArea', BaseInputText, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.BaseInputText */
        initNode: function(parent, attrs) {
            attrs.tagName ??= 'textarea';
            attrs.inputType = null;
            attrs.resize ??= 'none';
            attrs.wrap ??= 'soft';
            
            this.callSuper(parent, attrs);
        },
        
        /** @overrides */
        destroy: function() {
            this.__resizeObserver?.unobserve(this.getIDE());
            this.callSuper();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setResize: function(v) {
            const self = this;
            if (self.resize !== v) {
                v = self.resize = self.getIDS().resize = v || 'none';
                if (self.inited) self.fireEvent('resize', v);
                
                if (v !== 'none') {
                    (self.__resizeObserver ??= new ResizeObserver(() => {self.doResize();})).observe(self.getIDE());
                }
            }
        },
        
        setWrap: function(v) {setDomAttr(this, 'wrap', v);},
        
        
        // Methods /////////////////////////////////////////////////////////////
        doResize: function() {
            const resize = this.resize;
            if (resize === 'both' || resize === 'horizontal') SizeToDom.sizeWidth(this);
            if (resize === 'both' || resize === 'vertical') SizeToDom.sizeHeight(this);
        }
    });
    
    /** A text input with select list.
        
        Attributes:
            filterItems:boolean Indicates if the list items should be filtered down based on the 
                current value. Defaults to true.
            fullItemConfig:array The full list of items that can be shown in the list. The actual 
                itemConfig used will be filtered based on the current value of the input text.
        
        @class */
    pkg.ComboBox = new JSClass('ComboBox', InputText, {
        include: [
            pkg.Activateable,
            pkg.KeyActivation,
            pkg.ListViewAnchor
        ],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.Input */
        initNode: function(parent, attrs) {
            this.filterItems = true;
            
            attrs.activationKeys ??= [GlobalKeys.CODE_ENTER, GlobalKeys.CODE_ESC, GlobalKeys.CODE_ARROW_UP, GlobalKeys.CODE_ARROW_DOWN];
            attrs.bgColor ??= '#fff';
            attrs.borderWidth ??= 1;
            attrs.borderStyle ??= 'solid';
            attrs.floatingAlignOffset ??= attrs.borderWidth;
            attrs.fullItemConfig ??= [];
            attrs.listViewAttrs = {...attrs.listViewAttrs, maxHeight:attrs.listViewAttrs?.maxHeight ?? 99};
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setFullItemConfig: function(v) {this.fullItemConfig = v;},
        setFilterItems: function(v) {this.filterItems = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides
            Show floating panel if the value has changed during during user interaction. */
        __syncToDom: function(event) {
            const existing = this.value;
            this.callSuper(event);
            if (existing !== this.value) this.showFloatingPanel();
        },
        
        /** @overrides */
        showFloatingPanel: function(panelId) {
            const fp = this.getFloatingPanel(panelId);
            if (fp) {
                // Filter config
                let itemConfig;
                if (this.filterItems) {
                    itemConfig = [];
                    
                    const curValue = this.value,
                        normalizedCurValue = curValue == null ? '' : ('' + curValue).toLowerCase(),
                        fullItemConfig = this.fullItemConfig,
                        len = fullItemConfig.length;
                    for (let i = 0; len > i;) {
                        const item = fullItemConfig[i++],
                            normalizedItemValue = item.attrs.text.toLowerCase(),
                            idx = normalizedItemValue.indexOf(normalizedCurValue);
                        if (idx === 0) {
                            if (normalizedItemValue !== normalizedCurValue) itemConfig.push(item);
                        } else if (idx > 0) {
                            itemConfig.push(item);
                        }
                    }
                } else {
                    itemConfig = this.fullItemConfig;
                }
                
                if (itemConfig.length > 0) {
                    fp.setMinWidth(this.width - 2 * this.borderWidth); // Must be set before setItemConfig
                    this.setItemConfig(itemConfig);
                    this.callSuper(panelId);
                } else {
                    this.hideFloatingPanel(panelId);
                }
            }
        },
        
        /** @overrides */
        doItemActivated: function(itemView) {
            this.setValue(itemView.value == null ? itemView.text : itemView.value);
            this.callSuper(itemView);
        },
        
        /** @overrides */
        doActivated: function() {
            this.toggleFloatingPanel();
        }
    });
    
    /** A wrapper around a native HTML select component.
        
        Events:
            multiple:boolean
            size:int
            value:string
        
        Attributes:
            multiple:boolean Indicates if multiple options can be selected or not. Defaults 
                to false.
            size:int The number of options to show. The default value is 4 for multiple == true 
                and 1 for multiple == false. It is recommended that a size of at least 4 be used 
                when multiple is 2.
            options:array (write only) Adds a list of options to this select list. The value should 
                be an array of myt.InputSelectOptions attrs that will be used to instantiate 
                new myt.InputSelectOption instances on this select list.
        
        @class */
    pkg.InputSelect = new JSClass('InputSelect', NativeInputWrapper, {
        include: [SizeToDom],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.NativeInputWrapper */
        initNode: function(parent, attrs) {
            attrs.tagName ??= 'select';
            attrs.inputType = null;
            attrs.multiple ??= false;
            attrs.size ??= attrs.multiple ? 4 : 1;
            this.callSuper(parent, attrs);
            
            this.attachToDom(this, '__syncToDom', 'change');
            
            // Make sure initial value is in sync with the UI
            this.__syncToDom();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setMultiple: function(v) {setDomAttr(this, 'multiple', v);},
        setSize: function(v) {setDomAttr(this, 'size', v);},
        
        setOptions: function(v) {
            this.destroyAllOptions();
            if (isArray(v)) {
                for (const option of v) this.addOption(option);
            }
        },
        
        /** The options are just the subviews.
            @returns an array of options for this select list. */
        getOptions: function() {
            return this.getSubviews().slice();
        },
        
        /** @overrides myt.NativeInputWrapper
            Does not update the dom since the dom element's 'value' attribute doesn't 
            support lists. */
        setValue: function(v) {
            if (isArray(v) && pkg.areArraysEqual(v, this.value)) return;
            
            if (this.value !== v) {
                this.value = v;
                if (this.inited) this.fireEvent('value', v);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.View */
        subviewAdded: function(sv) {
            // Destroy subview if it's not supported.
            if (!(sv instanceof InputSelectOption)) {
                pkg.dumpStack('Subview unsupported. Destroying it');
                sv.destroy();
            }
        },
        
        /** @overrides myt.FocusObservable */
        showFocusIndicator: function() {
            this.hideDefaultFocusIndicator();
            this.setBoxShadow(FOCUS_SHADOW);
        },
        
        /** @overrides myt.FocusObservable */
        hideFocusIndicator: function() {
            this.hideDefaultFocusIndicator();
            this.setBoxShadow();
        },
        
        // Options //
        /** Gets an array of selected myt.InputSelectOptions.
            @returns {!Array} - An array of selected myt.InputSelectOptions. */
        getSelectedOptions: function() {
            return this.getOptions().filter(option => option.isSelected());
        },
        
        /** Gets an array of selected myt.InputSelectOption values.
            @returns {!Array} - An array of selected option values. */
        getSelectedOptionValues: function() {
            return this.getSelectedOptions().map(option => option.value);
        },
        
        /** Gets the myt.InputSelectOption with the provided value.
            @param {*} value - The value of the option to get.
            @returns {?Object} - The matching myt.InputSelectOption option or undefined if 
                not found. */
        getOptionForValue: function(value) {
            return this.getOptions().find(option => option.value === value);
        },
        
        /** Adds a new myt.InputSelectionOption to this select list.
            @param attrs:object The attrs for the new option
            @returns myt.InputSelectOption: The newly created option. */
        addOption: function(attrs) {
            return new InputSelectOption(this, attrs);
        },
        
        destroyAllOptions: function() {
            for (const option of this.getOptions()) option.destroy();
        },
        
        /** Destroys an option that has the provided value.
            @param value:* The value of the option to remove.
            @returns boolean: true if the option is destroyed, false otherwise. */
        destroyOptionWithValue: function(value) {
            const option = this.getOptionForValue(value);
            if (option) {
                option.destroy();
                if (option.destroyed) return true;
            }
            return false;
        },
        
        // Selection //
        /** Deselects all selected options included disabled options.
            @returns {undefined} */
        deselectAll: function() {
            let changed = false;
            for (const option of this.getOptions()) {
                if (option.isSelected()) {
                    option.setSelected(false);
                    changed = true;
                }
            }
            if (changed) this.__doChanged();
        },
        
        selectValues: function(values) {
            if (!isArray(values)) values = [values];
            for (const value of values) this.selectValue(value);
        },
        
        /** Selects the option that has the provided value.
            @param value:* The value of the option to select.
            @returns {undefined} */
        selectValue: function(value) {
            this.select(this.getOptionForValue(value));
        },
        
        /** Selects the provided option.
            @param option:myt.InputSelectOption The option to select.
            @returns {undefined} */
        select: function(option) {
            if (option?.canSelect(this)) {
                option.setSelected(true);
                this.__syncToDom();
            }
        },
        
        /** Deselects the option that has the provided value.
            @param {*} value - The value of the option to deselect.
            @returns {undefined} */
        deselectValue: function(value) {
            this.deselect(this.getOptionForValue(value));
        },
        
        /** Deselects the provided option.
            @param option:myt.InputSelectOption The option to deselect.
            @returns {undefined} */
        deselect: function(option) {
            if (option?.canDeselect(this)) {
                option.setSelected(false);
                this.__syncToDom();
            }
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __doChanged: function(event) {
            this.__syncToDom();
            this.doChanged();
        },
        
        /** Called whenever the underlying dom element fires a "change" event.
            @returns {undefined} */
        doChanged: () => {},
        
        /** @private
            @returns {undefined} */
        __syncToDom: function() {
            this.setValue(this.multiple ? this.getSelectedOptionValues() : this.getDomValue());
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
        
        mathRound = Math.round,
        
        /** Provides a setValue and getValue method.
            
            Events:
                value:*
            
            Attributes:
                value:* The stored value.
                valueFilter:function If it exists, values will be run through this filter function 
                    before being set on the component. By default no valueFilter exists. A value 
                    filter function must take a single value as an argument and return a value.
            
            @class */
        ValueComponent = pkg.ValueComponent = new JSModule('ValueComponent', {
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.appendToEarlyAttrs('valueFilter','value');
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setValueFilter: function(v) {
                this.valueFilter = v;
                
                if (this.inited && v) this.setValue(this.value);
            },
            
            setValue: function(v) {
                if (this.valueFilter) v = this.valueFilter(v);
                
                if (this.value !== v) {
                    this.value = v;
                    if (this.inited) this.fireEvent('value', this.getValue());
                }
            },
            
            getValue: function() {
                return this.value;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Combines a value filter with any existing value filter.
                @param filter:function the value filter to add.
                @param where:string (optional) Determines where to add the filter. Supported values 
                    are 'first' and 'last'. Defaults to 'first'.
                @returns {undefined} */
            chainValueFilter: function(filter, where) {
                const existingFilter = this.valueFilter;
                let chainedFilter;
                if (existingFilter) {
                    if (where === 'last') {
                        chainedFilter = v => filter(existingFilter(v));
                    } else {
                        // "where" is 'first' or not provided.
                        chainedFilter = v => existingFilter(filter(v));
                    }
                } else {
                    chainedFilter = filter;
                }
                this.setValueFilter(chainedFilter);
            }
        }),
        
        /** A value that consists of an upper and lower value. The lower value must be less than or 
            equal to the upper value. The value object that must be passed into setValue and 
            returned from getValue is an object of the form: {lower:number, upper:number}.
            
            @class */
        RangeComponent = pkg.RangeComponent = new JSModule('RangeComponent', {
            include: [ValueComponent],
            
            
            // Accessors ///////////////////////////////////////////////////////
            setLowerValue: function(v) {
                this.setValue({
                    lower:v, 
                    upper:(this.value && this.value.upper !== undefined) ? this.value.upper : v
                });
            },
            
            getLowerValue: function() {
                return this.value ? this.value.lower : undefined;
            },
            
            setUpperValue: function(v) {
                this.setValue({
                    lower:(this.value && this.value.lower !== undefined) ? this.value.lower : v,
                    upper:v
                });
            },
            
            getUpperValue: function() {
                return this.value ? this.value.upper : undefined;
            },
            
            setValue: function(v) {
                if (v) {
                    const existing = this.value,
                        existingLower = existing ? existing.lower : undefined,
                        existingUpper = existing ? existing.upper : undefined;
                    
                    if (this.valueFilter) v = this.valueFilter(v);
                    
                    // Do nothing if value is identical
                    if (v.lower === existingLower && v.upper === existingUpper) return;
                    
                    // Assign upper to lower if no lower was provided.
                    v.lower ??= v.upper;
                    
                    // Assign lower to upper if no upper was provided.
                    v.upper ??= v.lower;
                    
                    // Swap lower and upper if they are in the wrong order
                    if (v.lower !== undefined && v.upper !== undefined && v.lower > v.upper) {
                        const temp = v.lower;
                        v.lower = v.upper;
                        v.upper = temp;
                    }
                    
                    this.value = v;
                    if (this.inited) {
                        this.fireEvent('value', this.getValue());
                        if (v.lower !== existingLower) this.fireEvent('lowerValue', v.lower);
                        if (v.upper !== existingUpper) this.fireEvent('upperValue', v.upper);
                    }
                } else {
                    this.callSuper(v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            getValueCopy: function() {
                const v = this.value;
                return {lower:v.lower, upper:v.upper};
            }
        }),
        
        /** A numeric value component that stays within a minimum and maximum value.
            
            Events:
                minValue:number
                maxValue:number
                snapToInt:boolean
            
            Attributes:
                minValue:number the largest value allowed. If undefined or null no min value 
                    is enforced.
                maxValue:number the lowest value allowed. If undefined or null no max value 
                    is enforced.
                snapToInt:boolean If true values can only be integers. Defaults to true.
            
            @class */
        BoundedValueComponent = pkg.BoundedValueComponent = new JSModule('BoundedValueComponent', {
            include: [ValueComponent],
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                
                self.appendToEarlyAttrs('snapToInt','minValue','maxValue');
                
                attrs.snapToInt ??= true;
                
                if (!attrs.valueFilter) {
                    attrs.valueFilter = v => {
                        const max = self.maxValue;
                        if (max != null && v > max) return max;
                        
                        const min = self.minValue;
                        if (min != null && v < min) return min;
                        
                        return v;
                    };
                }
                
                self.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setSnapToInt: function(v) {
                if (this.snapToInt !== v) {
                    this.snapToInt = v;
                    if (this.inited) {
                        this.fireEvent('snapToInt', v);
                        
                        // Update min, max and value since snap has been turned on
                        if (v) {
                            this.setMinValue(this.minValue);
                            this.setMaxValue(this.maxValue);
                            this.setValue(this.value);
                        }
                    }
                }
            },
            
            setMinValue: function(v) {
                if (this.snapToInt && v != null) v = mathRound(v);
                
                if (this.minValue !== v) {
                    const max = this.maxValue;
                    if (max != null && v > max) v = max;
                    
                    if (this.minValue !== v) {
                        this.minValue = v;
                        if (this.inited) {
                            this.fireEvent('minValue', v);
                            
                            // Rerun setValue since the filter has changed.
                            this.setValue(this.value);
                        }
                    }
                }
            },
            
            setMaxValue: function(v) {
                if (this.snapToInt && v != null) v = mathRound(v);
                
                if (this.maxValue !== v) {
                    const min = this.minValue;
                    if (min != null && v < min) v = min;
                    
                    if (this.maxValue !== v) {
                        this.maxValue = v;
                        if (this.inited) {
                            this.fireEvent('maxValue', v);
                            
                            // Rerun setValue since the filter has changed.
                            this.setValue(this.value);
                        }
                    }
                }
            },
            
            /** @overrides myt.ValueComponent */
            setValue: function(v) {
                this.callSuper(this.snapToInt && v != null && !isNaN(v) ? mathRound(v) : v);
            }
        });
    
    /** A numeric value component that stays within an upper and lower value and where the value 
        is a range.
        
        @class */
    pkg.BoundedRangeComponent = new JSModule('BoundedRangeComponent', {
        include: [BoundedValueComponent, RangeComponent],
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            const self = this;
            if (!attrs.valueFilter) {
                attrs.valueFilter = v => {
                    if (v) {
                        const max = self.maxValue,
                            min = self.minValue;
                        if (max != null && v.upper > max) v.upper = max;
                        if (min != null && v.lower < min) v.lower = min;
                    }
                    return v;
                };
            }
            
            self.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.ValueComponent */
        setValue: function(v) {
            if (this.snapToInt && v != null) {
                if (v.lower != null && !isNaN(v.lower)) v.lower = mathRound(v.lower);
                if (v.upper != null && !isNaN(v.upper)) v.upper = mathRound(v.upper);
            }
            this.callSuper(v);
        }
    });
})(myt);


(pkg => {
    const STYLE_SOLID = 'solid',
        STYLE_OUTLINE = 'outline',
        
        updateUI = checkbox => {
            const label = checkbox.label ?? '';
            checkbox.setText(
                '<i class="' + 
                (checkbox.checkboxStyle === STYLE_SOLID ? 'fas' : 'far') + 
                ' fa-' + (checkbox.isChecked() ? 'check-' : '') + 'square"></i>' +
                (label.length > 0 ? ' ' + label : '')
            );
        };
    
    /** A checkbox component.
        
        Attributes:
            label:string
            checkboxStyle:string Determines what style of checkbox to display. Supported values 
                are "solid" and "outline".
        
        @class */
    pkg.Checkbox = new JS.Class('Checkbox', pkg.Text, {
        include: [pkg.SimpleButtonStyle, pkg.ValueComponent],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            // Ensures the "pointer" cursor shows up rather than the "default" cursor.
            this.appendToEarlyAttrs('userUnselectable');
            
            attrs.value ??= false;
            attrs.focusIndicator ??= false;
            attrs.checkboxStyle ??= STYLE_OUTLINE;
            attrs.activeColor ??= 'inherit';
            attrs.hoverColor ??= 'inherit';
            attrs.readyColor ??= 'inherit';
            
            this.callSuper(parent, attrs);
            
            pkg.FontAwesome.registerForNotification(this);
            
            updateUI(this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.ValueComponent */
        setValue: function(v) {
            if (this.value !== v) {
                this.callSuper(v);
                if (this.inited) updateUI(this);
            }
        },
        
        setLabel: function(v) {
            if (this.label !== v) {
                this.set('label', v, true);
                if (this.inited) updateUI(this);
            }
        },
        
        setCheckboxStyle: function(v) {
            if (this.checkboxStyle !== v) {
                this.set('checkboxStyle', v, true);
                if (this.inited) updateUI(this);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        isChecked: function() {
            return this.value === true;
        },
        
        /** @overrides myt.Button
            Toggle the value attribute when activated. */
        doActivated: function() {
            this.setValue(!this.value);
        },
        
        /** @overrides myt.SimpleButtonStyle */
        draw: function(color, opacity=1) {
            this.setOpacity(opacity);
            this.setTextColor(color);
        }
    });
})(myt);


(pkg => {
    let undefToEmptyValueProcessor;
    
    const {Class:JSClass, Module:JSModule} = JS,
        
        consoleWarn = console.warn,
        
        {
            KeyObservable, UpdateableUI,
            dumpStack,
            global:G
        } = pkg,
        GlobalFocus = G.focus,
        GlobalKeys = G.keys,
        
        DEFAULT_ATTR = 'runForDefault',
        ROLLBACK_ATTR = 'runForRollback',
        CURRENT_ATTR = 'runForCurrent',
        
        ACCELERATOR_SUBMIT = 'submit',
        ACCELERATOR_CANCEL = 'cancel',
        ACCELERATOR_ACCEPT = 'accept',
        ACCELERATOR_REJECT = 'reject',
        
        ACCELERATOR_SCOPE_ROOT = 'root',
        ACCELERATOR_SCOPE_ELEMENT = 'element',
        ACCELERATOR_SCOPE_NONE = 'none',
        
        WHEN_BLUR_WITH_KEY_FIX = 'blurWithKeyFix',
        WHEN_BLUR = 'blur',
        WHEN_KEY = 'key',
        
        processorsById = {},
        
        getValueProcessor = id => processorsById[id],
        
        doFuncOnIdentifiable = (identifiable, func) => {
            if (identifiable) {
                const id = identifiable.id;
                if (identifiable.id) {
                    func(id);
                } else {
                    dumpStack('No ID');
                }
            } else {
                dumpStack('No processor');
            }
        },
        
        registerValueProcessor = identifiable => {
            doFuncOnIdentifiable(identifiable, id => {processorsById[id] = identifiable;});
        },
        
        getBooleanAttributeGroup = formRadioGroup => pkg.BAG.getGroup('selected', formRadioGroup.groupId),
        
        /*  Search the radio group for a matching node and make that one the true node.
            @param {!Object} formRadioGroup
            @returns {undefined} */
        updateRadioGroupValue = formRadioGroup => {
            const bag = getBooleanAttributeGroup(formRadioGroup);
            if (bag) {
                const nodes = bag.getNodes(),
                    v = formRadioGroup.value;
                let i = nodes.length;
                while (i) {
                    const node = nodes[--i];
                    if (node.optionValue === v) {
                        bag.setTrue(node);
                        break;
                    }
                }
            }
        },
        
        startMonitoringRadioGroup = formRadioGroup => {
            if (formRadioGroup.groupId) {
                const bag = getBooleanAttributeGroup(formRadioGroup);
                if (bag) formRadioGroup.syncTo(bag, '__syncValue', 'trueNode');
            }
        },
        
        stopMonitoringRadioGroup = formRadioGroup => {
            if (formRadioGroup.groupId) {
                const bag = getBooleanAttributeGroup(formRadioGroup);
                if (bag) formRadioGroup.detachFrom(bag, '__syncValue', 'trueNode');
            }
        },
        
        /*  Runs the validators on the form.
            @param isValid:boolean The currently determined validity.
            @returns boolean true if this form is valid, false otherwise. */
        applyValidation = (form, isValid) => {
            const errorMessages = [],
                __v = form.__v;
            if (__v) {
                for (const validator of __v) {
                    isValid = validator.isFormValid(form, null, errorMessages) && isValid;
                }
            }
            form.setErrorMessages(errorMessages);
            form.setIsValid(isValid);
            return isValid;
        },
        
        /*  Runs the provided value through all the ValueProcessors.
            @param value:* The value to process.
            @param checkAttr:string The name of the attribute on each processor that is checked to 
                see if that processor should be run or not.
            @returns * The processed value. */
        processValue = (formElement, value, checkAttr) => {
            const __vp = formElement.__vp;
            if (__vp) {
                for (const processor of __vp) {
                    if (processor[checkAttr]) value = processor.process(value);
                }
            }
            return value;
        },
        
        /** Modifies a value. Typically used to convert a form element value to its canonical form.
            
            Attributes:
                id:string The ideally unique ID for this value processor.
                runForDefault:boolean Indicates this processor should be run for default form 
                    values. Defaults to true.
                runForRollback:boolean Indicates this processor should be run for rollback form 
                    values. Defaults to true.
                runForCurrent:boolean Indicates this processor should be run for current form 
                    values. Defaults to true.
            
            @class */
        ValueProcessor = pkg.ValueProcessor = new JSClass('ValueProcessor', {
            // Constructor /////////////////////////////////////////////////////
            /** Creates a new ValueProcessor
                @param {string} id - The ideally unique ID for a processor instance.
                @param {boolean} [runForDefault]
                @param {boolean} [runForRollback]
                @param {boolean} [runForCurrent]
                @returns {undefined} */
            initialize: function(id, runForDefault, runForRollback, runForCurrent) {
                this.id = id;
                
                this[DEFAULT_ATTR] = !!runForDefault;
                this[ROLLBACK_ATTR] = !!runForRollback;
                this[CURRENT_ATTR] = !!runForCurrent;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Processes the value. The default implementation returns the value unmodified.
                @param {*} value - The value to modify.
                @returns {*} - The modified value. */
            process: value => value
        }),
        
        /** Converts values to a Number if possible. If the value becomes NaN the original value 
            is returned.
            
            @class */
        ToNumberValueProcessor = pkg.ToNumberValueProcessor = new JSClass('ToNumberValueProcessor', ValueProcessor, {
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.ValueProcessor */
            process: value => {
                // Don't convert "empty" values to a number since they'll become zero which is 
                // probably incorrect. Also catch undefined/null values since they will become NaN.
                if (value == null || value === '' || value === '-') return value;
                
                const numericValue = Number(value);
                return isNaN(numericValue) ? value : numericValue;
            }
        }),
        
        /** Trims the whitespace from a value.
            
            Attributes:
                trim:string Determines what kind of trimming to do. Supported values are 'left', 
                    'right' and 'both'. The default value is 'both'.
            
            @class */
        TrimValueProcessor = pkg.TrimValueProcessor = new JSClass('TrimValueProcessor', ValueProcessor, {
            // Constructor /////////////////////////////////////////////////////
            /** @overrides myt.ValueProcessor
                @param {string} id - The ideally unique ID for a processor instance.
                @param {boolean} [runForDefault]
                @param {boolean} [runForRollback]
                @param {boolean} [runForCurrent]
                @param trim:string Determines the type of trimming to do. Allowed values are 'left',
                    'right' or 'both'. The default value is 'both'.
                @returns {undefined} */
            initialize: function(id, runForDefault, runForRollback, runForCurrent, trim) {
                this.callSuper(id, runForDefault, runForRollback, runForCurrent);
                
                this.trim = trim;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides */
            process: function(value) {
                value += '';
                switch (this.trim) {
                    case 'start':
                    case 'left':
                        return value.trimStart();
                    case 'end':
                    case 'right':
                        return value.trimEnd();
                    default:
                        return value.trim();
                }
            }
        }),
        
        /** Converts undefined values to a default value.
            
            Attributes:
                defaultValue:* The value to return when the processed value is undefined.
            
            @class */
        UndefinedValueProcessor = pkg.UndefinedValueProcessor = new JSClass('UndefinedValueProcessor', ValueProcessor, {
            // Constructor /////////////////////////////////////////////////////
            /** @overrides myt.ValueProcessor
                @param {string} id - The ideally unique ID for a processor instance.
                @param {boolean} [runForDefault]
                @param {boolean} [runForRollback]
                @param {boolean} [runForCurrent]
                @param {*} [defaultValue] - The default value to convert undefined to.
                @returns {undefined} */
            initialize: function(id, runForDefault, runForRollback, runForCurrent, defaultValue) {
                this.callSuper(id, runForDefault, runForRollback, runForCurrent);
                
                this.defaultValue = defaultValue;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.ValueProcessor */
            process: function(value) {
                return value === undefined ? this.defaultValue : value;
            }
        }),
        
        /** Provides "form" functionality to a node. Forms can be nested to build up larger forms 
            from one or more subforms.
            
            Events:
                isValid:boolean Fired when the form changes validity.
                isChanged:boolean Fired when the form becomes changed or unchanged.
            
            Attributes:
                id:string The unique ID for this form relative to its parent form.
                form:myt.Form A reference to the parent form if it exists.
                errorMessages:array A list of error messages that occurred during the last 
                    execution of doValidation.
                isValid:boolean Indicates if the data in this form is valid or not.
                isChanged:boolean Indicates if the data in this form is different from the 
                    rollback value or not.
            
            Private Attributes:
                _lockCascade:boolean Prevents changes to "isChanged" and "isValid" from cascading 
                    upwards to the parent form. Used during reset and rollback.
                __sf:object A map of child forms/elements by ID.
                __acc:object A map of method references by accelerator identifier. The values will 
                    be function references. An intended use of these is to submit or cancel a form 
                    by keystroke.
                __v:array A list of validators to apply to this form.
            
            @class */
        Form = pkg.Form = new JSModule('Form', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                ACCELERATOR_SCOPE_ROOT:ACCELERATOR_SCOPE_ROOT,
                ACCELERATOR_SCOPE_ELEMENT:ACCELERATOR_SCOPE_ELEMENT,
                ACCELERATOR_SCOPE_NONE:ACCELERATOR_SCOPE_NONE
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                
                self.isChanged = self._lockCascade = false;
                self.isValid = true;
                
                self.__sf = {};
                self.__v = [];
                self.__acc = {};
                
                self.callSuper(parent, attrs);
                
                if (self.form?.isA(Form)) self.form.addSubForm(self);
            },
            
            /** @overrides myt.Node. */
            destroy: function() {
                if (this.form?.isA(Form)) this.form.removeSubForm(this.id);
                
                this.callSuper();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setErrorMessages: function(v) {
                this.set('errorMessages', v, true);
            },
            
            getFullId: function() {
                const ids = [this.id];
                let form = this.form;
                while (form && form.id) {
                    ids.unshift(form.id);
                    form = form.form;
                }
                return ids.join('.');
            },
            
            setId: function(v) {
                if (this.id !== v) {
                    const existingId = this.id;
                    this.id = v;
                    
                    const form = this.form;
                    if (form && this.inited) {
                        form.removeSubForm(existingId);
                        form.addSubForm(this);
                    }
                }
            },
            
            setForm: function(v) {
                if (this.form !== v) {
                    const existingForm = this.form;
                    this.form = v;
                    existingForm?.removeSubForm(this.id);
                    if (this.inited) v?.addSubForm(this);
                }
            },
            
            setIsValid: function(v) {
                // Don't abort when value hasn't changed. The reason this form is invalid may have 
                // changed so we want an event to fire so any new error messages can be shown.
                this.isValid = v;
                if (this.inited) this.fireEvent('isValid', v);
                
                const form = this.form;
                if (form && !this._lockCascade) {
                    if (v) {
                        form.verifyValidState(this);
                    } else {
                        form.notifySubFormInvalid();
                    }
                }
            },
            
            setIsChanged: function(v) {
                if (this.isChanged !== v) {
                    this.isChanged = v;
                    if (this.inited) this.fireEvent('isChanged', v);
                    
                    const form = this.form;
                    if (form && !this._lockCascade) {
                        if (v) {
                            form.notifySubFormChanged();
                        } else {
                            form.verifyChangedState(this);
                        }
                    }
                }
            },
            
            /** Allows bulk setting of validators.
                @param validators:array An array of myt.Validator instances or IDs of validators 
                    from the myt.global.validators registry.
                @returns {undefined} */
            setValidators: function(validators) {
                let i = validators.length;
                while (i) {
                    const validator = validators[--i];
                    if (typeof validator === 'string') {
                        validators[i] = G.validators.getValidator(validator);
                        if (!validators[i]) validators.splice(i, 1);
                    }
                }
                
                this.__v = validators;
            },
            
            /** Gets the value of this form. For a form this will be a map of all the subform 
                values by ID. Form elements should override this to return an element 
                specific value.
                @returns object */
            getValue: function() {
                // Allow for superclass to have custom getValue behavior.
                if (this.callSuper) return this.callSuper();
                
                // Only do "form" behavior for true forms, not for form elements.
                if (this.isA(FormElement)) return this.value;
                
                const retval = {}, 
                    subForms = this.__sf;
                for (const id in subForms) retval[id] = subForms[id].getValue();
                return retval;
            },
            
            /** Sets the value of this form. For a form the value should be a map containing values 
                for each of the subform elements. The entries in the map will be applied to each of 
                the subforms.
                @param value:object the value to set.
                @returns the value that was actually set. */
            setValue: function(value) {
                // Allow for superclass to have custom setValue behavior.
                this.callSuper?.(value);
                
                // Only do "form" behavior for true forms, not for form elements.
                if (typeof value === 'object' && !this.isA(FormElement)) {
                    for (const id in value) {
                        const subform = this.getSubForm(id);
                        if (subform) {
                            value[id] = subform.setValue(value[id]);
                        } else {
                            consoleWarn('ID in setValue for missing subform', id);
                        }
                    }
                }
                
                // Notify parent form of value change.
                this.form?.notifyValueChanged(this);
                
                return value;
            },
            
            /** Gets the default value of this form. For a form this will be a map of all the 
                subform default values by ID. Form elements should override this to return an 
                element specific default value.
                @returns object */
            getDefaultValue: function() {
                const retval = {};
                let subForms = this.__sf;
                for (const id in subForms) retval[id] = subForms[id].getDefaultValue();
                return retval;
            },
            
            /** Sets the default value of this form. For a form the value should be a map 
                containing default values for each of the subform elements. The entries in the map 
                will be applied to each of the subforms.
                @param value:object the value to set.
                @returns the value that was actually set. */
            setDefaultValue: function(value) {
                if (typeof value === 'object') {
                    for (const id in value) {
                        const subform = this.getSubForm(id);
                        if (subform) {
                            value[id] = subform.setDefaultValue(value[id]);
                        } else {
                            consoleWarn('ID in setDefaultValue for missing subform', id);
                        }
                    }
                }
                return value;
            },
            
            /** Gets the rollback value of this form. For a form this will be a map of all the 
                subform rollback values by ID. Form elements should override this to return an 
                element specific rollback value.
                @returns object */
            getRollbackValue: function() {
                const retval = {}, 
                    subForms = this.__sf;
                for (const id in subForms) retval[id] = subForms[id].getRollbackValue();
                return retval;
            },
            
            /** Sets the rollback value of this form. For a form the value should be a map 
                containing rollback values for each of the subform elements. The entries in the 
                map will be applied to each of the subforms.
                @param value:object the value to set.
                @returns the value that was actually set. */
            setRollbackValue: function(value) {
                if (typeof value === 'object') {
                    for (const id in value) {
                        const subform = this.getSubForm(id);
                        if (subform) {
                            value[id] = subform.setRollbackValue(value[id]);
                        } else {
                            consoleWarn('ID in setRollbackValue for missing subform', id);
                        }
                    }
                }
                return value;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Add an accelerator to this form.
                @param id:string the ID for the accelerator.
                @param func:function the function to call when the accelerator is invoked.
                @returns {undefined} */
            addAccelerator: function(id, func) {
                this.__acc[id] = func;
            },
            
            /** Removes an accelerator from this form.
                @param id:string the ID for the accelerator.
                @returns {undefined} */
            removeAccelerator: function(id) {
                delete this.__acc[id];
            },
            
            /** Executes an accelerator in this form with the provided ID.
                @param id:string The ID of the accelerator to invoke.
                @param value:* (optional) The value to pass to the function.
                @returns {undefined} */
            invokeAccelerator: function(id, value) {
                this.__acc[id]?.call(this, value ?? null);
            },
            
            /** Adds a validator to this form.
                @param validator:myt.Validator The validator to add.
                @returns {undefined} */
            addValidator: function(validator) {
                if (validator) this.__v.push(validator);
            },
            
            /** Removes a validator from this form.
                @param id:string The ID of the validator to remove.
                @returns the removed myt.Validator or undefined if not found. */
            removeValidator: function(id) {
                if (id) {
                    const validators = this.__v;
                    let i = validators.length;
                    while (i) {
                        const validator = validators[--i];
                        if (validator.id === id) {
                            validators.splice(i, 1);
                            return validator;
                        }
                    }
                }
            },
            
            /** Gets the oldest ancestor form of this form or the form itself.
                @returns myt.Form */
            getRootForm: function() {
                return this.form ? this.form.getRootForm() : this;
            },
            
            /** Adds an myt.Form to this form.
                @param subform:myt.Form the form to add as a subform.
                @returns {undefined} */
            addSubForm: function(subform) {
                const id = subform.id;
                if (this.getSubForm(id) != null) {
                    consoleWarn('ID in use for subform, add aborted', id, subform);
                } else {
                    subform.setForm(this);
                    this.__sf[id] = subform;
                    
                    if (subform.isChanged) this.notifySubFormChanged();
                    if (!subform.isValid) this.notifySubFormInvalid();
                }
            },
            
            /** Removes the subform with the provided ID from this form.
                @param id:string The ID of the form to remove.
                @returns myt.Form or undefined if not found. */
            removeSubForm: function(id) {
                const subform = this.getSubForm(id);
                if (subform) {
                    subform.setForm(null);
                    delete this.__sf[id];
                    this.verifyChangedState();
                    this.verifyValidState();
                }
                return subform;
            },
            
            /** Gets the subform with the provided ID from this form.
                @param id:string The ID of the form to get.
                @returns myt.Form or undefined if not found. */
            getSubForm: function(id) {
                return this.__sf[id];
            },
            
            getSubForms: function() {
                return this.__sf;
            },
            
            getInvalidSubformIds: function(doValidation) {
                if (doValidation) this.doValidation();
                
                const retval = [];
                (function inspect(subform) {
                    if (subform.isA(FormElement)) {
                        if (!subform.isValid) retval.push(subform.getFullId());
                    } else {
                        const subforms = subform.getSubForms();
                        for (const key in subforms) inspect(subforms[key]);
                    }
                })(this);
                
                return retval;
            },
            
            /** Gets all error messages from the entire form tree.
                @returns array of error messages strings. */
            getAllErrorMessages: function() {
                const subForms = this.__sf;
                let msgs = (this.errorMessages ?? []).slice();
                for (const id in subForms) msgs.push(...subForms[id].getAllErrorMessages());
                return msgs;
            },
            
            /** Called when a subform changes to the "invalid" state.
                @returns {undefined} */
            notifySubFormInvalid: function() {
                this.setIsValid(false);
            },
            
            /** Tests if this form is valid or not and updates the isValid attribute if necessary. 
                Allows upwards cascade of validity.
                @param subformToIgnore:myt.Form (optional) A subform that will not be checked for 
                    validity. This is typically the subform that is invoking this method.
                @returns boolean true if this form is valid, false otherwise. */
            verifyValidState: function(subformToIgnore) {
                const subForms = this.__sf;
                let isValid = true;
                for (const id in subForms) {
                    const subform = subForms[id];
                    if (subform !== subformToIgnore) isValid = subform.isValid && isValid;
                }
                return applyValidation(this, isValid);
            },
            
            /** Tests if this form is valid or not. Performs a top down validation check across 
                the entire form tree. Does not allow upwards cascade of validity check since this 
                is intended to be a top down check.
                @returns boolean true if this form is valid, false otherwise. */
            doValidation: function() {
                const subForms = this.__sf;
                let isValid = true;
                for (const id in subForms) isValid = subForms[id].doValidation() && isValid;
                
                this._lockCascade = true;
                isValid = applyValidation(this, isValid);
                this._lockCascade = false;
                
                return isValid;
            },
            
            /** Called whenever a value changes for the form or any subform therein.
                @param sourceForm:myt.Form the form that had a value change.
                @returns {undefined} */
            notifyValueChanged: function(sourceForm) {
                this.form?.notifyValueChanged(sourceForm);
            },
            
            /** Called when a subform changed to the "changed" state.
                @returns {undefined} */
            notifySubFormChanged: function() {
                this.setIsChanged(true);
            },
            
            /** Tests if this form is changed or not and updates the isChanged attribute if 
                necessary. Allows upwards cascade of changed state.
                @param subformToIgnore:myt.Form (optional) A subform that will not be checked for 
                    changed state. This is typically the subform that is invoking this method.
                @returns boolean true if this form is changed, false otherwise. */
            verifyChangedState: function(subformToIgnore) {
                const subForms = this.__sf;
                let isChanged = false;
                for (const id in subForms) {
                    const subform = subForms[id];
                    if (subform !== subformToIgnore) isChanged = subform.isChanged || isChanged;
                }
                this.setIsChanged(isChanged);
                return isChanged;
            },
            
            /** Initializes the form to the provided values.
                @param defaultValue:object The default value.
                @param rollbackValue:object The rollback value.
                @param value:object The current value.
                @returns {undefined} */
            setup: function(defaultValue, rollbackValue, value) {
                this._lockCascade = true;
                this.setIsChanged(false);
                this.setErrorMessages([]);
                this.setIsValid(true);
                this._lockCascade = false;
                
                defaultValue ??= {};
                rollbackValue ??= {};
                value ??= {};
                
                const subForms = this.__sf;
                for (const id in subForms) subForms[id].setup(defaultValue[id], rollbackValue[id], value[id]);
            },
            
            /** Resets this form to the default values.
                @returns {undefined} */
            resetForm: function() {
                this._lockCascade = true;
                
                const subForms = this.__sf;
                for (const id in subForms) subForms[id].resetForm();
                
                this.setIsChanged(false);
                this.setErrorMessages([]);
                this.setIsValid(true);
                
                this._lockCascade = false;
            },
            
            /** Rolls back this form to the rollback values.
                @returns {undefined} */
            rollbackForm: function() {
                this._lockCascade = true;
                
                const subForms = this.__sf;
                for (const id in subForms) subForms[id].rollbackForm();
                
                this.setIsChanged(false);
                this.setErrorMessages([]);
                this.setIsValid(true);
                
                this._lockCascade = false;
            },
            
            /** Gets the changed values of this form. For a form this will be a map of all the 
                subform values by ID that are in the "changed" state. Form elements should override 
                this to return an element specific value.
                @returns object */
            getChangedValue: function() {
                const retval = {}, 
                    subForms = this.__sf;
                for (const id in subForms) {
                    const subform = subForms[id];
                    if (subform.isChanged) retval[id] = subform.getChangedValue();
                }
                return retval;
            }
        }),
        
        /** Provides "form" element functionality to a node. A form element 
            is a form that actually has a value.
            
            Events:
                defaultValue:* Fired when the default value changes.
                rollbackValue:* Fired when the rollback value changes.
            
            Attributes:
                value:* The current value of the form element.
                rollbackValue:* The rollback value of the form element.
                defaultValue:* The default value of the form element.
            
            Private Attributes:
                __vp:array A list of myt.ValueProcessors that get applied to a value whenever it is 
                    retrieved via the methods: getValue, getRollbackValue or getDefaultValue.
            
            @class */
        FormElement = pkg.FormElement = new JSModule('FormElement', {
            include: [Form],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.__vp = [];
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.Form */
            getValue: function() {
                return processValue(this, this.callSuper ? this.callSuper() : this.value, CURRENT_ATTR);
            },
            
            /** @overrides myt.Form */
            setValue: function(value) {
                if (value === undefined) value = this.getRollbackValue();
                if (this.value !== value) {
                    this.callSuper(value);
                    this.verifyChangedState();
                }
                return value;
            },
            
            /** @overrides myt.Form */
            getDefaultValue: function() {
                return processValue(this, this.defaultValue, DEFAULT_ATTR);
            },
            
            /** @overrides myt.Form */
            setDefaultValue: function(value) {
                if (this.defaultValue !== value) {
                    this.defaultValue = value;
                    if (this.inited) this.fireEvent('defaultValue', value);
                    this.verifyChangedState();
                }
                return value;
            },
            
            /** @overrides myt.Form */
            getRollbackValue: function() {
                return processValue(this, this.rollbackValue, ROLLBACK_ATTR);
            },
            
            /** @overrides myt.Form */
            setRollbackValue: function(value) {
                if (value === undefined) value = this.getDefaultValue();
                if (this.rollbackValue !== value) {
                    this.rollbackValue = value;
                    if (this.inited) this.fireEvent('rollbackValue', value);
                    this.verifyChangedState();
                }
                return value;
            },
            
            /** Allows bulk setting of ValueProcessors.
                @param processors:array An array of myt.ValueProcessor instances or IDs of value 
                    processors from the myt.global.valueProcessors registry.
                @returns {undefined} */
            setValueProcessors: function(processors) {
                let i = processors.length;
                while (i) {
                    const processor = processors[--i];
                    if (typeof processor === 'string') {
                        processors[i] = getValueProcessor(processor);
                        if (!processors[i]) processors.splice(i, 1);
                    }
                }
                
                this.__vp = processors;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Adds a ValueProcessor to this form element.
                @param processor:myt.ValueProcessor
                @returns {undefined} */
            addValueProcessor: function(processor) {
                this.__vp.push(processor);
            },
            
            /** Removes a ValueProcessor from this form element.
                @param id:string the ID of the processor to remove.
                @returns the removed myt.ValueProcessor or undefined if not found. */
            removeValueProcessor: function(id) {
                if (id) {
                    const processors = this.__vp;
                    let i = processors.length;
                    while (i) {
                        const processor = processors[--i];
                        if (processor.id === id) {
                            processors.splice(i, 1);
                            return processor;
                        }
                    }
                }
            },
            
            /** @overrides myt.Form */
            addSubForm: subform => {
                dumpStack('addSubForm unsupported on FormElement');
            },
            
            /** @overrides myt.Form */
            getSubForm: id => {
                dumpStack('getSubForm unsupported on FormElement');
            },
            
            /** @overrides myt.Form */
            removeSubForm: id => {
                dumpStack('removeSubForm unsupported on FormElement');
            },
            
            /** @overrides myt.Form */
            verifyChangedState: function(subformToIgnore) {
                const isChanged = this.getValue() !== this.getRollbackValue();
                this.setIsChanged(isChanged);
                return isChanged;
            },
            
            /** @overrides myt.Form */
            setup: function(defaultValue, rollbackValue, value) {
                this._lockCascade = true;
                
                // Reset values to uninitialized state to make repeated calls to setup behave 
                // identically. Otherwise values could bleed through.
                this.defaultValue = undefined;
                this.rollbackValue = undefined;
                this.value = undefined;
                
                this.setDefaultValue(defaultValue);
                this.setRollbackValue(rollbackValue);
                
                this.setIsChanged(false);
                this.setErrorMessages([]);
                this.setIsValid(true);
                
                this._lockCascade = false;
                
                this.setValue(value);
            },
            
            /** @overrides myt.Form */
            resetForm: function() {
                this._lockCascade = true;
                
                const defaultValue = this.getDefaultValue();
                this.setRollbackValue(defaultValue);
                this.setValue(defaultValue);
                
                this.setIsChanged(false);
                this.setErrorMessages([]);
                this.setIsValid(true);
                
                this._lockCascade = false;
            },
            
            /** @overrides myt.Form */
            rollbackForm: function() {
                this._lockCascade = true;
                
                this.setValue(this.getRollbackValue());
                
                this.setIsChanged(false);
                this.setErrorMessages([]);
                this.setIsValid(true);
                
                this._lockCascade = false;
            },
            
            /** @overrides myt.Form
                @returns The current value if this form is in the changed 
                    state, otherwise undefined. */
            getChangedValue: function() {
                return this.isChanged ? this.getValue() : undefined;
            }
        }),
        
        /** Provides common functionality for text related form elements.
            
            Accelerators:
                accept: Invokes the doAccept function. Activated upon key down of the ENTER key.
                reject: Invokes the doReject function. Activated upon key up of the ESC key.
            
            Attributes:
                errorColor:color_string The color to use when a validation error exists. Defaults 
                    to '#f99'.
                actionRequiredColor:color_string The color to use when a validation error exists 
                    but the user has not modified the value. Defaults to '#966'.
                normalColor:color_string The color to use when no validation error exists. 
                    Defaults to '#999'.
                validateWhen:string Indicates when to run validation.
                    Supported values are:
                        key: Validate as the user types.
                        blur: Validate when blurring out of the UI control
                        blurWithKeyFix: The same as blur except we also validate as the user types 
                            if currently invalid.
                        none: Don't do any validation when interacting with the field.
                    The default value is 'key'.
                acceleratorScope:string The scope the accelerators will be applied to.
                    Supported values are:
                        element: Take action on this element only
                        root: Take action on the root form.
                        none: Take no action.
                    The default value is 'element'.
            
            @class */
        FormInputTextMixin = pkg.FormInputTextMixin = new JSModule('FormInputTextMixin', {
            include: [FormElement, UpdateableUI],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.Input */
            initNode: function(parent, attrs) {
                const self = this;
                
                self.acceleratorScope = ACCELERATOR_SCOPE_ELEMENT;
                self.validateWhen = WHEN_KEY;
                self.errorColor = '#f99';
                self.actionRequiredColor = '#966';
                self.normalColor = '#999';
                
                attrs.bgColor ??= '#fff';
                attrs.borderWidth ??= 1;
                attrs.borderStyle ??= 'solid';
                
                self.callSuper(parent, attrs);
                
                self.addValueProcessor(undefToEmptyValueProcessor);
                
                self.attachToDom(self, '__hndlKeyDown', 'keydown');
                self.attachToDom(self, '__hndlKeyUp', 'keyup');
                
                self.addAccelerator(ACCELERATOR_ACCEPT, self.doAccept);
                self.addAccelerator(ACCELERATOR_REJECT, self.doReject);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setValidateWhen: function(v) {this.validateWhen = v;},
            setAcceleratorScope: function(v) {this.acceleratorScope = v;},
            setErrorColor: function(v) {this.errorColor = v;},
            setActionRequiredColor: function(v) {this.actionRequiredColor = v;},
            setNormalColor: function(v) {this.normalColor = v;},
            
            setIsChanged: function(v) {
                this.callSuper(v);
                if (this.inited) this.updateUI();
            },
            
            setIsValid: function(v) {
                this.callSuper(v);
                if (this.inited) this.updateUI();
            },
            
            /** @overrides myt.FormElement */
            setValue: function(v) {
                const retval = this.callSuper(v);
                
                // Validate as we type.
                const when = this.validateWhen;
                if (when === WHEN_KEY || when === WHEN_BLUR_WITH_KEY_FIX) this.verifyValidState();
                
                return retval;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            doAccept: function() {
                if (!this.disabled) {
                    switch (this.acceleratorScope) {
                        case ACCELERATOR_SCOPE_ROOT:
                            this.getRootForm().invokeAccelerator(ACCELERATOR_SUBMIT);
                            break;
                        case ACCELERATOR_SCOPE_ELEMENT:
                            // Tab navigate forward
                            GlobalFocus.next(false);
                            break;
                        case ACCELERATOR_SCOPE_NONE:
                        default:
                    }
                }
            },
            
            doReject: function() {
                if (!this.disabled) {
                    switch (this.acceleratorScope) {
                        case ACCELERATOR_SCOPE_ROOT:
                            this.getRootForm().invokeAccelerator(ACCELERATOR_CANCEL);
                            break;
                        case ACCELERATOR_SCOPE_ELEMENT:
                            this.rollbackForm();
                            this.getRootForm().doValidation();
                            this.form?.verifyChangedState(this);
                            break;
                        case ACCELERATOR_SCOPE_NONE:
                        default:
                    }
                }
            },
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __hndlKeyDown: function(event) {
                if (KeyObservable.isEnterKeyEvent(event)) this.invokeAccelerator(ACCELERATOR_ACCEPT);
            },
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            __hndlKeyUp: function(event) {
                if (KeyObservable.isEscKeyEvent(event)) this.invokeAccelerator(ACCELERATOR_REJECT);
            },
            
            /** @overrides myt.FocusObservable */
            doBlur: function() {
                this.callSuper();
                
                // Validate on blur
                const when = this.validateWhen;
                if (when === WHEN_BLUR || when === WHEN_BLUR_WITH_KEY_FIX) this.verifyValidState();
            },
            
            /** @overrides myt.UpdateableUI */
            updateUI: function() {
                this.setBorderColor(
                    this.isValid ? this.normalColor : (this.isChanged ? this.errorColor : this.actionRequiredColor)
                );
            }
        });
        
    /** Provides additional common functionality for a root level form.
        
        Accelerators:
            submit: Invokes the doSubmit function which in turn may invoke the doValidSubmit or 
                doInvalidSubmit function.
            cancel: Invokes the doCancel function.
        
        @class */
    pkg.RootForm = new JSModule('RootForm', {
        include: [Form],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            
            this.addAccelerator(ACCELERATOR_SUBMIT, this.doSubmit);
            this.addAccelerator(ACCELERATOR_CANCEL, this.doCancel);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        doSubmit: function() {
            if (this.isChanged) {
                if (this.doValidation()) {
                    this.doValidSubmit(this.getValue());
                } else {
                    this.doInvalidSubmit();
                }
            }
        },
        
        /** Called when the form is submitted and it is valid.
            @param {*} value
            @returns {undefined} */
        doValidSubmit: value => {},
        
        /** Called when the form is submitted and it is not valid.
            @returns {undefined} */
        doInvalidSubmit: () => {},
        
        /** Rolls back the form and revalidates it.
            @returns {undefined} */
        doCancel: function() {
            this.rollbackForm();
            this.doValidation();
        }
    });
    
    /** An myt.Checkbox that is also a FormElement.
        
        @class */
    pkg.FormCheckbox = new JSClass('FormCheckbox', pkg.Checkbox, {
        include: [FormElement],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            this.rollbackValue = this.defaultValue = false;
            this.callSuper(parent, attrs);
        }
    });
    
    /** An myt.ComboBox that is also a FormElement.
        
        @class */
    pkg.FormComboBox = new JSClass('FormComboBox', pkg.ComboBox, {
        include: [FormElement, UpdateableUI],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.Input */
        initNode: function(parent, attrs) {
            this.acceleratorScope = ACCELERATOR_SCOPE_ELEMENT;
            this.validateWhen = WHEN_KEY;
            this.errorColor = '#f99';
            this.actionRequiredColor = '#966';
            this.normalColor = '#999';
            
            this.callSuper(parent, attrs);
            
            this.addValueProcessor(undefToEmptyValueProcessor);
            
            this.addAccelerator(ACCELERATOR_ACCEPT, this.doAccept);
            this.addAccelerator(ACCELERATOR_REJECT, this.doReject);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setValidateWhen: function(v) {this.validateWhen = v;},
        setAcceleratorScope: function(v) {this.acceleratorScope = v;},
        setErrorColor: function(v) {this.errorColor = v;},
        setActionRequiredColor: function(v) {this.actionRequiredColor = v;},
        setNormalColor: function(v) {this.normalColor = v;},
        
        setIsChanged: function(v) {
            this.callSuper(v);
            if (this.inited) this.updateUI();
        },
        
        setIsValid: function(v) {
            this.callSuper(v);
            if (this.inited) this.updateUI();
        },
        
        /** @overrides myt.FormElement */
        setValue: function(v) {
            const retval = this.callSuper(v);
            
            // Validate as we type.
            const when = this.validateWhen;
            if (when === WHEN_KEY || when === WHEN_BLUR_WITH_KEY_FIX) this.verifyValidState();
            
            return retval;
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        doAccept: function() {
            if (!this.disabled) {
                switch (this.acceleratorScope) {
                    case ACCELERATOR_SCOPE_ROOT:
                        this.getRootForm().invokeAccelerator(ACCELERATOR_SUBMIT);
                        break;
                    case ACCELERATOR_SCOPE_ELEMENT:
                        // Tab navigate forward
                        GlobalFocus.next(false);
                        break;
                    case ACCELERATOR_SCOPE_NONE:
                    default:
                }
            }
        },
        
        doReject: function() {
            if (!this.disabled) {
                switch (this.acceleratorScope) {
                    case ACCELERATOR_SCOPE_ROOT:
                        this.getRootForm().invokeAccelerator(ACCELERATOR_CANCEL);
                        break;
                    case ACCELERATOR_SCOPE_ELEMENT:
                        this.rollbackForm();
                        this.getRootForm().doValidation();
                        this.form?.verifyChangedState(this);
                        break;
                    case ACCELERATOR_SCOPE_NONE:
                    default:
                }
            }
        },
        
        notifyPanelShown: function(panel) {
            this._isShown = true;
        },
        
        notifyPanelHidden: function(panel) {
            this._isShown = false;
        },
        
        /** @overrides myt.ListViewAnchor. */
        doActivationKeyDown: function(code, isRepeat) {
            if (code === GlobalKeys.CODE_ESC && !this._isShown) {
                this.invokeAccelerator(ACCELERATOR_REJECT);
            } else {
                this.callSuper(code, isRepeat);
            }
        },
        
        /** @overrides myt.ListViewAnchor. */
        doActivationKeyUp: function(code) {
            if (code === GlobalKeys.CODE_ENTER && !this._isShown) {
                this.invokeAccelerator(ACCELERATOR_ACCEPT);
            } else {
                this.callSuper(code);
            }
        },
        
        /** @overrides myt.FocusObservable */
        doBlur: function() {
            this.callSuper();
            
            // Validate on blur
            const when = this.validateWhen;
            if (when === WHEN_BLUR || when === WHEN_BLUR_WITH_KEY_FIX) this.verifyValidState();
        },
        
        /** @overrides myt.UpdateableUI */
        updateUI: function() {
            this.setBorderColor(
                this.isValid ? this.normalColor : (this.isChanged ? this.errorColor : this.actionRequiredColor)
            );
        }
    });
    
    /** An myt.EditableText that is also a FormElement.
        
        @class */
    pkg.FormEditableText = new JSClass('FormEditableText', pkg.EditableText, {
        include: [FormInputTextMixin],
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.FormInputTextMixin */
        __hndlKeyDown: function(event) {
            // Only allow enter key as accelerator if no wrapping is occurring
            if (this.whitespace === 'nowrap') this.callSuper(event);
        }
    });
    
    /** An myt.InputText that is also a FormElement.
        
        @class */
    pkg.FormInputText = new JSClass('FormInputText', pkg.InputText, {
        include: [FormInputTextMixin]
    });
    
    /** An myt.InputTextArea that is also a FormElement.
        
        Accelerators:
            Only "reject" from myt.FormInputTextMixin.
        
        @class */
    pkg.FormInputTextArea = new JSClass('FormInputTextArea', pkg.InputTextArea, {
        include: [FormInputTextMixin],
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.FormInputTextMixin */
        __hndlKeyDown: event => {/* Do nothing so the "accept" accelerator is not invoked. */}
    });
    
    /** An myt.InputSelect that is also a FormElement.
        
        Private Attributes:
            __abortSetValue:boolean Prevents setValue from being called again when performing 
                operations from within setValue.
        
        @class */
    pkg.FormInputSelect = new JSClass('FormInputSelect', pkg.InputSelect, {
        include: [FormElement],
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.FormElement */
        setValue: function(v) {
            if (this.__abortSetValue) return;
            
            const retval = this.callSuper(v);
            
            // Clear Selection and then reselect
            this.__abortSetValue = true;
            this.deselectAll();
            this.selectValues(retval);
            this.__abortSetValue = false;
            
            this.verifyValidState();
            
            return retval;
        }
    });
    
    /** Monitors a radio button group for a form.
        
        Attributes:
            groupId:string The ID of the radio group to monitor.
        
        @class */
    pkg.FormRadioGroup = new JSClass('FormRadioGroup', pkg.Node, {
        include: [pkg.ValueComponent, FormElement],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.groupId ??= pkg.generateGuid();
            
            this.callSuper(parent, attrs);
            
            if (this.value !== undefined) updateRadioGroupValue(this);
            startMonitoringRadioGroup(this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.FormElement */
        setValue: function(v) {
            const retval = this.callSuper(v);
            if (this.inited) updateRadioGroupValue(this);
            return retval;
        },
        
        setGroupId: function(v) {
            if (this.groupId !== v) {
                stopMonitoringRadioGroup(this);
                this.groupId = v;
                if (this.inited) startMonitoringRadioGroup(this);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __syncValue: function(event) {
            const value = event.value;
            this.setValue(value ? value.optionValue : null);
        }
    });
    
    /** Pulls the current value from another form field if the provided value is undefined, null 
        or empty string.
        
        Attributes:
            otherField:myt.FormElement The form element to pull the current value from.
        
        @class */
    pkg.UseOtherFieldIfEmptyValueProcessor = new JSClass('UseOtherFieldIfEmptyValueProcessor', ValueProcessor, {
        // Constructor /////////////////////////////////////////////////////////
        /** @overrides myt.ValueProcessor
            @param {string} id - The ideally unique ID for a processor instance.
            @param {boolean} [runForDefault]
            @param {boolean} [runForRollback]
            @param {boolean} [runForCurrent]
            @param {!Object} [otherField] - The myt.FormElement to pull the value from.
            @returns {undefined} */
        initialize: function(id, runForDefault, runForRollback, runForCurrent, otherField) {
            this.callSuper(id, runForDefault, runForRollback, runForCurrent);
            
            this.otherField = otherField;
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides */
        process: function(value) {
            return (value == null || value === '') ? this.otherField.getValue() : value;
        }
    });
    
    /** Stores myt.ValueProcessors by ID so they can be used in multiple places easily. */
    new JS.Singleton('GlobalValueProcessorRegistry', {
        // Life Cycle //////////////////////////////////////////////////////////
        initialize: function() {
            // Register a few common ValueProcessors
            registerValueProcessor(undefToEmptyValueProcessor = new UndefinedValueProcessor('undefToEmpty', true, true, true, ''));
            registerValueProcessor(new ToNumberValueProcessor('toNumber', true, true, true));
            registerValueProcessor(new TrimValueProcessor('trimLeft', true, true, true, 'left'));
            registerValueProcessor(new TrimValueProcessor('trimRight', true, true, true, 'right'));
            registerValueProcessor(new TrimValueProcessor('trimBoth', true, true, true, 'both'));
            
            G.register('valueProcessors', this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** Gets a ValueProcessor for the ID.
            @param id:string the ID of the ValueProcessor to get.
            @returns an myt.ValueProcessor or undefined if not found. */
        getValueProcessor: getValueProcessor,
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Adds a ValueProcessor to this registry.
            @param identifiable:myt.ValueProcessor the ValueProcessor to add.
            @returns {undefined} */
        register: registerValueProcessor,
        
        /** Removes a ValueProcessor from this registery.
            @param identifiable:myt.ValueProcessor the ValueProcessor to remove.
            @returns {undefined} */
        unregister: identifiable => {
            doFuncOnIdentifiable(identifiable, id => {
                // Make sure the processor is in the repository then delete.
                if (getValueProcessor(id)) delete processorsById[id];
            });
        }
    });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        dumpStack = pkg.dumpStack,
        
        mathRound = Math.round,
        
        MIME_TYPES_BY_EXTENSION = {
            gif:'image/gif',
            png:'image/png',
            jpg:'image/jpeg',
            jpeg:'image/jpeg',
            svg:'image/svg+xml',
            webp:'image/webp',
            ico:'image/vnd.microsoft.icon'
        },
        
        doDragListeners = (target, funcName) => {
            target[funcName](target, 'doDragOver', 'dragover', false);
            target[funcName](target, 'doDragEnter', 'dragenter', false);
            target[funcName](target, 'doDragLeave', 'dragleave', false);
            target[funcName](target, 'doDrop', 'drop', false);
        },
        
        /** Provides browser drag and drop support.
            
            Requires myt.Disableable as a super mixin.
            
            @class */
        DragDropSupport = pkg.DragDropSupport = new JS.Module('DragDropSupport', {
            include: [pkg.DragDropObservable],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.View */
            initNode: function(parent, attrs) {
                this.callSuper(parent, attrs);
                
                if (!this.disabled) this.setupDragListeners();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.Disableable */
            setDisabled: function(v) {
                if (this.disabled !== v) {
                    this.getIDE().disabled = v;
                    this.callSuper(v);
                    
                    if (this.inited) {
                        if (v) {
                            this.teardownDragListeners();
                        } else {
                            this.setupDragListeners();
                        }
                    }
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @private */
            setupDragListeners: function() {
                doDragListeners(this, 'attachToDom');
            },
            
            /** @private */
            teardownDragListeners: function() {
                doDragListeners(this, 'detachFromDom');
            },
            
            /** @param {!Object} event
                @returns {undefined} */
            doDragOver: event => {},
            
            /** @param {!Object} event
                @returns {undefined} */
            doDragEnter: event => {},
            
            /** @param {!Object} event
                @returns {undefined} */
            doDragLeave: event => {},
            
            /** @param {!Object} event
                @returns {undefined} */
            doDrop: function(event) {
                this.handleFiles(event.value.dataTransfer.files, event);
            },
            
            /** @param {?Array} files
                @param {!Object} event
                @returns {undefined} */
            handleFiles: function(files, event) {
                if (files !== undefined) {
                    let i = files.length;
                    while (i) {
                        const file = this.filterFiles(files[--i]);
                        if (file) this.handleDroppedFile(file, event);
                    }
                } else {
                    dumpStack('No File API');
                }
            },
            
            /** Provides an opportunity to prevent a file from being handled. The default 
                implementation returns the provided file argument.
                @param file:File the file to be checked for handleability.
                @returns file:File the file to be handled (possibly modified by this function) or 
                    something falsy if the file should not be handled. */
            filterFiles: file => file,
            
            /** @param {!Object} file
                @param {!Object} event
                @returns {undefined} */
            handleDroppedFile: (file, event) => {}
        }),
        
        /** Component to upload files.
            
            @class */
        Uploader = pkg.Uploader = new JSClass('Uploader', pkg.View, {
            include: [DragDropSupport, pkg.Disableable, pkg.FormElement],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** The attribute key used in a file to store the path for the file on 
                    the server. */
                FILE_ATTR_SERVER_PATH: 'serverPath',
                
                readFile: (file, handlerFunc, asText) => {
                    if (FileReader !== undefined) {
                        const reader = new FileReader();
                        reader.onload = event => {handlerFunc(event.target.result);};
                        if (asText) {
                            reader.readAsText(file);
                        } else {
                            reader.readAsDataURL(file);
                        }
                    }
                },
                
                isSameFile: (f1, f2) => f1 != null && f2 != null && f1.name === f2.name && f1.type === f2.type && f1.size === f2.size,
                
                createFile: urlStr => {
                    const fileName = (new pkg.URI(urlStr)).file;
                    return {
                        name: fileName,
                        serverPath: urlStr,
                        size: -1,
                        type: MIME_TYPES_BY_EXTENSION[pkg.getExtension(fileName)]
                    };
                }
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.View */
            initNode: function(parent, attrs) {
                const self = this;
                
                self.files = [];
                
                // Modify attrs so setter gets called.
                attrs.requestFileParam ??= 'file';
                attrs.maxFiles ??= -1;
                attrs.responseIsRaw ??= false;
                
                self.callSuper(parent, attrs);
                
                // Support click to upload too.
                self.fileInput = new pkg.NativeInputWrapper(self, {
                    percentOfParentWidth:100, percentOfParentHeight:100,
                    opacity:0.01, disabled:self.disabled, overflow:'hidden'
                }, [pkg.SizeToParent, {
                    initNode: function(parent, attrs) {
                        this.inputType = 'file';
                        this.callSuper(parent, attrs);
                        this.attachToDom(this, '_hndlInput', 'change');
                        
                        this.getIDE().multiple = self.maxFiles > 1;
                    },
                    
                    _hndlInput: function(event) {
                        self.handleFiles(this.getIDE().files, event);
                    }
                }]);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** Add a "remote" file when the value is set.
                @param {string} v - the URI for a remote file.
                @returns {string} */
            setValue: function(v) {
                this.clearFiles();
                
                if (v) {
                    if (!Array.isArray(v)) v = [v];
                    for (const urlStr of v) this.addFile(Uploader.createFile(urlStr));
                }
                
                return this.callSuper ? this.callSuper(v) : v;
            },
            
            /** @returns {string} The path to the uploaded files. */
            getValue: function() {
                return this.value;
            },
            
            /** @overrides myt.Disableable */
            setDisabled: function(v) {
                this.callSuper(v);
                this.fileInput?.setDisabled(v);
            },
            
            setMaxFiles: function(v) {
                if (this.maxFiles !== v) {
                    this.maxFiles = v;
                    if (this.inited) this.fireEvent('maxFiles', v);
                    if (this.fileInput) this.fileInput.getIDE().multiple = v > 1;
                }
            },
            
            setUploadUrl: function(v) {this.set('uploadUrl', v, true);},
            setRequestFileParam: function(v) {this.set('requestFileParam', v, true);},
            setResponseIsRaw: function(v) {this.set('responseIsRaw', v, true);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.View */
            bringSubviewToFront: function(sv) {
                if (sv === this.fileInput) {
                    this.callSuper(sv);
                } else {
                    this.sendSubviewBehind(sv, this.fileInput);
                }
            },
            
            /** @overrides myt.View */
            subviewAdded: function(sv) {
                this.callSuper(sv);
                
                if (this.fileInput) this.bringSubviewToFront(this.fileInput);
            },
            
            handleDroppedFile: function(file, event) {
                this.addFile(file);
            },
            
            /** @overrides myt.DragDropSupport */
            filterFiles: function(file) {
                // Prevent max files from being exceeded.
                return this.maxFiles >= 0 && this.files.length >= this.maxFiles ? null : file;
            },
            
            uploadFiles: function(url, fileParam) {
                url ??= this.uploadUrl;
                
                const files = this.files;
                let i = files.length;
                while (i) this.uploadFile(files[--i], url, fileParam);
            },
            
            makeFetchOptionsForUpload: formData => ({method:'POST', body:formData}),
            
            uploadFile: function(file, url, fileParam) {
                const self = this,
                    formData = new FormData();
                formData.append(fileParam ?? self.requestFileParam, file, file.name.replaceAll('%20', ' '));
                pkg.doFetch(
                    url ?? self.uploadUrl,
                    self.makeFetchOptionsForUpload(formData),
                    self.responseIsRaw,
                    data => {
                        self.handleUploadSuccess(file, data);
                    },
                    error => {
                        self.handleUploadFailure(file, error);
                    }
                );
            },
            
            handleUploadSuccess: function(file, data) {
                file[Uploader.FILE_ATTR_SERVER_PATH] = this.parseServerPathFromResponse(file, data);
                this.updateValueFromFiles();
            },
            
            handleUploadFailure: (file, error) => {
                dumpStack('Upload failure:' + error.status + ':' + error.message);
            },
            
            /** Subclasses must implement this to extract the uploaded file path from the response. 
                By default this returns null.
                @param {!Object} file
                @param {!Object} data
                @returns {undefined} */
            parseServerPathFromResponse: (file, data) => null,
            
            addFile: function(file) {
                this.files.push(file);
                this.updateValueFromFiles();
                this.fireEvent('addFile', file);
            },
            
            removeFile: function(file) {
                const self = this,
                    files = self.files;
                let i = files.length;
                while (i) {
                    if (Uploader.isSameFile(files[--i], file)) {
                        files.splice(i, 1);
                        self.updateValueFromFiles();
                        self.fireEvent('removeFile', file);
                        break;
                    }
                }
            },
            
            updateValueFromFiles: function() {
                const self = this,
                    value = [],
                    files = self.files;
                let i = files.length;
                while (i) {
                    const serverPath = files[--i][Uploader.FILE_ATTR_SERVER_PATH];
                    if (serverPath) value.push(serverPath);
                }
                
                const len = value.length;
                self.value = len === 1 ? value[0] : (len === 0 ? undefined : value);
                
                // Reset the form element if empty. Otherwise uploading the 
                // same file again won't trigger a change event.
                if (!self.value) self.fileInput.getIDE().value = '';
                
                self.verifyChangedState(); // FIXME: mimics what happens in myt.FormElement setValue
                self.form?.notifyValueChanged(self); // FIXME: mimics what happens in myt.Form setValue
                
                self.fireEvent('value', self.value);
            },
            
            clearFiles: function() {
                const files = this.files;
                let i = files.length;
                while (i) this.removeFile(files[--i]);
            }
        }),
        
        /** Component to upload image files.
            
            @class */
        ImageUploader = pkg.ImageUploader = new JSClass('ImageUploader', Uploader, {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                isImageFile: file => (/image/i).test(file.type)
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.View */
            initNode: function(parent, attrs) {
                attrs.maxFiles = 1;
                
                this.callSuper(parent, attrs);
            },
            
            
            // Attributes //////////////////////////////////////////////////////
            setWidth: function(v) {
                this.callSuper(v);
                if (this.inited) this.updateImageSize();
            },
            
            setHeight: function(v) {
                this.callSuper(v);
                if (this.inited) this.updateImageSize();
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            filterFiles: function(file) {
                if (ImageUploader.isImageFile(file) || this.allowNonImages) {
                    // Remove existing file
                    while (this.files.length > 0) this.removeFile(this.files[0]);
                    return this.callSuper(file);
                }
            },
            
            addFile: function(file) {
                const self = this,
                    isImageFile = ImageUploader.isImageFile(file);
                
                self.callSuper(file);
                
                const image = self.image = new pkg.Image(self, {useNaturalSize:false, align:'center', valign:'middle'});
                
                image.file = file;
                
                // Read into image
                const readImageFunc = src => {
                    const img = new Image();
                    img.onload = () => {
                        file.width = img.width;
                        file.height = img.height;
                        if (image && !image.destroyed) self.updateImage(file, image, img.src);
                    };
                    img.src = src;
                };
                if (isImageFile) {
                    if (file.size === -1) {
                        readImageFunc(file.serverPath);
                    } else if (ImageUploader.isImageFile(file)) {
                        Uploader.readFile(file, readImageFunc);
                    }
                } else {
                    if (file.size === -1) {
                        self.updateImage(file, image, file.serverPath);
                    } else {
                        Uploader.readFile(file, result => {self.updateImage(file, image, result);});
                    }
                }
            },
            
            scaleToFit: (boundsWidth, boundsHeight, imgWidth, imgHeight) => {
                const boundsRatio = boundsWidth / boundsHeight,
                    imgRatio = imgWidth / imgHeight;
                if (imgRatio > boundsRatio) {
                    return [boundsWidth, imgHeight * boundsWidth / imgWidth];
                } else {
                    return [imgWidth * boundsHeight / imgHeight, boundsHeight];
                }
            },
            
            removeFile: function(file) {
                this.callSuper(file);
                
                const images = this.getSubviews();
                let i = images.length;
                while (i) {
                    const image = images[--i];
                    if (Uploader.isSameFile(image.file, file)) {
                        image.destroy();
                        break;
                    }
                }
            },
            
            handleDroppedFile: function(file, event) {
                this.callSuper(file, event);
                
                this.uploadFile(file, this.uploadUrl);
            },
            
            updateImage: function(file, image, src) {
                this.nativeWidth = file.width;
                this.nativeHeight = file.height;
                
                this.updateImageSize();
                
                image.setImageUrl(src);
            },
            
            updateImageSize: function() {
                const image = this.image;
                if (image && !image.destroyed) {
                    const size = this.scaleToFit(this.width, this.height, this.nativeWidth, this.nativeHeight),
                        w = mathRound(size[0]), 
                        h = mathRound(size[1]);
                    image.setImageSize(w + 'px ' + h + 'px');
                    image.setWidth(w);
                    image.setHeight(h);
                }
            },
            
            getImageSize: function() {
                return this.files.length ? {width:this.nativeWidth, height:this.nativeHeight} : null;
            }
        });
})(myt);


(pkg => {
    const updateMonitoringSubview = (stc, sv, func, targetFuncName) => {
            func = func.bind(stc);
            if (stc.axis !== 'y') {
                func(sv, targetFuncName, 'x');
                func(sv, targetFuncName, 'boundsWidth');
            }
            if (stc.axis !== 'x') {
                func(sv, targetFuncName, 'y');
                func(sv, targetFuncName, 'boundsHeight');
            }
            func(sv, targetFuncName, 'visible');
        };
    
    /** A special "layout" that resizes the parent to fit the children rather than laying out 
        the children.
        
        Events:
            axis:string
            paddingX:number
            paddingY:number
        
        Attributes:
            axis:string The axis along which to resize this view to fit its children. Supported 
                values are 'x', 'y' and 'both'. Defaults to 'x'.
            paddingX:number Additional space added on the child extent along the x-axis. 
                Defaults to 0.
            paddingY:number Additional space added on the child extent along the y-axis. 
                Defaults to 0.
        
        @class */
    pkg.SizeToChildren = new JS.Class('SizeToChildren', pkg.Layout, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.Node */
        initNode: function(parent, attrs) {
            this.axis = 'x';
            this.paddingX = this.paddingY = 0;
            
            this.callSuper(parent, attrs);
        },
        
        
        // Acessors ////////////////////////////////////////////////////////////
        setAxis: function(v) {
            if (this.axis !== v) {
                if (this.inited) {
                    this.stopMonitoringAllSubviews();
                    this.axis = v;
                    this.startMonitoringAllSubviews();
                    this.fireEvent('axis', v);
                    this.update();
                } else {
                    this.axis = v;
                }
            }
        },
        
        setPaddingX: function(v) {
            if (this.paddingX !== v) {
                this.paddingX = v;
                if (this.inited) {
                    this.fireEvent('paddingX', v);
                    this.update();
                }
            }
        },
        
        setPaddingY: function(v) {
            if (this.paddingY !== v) {
                this.paddingY = v;
                if (this.inited) {
                    this.fireEvent('paddingY', v);
                    this.update();
                }
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.ConstantLayout */
        update: function() {
            if (this.canUpdate()) {
                // Prevent inadvertent loops
                this.incrementLockedCounter();
                
                const parent = this.parent;
                if (!parent.isBeingDestroyed) {
                    const svs = this.subviews, 
                        len = svs.length,
                        axis = this.axis,
                        mathMax = Math.max;
                    let i,
                        max;
                    if (axis !== 'y') {
                        i = len;
                        max = 0;
                        while (i) {
                            const sv = svs[--i];
                            if (sv.visible) max = mathMax(max, sv.x + (sv.boundsWidth > 0 ? sv.boundsWidth : 0));
                        }
                        parent.setWidth(max + this.paddingX);
                    }
                    if (axis !== 'x') {
                        i = len;
                        max = 0;
                        while (i) {
                            const sv = svs[--i];
                            if (sv.visible) max = mathMax(max, sv.y + (sv.boundsHeight > 0 ? sv.boundsHeight : 0));
                        }
                        parent.setHeight(max + this.paddingY);
                    }
                }
                
                this.decrementLockedCounter();
            }
        },
        
        /** @overrides myt.Layout
            Provides a default implementation that calls update when the visibility or extent of a 
            subview changes. */
        startMonitoringSubview: function(sv) {
            updateMonitoringSubview(this, sv, this.attachTo, 'update');
        },
        
        /** @overrides myt.Layout
            Provides a default implementation that calls update when the visibility or extent of a 
            subview changes. */
        stopMonitoringSubview: function(sv) {
            updateMonitoringSubview(this, sv, this.detachFrom, 'update');
        }
    });
})(myt);


(pkg => {
    /*  Tracks how many ModalPanel instances are currently open. */
    let openModalPanelCount = 0;
    
    const JSClass = JS.Class,
        
        {View, SizeToParent, RootView} = pkg,
        
        /** A dimmer that can be placed on another myt.View to obscure the subviews of that view.
            
            Attributes:
                restoreFocus:boolean when true focus will be sent back to the view that had focus 
                    before the dimmer was shown when the dimmer is hidden. Defaults to true.
                prevFocus:myt.View or dom element. The thing to set focus on when the dimmer is 
                    hidden if restoreFocus is true.
            
            @class */
        Dimmer = pkg.Dimmer = new JSClass('Dimmer', View, {
            include: [SizeToParent],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                OPACITY: 0.35,
                COLOR: '#000'
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.View */
            initNode: function(parent, attrs) {
                const self = this;
                
                self.restoreFocus = true;
                
                attrs.focusable = attrs.focusCage = true;
                
                attrs.percentOfParentWidth ??= 100;
                attrs.percentOfParentHeight ??= 100;
                attrs.visible ??= false;
                attrs.ignoreLayout ??= true;
                
                self.callSuper(parent, attrs);
                
                self.overlay = new View(self, {
                    ignorePlacement:true, 
                    opacity:Dimmer.OPACITY,
                    bgColor:Dimmer.COLOR,
                    percentOfParentWidth:100,
                    percentOfParentHeight:100
                }, [SizeToParent]);
                
                // Eat mouse events
                for (const eventName of ['mouseover','mouseout','mousedown','mouseup','click','dblclick','mousemove']) {
                    self.attachDomObserver(self, 'eatMouseEvent', eventName);
                }
                
                RootView.setupCaptureDrop(self);
            },
            
            /** @overrides myt.View */
            destroy: function() {
                RootView.teardownCaptureDrop(this);
                this.callSuper();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setRestoreFocus: function(v) {this.restoreFocus = v;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** A handler for mouse events that does nothing and prevents propogation.
                @param {!Object} event
                @return boolean True so that the dom event gets eaten. */
            eatMouseEvent: event => true,
            
            /** Shows the dimmer and remembers the focus location.
                @returns {undefined} */
            show: function() {
                const self = this,
                    globalFocus = pkg.global.focus;
                self.prevFocus = globalFocus.focusedView ?? globalFocus.focusedDom;
                
                self.makeHighestZIndex();
                
                // Prevent focus traversing
                if (self.focusable) self.focus();
                
                self.setVisible(true);
            },
            
            /** Hides the dimmer and restores focus if necessary.
                @param {boolean} [ignoreRestoreFocus] - When true focus will not be restored.
                @returns {undefined} */
            hide: function(ignoreRestoreFocus) {
                const self = this;
                if (self.visible) {
                    self.setVisible(false);
                    
                    if (!ignoreRestoreFocus && self.restoreFocus) self.prevFocus?.focus();
                }
            }
        }),
        
        /** An myt.Dimmer that also provides a content panel.
            
            Attributes:
                content:myt.View The content view placed inside the dimmer.
                sizingStrategy:string Determines how the content view is positioned relative to the 
                    bounds of the dimmer. Supported values are:
                        children: The content will be sized to fit the children it contains. The 
                            content will be positioned in the center and middle of the dimmer. This 
                            is the default sizingStrategy
                        parent: The content will be sized to the bounds of the dimmer.
                        basic: The content will not be sized in any way. It will be positioned in 
                            the center and middle of the dimmer.
                        none: The content will not be sized or positioned in any way.
                marginTop:number The margin above the content when the sizingStrategy is "parent". 
                    Defaults to 40 if not provided.
                marginLeft:number The margin on the left side of the content when the 
                    sizingStrategy is "parent". Defaults to 40 if not provided.
                marginBottom:number The margin below the content when the sizingStrategy is 
                    "parent". Defaults to 40 if not provided.
                marginRight:number The margin on the right side of the content when the 
                    sizingStrategy is "parent". Defaults to 40 if not provided.
                paddingX:number The internal horizontal padding when the sizingStrategy is 
                    "children". Defaults to 20 if not provided.
                paddingY:number The internal vertical padding when the sizingStrategy is 
                    "children". Defaults to 15 if not provided.
                
            @class */
        ModalPanel = pkg.ModalPanel = new JSClass('ModalPanel', Dimmer, {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** The default horizontal padding. */
                PADDING_X:20,
                
                /** The default vertical padding. */
                PADDING_Y:15,
                
                /** The default margin top. */
                MARGIN_TOP:40,
                
                /** The default margin left. */
                MARGIN_LEFT:40,
                
                /** The default margin bottom. */
                MARGIN_BOTTOM:40,
                
                /** The default margin right. */
                MARGIN_RIGHT:40,
                
                getOpenModalPanelCount: () => openModalPanelCount,
                
                hasOpenModalPanels: () => openModalPanelCount > 0
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this,
                    viewAttrs = {name:'content', ignorePlacement:true},
                    centeredViewAttrs = {...viewAttrs, align:'center', valign:'middle'};
                
                self.defaultPlacement = 'content';
                
                attrs.sizingStrategy ??= 'children';
                
                // Used for parent sizing strategy
                attrs.marginTop ??= ModalPanel.MARGIN_TOP;
                attrs.marginLeft ??= ModalPanel.MARGIN_LEFT;
                attrs.marginBottom ??= ModalPanel.MARGIN_BOTTOM;
                attrs.marginRight ??= ModalPanel.MARGIN_RIGHT;
                
                // Used for "children" sizing strategy
                attrs.paddingX ??= ModalPanel.PADDING_X;
                attrs.paddingY ??= ModalPanel.PADDING_Y;
                
                self.callSuper(parent, attrs);
                
                switch (self.sizingStrategy) {
                    case 'children':
                        new pkg.SizeToChildren(new View(self, centeredViewAttrs), {
                            name:'sizeToChildren', axis:'both',
                            paddingX:self.paddingX, 
                            paddingY:self.paddingY
                        });
                        break;
                    case 'parent':
                        new View(self, {
                            ...viewAttrs, 
                            x:self.marginLeft,
                            y:self.marginTop,
                            percentOfParentWidthOffset:-self.marginLeft - self.marginRight,
                            percentOfParentHeightOffset:-self.marginTop - self.marginBottom,
                            percentOfParentWidth:100,
                            percentOfParentHeight:100
                        }, [SizeToParent]);
                        break;
                    case 'basic':
                        new View(self, centeredViewAttrs);
                        break;
                    case 'none':
                    default:
                        new View(self, viewAttrs);
                }
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setSizingStrategy: function(v) {this.sizingStrategy = v;},
            
            setMarginTop: function(v) {this.marginTop = v;},
            setMarginLeft: function(v) {this.marginLeft = v;},
            setMarginBottom: function(v) {this.marginBottom = v;},
            setMarginRight: function(v) {this.marginRight = v;},
            
            setPaddingX: function(v) {this.paddingX = v;},
            setPaddingY: function(v) {this.paddingY = v;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.Dimmer */
            show: function() {
                this.callSuper();
                openModalPanelCount++;
            },
            
            /** @overrides myt.Dimmer */
            hide: function(ignoreRestoreFocus) {
                this.callSuper(ignoreRestoreFocus);
                openModalPanelCount = Math.max(0, openModalPanelCount - 1);
            }
        });
})(myt);


(pkg => {
    const
        spin = spinner => {
            spinner[spinner.visible ? 'addDomClass' : 'removeDomClass']('mytCenterSpin');
        },
        
        /*  Remove the border from the dom element width and height so that the spinner doesn't 
            take up more space that the size. */
        updateSize = spinner => {
            const size = spinner.size,
                ids = spinner.getIDS();
            spinner.setWidth(size);
            spinner.setHeight(size);
            ids.width = ids.height = (size - 2*spinner.borderWidth) + 'px';
        };
    
    /** A spinner that uses the CSS border property and a CSS rotation animation to create the 
        appearance of a spinner.
        
        Events:
            spinColor
        
        Attributes:
            size:number The width and height of the spinner.
            spinColor:color_string The color spinning quarter of the border.
        
        @class */
    pkg.Spinner = new JS.Class('Spinner', pkg.View, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            const self = this;
            
            self.lateAttrs = ['spinColor'];
            
            attrs.visible ??= false;
            attrs.borderWidth ??= 5;
            attrs.borderColor ??= '#fff';
            attrs.borderStyle ??= 'solid';
            attrs.spinColor ??= '#000';
            
            self.callSuper(parent, attrs);
            
            self.getIDS().borderRadius = '50%';
            
            updateSize(self);
            spin(self);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setSize: function(v) {
            if (this.size !== v) {
                this.size = v;
                if (this.inited) updateSize(this);
            }
        },
        
        setSpinColor: function(v) {
            if (this.spinColor !== v) {
                this.getIDS().borderTopColor = this.spinColor = v;
                if (this.inited) this.fireEvent('spinColor', v);
            }
        },
        
        /** @overrides myt.View */
        setBorderWidth: function(v) {
            if (this.borderWidth !== v) {
                this.callSuper(v);
                if (this.inited) updateSize(this);
            }
        },
        
        /** @overrides myt.View */
        setVisible: function(v) {
            if (this.visible !== v) {
                this.callSuper(v);
                if (this.inited) spin(this);
            }
        }
    });
})(myt);


(pkg => {
    const sizeClasses = ['','fa-lg','fa-2x','fa-3x','fa-4x','fa-5x'],
        
        makeTag = props => {
            if (Array.isArray(props)) {
                let len = props.length;
                if (len > 0) {
                    props.unshift('fa');
                    len++;
                    
                    if (!props[1].startsWith('fa-')) props[1] = 'fa-' + props[1];
                    
                    if (len >= 3) props[2] = sizeClasses[props[2]] ?? '';
                    
                    if (len > 3) {
                        for (let i = 3; len > i; i++) {
                            if (!props[i].startsWith('fa-')) props[i] = 'fa-' + props[i];
                        }
                    }
                    
                    return '<i class="' + props.join(' ') + '"></i>';
                }
            }
            
            pkg.dumpStack('Error making tag');
            console.error(props);
            return '';
        },
        
        updateInstance = instance => {
            let props = instance.properties;
            if (props) {
                if (typeof props === 'string') {
                    props = props.split(' ');
                } else {
                    props = props.slice();
                }
            } else {
                props = [];
            }
            props.unshift(instance.icon, instance.size);
            
            instance.setHtml(makeTag(props));
        },
        
        registerForNotification = instance => {
            for (const fontName of ['Free 400', 'Free 900', 'Brands 400']) {
                pkg.registerForFontNotification(instance, 'Font Awesome 5 ' + fontName);
            }
        };
    
    /** An adapter for FontAwesome.
        
        Attributes:
            icon:string - The name of the FA icon to set.
            size:number - A number from 0 to 5 with 0 being normal size and 5 being the largest size.
            propeties:string || array - A space separated string or list of FA CSS classes to set.
        
        @class */
    pkg.FontAwesome = new JS.Class('FontAwesome', pkg.Markup, {
        // Class Methods and Attributes ////////////////////////////////////////
        extend: {
            makeTag: makeTag,
            registerForNotification: registerForNotification
        },
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            this.size = 0;
            this.icon = '';
            
            this.callSuper(parent, attrs);
            
            updateInstance(this);
            registerForNotification(this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setIcon: function(v) {
            const existing = this.icon;
            this.set('icon', v, true);
            if (this.inited && existing !== v) updateInstance(this);
        },
        
        setSize: function(v) {
            const existing = this.size;
            this.set('size', v, true);
            if (this.inited && existing !== v) updateInstance(this);
        },
        
        setProperties: function(v) {
            this.properties = v;
            this.fireEvent('properties', v);
            if (this.inited) updateInstance(this);
        }
    });
    
    pkg.loadCSSFonts(['https://use.fontawesome.com/releases/v5.15.4/css/all.css']);
})(myt);


(pkg => {
    let // ColorPicker
        colorPicker,
        
        isEmpty,
        supportsAlphaChannel,
        currentColorHex,
        
        currentHue = 0,
        currentSaturation = 0,
        currentValue = 0,
        currentOpacity = 255,
        
        selectionPalette = [],
        defaultPalette,
        
        paletteContainer,
        colorView,
        colorThumb,
        hueView,
        hueThumb,
        inputView,
        currentColorButton,
        alphaChannelSlider,
        
        // DatePicker
        datePicker,
        
        localeData,
        dateOnly,
        timeOnly,
        firstDayOfWeek,
        allowedDays,
        minDate,
        maxDate,
        minTime,
        maxTime,
        minuteInterval,
        
        pickedDate,
        
        prevMonthBtn,
        curMonthTxt,
        nextMonthBtn,
        calendarView,
        timeListView;
    
    const JSClass = JS.Class,
        
        {
            View, Text, ModalPanel, SizeToChildren, SpacedLayout, WrappingLayout, SelectionManager, Color, 
            LocalStorage, Button, TextButton, Draggable,
            FontAwesome:{makeTag}
        } = pkg,
        
        {min:mathMin, max:mathMax} = Math,
        
        BORDER_333 = [1, 'solid', '#333'],
        BORDER_999 = [1, 'solid', '#999'],
        BORDER_FFF = [1, 'solid', '#fff'],
        
        /*  Hide spinner related elements. */
        hideSpinner = dialog => {
            if (dialog.spinner) {
                dialog.spinner.setVisible(false);
                dialog.spinner = undefined;
            }
        },
        
        /*  The class used as the default BUTTON_CLASS in myt.Dialog. */
        DialogButton = new JSClass('DialogButton', TextButton, {
            /** @overrides */
            initNode: function(parent, attrs) {
                attrs.height ??= 17;
                attrs.paddingTop ??= 3;
                attrs.paddingLeft ??= 10;
                attrs.paddingRight ??= 10;
                attrs.activeColor ??= '#bbb';
                attrs.hoverColor ??= '#ddd';
                attrs.readyColor ??= '#ccc';
                
                attrs.domClass = 'mytButtonText';
                
                this.callSuper(parent, attrs);
            }
        }),
        
        // ColorPicker
        TRANSPARENT = 'transparent',
        LOCAL_STORAGE_KEY = 'myt.default',
        DOM_CLASS_CHECKERBOARD = 'mytCheckerboardPattern',
        CHECKMARK = makeTag(['check']),
        
        initializePaletteLookup = palette => {
            for (let color of palette) {
                if (color?.length === 7) color += 'ff';
                paletteLookup[color] = true;
            }
        },
        paletteLookup = {},
        
        hsvToHex = (h, s, v) => Color.makeColorFromHSV(h * 360, s * 100, v * 100).getHtmlHexString(),
        
        /** @class */
        Swatch = new JSClass('Swatch', View, {
            include:[Button],
            initNode: function(parent, attrs) {
                const size = attrs.width = attrs.height = 16;
                attrs.border = BORDER_999;
                attrs.domClass = DOM_CLASS_CHECKERBOARD;
                
                const bgColor = attrs.bgColor;
                
                this.callSuper(parent, attrs);
                
                this.colorView = new View(this, {width:size, height:size, bgColor:bgColor});
                
                if (bgColor === currentColorHex) {
                    const color = Color.makeColorFromHexString(currentColorHex);
                    new Text(this, {
                        x:2, y:2, text:CHECKMARK, fontSize:'12px', 
                        textColor:color.red + color.green + color.blue < 3*255/2 ? '#fff' : '#000'
                    });
                }
            },
            setBgColor: function(v) {
                this.colorView?.setBgColor(v);
                this.setTooltip(v);
            },
            doActivated: function() {
                colorPicker.setColor(this.colorView.bgColor);
            },
            drawHoverState: function() {this.setBorder(BORDER_333);},
            drawReadyState: function() {this.setBorder(BORDER_999);}
        }),
        
        /** @class */
        ColorPicker = pkg.ColorPicker = new JSClass('ColorPicker', View, {
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                colorPicker = this;
                colorPicker._isReady = false;
                
                let initialColorHex = attrs.color ?? TRANSPARENT;
                delete attrs.color;
                
                supportsAlphaChannel = attrs.alphaChannel ?? false;
                delete attrs.alphaChannel;
                
                defaultPalette = attrs.palette ?? [];
                initializePaletteLookup(defaultPalette);
                delete attrs.palette;
                
                isEmpty = initialColorHex === TRANSPARENT;
                
                colorPicker.callSuper(parent, attrs);
                
                // Build UI
                paletteContainer = new View(colorPicker, {width:160, height:170});
                new WrappingLayout(paletteContainer, {spacing:4, lineSpacing:4});
                
                const colorViewSize = 139;
                colorView = new View(colorPicker, {x:170, width:colorViewSize, height:colorViewSize, border:BORDER_333}, [Draggable, {
                    requestDragPosition: function(x, y) {
                        colorView.callSuper(colorView.x, colorView.y);
                        const pos = this.getPagePosition();
                        currentSaturation = parseFloat(mathMax(0, mathMin(1, (x + this.dragInitX - pos.x) / this.width)));
                        currentValue = parseFloat(1 - mathMax(0, mathMin(1, (y + this.dragInitY - pos.y) / this.height)));
                        isEmpty = false;
                        colorPicker.updateUI();
                    }
                }]);
                const satView = new View(colorView, {width:colorViewSize, height:colorViewSize}),
                    valView = new View(satView, {width:colorViewSize, height:colorViewSize});
                satView.getIDS().backgroundImage = 'linear-gradient(to right, #fff, rgba(204, 154, 129, 0))';
                valView.getIDS().backgroundImage = 'linear-gradient(to top, #000, rgba(204, 154, 129, 0))';
                colorThumb = new View(valView, {width:6, height:6, bgColor:'#000', border:BORDER_FFF, roundedCorners:4});
                
                hueView = new View(colorPicker, {x:315, y:30, width:24, height:109, border:BORDER_333}, [Draggable, {
                    requestDragPosition: function(x, y) {
                        this.callSuper(hueView.x, hueView.y);
                        currentHue = parseFloat(mathMax(0, mathMin(1, (y + this.dragInitY - this.getPagePosition().y) / this.height)));
                        isEmpty = false;
                        colorPicker.updateUI();
                    }
                }]);
                hueView.getIDS().background = 'linear-gradient(to top, #f00 0%, #f0f 17%, #00f 33%, #0ff 50%, #0f0 67%, #ff0 83%, #f00 100%)';
                hueThumb = new View(hueView, {x:-1, width:24, height:2, bgColor:'#fff', border:[1, 'solid', '#000']});
                
                new View(colorPicker, {
                    x:315, width:24, height:24, border:BORDER_333, tooltip:'Set to transparent.', domClass:DOM_CLASS_CHECKERBOARD
                }, [Button, {doActivated: () => {colorPicker.setColor(TRANSPARENT);}}]);
                
                let y = 146;
                
                // Alpha Channel Row
                if (supportsAlphaChannel) {
                    alphaChannelSlider = new pkg.LabelSlider(colorPicker, {
                        x:170, y:y, width:colorViewSize + 26 + 6,
                        minValue:0, maxValue:255, flipThreshold:55, labelColor:'#fff'
                    }, [{
                        setText: function(event, noAnim) {
                            let v = event.value;
                            
                            if (v == null || isNaN(v)) v = 0;
                            
                            event.value = pkg.formatAsPercentage(v / 255, 0);
                            this.callSuper(event, true);
                            
                            currentOpacity = v;
                            if (colorPicker._isReady) {
                                isEmpty = false;
                                colorPicker.updateUI();
                            }
                        }
                    }]);
                    
                    y += 23;
                }
                
                // Selection Row
                inputView = new pkg.InputText(colorPicker, {
                    x:236, y:y, width:105, height:25, roundedCorners:3, textColor:'#333', border:BORDER_333, maxLength:11,
                    fontFamily:'monospace'
                });
                colorPicker.attachToDom(inputView, '_submitInput', 'blur');
                colorPicker.attachToDom(inputView, '_handleKeyDown', 'keydown');
                inputView.getIDS().paddingLeft = '6px';
                
                const initialColorContainer = new View(colorPicker, {
                    x:170, y:y, width:60, height:23, border:BORDER_333, domClass:DOM_CLASS_CHECKERBOARD
                });
                new View(initialColorContainer, {
                    width:30, height:23, focusIndicator:false,
                    bgColor:initialColorHex
                }, [Button, {doActivated: () => {colorPicker.setColor(initialColorHex);}}]);
                currentColorButton = new View(initialColorContainer, {x:30, width:30, height:23});
                
                // Load Palette
                const savedPalette = LocalStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedPalette) {
                    selectionPalette = savedPalette.split(';');
                    initializePaletteLookup(selectionPalette);
                }
                
                colorPicker.setColor(initialColorHex);
                
                colorPicker._isReady = true;
            },
            
            /** @private */
            _handleKeyDown: event => {
                if (pkg.KeyObservable.isEnterKeyEvent(event)) colorPicker._submitInput();
            },
            
            /** @private */
            _submitInput: () => {
                colorPicker.setColor(inputView.value);
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            addToPalette: hexColor => {
                if (hexColor && hexColor !== TRANSPARENT && !paletteLookup[hexColor]) {
                    selectionPalette.unshift(hexColor);
                    selectionPalette.length = mathMin(selectionPalette.length, 56);
                    LocalStorage.setItem(LOCAL_STORAGE_KEY, selectionPalette.join(';'));
                }
            },
            
            setColor: color => {
                const colorIsNotTransparent = color && color !== TRANSPARENT;
                
                // Extract alpha channel
                if (supportsAlphaChannel) {
                    let alpha = 'ff';
                    if (colorIsNotTransparent && color.length > 7) {
                        alpha = color.slice(7,9);
                        color = color.slice(0,7);
                    }
                    alphaChannelSlider.setValue(parseInt(alpha, 16));
                } else {
                    if (colorIsNotTransparent && color.length > 7) {
                        color = color.slice(0,7);
                    }
                }
                
                if (colorIsNotTransparent) {
                    const newHsv = (Color.makeColorFromHexString(color)).getHSV();
                    currentHue = newHsv.h / 360;
                    currentSaturation = newHsv.s;
                    currentValue = newHsv.v;
                    isEmpty = false;
                } else {
                    isEmpty = true;
                }
                
                colorPicker.updateUI();
            },
            
            getColor: () => {
                if (isEmpty) {
                    return TRANSPARENT;
                } else {
                    let opacityPart = '';
                    if (supportsAlphaChannel) {
                        opacityPart = currentOpacity.toString(16);
                        if (opacityPart.length < 2) opacityPart = '0' + opacityPart;
                    }
                    return hsvToHex(currentHue, currentSaturation, currentValue) + opacityPart;
                }
            },
            
            updateUI: () => {
                const isNotEmpty = !isEmpty;
                hueThumb.setVisible(isNotEmpty);
                colorThumb.setVisible(isNotEmpty);
                if (isNotEmpty) {
                    colorThumb.setX(mathMax(0, mathMin(1, currentSaturation) * (colorView.width + 2)) - 5);
                    colorThumb.setY(mathMax(0, mathMin(1, 1 - currentValue) * (colorView.height + 2)) - 5);
                    hueThumb.setY((currentHue * (hueView.height - 2)) - 1);
                }
                
                colorView.setBgColor(hsvToHex(currentHue, 1, 1));
                
                // Update input
                currentColorHex = colorPicker.getColor();
                inputView.setValue(currentColorHex);
                currentColorButton.setBgColor(currentColorHex);
                
                colorPicker.redrawPalette();
            },
            
            redrawPalette: pkg.debounce(() => {
                paletteContainer.destroyAllSubviews();
                
                const alreadyAdded = new Set();
                defaultPalette.push(...selectionPalette);
                for (let color of defaultPalette) {
                    if (supportsAlphaChannel || color.length === 7) {
                        if (color.length === 7) color += 'ff';
                        if (!alreadyAdded.has(color)) {
                            new Swatch(paletteContainer, {bgColor:color});
                            alreadyAdded.add(color);
                        }
                    }
                }
            }, 50)
        }),
        
        // DatePicker
        clipValue = (value, max) => mathMax(0, mathMin(max, parseInt(value))),
        
        parseTime = timeStr => {
            const parts = timeStr.split(':');
            return [clipValue(parts[0], 23), clipValue(parts[1], 60)];
        },
        
        resetSelectionManager = view => {
            view.deselectAll();
            view.destroyAllSubviews();
        },
        
        SelectableBtn = new JSClass('SelectableBtn', TextButton, {
            include:[pkg.Selectable],
            
            setSelected: function(v) {
                this.callSuper(v);
                this.updateUI();
            },
            
            updateUI: function() {
                this.callSuper();
                
                if (this.isSelected()) {
                    this.setBgColor('#666');
                    this.setTextColor('#fff');
                } else {
                    this.setTextColor();
                }
            }
        }),
        
        /** @class */
        TimeBtn = new JSClass('TimeBtn', SelectableBtn, {
            initNode: function(parent, attrs) {
                attrs.width = timeOnly ? 175 : 49;
                this.callSuper(parent, attrs);
            },
            
            doActivated: function() {
                this.callSuper();
                const value = this.text,
                    timeParts = parseTime(value);
                timeListView.selectById(value);
                pickedDate.setHours(timeParts[0]);
                pickedDate.setMinutes(timeParts[1]);
            }
        }),
        
        /** @class */
        DayBtn = new JSClass('DayBtn', SelectableBtn, {
            initNode: function(parent, attrs) {
                attrs.width = 23;
                attrs.border = BORDER_FFF;
                this.callSuper(parent, attrs);
            },
            
            setData: function(v) {this.data = v;},
            
            setIsAnotherMonth: function(v) {this.isAnotherMonth = v;},
            setIsToday: function(v) {this.isToday = v;},
            setIsSunday: function(v) {this.isSunday = v;},
            setIsSaturday: function(v) {this.isSaturday = v;},
            
            updateUI: function() {
                if (!this.destroyed) {
                    this.callSuper();
                    
                    if (!this.isSelected()) this.setTextColor(this.isAnotherMonth ? '#ccc' : (this.isSunday ? '#d40' : (this.isSaturday ? '#04a' : null)));
                    this.setBorderColor(this.isToday ? '#090' : '#fff');
                }
            },
            
            doActivated: function() {
                this.callSuper();
                const targetDate = new Date(this.data);
                targetDate.setHours(pickedDate.getHours());
                targetDate.setMinutes(pickedDate.getMinutes());
                drawForDate(targetDate);
            }
        }),
        
        drawForDate = date => {
            date.setSeconds(0);
            date.setMilliseconds(0);
            
            // Prevent selection of disallowed days of the week
            const hasDisallowedDays = allowedDays.length <= 6;
            let i;
            if (hasDisallowedDays) {
                i = 7;
                while (i--) {
                    if (allowedDays.includes(date.getDay())) {
                        break;
                    } else {
                        date.setDate(date.getDate() + 1);
                    }
                }
            }
            
            // Save new date to Picker data
            pickedDate = date;
            
            // Calculate dates
            const timeListScrollTop = timeListView.getODE().scrollTop,
                todayDateObj = new Date(),
                todayFullYear = todayDateObj.getFullYear(),
                todayMonth = todayDateObj.getMonth(),
                todayDate = todayDateObj.getDate(),
                todayHours = todayDateObj.getHours(),
                todayMinutes = todayDateObj.getMinutes(),
                dateFullYear = date.getFullYear(),
                dateMonth = date.getMonth(),
                dateDate = date.getDate(),
                dateTime = date.getTime(),
                dateHours = date.getHours(),
                dateMinutes = date.getMinutes(),
                firstWday = new Date(dateFullYear, dateMonth, 1).getDay() - firstDayOfWeek,
                lastDay = new Date(dateFullYear, dateMonth + 1, 0).getDate(),
                beforeMonthLastDay = new Date(dateFullYear, dateMonth, 0).getDate(),
                dateBeforeMonth = new Date(dateFullYear, dateMonth, 0),
                dateNextMonth = new Date(dateFullYear, dateMonth + 2, 0),
                isCurrentYear = todayFullYear == dateFullYear,
                isCurrentMonth = isCurrentYear && todayMonth == dateMonth,
                isCurrentDay = isCurrentMonth && todayDate == dateDate,
                isPastMonth = dateFullYear < todayFullYear || (isCurrentYear && dateMonth < todayMonth);
            
            let realDayObj;
            if (!timeOnly) {
                resetSelectionManager(calendarView);
                
                // Header
                const cDate = new Date(dateTime),
                    firstDayDiff = 7 + firstDayOfWeek,
                    daysOfWeek = localeData['days'];
                curMonthTxt.setText(dateFullYear + ' ' + localeData['sep'] + ' ' + localeData['months'][dateMonth]);
                cDate.setMinutes(59);
                cDate.setHours(23);
                cDate.setSeconds(59);
                cDate.setDate(0); // last day of previous month
                prevMonthBtn.setVisible(minDate == null || minDate < cDate.getTime());
                cDate.setMinutes(0);
                cDate.setHours(0);
                cDate.setSeconds(0);
                cDate.setDate(1); // First day of next month
                cDate.setMonth(dateMonth + 1);
                nextMonthBtn.setVisible(maxDate == null || maxDate > cDate.getTime());
                
                // Column Headers
                for (i = 0; i < 7; i++) {
                    new Text(calendarView, {
                        width:23, height:20, textAlign:'center',
                        text:daysOfWeek[(i + firstDayDiff) % 7],
                        textColor:'#999'
                    });
                }
                
                // Days
                i = 0;
                let cellNum = 42;
                if (firstWday < 0) {
                    i = -7;
                    cellNum = 35;
                }
                
                realDayObj = new Date(dateTime);
                realDayObj.setHours(0);
                realDayObj.setMinutes(0);
                realDayObj.setSeconds(0);
                for (; i < cellNum; i++) {
                    const realDay = i + 1 - firstWday,
                        wday = (i + firstDayDiff) % 7,
                        dayCell = new DayBtn(calendarView);
                    
                    if (firstWday > i) {
                        // Prev month days
                        dayCell.setText(beforeMonthLastDay + realDay);
                        dayCell.setData(dateBeforeMonth.getFullYear() + '/' + (dateBeforeMonth.getMonth() + 1) + '/' + (beforeMonthLastDay + realDay));
                        dayCell.setIsAnotherMonth(true);
                        realDayObj.setDate(beforeMonthLastDay + realDay);
                        realDayObj.setMonth(dateBeforeMonth.getMonth());
                        realDayObj.setYear(dateBeforeMonth.getFullYear());
                    } else if (i < firstWday + lastDay) {
                        // Current month days
                        dayCell.setText(realDay);
                        dayCell.setData((dateFullYear) + '/' + (dateMonth + 1) + '/' + realDay);
                        realDayObj.setDate(realDay);
                        realDayObj.setMonth(dateMonth);
                        realDayObj.setYear(dateFullYear);
                    } else {
                        // Next month days
                        dayCell.setText(realDay - lastDay);
                        dayCell.setData(dateNextMonth.getFullYear() + '/' + (dateNextMonth.getMonth() + 1) + '/' + (realDay - lastDay));
                        dayCell.setIsAnotherMonth(true);
                        realDayObj.setDate(realDay - lastDay);
                        realDayObj.setMonth(dateNextMonth.getMonth());
                        realDayObj.setYear(dateNextMonth.getFullYear());
                    }
                    
                    if (hasDisallowedDays && !allowedDays.includes(wday)) {
                        dayCell.setDisabled(true);
                    } else {
                        if (wday === 0) {
                            dayCell.setIsSunday(true);
                        } else if (wday === 6) {
                            dayCell.setIsSaturday(true);
                        }
                        
                        // Set active and today indication
                        if (realDay === dateDate) {
                            calendarView.select(dayCell);
                            dayCell.focus();
                        }
                        if (isCurrentMonth && realDay === todayDate) dayCell.setIsToday(true);
                        
                        const realDayObjMin =  new Date(realDayObj.getTime());
                        realDayObjMin.setHours(23);
                        realDayObjMin.setMinutes(59);
                        realDayObjMin.setSeconds(59);
                        if (
                            (minDate != null && (minDate > realDayObjMin.getTime())) || (maxDate != null && (maxDate < realDayObj.getTime()))
                        ) {
                            dayCell.setDisabled(true);
                        }
                    }
                    dayCell.updateUI();
                }
            }
            
            if (!dateOnly) {
                const maxTimeInMinutes = maxTime[0] * 60 + maxTime[1];
                
                resetSelectionManager(timeListView);
                
                let [hours, minutes] = minTime;
                realDayObj = new Date(dateTime);
                while (hours * 60 + minutes < maxTimeInMinutes) {
                    const is_past_time = hours < todayHours || (hours == todayHours && minutes < todayMinutes),
                        is_past = isCurrentDay && is_past_time,
                        timeCell = new TimeBtn(timeListView, {
                            text:('0' + hours).slice(-2) + ':' + ('0' + minutes).slice(-2)
                        });
                    if (hours === dateHours && minutes === dateMinutes) timeListView.select(timeCell);
                    
                    realDayObj.setHours(hours);
                    realDayObj.setMinutes(minutes);
                    const realDayObjTime = realDayObj.getTime();
                    if ((minDate != null && (minDate > realDayObjTime)) || (maxDate != null && (maxDate < realDayObjTime))) timeCell.setDisabled(true);
                    
                    minutes += minuteInterval;
                    if (minutes >= 60) {
                        minutes -= 60;
                        hours++;
                    }
                }
                
                // Restore the scroll position
                timeListView.scrollYTo(timeListScrollTop);
            }
        },
        
        /** @class */
        DatePicker = pkg.DatePicker = new JSClass('DatePicker', View, {
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                datePicker = this;
                
                const opt = {
                    current:null,
                    dateOnly:false,
                    timeOnly:false,
                    locales:null,
                    locale:'',
                    minuteInterval:30,
                    firstDayOfWeek:0,
                    showTodayButton:true,
                    minDate:null,
                    maxDate:null,
                    minTime:'00:00',
                    maxTime:'23:59',
                    allowedDays:null, // An array of day nums: [1,2,3,4,5] for week days only.
                    ...attrs.opt
                };
                delete attrs.opt;
                
                datePicker.callSuper(parent, attrs);
                
                localeData = opt.locales[opt.locale ?? 'en'];
                dateOnly = opt.dateOnly;
                timeOnly = opt.timeOnly;
                firstDayOfWeek = opt.firstDayOfWeek;
                minuteInterval = mathMax(5, mathMin(30, opt.minuteInterval));
                
                allowedDays = opt.allowedDays;
                if (!Array.isArray(allowedDays) || allowedDays.length === 0) allowedDays = [0,1,2,3,4,5,6];
                
                minDate = Date.parse(opt.minDate);
                minDate = isNaN(minDate) ? null : minDate;
                maxDate = Date.parse(opt.maxDate);
                maxDate = isNaN(maxDate) ? null : maxDate;
                
                minTime = parseTime(opt.minTime);
                maxTime = parseTime(opt.maxTime);
                
                // Build UI
                const headerView = new View(datePicker, {visible:!timeOnly});
                if (opt.showTodayButton) {
                    new TextButton(headerView, {width:24, text:makeTag(['home']), tooltip:localeData['today']}, [{
                        doActivated: () => {
                            drawForDate(new Date());
                        }
                    }]);
                }
                prevMonthBtn = new TextButton(headerView, {width:24, x:28, text:makeTag(['chevron-left']), tooltip:localeData['prevMonth']}, [{
                    doActivated: () => {
                        const targetMonth_lastDay = new Date(pickedDate.getFullYear(), pickedDate.getMonth(), 0).getDate();
                        if (targetMonth_lastDay < pickedDate.getDate()) pickedDate.setDate(targetMonth_lastDay);
                        
                        pickedDate.setMonth(pickedDate.getMonth() - 1);
                        drawForDate(pickedDate);
                        prevMonthBtn.focus();
                    }
                }]);
                curMonthTxt = new Text(headerView, {width:100, x:52, textAlign:'center'});
                nextMonthBtn = new TextButton(headerView, {width:24, x:152, text:makeTag(['chevron-right']), tooltip:localeData['nextMonth']}, [{
                    doActivated: () => {
                        const targetMonth_lastDay = new Date(pickedDate.getFullYear(), pickedDate.getMonth() + 1, 0).getDate();
                        if (targetMonth_lastDay < pickedDate.getDate()) pickedDate.setDate(targetMonth_lastDay);
                        
                        // Check a last date of a next month
                        const lastDate = (new Date(pickedDate.getFullYear(), pickedDate.getMonth() + 2, 0)).getDate();
                        if (lastDate < pickedDate.getDate()) pickedDate.setDate(lastDate);
                        
                        pickedDate.setMonth(pickedDate.getMonth() + 1);
                        drawForDate(pickedDate);
                        nextMonthBtn.focus();
                    }
                }]);
                
                calendarView = new View(datePicker, {
                    y:25, width:175, height:175,
                    visible:!timeOnly,
                    maxSelected:1,
                    itemSelectionId:'data'
                }, [SelectionManager]);
                new WrappingLayout(calendarView, {spacing:2, lineInset:2, lineSpacing:3});
                
                timeListView = new View(datePicker, {
                    x:timeOnly ? 0 : 195,
                    y:timeOnly ? 0 : 25,
                    width:(timeOnly ? 175 : 49) + pkg.DomElementProxy.getScrollbarSize(),
                    height:timeOnly ? 200 : 175,
                    overflow:'autoy',
                    visible:!dateOnly,
                    maxSelected:1,
                    itemSelectionId:'text'
                }, [SelectionManager]);
                new SpacedLayout(timeListView, {axis:'y', inset:1, spacing:3});
                
                datePicker.setWidth(timeListView.visible ? timeListView.x + timeListView.width : calendarView.width);
                
                drawForDate(opt.current ?? new Date());
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            getPickedDate: () => pickedDate
        }),
        
        /** A modal panel that contains a Dialog.
            
            Attributes:
                callbackFunction:function (read only) A function that gets called when the dialog 
                    is about to be closed. A single argument is passed in that indicates the UI 
                    element interacted with that should close the dialog. Supported values are: 
                    'closeBtn', 'cancelBtn' and 'confirmBtn'. The function should return true if 
                    the close should be aborted.
            
            @class */
        Dialog = pkg.Dialog = new JSClass('Dialog', ModalPanel, {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** The default corner radius. */
                RADIUS: 12,
                
                /** The default button class. */
                BUTTON_CLASS: DialogButton,
                
                /** The default box shadow. */
                SHADOW: [0, 4, 20, '#666'],
                
                /** The default border */
                BORDER: BORDER_FFF,
                
                /** The default background color. */
                BGCOLOR: '#fff',
                
                /** Makes the text wrap at 200px and the dialog will be at least 200px wide. */
                WRAP_TEXT_DEFAULTS: {
                    width:200,
                    fontWeight:'bold',
                    whiteSpace:'normal',
                    wordWrap:'break-word'
                },
                
                /** Makes the text stay on a single line and the dialog sizes to fit. */
                NO_WRAP_TEXT_DEFAULTS: {
                    width:'auto',
                    fontWeight:'bold',
                    whiteSpace:'nowrap',
                    wordWrap:'break-word'
                },
                
                /** Defaults used in a confirm dialog. */
                CONFIRM_DEFAULTS: {
                    cancelTxt:'Cancel',
                    confirmTxt:'Confirm',
                    maxContainerHeight:300,
                    showClose:false
                },
                
                /** Defaults used in a color picker dialog. */
                COLOR_PICKER_DEFAULTS: {
                    cancelTxt:'Cancel',
                    confirmTxt:'Choose',
                    titleText:'Choose a Color',
                    color:'#000000',
                    alphaChannel:false
                },
                
                /** Defaults used in a date picker dialog. */
                DATE_PICKER_DEFAULTS: {
                    cancelTxt:'Cancel',
                    confirmTxt:'Choose',
                    titleText:'Choose a Date',
                    timeOnlyTitleText:'Choose a Time',
                    color:'#000',
                    locales:{
                        en: {
                            days: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
                            months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                            sep: '-',
                            prevMonth: 'Previous month',
                            nextMonth: 'Next month',
                            today: 'Today'
                        }
                    },
                    locale:'en'
                }
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                attrs.buttonClass ??= Dialog.BUTTON_CLASS;
                
                this.callSuper(parent, attrs);
                
                const content = this.content;
                content.setRoundedCorners(Dialog.RADIUS);
                content.setBgColor(Dialog.BGCOLOR);
                content.setBoxShadow(Dialog.SHADOW);
                content.setBorder(Dialog.BORDER);
                content.setFocusCage(true);
                
                this.makeCloseButton(content);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setButtonClass: function(v) {this.buttonClass = v;},
            setCallbackFunction: function(v) {this.callbackFunction = v;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Make a standard button for a Dialog.
                @param {!Object} btnContainer - The myt.View to create the button on.
                @param {!Object} attrs - The attributes for the new button.
                @returns {!Object} - The created button.*/
            makeButton: function(btnContainer, attrs) {
                const self = this;
                return new self.buttonClass(btnContainer, attrs, [{
                    doActivated: function() {self.doCallback(this);}
                }]);
            },
            
            /** Creates a close button on the provided targetView.
                @param {!Object} targetView - The myt.View to create the button on.
                @returns {!Object} - The created myt.Button. */
            makeCloseButton: function(targetView) {
                return targetView.closeBtn = this.makeButton(targetView, {
                    ignoreLayout:true,
                    y:2,
                    align:'right',
                    alignOffset:2,
                    width:19,
                    height:16,
                    paddingLeft:0,
                    paddingRight:0,
                    roundedCorners:10,
                    activeColor:'#c00',
                    hoverColor:'#f33',
                    readyColor:'#f00',
                    textColor:'#fff',
                    text:makeTag(['times']),
                    tooltip:'Close Dialog.',
                });
            },
            
            /** @overrides myt.Dimmer */
            hide: function(ignoreRestoreFocus) {
                hideSpinner(this);
                
                this.callSuper(ignoreRestoreFocus);
            },
            
            /** Called before a dialog is shown to reset state and cleanup UI elements from the 
                previous display of the Dialog.
                @returns {undefined} */
            destroyContent: function() {
                hideSpinner(this);
                
                const content = this.content, 
                    stc = content.sizeToChildren;
                
                // Destroy all children except the close button since that gets reused.
                content.destroyAllSubviews(sv => sv.name !== 'closeBtn');
                
                // The blank dialog sets this.
                content.setVisible(true);
                this.overlay.setBgColor(pkg.Dimmer.COLOR);
                
                // Message and Confirm dialogs set this.
                this.setCallbackFunction();
                
                // The confirm dialog modifies this.
                stc.setPaddingY(ModalPanel.PADDING_Y);
                
                // The confirm content dialog modifies this.
                stc.setPaddingX(ModalPanel.PADDING_X);
                
                // Any opts could modify this
                content.setRoundedCorners(Dialog.RADIUS);
                content.setBgColor(Dialog.BGCOLOR);
                content.setBoxShadow(Dialog.SHADOW);
                content.setBorder(Dialog.BORDER);
            },
            
            /** Called by each of the buttons that can trigger the dialog to be hidden.
                @param {!Object} sourceView - The myt.View that triggered the hiding of the dialog.
                @returns {undefined} */
            doCallback: function(sourceView) {
                const cbf = this.callbackFunction;
                if (!cbf || !cbf.call(this, sourceView.name)) this.hide();
            },
            
            /** Shows this dialog as a regular dimmer.
                @param {?Object} opts - If opts.bgColor is provided it will be used for the bgColor 
                    of the overlay.
                @returns {undefined} */
            showBlank: function(opts) {
                this.destroyContent();
                
                this.content.setVisible(false);
                if (opts?.bgColor) this.overlay.setBgColor(opts.bgColor);
                
                this.show();
            },
            
            /** Shows a dialog with a message and the standard cancel button.
                @param {string} msg - The message to show.
                @param {?Function} [callbackFunction] - A function that gets called when the close 
                    button is activated. A single argument is passed in that indicates the UI 
                    element interacted with that should close the dialog. Supported values are: 
                    'closeBtn', 'cancelBtn' and 'confirmBtn'. The function should return true if 
                    the close should be aborted.
                @param {?Object} [opts] - Options that modify how the message is displayed. 
                    Supports: fontWeight, whiteSpace, wordWrap and width.
                @returns {undefined} */
            showMessage: function(msg, callbackFunction, opts) {
                const self = this,
                    content = self.content, 
                    closeBtn = content.closeBtn;
                
                opts = {...Dialog.WRAP_TEXT_DEFAULTS, ...opts};
                
                self.destroyContent();
                
                self.setCallbackFunction(callbackFunction);
                
                const msgView = content.msg = new Text(content, {
                    text:msg,
                    whiteSpace:opts.whiteSpace,
                    wordWrap:opts.wordWrap,
                    fontWeight:opts.fontWeight,
                    x:opts.msgX == null ? ModalPanel.PADDING_X : opts.msgX,
                    y:opts.msgY == null ? ModalPanel.PADDING_Y : opts.msgY,
                    width:opts.width
                });
                
                if (opts.titleText) {
                    self.setupTitle(content, opts.titleText);
                    msgView.setY(msgView.y + 24);
                }
                
                self.show();
                
                if (opts.showClose === false) {
                    closeBtn.setVisible(false);
                } else {
                    closeBtn.setVisible(true);
                    closeBtn.focus();
                }
            },
            
            showSimple: function(contentBuilderFunc, callbackFunction, opts, afterSetupFunc) {
                opts = opts ?? {};
                
                const self = this,
                    content = self.content,
                    closeBtn = content.closeBtn,
                    maxHeight = opts.maxContainerHeight;
                
                self.destroyContent();
                
                if (opts.bgColor) content.setBgColor(opts.bgColor);
                if (opts.roundedCorners) content.setRoundedCorners(opts.roundedCorners);
                if (opts.boxShadow) content.setBoxShadow(opts.boxShadow);
                if (opts.border) content.setBorder(opts.border);
                
                content.sizeToChildren.setPaddingX(1);
                self.setCallbackFunction(callbackFunction);
                
                const contentContainer = content.contentContainer = new View(content, {
                    x:1, y:25, overflow:'auto'
                }, [{
                    setHeight: function(v) {
                        if (v > maxHeight) v = maxHeight;
                        this.callSuper(v);
                    }
                }]);
                
                contentBuilderFunc.call(self, contentContainer);
                
                new SizeToChildren(contentContainer, {axis:'both'});
                
                self.show();
                
                closeBtn.setVisible(true);
                closeBtn.focus();
                
                if (opts.titleText) {
                    self.setupTitle(content, opts.titleText);
                    contentContainer.setY(self.header.height + 1);
                }
                
                // Set initial focus
                contentContainer.initialFocus?.focus();
                
                afterSetupFunc?.(self);
            },
            
            showConfirm: function(msg, callbackFunction, opts) {
                const self = this;
                
                opts = {...Dialog.CONFIRM_DEFAULTS, ...opts};
                
                self.showMessage(msg, callbackFunction, opts);
                self.setupFooterButtons(self.content.msg, opts);
            },
            
            showContentConfirm: function(contentBuilderFunc, callbackFunction, opts, afterSetupFunc) {
                opts = {...Dialog.CONFIRM_DEFAULTS, ...opts};
                
                const self = this,
                    content = self.content,
                    closeBtn = content.closeBtn,
                    maxHeight = opts.maxContainerHeight;
                
                self.destroyContent();
                
                content.sizeToChildren.setPaddingX(1);
                self.setCallbackFunction(callbackFunction);
                
                // Setup form
                const contentContainer = content.contentContainer = new View(content, {
                    x:1, y:25, overflow:'auto'
                }, [{
                    setHeight: function(v) {
                        this.callSuper(v > maxHeight ? maxHeight : v);
                    }
                }]);
                
                contentBuilderFunc.call(self, contentContainer);
                
                new SizeToChildren(contentContainer, {axis:'both'});
                
                self.show();
                
                closeBtn.setVisible(true);
                closeBtn.focus();
                
                self.setupTitle(content, opts.titleText);
                contentContainer.setY(self.header.height + 1);
                self.setupFooterButtons(contentContainer, opts);
                
                // Set initial focus
                contentContainer.initialFocus?.focus();
                
                afterSetupFunc?.(self);
            },
            
            /** Shows a dialog with a spinner and a message and no standard cancel button.
                @param {string} msg - the message to show.
                @param {?Objecft} opts - Options that modify how the message is displayed. 
                    Supports: fontWeight, whiteSpace, wordWrap and width.
                @returns {undefined} */
            showSpinner: function(msg, opts) {
                const self = this,
                    content = self.content;
                
                opts = {...Dialog.NO_WRAP_TEXT_DEFAULTS, ...opts};
                
                self.destroyContent();
                
                const spinner = self.spinner = new pkg.Spinner(content, {
                    align:'center', visible:true,
                    borderColor:'#ccc',
                    size:50, y:opts.msgY == null ? ModalPanel.PADDING_Y : opts.msgY,
                });
                if (msg) {
                    new Text(content, {
                        text:msg,
                        whiteSpace:opts.whiteSpace,
                        wordWrap:opts.wordWrap,
                        fontWeight:opts.fontWeight,
                        x:opts.msgX == null ? ModalPanel.PADDING_X : opts.msgX,
                        y:spinner.y + spinner.size + ModalPanel.PADDING_Y,
                        width:opts.width
                    });
                }
                
                self.show();
                
                content.closeBtn.setVisible(false);
                
                // Focus on the dimmer itself to prevent user interaction.
                self.focus();
            },
            
            showColorPicker: function(callbackFunction, opts) {
                const self = this,
                    content = self.content,
                    closeBtn = content.closeBtn;
                opts = {...Dialog.COLOR_PICKER_DEFAULTS, ...opts};
                self.destroyContent();
                
                // Set the callback function to one wrapped to handle each button type.
                self.setCallbackFunction(action => {
                    switch (action) {
                        case 'closeBtn':
                        case 'cancelBtn':
                            callbackFunction.call(self, action);
                            break;
                        case 'confirmBtn':
                            const colorAsHex = colorPicker.getColor();
                            colorPicker.addToPalette(colorAsHex);
                            callbackFunction.call(self, action, colorAsHex);
                            break;
                    }
                    colorPicker.destroy();
                });
                
                // Build Picker
                colorPicker = new ColorPicker(content, {
                    x:ModalPanel.PADDING_X,
                    y:ModalPanel.PADDING_Y + 24,
                    width:337,
                    height:177 + (opts.alphaChannel ? 23 : 0),
                    color:opts.color,
                    alphaChannel:opts.alphaChannel,
                    palette:['#000000','#111111','#222222','#333333','#444444','#555555','#666666','#777777','#888888','#999999','#aaaaaa','#bbbbbb','#cccccc','#dddddd','#eeeeee','#ffffff']
                });
                self.show();
                closeBtn.setVisible(true);
                closeBtn.focus();
                self.setupFooterButtons(colorPicker, opts);
                self.setupTitle(content, opts.titleText);
            },
            
            showDatePicker: function(callbackFunction, opts) {
                const self = this,
                    content = self.content,
                    closeBtn = content.closeBtn;
                opts = {...Dialog.DATE_PICKER_DEFAULTS, ...opts};
                self.destroyContent();
                
                // Set the callback function to one wrapped to handle each button type.
                self.setCallbackFunction(action => {
                    switch (action) {
                        case 'closeBtn':
                        case 'cancelBtn':
                            callbackFunction.call(self, action);
                            break;
                        case 'confirmBtn':
                            callbackFunction.call(self, action, datePicker.getPickedDate());
                            break;
                    }
                    datePicker.destroy();
                });
                
                // Build Picker
                datePicker= new DatePicker(content, {
                    x:ModalPanel.PADDING_X,
                    y:ModalPanel.PADDING_Y + 24,
                    height:195,
                    opt: {
                        current:new Date(opts.initialDate ?? Date.now()),
                        dateOnly:opts.dateOnly || false,
                        timeOnly:opts.timeOnly || false,
                        locales:opts.locales,
                        locale:opts.locale
                    }
                });
                self.show();
                closeBtn.setVisible(true);
                closeBtn.focus();
                self.setupFooterButtons(datePicker, opts);
                self.setupTitle(content, opts.timeOnly ? opts.timeOnlyTitleText : opts.titleText);
            },
            
            setupTitle: function(content, titleTxt) {
                const radius = Dialog.RADIUS;
                (this.header = new View(content, {
                    ignoreLayout:true,
                    width:content.width,
                    height:24,
                    bgColor:'#eee',
                    roundedTopLeftCorner:radius,
                    roundedTopRightCorner:radius
                })).sendToBack();
                content.title = new Text(content, {x:radius, y:4, text:titleTxt, fontWeight:'bold'});
            },
            
            /** @private 
                @param {!Object} mainView
                @param {!Object} opts
                @returns {undefined} */
            setupFooterButtons: function(mainView, opts) {
                const self = this,
                    content = self.content, 
                    DPY = ModalPanel.PADDING_Y,
                    HALF_DPY = DPY / 2,
                    btnContainer = content.btnContainer = new View(content, {y:mainView.y + mainView.height + DPY, align:'center'}),
                    btnConfigKeys = ['active','hover','ready','text'];
                
                // Cancel Button
                let attrs = opts.cancelAttrs ?? {};
                attrs.name ??= 'cancelBtn';
                attrs.text ??= opts.cancelTxt;
                for (let key of btnConfigKeys) {
                    key += 'Color';
                    if (opts[key] != null) attrs[key] = opts[key];
                }
                const cancelBtn = self.makeButton(btnContainer, attrs);
                
                // Confirm Button
                attrs = opts.confirmAttrs ?? {};
                attrs.name ??= 'confirmBtn';
                attrs.text ??= opts.confirmTxt;
                for (let key of btnConfigKeys) {
                    key += 'Color';
                    const optsKey = key + 'Confirm';
                    if (opts[optsKey] != null) attrs[key] = opts[optsKey];
                }
                self.makeButton(btnContainer, attrs);
                
                // Additional Buttons
                const buttons = opts.button;
                if (buttons) {
                    for (const buttonAttrs of buttons) {
                        self.makeButton(btnContainer, buttonAttrs);
                    }
                }
                
                new SizeToChildren(btnContainer, {axis:'y'});
                new SpacedLayout(btnContainer, {spacing:4, collapseParent:true});
                
                content.sizeToChildren.setPaddingY(HALF_DPY);
                
                const bgY = btnContainer.y - HALF_DPY;
                (new View(content, {
                    ignoreLayout:true,
                    y:bgY,
                    width:content.width,
                    height:content.height - bgY,
                    bgColor:'#eee'
                })).sendToBack();
                
                if (opts.showClose === false) cancelBtn.focus();
            }
        });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        dumpStack = pkg.dumpStack,
        
        // Safe as a closure variable because the registry is a singleton.,
        validators = {},
        
        getValidator = id => validators[id],
        
        doFuncOnIdentifiable = (identifiable, func) => {
            if (identifiable) {
                const id = identifiable.id;
                if (identifiable.id) {
                    func(id);
                } else {
                    dumpStack('No ID');
                }
            } else {
                dumpStack('No validator');
            }
        },
        
        register = identifiable => {
            doFuncOnIdentifiable(identifiable, id => {validators[id] = identifiable;});
        },
        
        /** Tests if a value is "valid" or not.
            
            Attributes:
                id:string the ideally unique ID for this Validator so it can be stored and 
                    retreived from the myt.global.validators registry.
            
            @class */
        Validator = pkg.Validator = new JSClass('Validator', {
            /** Creates a new Validator
                @param {string} id - The ideally unique ID for a validator instance. */
            initialize: function(id) {
                this.id = id;
            },
            
            /** Tests if the value is valid or not.
                @param {*} value - The value to test validity for.
                @param {?Object} [config] - A map of configuration values that can be used to 
                    augment the validation function as needed. The nature of this config will be 
                    specific to each Validator class.
                @param {?Array} [errorMessages] - Any error messages arising during validation will 
                    be pushed onto thiis array if it is provided.
                @returns {boolean} true if the value is valid, false otherwise. */
            isValid: (value, config, errorMessages) => true,
            
            /** Tests if the form is valid or not.
                @param {!Object} form - The myt.Form to test validity for.
                @param {?Object} [config] - A map of configuration values that can be used to 
                    augment the validation function as needed. The nature of this config will be 
                    specific to each Validator class.
                @param {?Array} [errorMessages] - Any error messages arising during validation will 
                    be pushed onto thiis array if it is provided.
                @returns {boolean} true if the form is valid, false otherwise. */
            isFormValid: function(form, config, errorMessages) {
                config ??= {};
                config.form = form;
                return this.isValid(form.getValue(), config, errorMessages);
            }
        }),
        
        /** Tests that a value is not null, undefined or empty.
            
            @class */
        RequiredFieldValidator = pkg.RequiredFieldValidator = new JSClass('RequiredFieldValidator', Validator, {
            /** @overrides myt.Validator */
            isValid: (value, config, errorMessages) => {
                if (value == null || value === '' || (typeof value === 'string' && value.trim() === '')) {
                    errorMessages?.push('This value is required.');
                    return false;
                }
                
                return true;
            }
        }),
        
        /** Tests that the value differs from the form rollback value by more than just case.
            
            @class */
        EqualsIgnoreCaseValidator = pkg.EqualsIgnoreCaseValidator = new JSClass('EqualsIgnoreCaseValidator', Validator, {
            /** @overrides myt.Validator */
            isValid: (value, config, errorMessages) => {
                const rbv = config.form.getRollbackValue();
                if (value && rbv && value.toLowerCase() === rbv.toLowerCase()) {
                    errorMessages?.push('Value must differ by more than just case.');
                    return false;
                }
                
                return true;
            }
        }),
        
        /** Verifies that a value is in the form of a URL.
        
            @class */
        URLValidator = pkg.URLValidator = new JSClass('URLValidator', Validator, {
            /** @overrides myt.Validator
                @param {string} id
                @param originalRawQuery:boolean if true this prevents the query from 
                    being normalized. */
            initialize: function(id, originalRawQuery) {
                this.callSuper(id);
                this.originalRawQuery = originalRawQuery;
            },
            
            /** @overrides myt.Validator */
            isValid: function(value, config, errorMessages) {
                const uri = new pkg.URI(value);
                if (uri.toString(this.originalRawQuery) !== value) {
                    errorMessages?.push('Invalid URL.');
                    return false;
                }
                return true;
            }
        }),
        
        /** Verifies that a value is JSON.
        
            @class */
        JSONValidator = pkg.JSONValidator = new JSClass('JSONValidator', Validator, {
            /** @overrides myt.Validator */
            isValid: (value, config, errorMessages) => {
                try {
                    JSON.parse(value);
                    return true;
                } catch(e) {
                    errorMessages?.push(e);
                    return false;
                }
            }
        });
    
    /** Tests that the value from two fields are equal.
        
        @class */
    pkg.EqualFieldsValidator = new JSClass('EqualFieldsValidator', Validator, {
        /** @overrides myt.Validator
            @param {string} id
            @param fieldA the first form field to compare.
            @param fieldB the second form field to compare. */
        initialize: function(id, fieldA, fieldB) {
            this.callSuper(id);
            
            this.fieldA = fieldA;
            this.fieldB = fieldB;
        },
        
        /** @overrides myt.Validator */
        isValid: function(value, config, errorMessages) {
            if (value && this.fieldA.getValue() === this.fieldB.getValue()) return true;
            
            errorMessages?.push('The field "' + this.fieldA.key + '" must be equal to the field "' + this.fieldB.key + '".');
            return false;
        }
    });
    
    /** Tests that the value has a length between a min and max value.
        
        @class */
    pkg.LengthValidator = new JSClass('LengthValidator', Validator, {
        /** @overrides myt.Validator
            @param {string} id
            @param {number} min - The minimum length value.
            @param {number} max - The maximum length value. */
        initialize: function(id, min, max) {
            this.callSuper(id);
            
            this.min = min;
            this.max = max;
        },
        
        /** @overrides myt.Validator */
        isValid: function(value, config, errorMessages) {
            const len = value ? value.length : 0,
                min = this.min,
                max = this.max;
            
            // Test min
            if (min !== undefined && min > len) {
                errorMessages?.push('The value must not be less than ' + min + ' characters long.');
                return false;
            }
            
            // Test max
            if (max !== undefined && max < len) {
                errorMessages?.push('The value must not be greater than ' + max + ' characters long.');
                return false;
            }
            
            return true;
        }
    });
    
    /** Tests that a value is between a min and max value.
        
        @class */
    pkg.NumericRangeValidator = new JSClass('NumericRangeValidator', Validator, {
        /** @overrides myt.Validator
            @param {string} id
            @param {number} min - The minimum value.
            @param {number} max - The maximum value. */
        initialize: function(id, min, max) {
            this.callSuper(id);
            
            this.min = min;
            this.max = max;
        },
        
        /** @overrides myt.Validator */
        isValid: function(value, config, errorMessages) {
            // Treat empty values as valid
            if (value === '') return true;
            
            // Must be a number
            const numericValue = Number(value),
                min = this.min,
                max = this.max;
            if (isNaN(numericValue)) {
                errorMessages?.push('Value is not a number.');
                return false;
            }
            
            // Test min
            if (min !== undefined && min > numericValue) {
                errorMessages?.push('Value must not be less than ' + min + '.');
                return false;
            }
            
            // Test max
            if (max !== undefined && max < numericValue) {
                errorMessages?.push('Value must not be greater than ' + max + '.');
                return false;
            }
            
            return true;
        }
    });
    
    /** A Validator composed from multiple Validators.
        
        Private Attributes:
            __v:array The array of myt.Validators that compose this Validator.
        
        @class */
    pkg.CompoundValidator = new JSClass('CompoundValidator', Validator, {
        // Constructor /////////////////////////////////////////////////////////
        /** Creates a new CompoundValidator for the ID and 0 or more Validators provided.
            @param {string} id
            @param arguments:args - Every argument after the first argument must be a myt.Validator 
                or a myt.Validator ID from the myt.global.validators registry.*/
        initialize: function(id, ...args) {
            this.callSuper(id);
            
            // Make sure each arg is an myt.Validator
            let i = args.length;
            while (i) {
                let validator = args[--i];
                if (typeof validator === 'string') {
                    args[i] = validator = getValidator(validator);
                    if (!validator) args.splice(i, 1);
                }
            }
            
            this.__v = args;
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Add a myt.Validator to this myt.CompoundValidator.
            @param {!Object|string} v - The myt.Validator to add or a string used to lookup a 
                Validator in the Validator repository.
            @returns {undefined} */
        addValidator: function(v) {
            if (typeof v === 'string') v = getValidator(v);
            if (v) this.__v.push(v);
        },
        
        /** @overrides myt.Validator */
        isValid: function(value, config, errorMessages) {
            const validators = this.__v, 
                len = validators.length;
            let isValid = true,
                i = 0;
            for (; len > i;) isValid = validators[i++].isValid(value, config, errorMessages) && isValid;
            return isValid;
        }
    });
    
    /** Stores myt.Validators by ID so they can be used in multiple places easily.
        
        @class */
    new JS.Singleton('GlobalValidatorRegistry', {
        // Life Cycle //////////////////////////////////////////////////////////
        initialize: function() {
            // Register a few common Validators
            register(new RequiredFieldValidator('required'));
            register(new EqualsIgnoreCaseValidator('equalsIgnoreCase'));
            register(new URLValidator('url'));
            register(new JSONValidator('json'));
            
            pkg.global.register('validators', this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** Gets a Validator for the ID.
            @param {string} id - the ID of the Validator to get.
            @returns {?Obect} - An myt.Validator or undefined if not found. */
        getValidator: getValidator,
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Adds a Validator to this registry.
            @param {!Object} identifiable - The myt.Validator to add.
            @returns {undefined} */
        register: register,
        
        /** Removes a Validator from this registery.
            @param {!Object} identifiable - The myt.Validator to remove.
            @returns {undefined} */
        unregister: identifiable => {
            doFuncOnIdentifiable(identifiable, id => {
                // Make sure the validator is in the repository then delete.
                if (getValidator(id)) delete validators[id];
            });
        }
    });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        {min:mathMin, max:mathMax, round:mathRound, abs:mathAbs} = Math,
        
        View = pkg.View,
        
        SliderThumb = new JSClass('SliderThumb', pkg.SimpleButton, {
            include: [pkg.Draggable, pkg.ArrowKeyActivation],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const width = attrs.width = parent.thumbWidth,
                    height = attrs.height = parent.thumbHeight;
                attrs.roundedCorners = mathMin(height, width) / 2;
                attrs.repeatKeyDown = true;
                attrs.activationKeys = pkg.global.keys.ARROW_KEYS;
                attrs.activeColor = '#bbb';
                attrs.readyColor = '#ccc';
                attrs.hoverColor = '#ddd';
                attrs.boxShadow = [0, 0, 4, '#666'];
                
                this.callSuper(parent, attrs);
                
                this[parent.axis === 'x' ? 'setY' : 'setX'](parent.thumbOffset);
                
                this.syncTo(parent, 'setDisabled', 'disabled');
                
                parent._syncThumbToValue(this, parent.getValue());
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** @overrides myt.Disableable */
            setDisabled: function(v) {
                this.callSuper(this.valueFromEvent(v));
            },
            
            /** @overrides myt.FocusObservable */
            setFocused: function(v) {
                this.callSuper(v);
                if (v) this.makeHighestZIndex();
            },
            
            /** @overrides myt.View */
            setX: function(v) {
                if (this.x !== v) {
                    this.callSuper(v);
                    
                    const p = this.parent;
                    if (p.axis === 'x') p.syncValueToThumb(this);
                }
            },
            
            /** @overrides myt.View */
            setY: function(v) {
                if (this.y !== v) {
                    this.callSuper(v);
                    
                    const p = this.parent;
                    if (p.axis === 'y') p.syncValueToThumb(this);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.Draggable */
            requestDragPosition: function(x, y) {
                if (!this.disabled) {
                    const parent = this.parent,
                        minPx = parent.getMinPixelValueForThumb(this),
                        maxPx = parent.getMaxPixelValueForThumb(this),
                        snapThreshold = parent.snapThreshold;
                    let halfSize,
                        pos,
                        funcName;
                    if (parent.axis === 'x') {
                        halfSize = this.width / 2;
                        pos = x;
                        funcName = 'setX';
                    } else {
                        halfSize = this.height / 2;
                        pos = y;
                        funcName = 'setY';
                    }
                    
                    if (parent.allowSnap(this)) {
                        for (let snapPx of parent.getSnapValuesAsPx()) {
                            snapPx -= halfSize;
                            if (mathAbs(pos - snapPx) <= snapThreshold) {
                                pos = snapPx;
                                break;
                            }
                        }
                    }
                    
                    this[funcName](mathMin(mathMax(pos, minPx - halfSize), maxPx - halfSize));
                }
            },
            
            /** @overrides myt.ArrowKeyActivation. */
            doKeyArrowLeftOrUp: function(isLeft, isRepeat) {
                if (isLeft) {
                    this.parent.nudgeValueLeft(this);
                } else {
                    this.parent.nudgeValueUp(this);
                }
                return true;
            },
            
            /** @overrides myt.ArrowKeyActivation. */
            doKeyArrowRightOrDown: function(isRight, isRepeat) {
                if (isRight) {
                    this.parent.nudgeValueRight(this);
                } else {
                    this.parent.nudgeValueDown(this);
                }
                return true;
            }
        }),
        
        /** A base class for slider components.
            
            Attributes:
                axis:string Indicates the direction the slider moves in. Allowed values are 'x' 
                    and 'y'. Defaults to 'x'.
                trackInset:number the number of pixels to inset the start of the track from the 
                    top/left edge of the component. Defaults to 0.
                trackOutset:number the number of pixels to inset the end of the track from the 
                    bottom/right edge of the component. Default to 0.
                thumbWidth:number The width of the thumb.
                thumbHeight:number The height of the thumb.
                thumbOffset:number The x/y offset of the thumb. Will applied to the opposite 
                    dimension to the axis.
                nudgeAmount:number the amount to nudge the value when the arrows keys are invoked. 
                    Defaults to 1.
            
            Private Attributes:
                __lockSync:boolean Used internally to prevent infinite loops.
            
            @class */
        BaseSlider = pkg.BaseSlider = new JSClass('BaseSlider', View, {
            include: [pkg.Disableable],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.View */
            initNode: function(parent, attrs) {
                attrs.axis ??= 'x';
                if (attrs.axis === 'x') {
                    attrs.width ??= 100;
                    attrs.height ??= 18;
                } else {
                    attrs.width ??= 18;
                    attrs.height ??= 100;
                }
                attrs.bgColor ??= '#999';
                attrs.roundedCorners ??= 9;
                attrs.trackInset ??= 9;
                attrs.trackOutset ??= 9;
                attrs.thumbWidth ??= 16;
                attrs.thumbHeight ??= 16;
                attrs.thumbOffset ??= 1;
                attrs.nudgeAmount ??= 1;
                
                attrs.snapThreshold ??= 8;
                attrs.snapValues ??= [];
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setAxis: function(v) {this.axis = v;},
            setTrackInset: function(v) {this.trackInset = v;},
            setTrackOutset: function(v) {this.trackOutset = v;},
            setThumbWidth: function(v) {this.thumbWidth = v;},
            setThumbHeight: function(v) {this.thumbHeight = v;},
            setThumbOffset: function(v) {this.thumbOffset = v;},
            setNudgeAmount: function(v) {this.nudgeAmount = v;},
            
            setSnapThreshold: function(v) {this.snapThreshold = v;},
            setSnapValues: function(v) {this.snapValues = v;},
            getSnapValuesAsPx: function() {
                const retval = [];
                for (const v of this.snapValues) retval.push(this.convertValueToPixels(v));
                return retval;
            },
            
            // Methods /////////////////////////////////////////////////////////
            allowSnap: function(thumb) {
                const lastMousePosition = thumb.__lastMousePosition,
                    elemPos = pkg.DomElementProxy.getRelativePosition(thumb.getODE()),
                    isXAxis = this.axis === 'x',
                    crossSize = isXAxis ? thumb.height : thumb.width,
                    diff = isXAxis ? lastMousePosition.y - elemPos.y : lastMousePosition.x - elemPos.x;
                // We only do snapping if the mouse is within the cross axis bounds of the thumb.
                return diff > 0 && diff < crossSize;
            },
            
            convertValueToPixels: function(v) {
                const self = this,
                    minV = self.minValue,
                    trackInset = self.trackInset,
                    pxRange = (self.axis === 'x' ? self.width : self.height) - trackInset - self.trackOutset,
                    valueRange = self.maxValue - minV;
                return trackInset + ((v - minV) * (pxRange / valueRange));
            },
            
            convertPixelsToValue: function(px) {
                const self = this,
                    minV = self.minValue,
                    trackInset = self.trackInset,
                    pxRange = (self.axis === 'x' ? self.width : self.height) - trackInset - self.trackOutset,
                    valueRange = self.maxValue - minV;
                return ((px - trackInset) * (valueRange / pxRange)) + minV;
            },
            
            nudgeValueLeft: function(thumb) {
                this._nudge(thumb, false);
            },
            
            nudgeValueUp: function(thumb) {
                this._nudge(thumb, false);
            },
            
            nudgeValueRight: function(thumb) {
                this._nudge(thumb, true);
            },
            
            nudgeValueDown: function(thumb) {
                this._nudge(thumb, true);
            },
            
            _nudge: (thumb, up) => {/* Subclasses to implement */},
            
            _syncThumbToValue: function(thumb, value) {
                value = this.convertValueToPixels(value);
                if (this.axis === 'x') {
                    thumb.setX(value - thumb.width / 2);
                } else {
                    thumb.setY(value - thumb.height / 2);
                }
            },
            
            /** Should only be called by SliderThumb.
                @private
                @param {!Object} thumb
                @returns {undefined} */
            syncValueToThumb: function(thumb) {
                if (this.inited && !this.__lockSync) {
                    this.__lockSync = true;
                    this._syncValueToThumb(thumb, this.convertPixelsToValue(
                        this.axis === 'x' ? thumb.x + thumb.width / 2 : thumb.y + thumb.height / 2
                    ));
                    this.__lockSync = false;
                }
            },
            
            _syncValueToThumb: (thumb, converted) => {/* Subclasses to implement */},
            
            /** Should only be called by SliderThumb.
                @private
                @param {!Object} thumb
                @returns {number} */
            getMinPixelValueForThumb: function(thumb) {
                return this.convertValueToPixels(this.minValue);
            },
            
            /** Should only be called by SliderThumb.
                @private
                @param {!Object} thumb
                @returns {number} */
            getMaxPixelValueForThumb: function(thumb) {
                return this.convertValueToPixels(this.maxValue);
            }
        });
    
    /** A slider component that supports two thumbs, a lower one and an upper one.
        
        @class */
    pkg.RangeSlider = new JSClass('RangeSlider', BaseSlider, {
        include: [pkg.BoundedRangeComponent],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.BaseSlider */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            
            const rangeFillView = this.rangeFill = new View(this, {bgColor:'#666'});
            if (this.axis === 'x') {
                rangeFillView.setY(this.thumbOffset);
                rangeFillView.setHeight(this.thumbHeight);
                rangeFillView.setRoundedCorners(this.thumbHeight / 2);
            } else {
                rangeFillView.setX(this.thumbOffset);
                rangeFillView.setWidth(this.thumbWidth);
                rangeFillView.setRoundedCorners(this.thumbWidth / 2);
            }
            
            this.thumbLower = new SliderThumb(this);
            this.thumbUpper = new SliderThumb(this);
            
            this._syncRangeFillToValue();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides */
        setValue: function(v) {
            this.callSuper(v);
            
            if (this.inited) {
                // Sync position of thumb
                if (!this.__lockSync) {
                    v = this.getValue();
                    this._syncThumbToValue(this.thumbLower, v);
                    this._syncThumbToValue(this.thumbUpper, v);
                }
                this._syncRangeFillToValue();
            }
        },
        
        /** @overrides
            Update the thumb position if the width changes. */
        setWidth: function(v) {
            const existing = this.width;
            this.callSuper(v);
            if (this.inited && this.axis === 'x' && this.width !== existing) {
                const value = this.getValue();
                this._syncThumbToValue(this.thumbLower, value);
                this._syncThumbToValue(this.thumbUpper, value);
            }
        },
        
        /** @overrides
            Update the thumb position if the height changes. */
        setHeight: function(v) {
            const existing = this.height;
            this.callSuper(v);
            if (this.inited && this.axis === 'y' && this.height !== existing) {
                const value = this.getValue();
                this._syncThumbToValue(this.thumbLower, value);
                this._syncThumbToValue(this.thumbUpper, value);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Should only be called by this and the rangeFill View.
            @private
            @returns {undefined} */
        _syncRangeFillToValue: function() {
            const rangeFill = this.rangeFill,
                value = this.getValue(),
                lowerPx = this.convertValueToPixels(value.lower),
                extent = this.convertValueToPixels(value.upper) - lowerPx;
            if (this.axis === 'x') {
                rangeFill.setX(lowerPx);
                rangeFill.setWidth(extent);
            } else {
                rangeFill.setY(lowerPx);
                rangeFill.setHeight(extent);
            }
        },
        
        /** @overrides myt.BaseSlider */
        _syncThumbToValue: function(thumb, value) {
            this.callSuper(thumb, thumb.name === 'thumbLower' ? value.lower : value.upper);
        },
        
        /** @overrides myt.BaseSlider */
        _syncValueToThumb: function(thumb, converted) {
            let value = this.getValueCopy();
            value[thumb.name === 'thumbLower' ? 'lower' : 'upper'] = converted;
            
            this.setValue(value);
            
            // Update thumb position since value may have been adjusted
            value = this.getValue();
            if (this.thumbLower) this._syncThumbToValue(this.thumbLower, value);
            if (this.thumbUpper) this._syncThumbToValue(this.thumbUpper, value);
        },
        
        /** @overrides myt.BaseSlider */
        _nudge: function(thumb, up) {
            const value = this.getValueCopy(),
                adj = this.nudgeAmount * (up ? 1 : -1);
            if (thumb.name === 'thumbLower') {
                value.lower = mathMin(value.lower + adj, value.upper);
            } else {
                value.upper = mathMax(value.upper + adj, value.lower);
            }
            this.setValue(value);
        },
        
        /** @overrides */
        getMinPixelValueForThumb: function(thumb) {
            return this.convertValueToPixels(
                thumb.name === 'thumbLower' ? this.minValue : this.getValue().lower
            );
        },
        
        /** @overrides */
        getMaxPixelValueForThumb: function(thumb) {
            return this.convertValueToPixels(
                thumb.name === 'thumbLower' ? this.getValue().upper : this.maxValue
            );
        }
    });
    
    /** A slider component.
        
        @class */
    pkg.Slider = new JSClass('Slider', BaseSlider, {
        include: [pkg.BoundedValueComponent],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.BaseSlider */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            
            this.thumb = new SliderThumb(this);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides */
        setValue: function(v) {
            this.callSuper(v);
            
            // Sync position of thumb
            if (this.inited && !this.__lockSync) this._syncThumbToValue(this.thumb, this.getValue());
        },
        
        /** @overrides
            Update the thumb position if the width changes. */
        setWidth: function(v) {
            const existing = this.width;
            this.callSuper(v);
            if (this.inited && this.axis === 'x' && this.width !== existing) this._syncThumbToValue(this.thumb, this.getValue());
        },
        
        /** @overrides
            Update the thumb position if the height changes. */
        setHeight: function(v) {
            const existing = this.height;
            this.callSuper(v);
            if (this.inited && this.axis === 'y' && this.height !== existing) this._syncThumbToValue(this.thumb, this.getValue());
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.BaseSlider */
        _syncValueToThumb: function(thumb, converted) {
            this.setValue(converted);
            
            // Update thumb position since value may have been adjusted
            this._syncThumbToValue(thumb, this.getValue());
        },
        
        /** @overrides myt.BaseSlider */
        _nudge: function(thumb, up) {
            this.setValue(this.getValue() + this.nudgeAmount * (up ? 1 : -1));
        }
    });
    
    /** @class */
    pkg.LabelSlider = new JSClass('LabelSlider', pkg.Slider, {
        // Life Cycle //////////////////////////////////////////////////////////
        initNode: function(parent, attrs) {
            const self = this;
            
            attrs.labelX ??= 8;
            attrs.labelY ??= 2;
            attrs.labelFontSize ??= '12px';
            attrs.labelColor ??= '#000';
            attrs.flipThreshold ??= mathRound((attrs.maxValue - attrs.minValue) / 2) || 0;
            
            self.quickSet(['labelX','labelY','labelFontSize','labelColor','flipThreshold'], attrs);
            
            self.callSuper(parent, attrs);
            
            const labelX = self.labelX;
            self.labelTxt = new pkg.Text(self, {
                x:labelX, y:self.labelY, textColor:self.labelColor, fontSize:self.labelFontSize
            }, [{
                initNode: function(parent, attrs) {
                    this.targetX = labelX;
                    this.callSuper(parent, attrs);
                },
                updateX: function(noAnim) {
                    const sliderValue = self.getValue(),
                        targetX = sliderValue >= self.flipThreshold ? labelX : self.width - this.width - labelX;
                    if (this.targetX !== targetX) {
                        this.targetX = targetX;
                        this.stopActiveAnimators('x');
                        if (noAnim) {
                            this.setX(targetX);
                        } else {
                            this.animate({attribute:'x', to:targetX, duration:250});
                        }
                    }
                }
            }]);
            self.syncTo(self, 'setText', 'value');
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides */
        setWidth: function(v) {
            this.callSuper(v);
            this.labelTxt?.updateX(true);
        },
        
        setText: function(event, noAnim) {
            const labelTxt = this.labelTxt;
            if (labelTxt) {
                labelTxt.setText(event.value);
                labelTxt.updateX(noAnim);
            }
        }
    });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        {abs:mathAbs, min:mathMin} = Math,
        
        {CODE_ENTER, CODE_SPACE, ARROW_KEYS} = pkg.global.keys,
        
        STATE_COLLAPSED = 0,
        STATE_RESTORED_JUST_COLLAPSED = 1,
        STATE_RESTORED_JUST_EXPANDED = 2,
        STATE_EXPANDED = 3,
        
        /*  Setup the limitToParent constraint.
            @param {!BaseDivider} divider
            @returns {undefined} */
        updateLimitToParentConstraint = divider => {
            const dim = divider.axis === 'y' ? 'height' : 'width';
            divider.constrain('__limitToParent', [divider, 'limitToParent', divider, dim, divider.parent, dim]);
        },
        
        NudgeMixin = pkg.NudgeMixin = new JS.Module('NudgeMixin', {
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                attrs.nudgeTargetValue ??= 'value';
                attrs.nudgeIncrement ??= 1;
                attrs.nudgeMin ??= 1;
                attrs.nudgeMax ??= 64;
                this.__nudgeAcc = attrs.nudgeMin;
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setNudgeIncrement: function(v) {this.set('nudgeIncrement', mathAbs(v), true);},
            setNudgeMin: function(v) {this.set('nudgeMin', mathAbs(v), true);},
            setNudgeMax: function(v) {this.set('nudgeMax', mathAbs(v), true);},
            setNudgeTargetValue: function(v) {this.set('nudgeTargetValue', v, true);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Nudge the value of the nudgeTargetValue repeatedly.
                @param {boolean} direction - When true indicates positive.
                @param {boolean} isRepeat - Indicates if this is the result of a repeated user 
                    action and should thus accelerate.
                @returns {boolean}  */
            nudge: function(direction, isRepeat) {
                const self = this,
                    nudgeTargetValue = self.nudgeTargetValue,
                    nudgeAcc = self.__nudgeAcc = isRepeat ? mathMin(self.__nudgeAcc + self.nudgeIncrement, self.nudgeMax) : self.nudgeMin;
                
                self.set(
                    nudgeTargetValue, 
                    (self.get(nudgeTargetValue) || 0) + (direction ? 1 : -1) * nudgeAcc
                );
                
                return true;
            }
        }),
        
        /** A divider is a UI control that allows the user to resize two area by dragging the 
            divider left/right or up/down.
            
            Events:
                limitToParent:number
            
            Attributes:
                @property {string} axis - Indicates if the divider should be constrained 
                    horizontally or vertically. Allowed values: 'x' or 'y'. This value can only be 
                    set during instantiation.
                @property {number} limitToParent - If set, this will constrain the maxValue to the 
                    appropriate parent view dimension less the limitToParent amount.
                @property {number} expansionState - Used by the "primary" action to update the 
                    divider position. Allowed values are:
                        collapsed:0
                        restored just collapsed:1
                        restored just expanded:2
                        expanded:3
                @property {number} restoreValue - The value used to restore the position in the 
                    "primary" action.
            
            Private Attributes:
                __nudgeAcc:number The multiplier in px per nudge.
            
            @class */
        BaseDivider = new JSClass('BaseDivider', pkg.SimpleButton, {
            include: [pkg.BoundedValueComponent, pkg.Draggable, pkg.ArrowKeyActivation, NudgeMixin],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                
                attrs.activeColor ??= '#bbb';
                attrs.hoverColor ??= '#ddd';
                attrs.readyColor ??= '#ccc';
                attrs.axis ??= 'x';
                attrs.minValue ??= 0;
                attrs.value ??= attrs.minValue;
                attrs.expansionState ??= STATE_RESTORED_JUST_EXPANDED;
                attrs.focusIndicator ??= false;
                attrs.repeatKeyDown ??= true;
                attrs.activationKeys ??= [CODE_ENTER, CODE_SPACE, ...ARROW_KEYS];
                
                if (attrs.axis === 'y') {
                    attrs.height ??= 6;
                    attrs.cursor ??= 'row-resize';
                } else {
                    attrs.width ??= 6;
                    attrs.cursor ??= 'col-resize';
                }
                self.quickSet(['axis'], attrs);
                
                self.callSuper(parent, attrs);
                
                // Do afterwards since the value might have been constrained from the value provided 
                // in the attrs.
                if (attrs.restoreValue == null) self.setRestoreValue(self.value);
                
                if (self.limitToParent != null) updateLimitToParentConstraint(self);
                
                self.attachDomObserver(self, 'doPrimaryAction', 'dblclick');
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setExpansionState: function(v) {this.expansionState = v;},
            setRestoreValue: function(v) {this.restoreValue = v;},
            
            setLimitToParent: function(v) {
                const self = this;
                
                if (self.limitToParent !== v) {
                    self.limitToParent = v;
                    if (self.inited) {
                        self.fireEvent('limitToParent', v);
                        
                        if (v == null) {
                            self.releaseConstraint('__limitToParent');
                        } else {
                            updateLimitToParentConstraint(self);
                        }
                    }
                }
            },
            
            setAxis: function(v) {
                if (this.inited) {
                    console.warn('Axis not updatable after instantiation');
                } else {
                    this.axis = v;
                }
            },
            
            /** Update the x or y position of the divider as the value changes.
                @overrides myt.ValueComponent
                @param {number} v - The x or y position to set.
                @returns {undefined} */
            setValue: function(v) {
                this.callSuper(v);
                
                v = this.value;
                if (this.axis === 'y') {
                    this.setY(v);
                } else {
                    this.setX(v);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Do the limitToParent constraint.
                @private
                @param {!Object} event
                @returns {undefined} */
            __limitToParent: function(event) {
                const self = this,
                    dim = self.axis === 'y' ? 'height' : 'width';
                self.setMaxValue(self.parent[dim] - self.limitToParent - self[dim]);
            },
            
            /** @overrides myt.Button. */
            doActivationKeyDown: function(key, isRepeat) {
                this.callSuper(key, isRepeat);
                
                switch (key) {
                    case CODE_ENTER:
                    case CODE_SPACE:
                        this.doPrimaryAction();
                }
            },
            
            /** @overrides myt.ArrowKeyActivation. */
            doKeyArrowLeftOrUp: function(isLeft, isRepeat) {
                return this.nudge(false, isRepeat);
            },
            
            /** @overrides myt.ArrowKeyActivation. */
            doKeyArrowRightOrDown: function(isRight, isRepeat) {
                return this.nudge(true, isRepeat);
            },
            
            /** Nudge the divider when the arrow keys are used. Nudging accelerates up to a limit 
                if the key is held down.
                @param {boolean} direction - When true indicates right/down.
                @param {boolean} isRepeat - Indicates if this is the result of a repeated key event.
                @returns {boolean}  */
            nudge: function(direction, isRepeat) {
                const self = this,
                    retval = self.callSuper(direction, isRepeat);
                self.setExpansionState(STATE_RESTORED_JUST_EXPANDED);
                self.setRestoreValue(self.value);
                return retval;
            },
            
            doPrimaryAction: function() {
                const self = this,
                    {restoreValue:rv, maxValue:maxV, minValue:minV} = self;
                let toValue;
                switch (self.expansionState) {
                    case STATE_COLLAPSED:
                        if (rv != null) {
                            self.setExpansionState(STATE_RESTORED_JUST_COLLAPSED);
                            if (rv === minV) {
                                // Prevent infinite loop if there's nowhere to animate to.
                                if (rv !== maxV) self.doPrimaryAction();
                            } else {
                                toValue = rv;
                            }
                        }
                        break;
                    case STATE_RESTORED_JUST_COLLAPSED:
                        if (maxV != null) {
                            self.setExpansionState(STATE_EXPANDED);
                            if (self.value === maxV) {
                                self.doPrimaryAction();
                            } else {
                                toValue = maxV;
                            }
                        }
                        break;
                    case STATE_RESTORED_JUST_EXPANDED:
                        if (minV != null) {
                            self.setExpansionState(STATE_COLLAPSED);
                            if (self.value === minV) {
                                self.doPrimaryAction();
                            } else {
                                toValue = minV;
                            }
                        }
                        break;
                    case STATE_EXPANDED:
                        if (rv != null) {
                            self.setExpansionState(STATE_RESTORED_JUST_EXPANDED);
                            if (rv === maxV) {
                                self.doPrimaryAction();
                            } else {
                                toValue = rv;
                            }
                        }
                        break;
                }
                self.animateToValue(toValue);
            },
            
            animateToValue: function(value, speed=250) {
                if (value != null) {
                    this.stopActiveAnimators('value');
                    this.animate({
                        attribute:'value',
                        to:value,
                        duration:speed
                    });
                }
            },
            
            /** Constrain dragging to horizontal or vertical based on axis.
                @overrides myt.Draggable */
            requestDragPosition: function(x, y) {
                if (!this.disabled) {
                    const value = this.axis === 'y' ? y : x,
                        curValue = this.value;
                    if (value !== curValue) {
                        this.setValue(value);
                        this.setRestoreValue(value);
                        this.setExpansionState(curValue > value ? STATE_RESTORED_JUST_EXPANDED : STATE_RESTORED_JUST_COLLAPSED);
                    }
                }
            }
        });
    
    /** A divider that moves left/right.
        
        @class */
    pkg.HorizontalDivider = new JSClass('HorizontalDivider', BaseDivider, {
        initNode: function(parent, attrs) {
            attrs.axis = 'x';
            this.callSuper(parent, attrs);
        }
    });
    
    /** A divider that moves left/right.
        
        @class */
    pkg.VerticalDivider = new JSClass('VerticalDivider', BaseDivider, {
        initNode: function(parent, attrs) {
            attrs.axis = 'y';
            this.callSuper(parent, attrs);
        }
    });
})(myt);


(pkg => {
    /** Use a shared idx so we can better distibute extra space during small but frequent resizings 
        such as what occurs when slowly resizing a grid. */
    let resizeIdx = 0;
    
    const {Class:JSClass, Module:JSModule} = JS,
        
        {min:mathMin, max:mathMax} = Math,
        
        {View, SpacedLayout, Node:{DEFAULT_PLACEMENT}} = pkg,
        
        // GridController
        findLastVisibleColumn = controller => {
            const hdrs = controller.columnHeaders;
            let i = hdrs.length;
            while (i) {
                const hdr = hdrs[--i];
                if (hdr.visible) return hdr;
            }
        },
        
        notifyHeadersOfSortState = controller => {
            const hdrs = controller.columnHeaders,
                [sortColumnId, sortOrder] = controller.sort ?? ['',''];
            let i = hdrs.length;
            while (i) {
                const hdr = hdrs[--i];
                if (hdr.columnId === sortColumnId) {
                    if (hdr.sortable) hdr.setSortState(sortOrder);
                } else {
                    hdr.setSortState('none');
                }
            }
            if (!controller.locked) controller.doSort();
        },
        
        /*  Calculate resize amounts and distribute it to the headers */
        calculateAndDistribute = (hdrs, extra, isFlex, nextFunc) => {
            if (extra !== 0) {
                // Get resizable column info
                const isGrow = extra > 0,
                    resizeInfo = [];
                let i = hdrs.length;
                while (i) {
                    const hdr = hdrs[--i];
                    if (hdr.resizable && (isFlex ? (hdr.flex > 0) : (hdr.flex === 0))) {
                        resizeInfo.push({
                            hdr:hdr,
                            limit:(isGrow ? hdr.maxValue : hdr.minValue) - hdr.value,
                            amt:0
                        });
                    }
                }
                
                // Calculate Amounts
                let resizeCount = resizeInfo.length;
                if (resizeCount > 0) {
                    let fullCount = 0;
                    
                    while (extra !== 0) {
                        if (resizeIdx >= resizeCount) {
                            resizeIdx = 0;
                            fullCount = 0;
                        }
                        
                        const info = resizeInfo[resizeIdx],
                            hdr = info.hdr;
                        
                        if (info.full) {
                            ++fullCount;
                        } else {
                            let incr;
                            if (isGrow) {
                                incr = mathMin(isFlex ? hdr.flex : 1, extra);
                                if (info.amt + incr > info.limit) {
                                    incr = info.limit - info.amt;
                                    info.full = true;
                                }
                            } else {
                                incr = mathMax(isFlex ? -hdr.flex : -1, extra);
                                if (info.amt + incr < info.limit) {
                                    incr = info.limit - info.amt;
                                    info.full = true;
                                }
                            }
                            info.amt += incr;
                            extra -= incr;
                        }
                        
                        if (fullCount === resizeCount) break;
                        
                        ++resizeIdx;
                    }
                    
                    // Distribute
                    for (const info of resizeInfo) info.hdr.setValue(info.hdr.value + info.amt);
                    
                    nextFunc?.(extra);
                }
            }
        },
        
        // GridColHdr
        defaultMaxValue = 1000,
        
        getPrevHdr = gridHeader => gridHeader.gridController?.getPrevHdr(gridHeader),
        
        getNextHdr = gridHeader => gridHeader.gridController?.getNextHdr(gridHeader),
        
        getGiveLeft = gridHeader => {
            const hdr = getPrevHdr(gridHeader);
            return hdr ? hdr.maxValue - hdr.value + getGiveLeft(hdr) : 0;
        },
        
        getGiveRight = gridHeader => {
            const hdr = getNextHdr(gridHeader);
            return hdr ? hdr.maxValue - hdr.value + getGiveRight(hdr) : 0;
        },
        
        getTakeLeft = gridHeader => {
            const hdr = getPrevHdr(gridHeader);
            return hdr ? hdr.minValue - hdr.value + getTakeLeft(hdr) : 0;
        },
        
        getTakeRight = gridHeader => {
            const hdr = getNextHdr(gridHeader);
            return hdr ? hdr.minValue - hdr.value + getTakeRight(hdr) : 0;
        },
        
        /*  @param {!Object} gridHeader
            @returns {undefined} */
        updateLast = gridHeader => {
            gridHeader.resizer.setVisible(!(gridHeader.last && gridHeader.gridController.fitToWidth));
        },
        
        /*  Steals width from previous column headers.
            @param {!Object} gridHeader
            @param {number} diff - The amount to steal. Will be a negative number.
            @returns {number} - The amount of width actually stolen. */
        stealPrevWidth = (gridHeader, diff) => {
            const hdr = getPrevHdr(gridHeader);
            let usedDiff = 0;
            if (hdr) {
                const newValue = hdr.value + diff;
                if (hdr.resizable) hdr.setValue(newValue);
                const remainingDiff = newValue - hdr.value;
                usedDiff = diff - remainingDiff;
                if (remainingDiff < 0) usedDiff += stealPrevWidth(hdr, remainingDiff);
            }
            return usedDiff;
        },
        
        /*  Gives width to previous column headers.
            @param {!Object} gridHeader
            @param {number} diff - The amount to give. Will be a positive number.
            @returns {number} - The amount of width actually given. */
        givePrevWidth = (gridHeader, diff) => {
            const hdr = getPrevHdr(gridHeader);
            let usedDiff = 0;
            if (hdr) {
                const newValue = hdr.value + diff;
                if (hdr.resizable) hdr.setValue(newValue);
                const remainingDiff = newValue - hdr.value;
                usedDiff = diff - remainingDiff;
                if (remainingDiff > 0) usedDiff += givePrevWidth(hdr, remainingDiff);
            }
            return usedDiff;
        },
        
        /*  Steals width from next column headers.
            @param {!Object} gridHeader
            @param {number} diff - The amount to steal. Will be a negative number.
            @returns {number} - The amount of width actually stolen. */
        stealNextWidth = (gridHeader, diff) => {
            const hdr = getNextHdr(gridHeader);
            if (hdr) {
                const newValue = hdr.value + diff;
                if (hdr.resizable) hdr.setValue(newValue);
                const remainingDiff = newValue - hdr.value;
                if (remainingDiff < 0) stealNextWidth(hdr, remainingDiff);
            }
        },
        
        /*  Gives width to next column headers.
            @param {!Object} gridHeader
            @param {number} diff - The amount to give. Will be a positive number.
            @returns {number} - The amount of width actually given. */
        giveNextWidth = (gridHeader, diff) => {
            const hdr = getNextHdr(gridHeader);
            if (hdr) {
                const newValue = hdr.value + diff;
                if (hdr.resizable) hdr.setValue(newValue);
                const remainingDiff = newValue - hdr.value;
                if (remainingDiff > 0) giveNextWidth(hdr, remainingDiff);
            }
        },
        
        // GridRow
        getRowSubview = (gridRow, columnHeader) => gridRow.getRef(columnHeader.columnId),
        
        // SimpleGridColHdr
        updateSortIcon = gridHeader => {
            let glyph = '';
            if (gridHeader.sortable) {
                switch (gridHeader.sortState) {
                    case Grid.SORT_ORDER_ASC: glyph = 'chevron-up'; break;
                    case Grid.SORT_ORDER_DESC: glyph = 'chevron-down'; break;
                }
            }
            gridHeader.sortIcon.setIcon(glyph);
        },
        
        updateTextWidth = gridHeader => {
            const textView = gridHeader.textView;
            textView?.setWidth(gridHeader.width - gridHeader.outset - textView.x);
        },
        
        /** Coordinates the behavior of a grid.
            
            Events:
                sort:array
                maxWidth:number
                minWidth:number
            
            Attributes:
                maxWidth:number the sum of the maximum widths of the columns.
                minWidth:number the sum of the minimum widths of the columns.
                gridWidth:number the width of the grid component.
                fitToWidth:boolean determines if the columns will always fill up the width of the 
                    grid or not. Defaults to true.
                lastColumn:myt.GridColHdr Holds a reference to the last column header.
                sort:array An array containing the id of the column to sort by and the order to 
                    sort by.
                locked:boolean Prevents the grid from updating the UI. Defaults to true. After a 
                    grid has been setup a call should be made to setLocked(false)
            
            Private Attributes:
                columnHeaders:array An array of column headers in this grid.
                rows:array An array of rows in this grid.
                __tempLock:boolean Prevents "change" notifications from being processed.
            
            @class */
        GridController = pkg.GridController = new JSModule('GridController', {
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                
                self.columnHeaders = [];
                self.rows = [];
                
                self.maxWidth = self.minWidth = self.gridWidth = 0;
                self.fitToWidth = self.locked = true;
                
                self.callSuper(parent, attrs);
                
                self.fitHeadersToWidth();
                notifyHeadersOfSortState(self);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setMaxWidth: function(v) {this.set('maxWidth', v, true);},
            setMinWidth: function(v) {this.set('minWidth', v, true);},
            
            setFitToWidth: function(v) {this.fitToWidth = v;},
            
            setSort: function(v) {
                if (!pkg.areArraysEqual(v, this.sort)) {
                    this.sort = v;
                    if (this.inited) {
                        this.fireEvent('sort', v);
                        notifyHeadersOfSortState(this);
                    }
                }
            },
            
            setLastColumn: function(v) {
                const cur = this.lastColumn;
                if (cur !== v) {
                    cur?.setLast(false);
                    this.lastColumn = v;
                    v?.setLast(true);
                }
            },
            
            setLocked: function(v) {
                this.locked = v;
                if (this.inited && !v) {
                    // Prevent change calls during fitHeadersToWidth
                    this.__tempLock = true;
                    this.fitHeadersToWidth();
                    this.__tempLock = false;
                    
                    // Reset min/max since notifyHdrVisibilityChange will update these values
                    this.setMaxWidth(0);
                    this.setMinWidth(0);
                    this.__skipInvisibleHeaders = true;
                    for (const hdr of this.columnHeaders) {
                        this.notifyHdrXChange(hdr);
                        this.notifyHdrWidthChange(hdr);
                        this.notifyHdrVisibilityChange(hdr);
                    }
                    this.__skipInvisibleHeaders = false;
                    
                    this.doSort();
                }
            },
            
            isLocked: function() {
                return this.locked || this.__tempLock;
            },
            
            setGridWidth: function(v) {
                v = this.valueFromEvent(v);
                if (this.gridWidth !== v) {
                    this.gridWidth = v;
                    if (this.inited) this.fitHeadersToWidth();
                }
            },
            
            setHdrChangeListener: function(value) {
                this.hdrChangeListener = value;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Sorts the rows according to the current sort criteria. Subclasses and instances 
                should implement this as needed.
                @returns {undefined} */
            doSort: () => {},
            
            // Column Headers
            /** Gets the column header before the provided one.
                @param {!Object} columnHeader
                @returns {?Object} The myt.GridColHdr or undefined if none exists. */
            getPrevHdr: function(columnHeader) {
                const hdrs = this.columnHeaders;
                let idx = this.getHdrIndex(columnHeader);
                if (idx > 0) {
                    while (idx) {
                        const hdr = hdrs[--idx];
                        if (hdr.visible) return hdr;
                    }
                }
            },
            
            /** Gets the column header after the provided one.
                @param {!Object} columnHeader
                @returns {?Object} The myt.GridColHdr or undefined if none exists. */
            getNextHdr: function(columnHeader) {
                const hdrs = this.columnHeaders,
                    len = hdrs.length;
                let idx = this.getHdrIndex(columnHeader) + 1;
                if (idx > 0 && idx < len) {
                    for (; len > idx;) {
                        const hdr = hdrs[idx++];
                        if (hdr.visible) return hdr;
                    }
                }
            },
            
            hasHdr: function(columnHeader) {
                return this.columnHeaders.includes(columnHeader);
            },
            
            getHdrIndex: function(columnHeader) {
                return this.columnHeaders.indexOf(columnHeader);
            },
            
            getHdrById: function(columnId) {
                for (const hdr of this.columnHeaders) {
                    if (hdr.columnId === columnId) return hdr;
                }
            },
            
            getVisibleHdrs: function() {
                return this.columnHeaders.filter(hdr => hdr.visible);
            },
            
            notifyAddHdr: function(columnHeader) {
                if (!this.hasHdr(columnHeader)) {
                    this.columnHeaders.push(columnHeader);
                    if (columnHeader.visible) this.setLastColumn(columnHeader);
                    this.fixupResizerCursors();
                }
            },
            
            notifyRemoveHdr: function(columnHeader) {
                const idx = this.getHdrIndex(columnHeader);
                if (idx > -1) {
                    this.columnHeaders.splice(idx, 1);
                    if (columnHeader.visible && columnHeader.last) this.setLastColumn(this.getPrevHdr(columnHeader));
                    this.fixupResizerCursors();
                }
            },
            
            notifyHdrXChange: function(columnHeader) {
                if (!this.isLocked()) {
                    for (const row of this.rows) row.notifyHdrXChange(columnHeader);
                    this._notifyHdrChange('X', columnHeader);
                }
            },
            
            notifyHdrWidthChange: function(columnHeader) {
                if (!this.isLocked()) {
                    for (const row of this.rows) row.notifyHdrWidthChange(columnHeader);
                    this._notifyHdrChange('Width', columnHeader);
                }
            },
            
            notifyHdrVisibilityChange: function(columnHeader) {
                const skip = this.__skipInvisibleHeaders && !columnHeader.visible;
                
                if (!skip && !this.isLocked()) {
                    this.updateRowsForVisibilityChange(columnHeader);
                    
                    this.setLastColumn(findLastVisibleColumn(this));
                    
                    const adjMultiplier = columnHeader.visible ? 1 : -1;
                    this.setMaxWidth(this.maxWidth + columnHeader.maxValue * adjMultiplier);
                    this.setMinWidth(this.minWidth + columnHeader.minValue * adjMultiplier);
                    
                    this.fitHeadersToWidth();
                    this.fixupResizerCursors();
                    
                    this._notifyHdrChange('Visibility', columnHeader);
                }
            },
            
            /** @private */
            _notifyHdrChange: function(propFuncname, columnHeader) {
                const hdrChangeListener = this.hdrChangeListener;
                if (hdrChangeListener) hdrChangeListener['notifyHdr' + propFuncname + 'Change'](columnHeader);
            },
            
            updateRowsForVisibilityChange: function(columnHeader) {
                for (const row of this.rows) row.notifyHdrVisibilityChange(columnHeader);
            },
            
            // Rows
            hasRow: function(row) {
                return this.rows.includes(row);
            },
            
            getRowIndex: function(row) {
                return this.rows.indexOf(row);
            },
            
            /** Gets a row for the provided id and matcher function. If no matcher function is 
                provided a default function will be used that assumes each row has a model property 
                and that model 
                property has an id property.
                @param {string} id
                @param {?Function} [matcherFunc]
                @returns {?Objecdt} */
            getRowById: function(id, matcherFunc=row => row.model.id === id) {
                return this.rows.find(matcherFunc);
            },
            
            getPrevRow: function(row) {
                const idx = this.getRowIndex(row) - 1;
                return this.rows[idx < 0 ? this.rows.length - 1 : idx];
            },
            
            getNextRow: function(row) {
                const idx = this.getRowIndex(row) + 1;
                return this.rows[idx < this.rows.length ? idx : 0];
            },
            
            notifyAddRow: function(row, doNotSort) {
                if (!this.hasRow(row)) {
                    this.rows.push(row);
                    
                    // Update cell positions
                    if (!this.locked) {
                        const w = this.width;
                        for (const hdr of this.columnHeaders) {
                            row.setWidth(w);
                            row.notifyHdrXChange(hdr);
                            row.notifyHdrWidthChange(hdr);
                            row.notifyHdrVisibilityChange(hdr);
                        }
                        
                        if (!doNotSort) this.doSort();
                    }
                }
            },
            
            notifyRemoveRow: function(row) {
                const idx = this.getRowIndex(row);
                if (idx > -1) this.rows.splice(idx, 1);
            },
            
            fitHeadersToWidth: function() {
                if (!this.locked && this.fitToWidth) {
                    // Determine extra width to distribute/consume
                    const hdrs = this.getVisibleHdrs();
                    let maxExtent = 0;
                    for (const hdr of hdrs) maxExtent = mathMax(maxExtent, hdr.x + hdr.width);
                    
                    // Distribute extra width to resizable flex columns and then to 
                    // non-flex columns.
                    calculateAndDistribute(hdrs, this.gridWidth - maxExtent, true, extra => {
                        calculateAndDistribute(hdrs, extra, false, null);
                    });
                }
            },
            
            fixupResizerCursors: function() {
                const hdrs = this.getVisibleHdrs();
                
                // Search forward hiding the cursor for each fixed column until a non-fixed column 
                // is encountered
                let allPrevAreFixed = true,
                    firstNonFixedIdx = 0;
                hdrs.forEach((hdr, idx) => {
                    if (allPrevAreFixed && hdr.isFixed()) {
                        hdr.setResizerCursor('', true);
                    } else {
                        if (allPrevAreFixed) firstNonFixedIdx = idx;
                        allPrevAreFixed = false;
                        hdr.restoreResizerCursor();
                    }
                });
                
                // Search backward hiding the cursor for each fixed column until a non-fixed 
                // column is encountered
                let allAfterAreFixed = true,
                    i = hdrs.length,
                    lastNonFixedIndex = i - 1;
                while (i > firstNonFixedIdx) {
                    const hdr = hdrs[--i];
                    if (allAfterAreFixed) {
                        hdr.setResizerCursor('', true);
                    } else {
                        hdr.restoreResizerCursor();
                    }
                    if (!hdr.isFixed()) {
                        if (allAfterAreFixed) lastNonFixedIndex = i;
                        allAfterAreFixed = false;
                    }
                }
                
                // Handle the case where there is only one resizable column. When there's only one 
                // there is not point in resizing it.
                if (firstNonFixedIdx === lastNonFixedIndex) hdrs[firstNonFixedIdx].setResizerCursor('', true);
            }
        }),
        
        /** Makes a view behave as a grid column header.
            
            Events:
                sortable:boolean
                sortState:string
                resizable:boolean
            
            Attributes:
                columnId:string The unique ID for this column relative to the grid it is part of.
                gridController:myt.GridController the controller for the grid this component is 
                    part of.
                flex:number If 1 or more the column will get extra space if any exists.
                resizable:boolean Indicates if this column can be resized or not. Defaults to true.
                last:boolean Indicates if this is the last column header or not.
                sortable:boolean Indicates if this column can be sorted or not. Defaults to true.
                sortState:string The sort state of this column. Allowed 
                    values are:
                        'ascending': Sorted in ascending order.
                        'descending': Sorted in descending order.
                        'none': Not currently an active sort column.
                cellXAdj:number The amount to shift the x values of cells updated by this column. 
                    Defaults to 0.
                cellWidthAdj:number The amount to grow/shrink the width of cells updated by this 
                    column. Defaults to 0.
            
            @class */
        GridColHdr = pkg.GridColHdr = new JSModule('GridColHdr', {
            include: [pkg.BoundedValueComponent],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                
                const resizerCursor = attrs.resizerCursor ?? 'col-resize';
                delete attrs.resizerCursor;
                
                attrs.minValue ??= 16;
                attrs.maxValue ??= defaultMaxValue;
                attrs.value ??= attrs.minValue;
                
                attrs.resizable ??= true;
                attrs.flex ??= 0;
                attrs.cellXAdj ??= 0;
                attrs.cellWidthAdj ??= 0;
                attrs.sortable ??= true;
                attrs.sortState ??= 'none';
                
                // Ensure participation in determinePlacement method of myt.Grid
                attrs.placement ??= DEFAULT_PLACEMENT;
                
                self.callSuper(parent, attrs);
                
                const gc = self.gridController;
                
                self.resizer = new View(self, {
                    cursor:resizerCursor, width:10, zIndex:1,
                    percentOfParentHeight:100, align:'right', alignOffset:-5,
                    draggableAllowBubble:false
                }, [pkg.SizeToParent, pkg.Draggable, {
                    requestDragPosition: function(x, y) {
                        let diff = x - this.x;
                        if (gc.fitToWidth) {
                            if (diff > 0) {
                                // Get amount that this header can grow
                                diff = mathMin(diff, -getTakeRight(self), self.maxValue - self.value + getGiveLeft(self));
                            } else if (diff < 0) {
                                // Get amount that this header can shrink
                                diff = mathMax(diff, -getGiveRight(self), self.minValue - self.value + getTakeLeft(self));
                            }
                            
                            if (diff === 0) return;
                        }
                        
                        const newValue = self.value + diff;
                        
                        if (self.resizable) self.setValue(newValue);
                        const remainingDiff = newValue - self.value;
                        let stolenAmt = remainingDiff - diff,
                            additionalActualDiff = 0;
                        if (remainingDiff < 0) {
                            additionalActualDiff = stealPrevWidth(self, remainingDiff);
                        } else if (remainingDiff > 0) {
                            additionalActualDiff = givePrevWidth(self, remainingDiff);
                        }
                        this.dragInitX += additionalActualDiff;
                        stolenAmt -= additionalActualDiff;
                        
                        if (gc.fitToWidth) {
                            if (stolenAmt < 0) {
                                stealNextWidth(self, stolenAmt);
                            } else if (stolenAmt > 0) {
                                giveNextWidth(self, stolenAmt);
                            }
                        }
                    }
                }]);
                
                if (gc) {
                    gc.notifyAddHdr(self);
                    gc.notifyHdrXChange(self);
                    gc.notifyHdrVisibilityChange(self);
                }
                self.setWidth(self.value);
                updateLast(self);
            },
            
            destroy: function(v) {
                this.setGridController();
                this.callSuper(v);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setSortable: function(v) {this.set('sortable', v, true);},
            setSortState: function(v) {this.set('sortState', v, true);},
            setResizable: function(v) {this.set('resizable', v, true);},
            setCellWidthAdj: function(v) {this.cellWidthAdj = v;},
            setCellXAdj: function(v) {this.cellXAdj = v;},
            setFlex: function(v) {this.flex = v;},
            setColumnId: function(v) {this.columnId = v;},
            
            setResizerCursor: function(v, restorable) {
                const self = this,
                    resizer = self.resizer,
                    existingCursor = resizer.cursor;
                if (v !== existingCursor) {
                    if (restorable) self.__rrc = existingCursor;
                    resizer.setCursor(v);
                }
            },
            
            restoreResizerCursor: function() {
                const self = this,
                    restoreResizerCursor = self.__rrc;
                if (restoreResizerCursor) {
                    self.setResizerCursor(restoreResizerCursor);
                    self.__rrc = null;
                }
            },
            
            /** Check if this GridHeader has a fixed size.
                @returns {boolean} */
            isFixed: function() {
                return this.minValue === this.maxValue;
            },
            
            setLast: function(v) {
                this.last = v;
                if (this.inited) updateLast(this);
            },
            
            setGridController: function(v) {
                const existing = this.gridController;
                if (existing !== v) {
                    existing?.notifyRemoveHdr(this);
                    this.gridController = v;
                    if (this.inited && v) {
                        v.notifyAddHdr(this);
                        v.notifyHdrXChange(this);
                        v.notifyHdrWidthChange(this);
                        v.notifyHdrVisibilityChange(this);
                    }
                }
            },
            
            /** @overrides myt.BoundedValueComponent */
            setValue: function(v) {
                this.callSuper(v);
                if (this.inited) this.setWidth(this.value);
            },
            
            /** @overrides myt.BoundedValueComponent */
            setMinValue: function(v) {
                const self = this,
                    oldMinValue = self.minValue ?? 0, 
                    gc = self.gridController;
                self.callSuper(v);
                if (self.inited && oldMinValue !== self.minValue) gc?.setMinWidth(gc.minWidth + self.minValue - oldMinValue);
            },
            
            /** @overrides myt.BoundedValueComponent */
            setMaxValue: function(v) {
                const self = this,
                    oldMaxValue = self.maxValue ?? 0,
                    gc = self.gridController;
                v ??= defaultMaxValue;
                self.callSuper(v);
                if (self.inited && oldMaxValue !== self.maxValue) gc?.setMaxWidth(gc.maxWidth + self.maxValue - oldMaxValue);
            },
            
            /** @overrides myt.View */
            setWidth: function(v) {
                const self = this,
                    cur = self.width;
                self.callSuper(v);
                if (self.inited && cur !== self.width) self.gridController?.notifyHdrWidthChange(self);
            },
            
            /** @overrides myt.View */
            setX: function(v) {
                const self = this,
                    cur = self.x;
                self.callSuper(v);
                if (self.inited && cur !== self.x) self.gridController?.notifyHdrXChange(self);
            },
            
            /** @overrides myt.View */
            setVisible: function(v) {
                const self = this,
                    cur = self.visible;
                self.callSuper(v);
                if (self.inited && cur !== self.visible) self.gridController?.notifyHdrVisibilityChange(self);
            }
        }),
        
        /** Makes a view behave as a row in a grid.
            
            Attributes:
                gridController:myt.GridConstroller A reference to the grid controller that is 
                    managing this row.
            
            @class */
        GridRow = pkg.GridRow = new JSModule('GridRow', {
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                // Ensure participation in determinePlacement method of myt.Grid
                attrs.placement ??= DEFAULT_PLACEMENT;
                
                this.callSuper(parent, attrs);
                
                this.gridController?.notifyAddRow(this);
            },
            
            destroy: function(v) {
                this.setGridController();
                this.callSuper(v);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setGridController: function(v) {
                const existing = this.gridController;
                if (existing !== v) {
                    existing?.notifyRemoveRow(this);
                    this.gridController = v;
                    if (this.inited) v?.notifyAddRow(this);
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            notifyHdrXChange: function(columnHeader) {
                getRowSubview(this, columnHeader)?.setX(columnHeader.x + columnHeader.cellXAdj);
            },
            
            notifyHdrWidthChange: function(columnHeader) {
                getRowSubview(this, columnHeader)?.setWidth(columnHeader.width + columnHeader.cellWidthAdj);
            },
            
            notifyHdrVisibilityChange: function(columnHeader) {
                getRowSubview(this, columnHeader)?.setVisible(columnHeader.visible);
            }
        }),
        
        /** An implementation of a grid component.
            
            Attributes:
                rowSpacing:number The spacing between rows. Defaults to 1.
                columnSpacing:number the spacing between columns. Defaults to 1.
                sizeHeightToRows:boolean If true, this component will be sized to fit all the rows 
                    without showing scrollbars. Defaults to undefined which is equivalent to false.
            
            @class */
        Grid = pkg.Grid = new JSClass('Grid', View, {
            include: [GridController],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                SORT_ORDER_ASC: 'ascending',
                SORT_ORDER_DESC: 'descending'
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides myt.View */
            initNode: function(parent, attrs) {
                const self = this;
                
                // Allows horizontal scrolling if the grid columns are too wide.
                attrs.overflow ??= 'autox';
                
                attrs.bgColor ??= '#ccc';
                attrs.rowSpacing ??= 1;
                attrs.columnSpacing ??= 1;
                
                const isAutoScrolling = attrs.isAutoScrolling;
                delete attrs.isAutoScrolling;
                
                self.callSuper(parent, attrs);
                
                // Build UI
                const header = self.header = new View(self, {overflow:'hidden'});
                header.xLayout = new SpacedLayout(header, {locked:true, collapseParent:true, spacing:self.columnSpacing});
                header.yLayout = new pkg.SizeToChildren(header, {locked:true, axis:'y'});
                
                const sizeHeightToRows = self.sizeHeightToRows,
                    contentMixins = isAutoScrolling ? [pkg.AutoScroller] : [],
                    content = self.content = new View(self, {overflow:sizeHeightToRows ? 'hidden' : 'autoy'}, contentMixins);
                content.yLayout = new SpacedLayout(content, {locked:true, axis:'y', spacing:self.rowSpacing, collapseParent:sizeHeightToRows});
                
                self.syncTo(self, 'setGridWidth', 'width');
                self.syncTo(header, '_updateContentWidth', 'width');
                self.constrain('_updateContentHeight', [sizeHeightToRows ? content : self, 'height', header, 'height', header, 'y']);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setSizeHeightToRows: function(v) {this.sizeHeightToRows = v;},
            
            setRowSpacing: function(v) {
                if (this.rowSpacing !== v) {
                    this.rowSpacing = v;
                    if (this.inited) this.content.yLayout.setSpacing(v);
                }
            },
            
            setColumnSpacing: function(v) {
                if (this.columnSpacing !== v) {
                    this.columnSpacing = v;
                    if (this.inited) this.header.xLayout.setSpacing(v);
                }
            },
            
            /** @overrides myt.GridController */
            setLocked: function(v) {
                // Performance: don't update layouts until the grid is unlocked.
                if (this.inited) {
                    for (const layout of [this.header.xLayout, this.header.yLayout, this.content.yLayout]) {
                        if (v) {
                            layout.incrementLockedCounter();
                        } else {
                            layout.decrementLockedCounter();
                            layout.update();
                        }
                    }
                }
                this.callSuper(v);
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @private
                @param {!Object} event
                @returns {undefined} */
            _updateContentWidth: function(event) {
                const content = this.content,
                    w = event.value;
                content.setWidth(w);
                for (const sv of content.getSubviews()) sv.setWidth(w);
            },
            
            /** @private
                @param {!Object} event
                @returns {undefined} */
            _updateContentHeight: function(event) {
                const self = this,
                    {header, content} = self,
                    y = header.y + header.height;
                content.setY(y);
                
                if (self.sizeHeightToRows) {
                    self.setHeight(y + content.height);
                } else {
                    content.setHeight(self.height - y);
                }
            },
            
            /** @overrides myt.Node */
            determinePlacement: function(placement, subnode) {
                // Automatically place column headers and rows in the header and content 
                // views respectively.
                if (placement === DEFAULT_PLACEMENT) {
                    let target;
                    if (subnode.isA(GridRow)) {
                        target = this.content;
                    } else if (subnode.isA(GridColHdr)) {
                        target = this.header;
                    }
                    
                    if (target) {
                        if (subnode.gridController !== this) subnode.setGridController(this);
                        return target;
                    }
                }
                
                return this.callSuper(placement, subnode);
            },
            
            /** @overrides myt.GridController */
            doSort: function() {
                const [sortField, sortOrder] = this.sort ?? ['', ''],
                    sortFunc = this.getSortFunction(sortField, sortOrder);
                if (sortFunc) {
                    const content = this.content, 
                        yLayout = content.yLayout;
                    this.rows.sort(sortFunc);
                    content.sortSubviews(sortFunc);
                    yLayout.sortSubviews(sortFunc);
                    yLayout.update();
                }
            },
            
            /** Gets the sort function used to sort the rows. Subclasses and instances should 
                implement this as needed.
                @param {string} sortColumnId,
                @param {string} sortOrder
                @returns {!Function}  a comparator function used for sorting. */
            getSortFunction: (sortColumnId, sortOrder) => {
                if (sortColumnId) {
                    // Default sort function uses the 'text' attribute of 
                    // the subview.
                    const sortNum = sortOrder === Grid.SORT_ORDER_ASC ? 1 : -1;
                    return (a, b) => {
                        const aValue = a.getRef(sortColumnId).text,
                            bValue = b.getRef(sortColumnId).text;
                        if (aValue > bValue) {
                            return sortNum;
                        } else if (bValue > aValue) {
                            return -sortNum;
                        }
                        return 0;
                    };
                }
            }
        });
    
    /** A simple implementation of a grid column header.
        
        Attributes:
            sortIconColor:color the color to fill the sort icon with if shown. Defaults to '#666'.
        
        @class */
    pkg.SimpleGridColHdr = new JSClass('SimpleGridColHdr', pkg.SimpleTextButton, {
        include: [GridColHdr],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            const self = this;
            
            attrs.activeColor ??= '#999';
            attrs.hoverColor ??= '#bbb';
            attrs.readyColor ??= '#aaa';
            attrs.inset ??= 2;
            attrs.sortIconColor ??= '#666';
            
            const outset = attrs.outset ?? 2;
            delete attrs.outset;
            
            self.callSuper(parent, attrs);
            
            self.sortIcon = new pkg.FontAwesome(self, {
                align:'right', alignOffset:3, valign:'middle', textColor:self.sortIconColor
            }, [{
                initNode: function(parent, attrs) {
                    this.callSuper(parent, attrs);
                    this.getIDS().fontSize = '0.7em'; // Looks better a bit smaller.
                },
                sizeViewToDom: function() {
                    this.callSuper();
                    self.setOutset(this.width + outset);
                    updateTextWidth(self);
                }
            }]);
            
            self.textView.enableEllipsis();
            
            self.setDisabled(!self.sortable);
            updateTextWidth(self);
            updateSortIcon(self);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setSortIconColor: function(v) {
            this.sortIconColor = v;
            this.sortIcon?.setTextColor(v);
        },
        
        /** @overrides myt.GridColHdr */
        setSortable: function(v) {
            this.callSuper(v);
            if (this.inited) {
                if (v) this.setOutset(14);
                this.setDisabled(!v);
                updateSortIcon(this);
            }
        },
        
        /** @overrides myt.GridColHdr */
        setSortState: function(v) {
            this.callSuper(v);
            if (this.inited) updateSortIcon(this);
        },
        
        /** @overrides myt.View */
        setWidth: function(v) {
            this.callSuper(v);
            if (this.inited) updateTextWidth(this);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        doActivated: function() {
            if (!this.disabled) {
                this.setSortState(this.sortState === Grid.SORT_ORDER_ASC ? Grid.SORT_ORDER_DESC : Grid.SORT_ORDER_ASC);
                this.gridController.setSort([this.columnId, this.sortState]);
            }
        },
        
        /** @overrides myt.SimpleButton */
        drawDisabledState: function() {this.draw(this.readyColor, 1);}
    });
})(myt);


(pkg => {
    const {Class:JSClass, Module:JSModule} = JS,
        
        math = Math,
        mathMax = math.max,
        
        {
            View, 
            global:{focus:GlobalFocus, keys:GlobalKeys},
            getAlphaObjSortFunc
        } = pkg,
        
        DEFAULT_CLASS_KEY = 'default',
        
        /*  Clears the selectedRow while leaving the selectedRowModel. */
        clearSelectedRow = selectableInfiniteList => {
            const existing = selectableInfiniteList.selectedRow;
            if (existing) {
                existing.setSelected(false);
                selectableInfiniteList.set('selectedRow', null, true);
            }
        },
        
        updateRowExtent = infiniteList => {
            infiniteList._rowExtent = infiniteList.rowSpacing + infiniteList.rowHeight;
        },
        
        getDomScrollTop = infiniteList => infiniteList.getIDE().scrollTop,
        
        setDomScrollTop = (infiniteList, v) => {
            infiniteList.scrollYTo(v, true);
        },
        
        getSubview = (gridRow, columnHeader) => gridRow.getRef(columnHeader.columnId),
        
        /** A mixin for rows in infinite scrolling lists
            
            Attributes:
                infiniteOwner
                model
                classKey
            
            @class */
        InfiniteListRow = pkg.InfiniteListRow = new JSModule('InfiniteListRow', {
            include: [pkg.Reusable],
            
            
            // Accessors ///////////////////////////////////////////////////////
            setInfiniteOwner: function(v) {
                this.infiniteOwner = v;
            },
            
            setModel: function(model) {
                this.model = model;
            },
            
            setClassKey: function(classKey) {
                this.classKey = classKey;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            notifyRefreshed: () => {/* Subclasses to implement as needed. */}
        }),
        
        /** A mixin for rows in infinite scrolling lists
            
            @class */
        SelectableInfiniteListRow = pkg.SelectableInfiniteListRow = new JSModule('SelectableInfiniteListRow', {
            include: [InfiniteListRow, pkg.Selectable]
        }),
        
        /** A base class for infinite scrolling lists
            
            Attributes:
                collectionModel
                rowClasses
                modelIDName
                numericSort
                ascendingSort
                rowHeight
                rowInset
                rowOutset
                rowSpacing
            
            Private Attributes:
                _listData:array The data for the rows in the list.
                _startIdx:int The index into the data of the first row shown
                _endIdx:int The index into the data of the last row shown
                _visibleRowsByIdx:object A cache of what rows are currently shown by the index of 
                    the data for the row. This provides faster performance when refreshing the list.
                _listView:myt.View The view that contains the rows in the list.
                _itemPool:myt.TrackActivesPool The pool for row views.
            
            @class */
        InfiniteList = pkg.InfiniteList = new JSClass('InfiniteList', View, {
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                let rowClasses = attrs.rowClasses;
                delete attrs.rowClasses;
                
                if (typeof rowClasses === 'function') {
                    const defaultClassObj = {};
                    defaultClassObj[DEFAULT_CLASS_KEY] = rowClasses;
                    rowClasses = defaultClassObj;
                }
                
                attrs.modelIDName ??= 'id';
                attrs.numericSort ??= true;
                attrs.ascendingSort ??= true;
                attrs.overflow ??= 'autoy';
                attrs.bgColor ??= '#ccc';
                attrs.rowSpacing ??= 1;
                attrs.rowInset ??= 0;
                attrs.rowOutset ??= 0;
                attrs.rowHeight ??= 30;
                attrs.overscrollBehavior ??= 'auto contain';
                
                self._rowExtent = self.rowSpacing = self.rowHeight = 0;
                self._startIdx = self._endIdx = -1;
                self._visibleRowsByIdx = {};
                
                self.callSuper(parent, attrs);
                
                // Build UI
                const listView = self._listView = new View(self);
                self._scrollAnchorView = new View(listView, {width:1, height:1, bgColor:'transparent'});
                self._itemPool = self.makePool(rowClasses, listView);
                
                self.attachTo(self, 'refreshListUI', 'height');
                self.attachToDom(self, 'refreshListUI', 'scroll');
            },
            
            makePool: (rowClasses, listView) => new pkg.TrackActivesMultiPool(rowClasses, listView),
            
            
            // Accessors ///////////////////////////////////////////////////////
            setOverscrollBehavior: function(v) {
                this.overscrollBehavior = v;
                this.getIDS().overscrollBehavior = v;
            },
            
            setCollectionModel: function(v) {this.collectionModel = v;},
            setModelIDName: function(v) {this.modelIDName = v;},
            setRowSpacing: function(v) {
                this.rowSpacing = v;
                updateRowExtent(this);
            },
            setRowHeight: function(v) {
                this.rowHeight = v;
                updateRowExtent(this);
            },
            
            getListData: function() {return this._listData;},
            
            setWidth: function(v) {
                if (v > 0) {
                    this.callSuper(v);
                    if (this.inited) {
                        const listView = this._listView,
                            w = this.width;
                        listView.setWidth(w);
                        for (const sv of listView.getSubviews()) sv.setWidth(w);
                    }
                }
            },
            
            getVisibleRows: function() {
                return Object.values(this._visibleRowsByIdx ?? {});
            },
            
            getVisibleRowForModel: function(model) {
                const rows = this.getVisibleRows();
                let i = rows.length;
                while (i) {
                    const row = rows[--i];
                    if (row.model === model) return row;
                }
            },
            
            getListViewHeight: function() {return this._listView.height;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @returns {undefined} */
            isScrolledToEnd: function() {
                return getDomScrollTop(this) + this.height === this._listView.height;
            },
            
            getSortFunction: function() {
                // Default to a numeric sort on the IDs
                const self = this,
                    modelIDName = self.modelIDName,
                    ascendingSort = self.ascendingSort;
                if (self.numericSort) {
                    return pkg.getNumericObjSortFunc(modelIDName, ascendingSort);
                } else {
                    return getAlphaObjSortFunc(modelIDName, ascendingSort, false);
                }
            },
            
            getFilterFunction: () => {/* Unimplemented which means don't filter anything out. */},
            
            scrollModelIntoView: function(model, doFocus) {
                const self = this,
                    idx = self.getIndexOfModelInData(model);
                let retval = false;
                if (idx >= 0) {
                    const rowExtent = self._rowExtent,
                        viewportTop = getDomScrollTop(self),
                        viewportBottom = viewportTop + self.height,
                        rowTop = self.rowInset + idx * rowExtent,
                        rowBottom = rowTop + rowExtent;
                    
                    // Only scroll if not overlapping visible area.
                    if (rowTop <= viewportTop) {
                        setDomScrollTop(self, rowTop);
                        retval = true;
                    } else if (rowBottom >= viewportBottom) {
                        setDomScrollTop(self, rowBottom - self.height);
                        retval = true;
                    }
                    
                    if (doFocus) {
                        const row = self.getVisibleRowForModel(model);
                        if (row) {
                            row.focus();
                        } else {
                            self._focusToModel = model;
                        }
                    }
                }
                
                return retval;
            },
            
            isModelInData: function(model) {
                return this.getIndexOfModelInData(model) >= 0;
            },
            
            getNextModel: function(model, wrap=true, alwaysReturnAModel=true) {
                const data = this.getListData(),
                    len = data.length;
                let idx = this.getIndexOfModelInData(model);
                if (idx >= 0) {
                    idx += 1;
                    if (idx >= len) {
                        return wrap ? data[0] : data[len - 1];
                    } else {
                        return data[idx];
                    }
                } else {
                    // Return last model for no result if so indicated
                    if (alwaysReturnAModel && len > 0) return data[len - 1];
                }
            },
            
            getPrevModel: function(model, wrap=true, alwaysReturnAModel=true) {
                const data = this.getListData(),
                    len = data.length;
                let idx = this.getIndexOfModelInData(model);
                if (idx >= 0) {
                    idx -= 1;
                    if (idx < 0) {
                        return wrap ? data[len - 1] : data[0];
                    } else {
                        return data[idx];
                    }
                } else {
                    // Return first model for no result if so indicated
                    if (alwaysReturnAModel && len > 0) return data[0];
                }
            },
            
            getIndexOfModelInData: function(model) {
                if (model) {
                    const self = this,
                        data = self.getListData();
                    let i = data.length;
                    while (i) if (self.areModelsEqual(data[--i], model)) return i;
                }
                return -1;
            },
            
            areModelsEqual: function(modelA, modelB) {
                const modelIDName = this.modelIDName;
                return modelA[modelIDName] === modelB[modelIDName];
            },
            
            getActiveRowForModel: function(model) {
                if (model) {
                    const self = this,
                        activeRows = self._itemPool.getActives();
                    let i = activeRows.length;
                    while (i) {
                        const row = activeRows[--i];
                        if (self.areModelsEqual(row.model, model)) return row;
                    }
                }
            },
            
            refreshListData: function(preserveScroll, forceFullReset) {
                this._listData = this.collectionModel.getAsSortedList(this.getSortFunction(), this.getFilterFunction());
                this.resetListUI(preserveScroll, forceFullReset);
            },
            
            resetListUI: function(preserveScroll, forceFullReset) {
                const self = this,
                    data = self.getListData(),
                    len = data.length,
                    listView = self._listView,
                    scrollAnchorView = self._scrollAnchorView;
                
                // Resize the listView to the height to accomodate all rows
                listView.setHeight(len * self._rowExtent - (len > 0 ? self.rowSpacing : 0) + self.rowInset + self.rowOutset);
                scrollAnchorView.setY(listView.height - scrollAnchorView.height);
                
                // Ensure the next refreshListUI actually refreshes
                self._startIdx = self._endIdx = -1;
                
                // Reset scroll position
                self.forceFullResetOnNextRefresh = forceFullReset;
                if (preserveScroll || getDomScrollTop(self) === 0) {
                    // Just refresh since we won't move the scroll position
                    self.refreshListUI();
                } else {
                    // Updating the scroll position triggers a refreshListUI via the DOM 
                    // scroll event.
                    setDomScrollTop(self, 0);
                }
            },
            
            putRowBackInPool: function(row) {
                // Clear or reassign focus since the row will get reused and the reused row will 
                // likely not be the appropriate focus.
                const currentFocus = GlobalFocus.focusedView;
                if (currentFocus?.isDescendantOf(row)) {
                    const focusTrap = this.getFocusTrap();
                    if (focusTrap) {
                        focusTrap.focus();
                    } else {
                        GlobalFocus.clear();
                    }
                }
                
                row.setVisible(false);
                this._itemPool.putInstance(row);
            },
            
            refreshListUI: function(ignoredEvent) {
                const self = this,
                    rowExtent = self._rowExtent,
                    rowInset = self.rowInset,
                    forceFullReset = self.forceFullResetOnNextRefresh,
                    scrollY = getDomScrollTop(self),
                    data = self.getListData() ?? [],
                    startIdx = mathMax(0, math.floor((scrollY - rowInset) / rowExtent)),
                    endIdx = math.min(data.length, math.ceil((scrollY - rowInset + self.height) / rowExtent));
                
                if (self.forceFullResetOnNextRefresh) self.forceFullResetOnNextRefresh = false;
                
                if (self._startIdx !== startIdx || self._endIdx !== endIdx || forceFullReset) {
                    const rowWidth = self.width,
                        rowHeight = self.rowHeight,
                        visibleRowsByIdx = self._visibleRowsByIdx,
                        focusToModel = self._focusToModel;
                    
                    self._startIdx = startIdx;
                    self._endIdx = endIdx;
                    
                    // Put all visible rows that are not within the idx range back into the pool
                    for (const idx in visibleRowsByIdx) {
                        if (idx < startIdx || idx >= endIdx) {
                            self.putRowBackInPool(visibleRowsByIdx[idx]);
                            delete visibleRowsByIdx[idx];
                        }
                    }
                    
                    for (let i = startIdx; i < endIdx; i++) {
                        let row = visibleRowsByIdx[i];
                        
                        const model = data[i],
                            classKey = self.getClassKey(model);
                        let mustUpdateRow = false;
                        if (!row || row.classKey !== classKey) {
                            if (row) self.putRowBackInPool(row);
                            
                            visibleRowsByIdx[i] = row = self._itemPool.getInstance(classKey);
                            
                            row.setInfiniteOwner(self);
                            row.setClassKey(classKey);
                            row.setWidth(rowWidth);
                            row.setHeight(rowHeight);
                            row.setY(rowInset + i * rowExtent);
                            row.setVisible(true);
                            
                            mustUpdateRow = true;
                        }
                        
                        if (forceFullReset || !row.model || !self.areModelsEqual(row.model, model)) {
                            row.setModel(model);
                            self.updateRow(row);
                        } else if (mustUpdateRow) {
                            self.updateRow(row);
                        }
                        
                        row.notifyRefreshed();
                        
                        // Maintain tab ordering by updating the underlying dom order.
                        row.bringToFront();
                        
                        if (focusToModel && self.areModelsEqual(focusToModel, model)) {
                            row.focus();
                            self._focusToModel = null;
                        }
                    }
                }
            },
            
            getClassKey: model => DEFAULT_CLASS_KEY,
            
            updateRow: row => {}
        }),
        
        /** A simple implementation of a SelectableInfiniteListRow.
            
            Attributes:
                selectedColor
            
            @class */
        SimpleSelectableInfiniteListRow = pkg.SimpleSelectableInfiniteListRow = new JSClass('SimpleSelectableInfiniteListRow', pkg.SimpleButton, {
            include: [SelectableInfiniteListRow, pkg.ArrowKeyActivation],
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                attrs.selectedColor ??= '#ccf';
                attrs.activeColor ??= '#f8f8f8';
                attrs.hoverColor ??= '#eee';
                attrs.readyColor ??= '#fff';
                attrs.focusIndicator ??= false;
                attrs.activationKeys ??= GlobalKeys.LIST_KEYS;
                
                this.callSuper(parent, attrs);
            },
            
            destroy: function() {
                if (this.selected) this.infiniteOwner.setSelectedRow();
                this.callSuper();
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setSelected: function(v) {
                this.callSuper(v);
                if (this.inited) this.updateUI();
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            clean: function() {
                this.setMouseOver(false);
                this.setMouseDown(false);
                if (this.focused) this.blur();
                this.callSuper();
            },
            
            updateUI: function() {
                this.callSuper();
                if (this.selected) this.setBgColor(this.selectedColor);
            },
            
            doActivated: function() {
                this.callSuper();
                this.infiniteOwner.setSelectedRow(this);
            },
            
            doActivationKeyDown: function(code, isRepeat) {
                if (code === GlobalKeys.CODE_ESC) {
                    if (this.selected) this.infiniteOwner.setSelectedRow();
                } else {
                    this.callSuper(code, isRepeat);
                }
            },
            
            /** @overrides myt.ArrowKeyActivation. */
            doKeyArrowLeftOrUp: function(isLeft, isRepeat) {
                this.infiniteOwner.selectPrevRowForModel(this.model);
                return true;
            },
            
            /** @overrides myt.ArrowKeyActivation. */
            doKeyArrowRightOrDown: function(isRight, isRepeat) {
                this.infiniteOwner.selectNextRowForModel(this.model);
                return true;
            },
            
            doActivationKeyUp: function(code) {
                switch (code) {
                    case GlobalKeys.CODE_ENTER:
                    case GlobalKeys.CODE_SPACE:
                        this.doActivated();
                        break;
                }
            }
        }),
        
        /** A base class for infinite scrolling lists that support a 
            selectable row.
            
            Attributes:
                selectedRow
                selectedRowModel
            
            @class */
        SelectableInfiniteList = pkg.SelectableInfiniteList = new JSClass('SelectableInfiniteList', InfiniteList, {
            // Accessors ///////////////////////////////////////////////////////
            setSelectedRow: function(row) {
                const existing = this.selectedRow;
                if (row !== existing) {
                    existing?.setSelected(false);
                    this.setSelectedRowModel();
                    this.set('selectedRow', row, true);
                    if (row) {
                        this.setSelectedRowModel(row.model);
                        row.setSelected(true);
                    }
                }
            },
            
            setSelectedRowModel: function(v) {
                this.set('selectedRowModel', v, true);
                
                // Scroll the selected row into view
                this.scrollModelIntoView(this.selectedRowModel, false);
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            getActiveSelectedRow: function() {
                return this.getActiveRowForModel(this.selectedRowModel);
            },
            
            selectRowForModel: function(model, focus, isNext) {
                if (model) {
                    clearSelectedRow(this);
                    this.setSelectedRowModel(model);
                    this.refreshListUI();
                    
                    // Focus on the newly selected row
                    if (focus) this.getActiveSelectedRow()?.focus();
                }
            },
            
            selectNextRowForModel: function(model, focus=true) {
                this.selectRowForModel(this.getNextModel(model), focus, true);
            },
            
            selectPrevRowForModel: function(model, focus=true) {
                this.selectRowForModel(this.getPrevModel(model), focus, false);
            },
            
            /** @overrides */
            resetListUI: function(preserveScroll, forceFullReset) {
                if (this.isModelInData(this.selectedRowModel)) {
                    // Only clear the selected row since it's still in the data and thus may be 
                    // shown again.
                    clearSelectedRow(this);
                } else {
                    // Clear the row and model since the model can no longer be shown.
                    this.setSelectedRow();
                }
                
                this.callSuper(preserveScroll, forceFullReset);
            },
            
            /** @overrides */
            putRowBackInPool: function(row) {
                if (row.selected) clearSelectedRow(this);
                this.callSuper(row);
            },
            
            /** @overrides */
            refreshListUI: function(ignoredEvent) {
                const currentFocus = GlobalFocus.focusedView;
                
                this.callSuper();
                
                const row = this.getActiveSelectedRow();
                if (row) {
                    this.set('selectedRow', row, true);
                    row.setSelected(true);
                    if (!currentFocus || currentFocus === row) row.focus(true);
                }
            }
        }),
        
        InfiniteGridRowMixin = new JSModule('InfiniteGridRowMixin', {
            // Methods /////////////////////////////////////////////////////////
            notifyXChange: function(columnHeader) {
                getSubview(this, columnHeader)?.setX(columnHeader.x + columnHeader.cellXAdj);
            },
            
            notifyWidthChange: function(columnHeader) {
                getSubview(this, columnHeader)?.setWidth(columnHeader.width + columnHeader.cellWidthAdj);
            },
            
            notifyVisibilityChange: function(columnHeader) {
                getSubview(this, columnHeader)?.setVisible(columnHeader.visible);
            }
        }),
        
        InfiniteGridMixin = new JSModule('InfiniteGridMixin', {
            // Accessors ///////////////////////////////////////////////////////
            setGridHeader: function(v) {
                (this.gridHeader = v)?.setGrid(this);
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            makeReady: function(sortState, forceFullReset) {
                const gridHeader = this.gridHeader;
                if (gridHeader) {
                    this.forceFullResetOnNextRefresh = forceFullReset;
                    gridHeader.setSort(sortState);
                    gridHeader.setLocked(false);
                } else {
                    this.refreshListData(false, forceFullReset);
                }
            },
            
            /** @overrides myt.InfiniteList */
            getSortFunction: function() {
                const [sortColumnId, sortOrder] = this.gridHeader.sort ?? ['',''];
                return sortColumnId ? getAlphaObjSortFunc(sortColumnId, sortOrder === pkg.Grid.SORT_ORDER_ASC, false) : this.callSuper();
            },
            
            /** @overrides myt.InfiniteList */
            updateRow: function(row) {
                const gridHeader = this.gridHeader;
                if (gridHeader) {
                    for (const hdr of gridHeader.columnHeaders) {
                        row.notifyXChange(hdr);
                        row.notifyWidthChange(hdr);
                        row.notifyVisibilityChange(hdr);
                    }
                }
            },
            
            notifyXChange: function(columnHeader) {
                for (const row of this.getVisibleRows()) row.notifyXChange(columnHeader);
            },
            
            notifyWidthChange: function(columnHeader) {
                for (const row of this.getVisibleRows()) row.notifyWidthChange(columnHeader);
            },
            
            notifyVisibilityChange: function(columnHeader) {
                for (const row of this.getVisibleRows()) row.notifyVisibilityChange(columnHeader);
            }
        });
    
    pkg.InfiniteGridRow = new JSModule('InfiniteGridRow', {
        include: [InfiniteListRow, InfiniteGridRowMixin]
    });
    
    pkg.SelectableInfiniteGridRow = new JSModule('SelectableInfiniteGridRow', {
        include: [SelectableInfiniteListRow, InfiniteGridRowMixin]
    });
    
    pkg.SimpleSelectableInfiniteGridRow = new JSClass('SimpleSelectableInfiniteGridRow', SimpleSelectableInfiniteListRow, {
        include: [InfiniteGridRowMixin]
    });
    
    /** A base class for infinite scrolling grids
        
        @class */
    pkg.InfiniteGrid = new JSClass('InfiniteGrid', InfiniteList, {
        include: [InfiniteGridMixin]
    });
    
    /** A base class for selectable infinite scrolling grids
        
        @class */
    pkg.SelectableInfiniteGrid = new JSClass('InfiniteGrid', SelectableInfiniteList, {
        include: [InfiniteGridMixin]
    });
    
    pkg.InfiniteGridHeader = new JSClass('InfiniteGridHeader', View, {
        include: [pkg.GridController],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.columnSpacing ??= 1;
            
            attrs.overflow = 'hidden';
            
            this.callSuper(parent, attrs);
            
            new pkg.SpacedLayout(this, {spacing:this.columnSpacing});
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setGrid: function(v) {this.grid = v;},
        setColumnSpacing: function(v) {this.columnSpacing = v;},
        
        getColumnSpacingInUse: function() {
            return this.columnSpacing === 0 ? 0 : mathMax(0, this.getVisibleHdrs().length - 1) * this.columnSpacing;
        },
        
        /** @overrides myt.View */
        setHeight: function(v) {
            this.callSuper(v);
            if (this.inited) {
                v = this.height;
                for (const hdr of this.columnHeaders) hdr.setHeight(v);
            }
        },
        
        /** @overrides myt.View */
        setWidth: function(v) {
            const self = this;
            self.callSuper(mathMax(self.minWidth, v));
            if (self.inited) {
                const width = self.width;
                self.setGridWidth(width);
                self.grid.setWidth(width);
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides */
        subviewAdded: function(sv) {
            this.callSuper(sv);
            
            if (sv.isA(pkg.GridColHdr)) {
                sv.setGridController(this);
                sv.setHeight(this.height);
            }
        },
        
        /** @overrides myt.GridController */
        doSort: function() {
            this.grid.refreshListData(true, this.grid.forceFullResetOnNextRefresh);
        },
        
        /** @overrides myt.GridController */
        notifyHdrXChange: function(columnHeader) {
            if (!this.isLocked()) {
                this.grid.notifyXChange(columnHeader);
                this._notifyHdrChange('X', columnHeader);
            }
        },
        
        /** @overrides myt.GridController */
        notifyHdrWidthChange: function(columnHeader) {
            if (!this.isLocked()) {
                this.grid.notifyWidthChange(columnHeader);
                this._notifyHdrChange('Width', columnHeader);
            }
        },
        
        /** @overrides myt.GridController */
        updateRowsForVisibilityChange: function(columnHeader) {
            this.grid.notifyVisibilityChange(columnHeader);
            if (!this.isLocked()) {
                this._notifyHdrChange('Visibility', columnHeader);
            }
        }
    });
})(myt);


(pkg => {
    const JSClass = JS.Class,
        
        /** Use this to implement more complex transitions in a PanelStack.
            
            @class */
        PanelStackTransition = pkg.PanelStackTransition = new JSClass('PanelStackTransition', pkg.Node, {
            // Methods /////////////////////////////////////////////////////////
            /** Called when transitioning to the provided panel. The default implementation keeps 
                the promise right away.
                @param panel:myt.StackablePanel
                @returns a promise object that has a next function. */
            to: panel => Promise.resolve(panel),
            
            /** Called when transitioning from the provided panel. The default implementation keeps 
                the promise right away.
                @param panel:myt.StackablePanel
                @returns a promise object that has a next function. */
            from: panel => Promise.resolve(panel)
        });
    
    /** Manages a stack of myt.View panel children that can be transitioned to an "active" state as 
        they are selected. The active panel will be sized to fit the bounds of the stack.
        
        @class */
    // FIXME: handle panel destruction
    // FIXME: handle panel insertion
    pkg.PanelStack = new JSClass('PanelStack', pkg.View, {
        include: [pkg.SelectionManager],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        initNode: function(parent, attrs) {
            attrs.overflow = 'hidden';
            
            attrs.itemSelectionId ??= 'panelId';
            attrs.maxSelected ??= 1;
            
            this.callSuper(parent, attrs);
            
            this.syncTo(this, '__updateHeight', 'height');
            this.syncTo(this, '__updateWidth', 'width');
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setTransition: function(transition) {this.set('transition', transition, true);},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __updateWidth: function(event) {
            // Only resize the active panel
            this.getActivePanel()?.setWidth(event.value);
        },
        
        /** @private
            @param {!Object} event
            @returns {undefined} */
        __updateHeight: function(event) {
            // Only resize the active panel
            this.getActivePanel()?.setHeight(event.value);
        },
        
        /** Gets the selected panel.
            @returns myt.StackablePanel: The selected panel or undefined if none selected. */
        getActivePanel: function() {
            return this.getSelected()[0];
        },
        
        getPanel: function(panelId) {
            return this.getSelectableItem(panelId);
        },
        
        selectPanel: function(panelId) {
            this.selectById(panelId);
        },
        
        /** @overrides myt.SelectionManager */
        doSelected: function(item) {
            item.setWidth(this.width);
            item.setHeight(this.height);
        },
        
        /** Called by a panel when it transitions between selected states. Should not be called 
            directly. Instead change the panel selection.
            @param panel:myt.StackablePanel The panel that is transitioning.
            @returns {undefined} */
        doStackTransition: function(panel) {
            this['doStackTransition' + (panel.selected ? 'To' : 'From')](panel);
        },
        
        /** Called by PanelStack.doStackTransition when the provided panel will be the newly 
            selected panel in the stack. Should not be called directly. Instead change the 
            panel selection.
            @param panel:myt.StackablePanel The panel that is transitioning.
            @returns {undefined} */
        doStackTransitionTo: function(panel) {
            const self = this;
            
            self.doBeforeTransitionTo(panel);
            
            const transition = self.transition;
            if (transition) {
                transition.to(panel).then(panel => {self.doAfterTransitionTo(panel);});
            } else {
                panel.makeHighestZIndex();
                panel.setVisible(true);
                
                self.doAfterTransitionTo(panel);
            }
        },
        
        doBeforeTransitionTo: panel => {},
        doAfterTransitionTo: panel => {},
        
        /** Called by PanelStack.doStackTransition when the provided panel will be the newly 
            deselected panel in the stack. Should not be called directly. Instead change the 
            panel selection.
            @param panel:myt.StackablePanel The panel that is transitioning.
            @returns {undefined} */
        doStackTransitionFrom: function(panel) {
            const self = this;
            
            self.doBeforeTransitionFrom(panel);
            
            const transition = self.transition;
            if (transition) {
                transition.from(panel).then(panel => {self.doAfterTransitionFrom(panel);});
            } else {
                panel.setVisible(false);
                self.doAfterTransitionFrom(panel);
            }
        },
        
        doBeforeTransitionFrom: panel => {},
        doAfterTransitionFrom: panel => {}
    });
    
    /** Makes a view act as a panel in a myt.PanelStack.
        
        Attributes:
            panelId:string The unique ID of the panel.
            panelStack:myt.PanelStack A reference to the panel stack this panel belongs to. If 
                undefined the parent view will be used.
        
        @class */
    pkg.StackablePanel = new JS.Module('StackablePanel', {
        include: [pkg.Selectable],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.visible = attrs.selected = false;
            
            attrs.bgColor ??= '#fff';
            attrs.panelId ??= attrs.name;
            
            this.callSuper(parent, attrs);
            
            if (this.selected) this.doStackTransition();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setPanelStack: function(v) {this.panelStack = v;},
        
        getPanelStack: function() {
            return this.panelStack ?? this.parent;
        },
        
        setPanelId: function(v) {this.panelId = v;},
        
        /** @overrides myt.Selectable */
        setSelected: function(v) {
            if (this.selected !== v) {
                this.callSuper(v);
                if (this.inited) this.doStackTransition();
            }
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called whenever a transition between panels is initiated by this panel. Default 
            behavior is to defer to the panelStack's doStackTransition method.
            @returns {undefined} */
        doStackTransition: function() {
            this.getPanelStack().doStackTransition(this);
        }
    });
    
    /** A PanelStackTransition that fades the opacity between the two panels.
        
        @class */
    pkg.PanelStackFadeTransition = new JSClass('PanelStackFadeTransition', PanelStackTransition, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.duration ??= 1000;
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setDuration: function(duration) {this.duration = duration;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        to: function(panel) {
            return new Promise((resolve, reject) => {
                panel.stopActiveAnimators('opacity');
                panel.setVisible(true);
                panel.animate({attribute:'opacity', to:1, duration:this.duration}).next(success => {
                    panel.makeHighestZIndex();
                    resolve(panel);
                });
            });
        },
        
        from: function(panel) {
            return new Promise((resolve, reject) => {
                panel.stopActiveAnimators('opacity');
                panel.animate({attribute:'opacity', to:0, duration:this.duration}).next(success => {
                    panel.setVisible(false);
                    resolve(panel);
                });
            });
        }
    });
    
    /** A PanelStackTransition that slides between the from and to panel.
        
        @class */
    pkg.PanelStackSlideTransition = new JSClass('PanelStackSlideTransition', PanelStackTransition, {
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.duration ??= 1000;
            attrs.direction ??= 'right';
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setDuration: function(duration) {this.duration = duration;},
        setDirection: function(direction) {this.direction = direction;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        to: function(panel) {
            const panelStack = panel.getPanelStack(),
                duration = this.duration;
            let toValue,
                axis;
            switch (this.direction) {
                case 'left':
                    axis = 'x';
                    toValue = panelStack.width;
                    break;
                case 'right':
                    axis = 'x';
                    toValue = -panelStack.width;
                    break;
                case 'up':
                    axis = 'y';
                    toValue = panelStack.height;
                    break;
                case 'down':
                    axis = 'y';
                    toValue = -panelStack.height;
                    break;
            }
            
            panel.stopActiveAnimators(axis);
            panel.set(axis, toValue);
            panel.setVisible(true);
            
            return new Promise((resolve, reject) => {
                const nextFunc = success => {
                    panel.makeHighestZIndex();
                    resolve(panel);
                };
                if (duration > 0) {
                    panel.animate({attribute:axis, to:0, duration:duration}).next(nextFunc);
                } else {
                    panel.set(axis, 0);
                    nextFunc();
                }
            });
        },
        
        from: function(panel) {
            const panelStack = panel.getPanelStack(),
                duration = this.duration;
            let toValue,
                axis;
            switch (this.direction) {
                case 'left':
                    axis = 'x';
                    toValue = -panelStack.width;
                    break;
                case 'right':
                    axis = 'x';
                    toValue = panelStack.width;
                    break;
                case 'up':
                    axis = 'y';
                    toValue = -panelStack.height;
                    break;
                case 'down':
                    axis = 'y';
                    toValue = panelStack.height;
                    break;
            }
            
            panel.stopActiveAnimators(axis);
            
            return new Promise((resolve, reject) => {
                const nextFunc = success => {
                    panel.setVisible(false);
                    resolve(panel);
                };
                if (duration > 0) {
                    panel.animate({attribute:axis, to:toValue, duration:duration}).next(nextFunc);
                } else {
                    panel.set(axis, toValue);
                    nextFunc();
                }
            });
        }
    });
})(myt);


(pkg => {
    const JSModule = JS.Module,
    
        {Draggable, global:{dragManager, mouse:globalMouse}} = pkg,
        
        ANY_GROUP = '*',
        
        /*  @param {!Object} autoScroller
            @param {!string} lessDir
            @param {!string} moreDir
            @returns {undefined} */
        resetScroll = (autoScroller, lessDir, moreDir) => {
            for (const dir of [lessDir, moreDir]) {
                autoScroller['__is' + dir] = false;
                autoScroller['__tmrId' + dir] = null;
            }
        },
        
        /*  @param {!Object} autoScroller
            @returns {undefined} */
        resetVScroll = autoScroller => {resetScroll(autoScroller, 'Up', 'Down');},
        
        /*  @param {!Object} autoScroller
            @returns {undefined} */
        resetHScroll = autoScroller => {resetScroll(autoScroller, 'Left', 'Right');},
        
        /** Adds drag group and drop group support to drag and drop related classes. Drag groups
            are used to mark the thing being dragged around. Drop groups are used to mark the
            things that can accept a thing dropped on them.
            
            Private Attributes:
                __dgs:object The keys are the set of drag groups this view supports. By default the 
                    special drag group of '*' which accepts all drag groups is defined.
                __anyDG:boolean The precalculated return value for the acceptAnyDragGroup method.
                __drpgs:object The keys are the set of drop groups this view supports. By default 
                    the special drop group of '*' which accepts all drop groups is defined.
                __anyDRPG:boolean The precalculated return value for the acceptAnyDropGroup method.
            
            @class */
        DragGroupSupport = pkg.DragGroupSupport = new JSModule('DragGroupSupport', {
            // Life Cycle //////////////////////////////////////////////////////
            /** @overrides */
            initNode: function(parent, attrs) {
                this.__dgs = {'*':true};
                this.__drpgs = {'*':true};
                this.__anyDG = this.__anyDRPG = true;
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setDragGroups: function(v) {
                const newDragGroups = this.__dgs = {};
                for (const dragGroup in v) newDragGroups[dragGroup] = true;
                this.__anyDG = newDragGroups.hasOwnProperty(ANY_GROUP);
            },
            
            getDragGroups: function() {
                return this.__dgs;
            },
            
            setDropGroups: function(v) {
                const newDropGroups = this.__drpgs = {};
                for (const dropGroup in v) newDropGroups[dropGroup] = true;
                this.__anyDRPG = newDropGroups.hasOwnProperty(ANY_GROUP);
            },
            
            getDropGroups: function() {
                return this.__drpgs;
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** Adds the provided dragGroup to the dragGroups.
                @param dragGroup:string The drag group to add.
                @returns {undefined} */
            addDragGroup: function(dragGroup) {
                if (dragGroup) {
                    this.__dgs[dragGroup] = true;
                    if (dragGroup === ANY_GROUP) this.__anyDG = true;
                }
            },
            
            /** Removes the provided dragGroup from the dragGroups.
                @param dragGroup:string The drag group to remove.
                @returns {undefined} */
            removeDragGroup: function(dragGroup) {
                if (dragGroup) {
                    delete this.__dgs[dragGroup];
                    if (dragGroup === ANY_GROUP) this.__anyDG = false;
                }
            },
            
            /** Determines if this drop target will accept drops from any drag group.
                @returns boolean: True if any drag group will be accepted, false otherwise. */
            isAnyDragGroup: function() {
                return this.__anyDG;
            },
            
            /** Adds the provided dropGroup to the dropGroups.
                @param dropGroup:string The droup group to add.
                @returns {undefined} */
            addDropGroup: function(dropGroup) {
                if (dropGroup) {
                    this.__drpgs[dropGroup] = true;
                    if (dropGroup === ANY_GROUP) this.__anyDRPG = true;
                }
            },
            
            /** Removes the provided dropGroup from the dropGroups.
                @param dropGroup:string The drop group to remove.
                @returns {undefined} */
            removeDropGroup: function(dropGroup) {
                if (dropGroup) {
                    delete this.__drpgs[dropGroup];
                    if (dropGroup === ANY_GROUP) this.__anyDRPG = false;
                }
            },
            
            /** Determines if this drop target will accept drops from any drop group.
                @returns boolean: True if any drop group will be accepted, false otherwise. */
            isAnyDropGroup: function() {
                return this.__anyDRPG;
            }
        });
    
    /** Makes an myt.View support being a source for myt.Dropable instances. Makes use of 
        myt.Draggable for handling drag initiation but this view is not actually draggable.
        
        Attributes:
            dropParent:myt.View The view to make the myt.Dropable instances in. Defaults to the 
                myt.RootView that contains this drop source.
            dropClass:JS.Class The myt.Dropable class that gets created in the default 
                implementation of makeDropable.
            dropClassAttrs:object The attrs to use when making the dropClass instance.
            dropable:mytDropable (read only) The dropable that was most recently created. Once the 
                dropable has been dropped this will be set to null.
        
        @class */
    pkg.DropSource = new JSModule('DropSource', {
        include: [Draggable],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            attrs.distanceBeforeDrag ??= 2;
            attrs.dropParent ??= parent.getRoot();
            
            this.callSuper(parent, attrs);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setDropClass: function(v) {this.dropClass = pkg.resolveClassname(v);},
        setDropClassAttrs: function(v) {this.dropClassAttrs = v;},
        setDropParent: function(v) {this.dropParent = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** @overrides myt.Draggable */
        startDrag: function(event) {
            const dropable = this.dropable = this.makeDropable();
            
            // Emulate mouse down on the dropable
            if (dropable) {
                // Remember distance and set to zero so a drag will begin for sure.
                const origDistance = dropable.distanceBeforeDrag;
                dropable.distanceBeforeDrag = 0;
                
                dropable.doMouseDown(event); // Execute MouseDownMixin
                dropable.__doMouseDown(event); // Execute Draggable
                
                // Restore distance
                dropable.distanceBeforeDrag = origDistance;
            }
        },
        
        /** @overrides myt.MouseDown */
        doMouseUp: function(event) {
            this.callSuper(event);
            
            // Emulate mouse up on the dropable
            const dropable = this.dropable;
            if (dropable) {
                dropable.__doMouseUp(event);
                dropable.doMouseUp(event);
                this.dropable = null;
            }
        },
        
        /** Called by startDrag to make a dropable.
            @returns myt.Dropable or undefined if one can't be created. */
        makeDropable: function() {
            const dropClass = this.dropClass,
                dropParent = this.dropParent;
            if (dropClass && dropParent) {
                const pos = pkg.DomElementProxy.getRelativePosition(this.getIDE(), dropParent.getIDE());
                return new dropClass(dropParent, {...this.dropClassAttrs, x:pos.x ?? 0, y:pos.y ?? 0});
            }
        }
    });
    
    /** Makes an myt.View support having myt.Dropable views dropped on it.
        
        @class */
    pkg.DropTarget = new JSModule('DropTarget', {
        include: [DragGroupSupport],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            this.callSuper(parent, attrs);
            
            dragManager.registerDropTarget(this);
        },
        
        /** @overrides */
        destroy: function() {
            dragManager.unregisterDropTarget(this);
            
            this.callSuper();
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called by myt.GlobalDragManager when a dropable is dragged over this target. Gives this 
            drop target a chance to reject a drop regardless of drag group. The default 
            implementation returns true if the view is not disabled.
            @param dropable:myt.Dropable The dropable being dragged.
            @returns boolean: True if the drop will be allowed, false otherwise. */
        willAcceptDrop: function(dropable) {
            // Components must be visible and not disabled to accept a drop.
            return !this.disabled && this.isVisible();
        },
        
        /** Called by myt.GlobalDragManager when a dropable starts being dragged that has a 
            matching drag group.
            @param dropable:myt.Dropable The dropable being dragged.
            @returns {undefined} */
        notifyDragStart: dropable => {},
        
        /** Called by myt.GlobalDragManager when a dropable stops being dragged that has a 
            matching drag group.
            @param dropable:myt.Dropable The dropable no longer being dragged.
            @returns {undefined} */
        notifyDragStop: dropable => {},
        
        /** Called by myt.GlobalDragManager when a dropable is dragged over this view and has a 
            matching drag group.
            @param dropable:myt.Dropable The dropable being dragged over this view.
            @returns {undefined} */
        notifyDragEnter: dropable => {},
        
        /** Called by myt.GlobalDragManager when a dropable is dragged out of this view and has a 
            matching drag group.
            @param dropable:myt.Dropable The dropable being dragged out of this view.
            @returns {undefined} */
        notifyDragLeave: dropable => {},
        
        /** Called by myt.GlobalDragManager when a dropable is dropped onto this view and has a 
            matching drag group.
            @param dropable:myt.Dropable The dropable being dropped onto this view.
            @returns {undefined} */
        notifyDrop: dropable => {}
    });
    
    /** Makes an myt.View drag and dropable via the mouse.
        
        Attributes:
            dropped:boolean Indicates this dropable was just dropped.
            dropFailed:boolean Indicates this dropable was just dropped outside of a drop target.
            dropTarget:myt.DropTarget The drop target this dropable is currently over.
        
        @class */
    pkg.Dropable = new JSModule('Dropable', {
        include: [Draggable, DragGroupSupport],
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setDropTarget: function(v) {this.dropTarget = v;},
        setDropped: function(v) {this.dropped = v;},
        setDropFailed: function(v) {this.dropFailed = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called by myt.GlobalDragManager when a dropable is dragged over a target. Gives this 
            dropable a chance to reject a drop regardless of drag group. The default implementation 
            returns true.
            @param dropTarget:myt.DropTarget The drop target dragged over.
            @returns boolean: True if the drop will be allowed, false otherwise. */
        willPermitDrop: dropTarget => true,
        
        /** @overrides myt.Draggable */
        startDrag: function(event) {
            this.setDropped(false);
            this.setDropFailed(false);
            
            dragManager.startDrag(this);
            this.callSuper(event);
        },
        
        /** @overrides myt.Draggable */
        updateDrag: function(event) {
            dragManager.updateDrag(event, this);
            this.callSuper(event);
        },
        
        /** @overrides myt.Draggable */
        stopDrag: function(event, isAbort) {
            dragManager.stopDrag(event, this, isAbort);
            this.callSuper(event, isAbort);
            
            if (isAbort) {
                this.notifyDropAborted();
            } else if (this.dropFailed) {
                this.notifyDropFailed();
            }
        },
        
        /** Called by myt.GlobalDragManager when this view is dragged over a drop target.
            @param dropTarget:myt.DropTarget The target that was dragged over.
            @returns {undefined} */
        notifyDragEntering: function(dropTarget) {
            this.setDropTarget(dropTarget);
        },
        
        /** Called by myt.GlobalDragManager when this view is dragged out of a drop target.
            @param dropTarget:myt.DropTarget The target that was dragged out of.
            @returns {undefined} */
        notifyDragLeaving: function(dropTarget) {
            this.setDropTarget();
        },
        
        /** Called by myt.GlobalDragManager when this view is dropped.
            @param dropTarget:myt.DropTarget The target that was dropped on. Will be undefined if 
                this dropable was dropped on no drop target.
            @param isAbort:boolean Indicates if the drop was the result of an abort or a 
                normal drop.
            @returns {undefined} */
        notifyDropped: function(dropTarget, isAbort) {
            this.setDropped(true);
            
            if (!this.dropTarget) this.setDropFailed(true);
        },
        
        /** Called after dragging stops and the drop failed. The default implementation 
            does nothing.
            @returns {undefined} */
        notifyDropFailed: () => {},
        
        /** Called after dragging stops and the drop was aborted. The default implementation 
            does nothing.
            @returns {undefined} */
        notifyDropAborted: () => {}
    });
    
    /** Makes an myt.View auto scroll during drag and drop.
        
        Attributes:
            scrollBorder:number The thickness of the auto scroll border. Defaults to 40 pixels.
            scrollFrequency:number The time between autoscroll adjustments. Defaults to 50 millis.
            scrollAmount:number The number of pixels to adjust by each time. Defaults to 2 pixels.
            scrollAcceleration:number The amount to increase scrolling by as the mouse gets closer 
                to the edge of the view. Setting this to 0 will result in no acceleration. 
                Defaults to 7.
        
        Private Attributes:
            __amtUp:number
            __amtDown:number
            __amtLeft:number
            __amtRight:number
            __isUp:boolean
            __tmrIdUp:number
            __isDown:boolean
            __tmrIdDown:number
            __isLeft:boolean
            __tmrIdLeft:number
            __isRight:boolean
            __tmrIdRight:number
        
        @class */
    pkg.AutoScroller = new JSModule('AutoScroller', {
        include: [DragGroupSupport],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides */
        initNode: function(parent, attrs) {
            this.scrollBorder = 40;
            this.scrollFrequency = 50;
            this.scrollAmount = 2;
            this.scrollAcceleration = 7;
            
            attrs.overflow ??= 'auto';
            
            this.callSuper(parent, attrs);
            
            dragManager.registerAutoScroller(this);
        },
        
        /** @overrides */
        destroy: function() {
            dragManager.unregisterAutoScroller(this);
            
            this.callSuper();
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setScrollBorder: function(v) {this.scrollBorder = Math.max(1, v);},
        setScrollFrequency: function(v) {this.scrollFrequency = v;},
        setScrollAmount: function(v) {this.scrollAmount = v;},
        setScrollAcceleration: function(v) {this.scrollAcceleration = v;},
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Called by myt.GlobalDragManager when a dropable starts being dragged that has a 
            matching drag group.
            @param {!Object} dropable - The myt.Dropable being dragged.
            @returns {undefined} */
        notifyAutoScrollerDragStart: function(dropable) {
            const ide = this.getIDE();
            if (ide.scrollHeight > ide.clientHeight || ide.scrollWidth > ide.clientWidth) {
                this.attachToDom(globalMouse, '__hndlMove', 'mousemove', true);
            }
        },
        
        /** Called by myt.GlobalDragManager when a dropable stops being dragged that has a 
            matching drag group.
            @param {!Object} dropable - The myt.Dropable no longer being dragged.
            @returns {undefined} */
        notifyAutoScrollerDragStop: function(dropable) {
            this.detachFromDom(globalMouse, '__hndlMove', 'mousemove', true);
            
            resetVScroll(this);
            resetHScroll(this);
        },
        
        /** Handles global mouse movement.
            @private
            @param {!Object} event
            @returns {undefined} */
        __hndlMove: function(event) {
            const self = this;
            
            let {pageX:mouseX, pageY:mouseY} = event.value;
            if (self.containsPoint(mouseX, mouseY)) {
                const pos = self.getPagePosition(), 
                    scrollBorder = self.scrollBorder,
                    calculateAmount = percent => Math.round(self.scrollAmount * (1 + self.scrollAcceleration * percent)),
                    doAutoScrollAdj = (dir, amt) => {
                        if (self['__is' + dir]) {
                            self.getIDE()['scroll' + (dir === 'Up' || dir === 'Down' ? 'Top' : 'Left')] += amt * self['__amt' + dir];
                            self['__tmrId' + dir] = setTimeout(() => {doAutoScrollAdj(dir, amt);}, self.scrollFrequency);
                        }
                    };
                
                mouseX -= pos.x;
                mouseY -= pos.y;
                
                if (mouseY < scrollBorder) {
                    self.__isUp = true;
                    self.__amtUp = calculateAmount(1 - mouseY / scrollBorder);
                    if (!self.__tmrIdUp) doAutoScrollAdj('Up', -1);
                } else if (self.height - mouseY < scrollBorder) {
                    self.__isDown = true;
                    self.__amtDown = calculateAmount(1 - (self.height - mouseY) / scrollBorder);
                    if (!self.__tmrIdDown) doAutoScrollAdj('Down', 1);
                } else {
                    resetVScroll(self);
                }
                
                if (mouseX < scrollBorder) {
                    self.__isLeft = true;
                    self.__amtLeft = calculateAmount(1 - mouseX / scrollBorder);
                    if (!self.__tmrIdLeft) doAutoScrollAdj('Left', -1);
                } else if (self.width - mouseX < scrollBorder) {
                    self.__isRight = true;
                    self.__amtRight = calculateAmount(1 - (self.width - mouseX) / scrollBorder);
                    if (!self.__tmrIdRight) doAutoScrollAdj('Right', 1);
                } else {
                    resetHScroll(self);
                }
            } else {
                resetVScroll(self);
                resetHScroll(self);
            }
        }
    });
})(myt);


(pkg => {
    const {max:mathMax, cos:mathCos, sin:mathSin, PI} = Math,
        degreesToRadians = pkg.Geometry.degreesToRadians,
        
        /*  Redraws the annulus
            @param {!Object} annulus - The Annulus to redraw.
            @returns {undefined} */
        redraw = annulus => {
            // Ensure endAngle is greater than or equal to startAngle
            let startAngle = degreesToRadians(annulus.startAngle), 
                endAngle = degreesToRadians(annulus.endAngle);
            if (startAngle > endAngle) {
                const tmp = startAngle;
                startAngle = endAngle;
                endAngle = tmp;
            }
            
            const path = annulus.__path,
                center = annulus.width / 2,
                thickness = annulus.thickness,
                innerRadius = annulus.radius,
                outerRadius = innerRadius + thickness,
                angleDiff = endAngle - startAngle,
                isFull = angleDiff + 0.0001 >= 2 * PI; // 0.0001 is to handle floating point errors
            
            // Will use two arcs for a full circle
            if (isFull) {
                startAngle = 0;
                endAngle = PI;
            }
            
            const 
                outerStartPoint = [center + outerRadius * mathCos(startAngle), center + outerRadius * mathSin(startAngle)],
                outerEndPoint =   [center + outerRadius * mathCos(endAngle),   center + outerRadius * mathSin(endAngle)],
                innerEndPoint =   [center + innerRadius * mathCos(endAngle),   center + innerRadius * mathSin(endAngle)],
                innerStartPoint = [center + innerRadius * mathCos(startAngle), center + innerRadius * mathSin(startAngle)],
                
                commands = ['M' + outerStartPoint.join()];
            if (isFull) {
                commands.push(
                    'A' + [outerRadius, outerRadius, 0, 1, 1, outerEndPoint].join(),
                    'A' + [outerRadius, outerRadius, 0, 1, 1, outerStartPoint].join(),
                    'L' + innerEndPoint.join(),
                    'A' + [innerRadius, innerRadius, 0, 1, 0, innerStartPoint].join(),
                    'A' + [innerRadius, innerRadius, 0, 1, 0, innerEndPoint].join()
                );
            } else {
                const largeArc = (angleDiff % (2 * PI)) > PI ? 1 : 0,
                    halfThickness = thickness / 2;
                commands.push(
                    'A' + [outerRadius, outerRadius, 0, largeArc, 1, outerEndPoint].join(),
                    annulus.endCapRounding ? 'A' + [halfThickness, halfThickness, 0, 0, 1, innerEndPoint].join() : 'L' + innerEndPoint.join(),
                    'A' + [innerRadius, innerRadius, 0, largeArc, 0, innerStartPoint].join(),
                    annulus.startCapRounding ? 'A' + [halfThickness, halfThickness, 0, 0, 1, outerStartPoint].join() : ''
                );
            }
            commands.push('z');
            
            path.setAttribute('d', commands.join(' '));
            path.setAttribute('fill', annulus.color);
        },
        
        /*  Ensures the size of the view exactly fits the annulus.
            @param {!Object} annulus - The Annulus to update.
            @returns {undefined} */
        updateSize = annulus => {
            const size = 2*(annulus.radius + annulus.thickness),
                svg = annulus.__svg;
            annulus.setWidth(size);
            annulus.setHeight(size);
            
            svg.setAttribute('viewBox', '0 0 ' + size + ' ' + size);
            svg.setAttribute('width', size);
            svg.setAttribute('height', size);
            
            redraw(annulus);
        },
        
        setAndRedraw = (annulus, attrName, value) => {
            if (annulus[attrName] !== value) {
                annulus[attrName] = value;
                if (annulus.inited) {
                    redraw(annulus);
                    annulus.fireEvent(attrName, value);
                }
            }
        },
        
        setAndUpdateSize = (annulus, attrName, value) => {
            if (annulus[attrName] !== value) {
                annulus[attrName] = value = mathMax(0, value);
                if (annulus.inited) {
                    updateSize(annulus);
                    annulus.fireEvent(attrName, value);
                }
            }
        },
        
        makeSVG = (elementName, parentElem) => {
            const svgElem = document.createElementNS('http://www.w3.org/2000/svg', elementName);
            parentElem?.appendChild(svgElem);
            return svgElem;
        },
         
        /** An annulus component.
            
            @class */
        Annulus = pkg.Annulus = new JS.Class('Annulus', pkg.BackView, {
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                const self = this;
                
                self.radius = self.thickness = self.startAngle = self.endAngle = 0;
                self.startCapRounding = self.endCapRounding = false;
                
                self.callSuper(parent, attrs);
                
                updateSize(self);
            },
            
            /** @overrides myt.View */
            createOurDomElement: function(parent) {
                const elements = this.callSuper(parent),
                    innerElem = Array.isArray(elements) ? elements[1] : elements,
                    svg = this.__svg = makeSVG('svg', innerElem);
                this.__path = makeSVG('path', svg);
                
                // Let the view handle mouse events
                svg.style.pointerEvents = 'none';
                
                return elements;
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** The outer radius of the Annulus. */
            setRadius: function(v) {setAndUpdateSize(this, 'radius', v);},
            
            /** The difference between the inner and outer radius. */
            setThickness: function(v) {setAndUpdateSize(this, 'thickness', v);},
            
            /** The start angle in radians. */
            setStartAngle: function(v) {setAndRedraw(this, 'startAngle', v);},
            
            /** The end angle in radians. */
            setEndAngle: function(v) {setAndRedraw(this, 'endAngle', v);},
            
            /** If true the starting cap will be drawn as a semicircle. */
            setStartCapRounding: function(v) {setAndRedraw(this, 'startCapRounding', v);},
            
            /** If true the ending cap will be drawn as a semicircle. */
            setEndCapRounding: function(v) {setAndRedraw(this, 'endCapRounding', v);},
            
            /** The hex color string to fill the Annulus with. */
            setColor: function(v) {setAndRedraw(this, 'color', v);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.View */
            isColorAttr: function(attrName) {
                return attrName === 'color' || this.callSuper(attrName);
            }
        });
})(myt);


(pkg => {
    let tooltipView;
    
    const JSClass = JS.Class,
        
        {mouse:GlobalMouse, windowResize:GlobalWindowResize, dragManager} = pkg.global,
        
        {min:mathMin, max:mathMax, round:mathRound} = Math,
        
        tooltipDomId = 'tooltipDiv',
        
        /*  Clears the tooltip timer. */
        clearCheckTipTimer = ttView => {
            if (ttView.__checkTID) {
                clearTimeout(ttView.__checkTID);
                delete ttView.__checkTID;
            }
        },
        
        /*  Checks if the last mouse position is inside the tip's parent. If not inside the tip 
            will also get hidden.
            @returns {boolean} false if the tip got hidden, true otherwise. */
        checkInTooltip = ttView => {
            if (ttView.tooltip) {
                const pos = ttView._lastPos;
                if (ttView.tooltip.parent.containsPoint(pos.x, pos.y)) return true;
            }
            ttView.hideTip();
            return false;
        },
        
        /** A base class for tooltip classes.
            
            Attributes:
                tooltip:object The tooltip configuration assigned to this tooltip when the mouse 
                    has moved over a view with TooltipMixin.
                tipDelay:number The time in millis to wait before showing the tooltip.
                tipHideDelay:number The time in millis to wait before hiding the tooltip.
            
            Private Attributes:
                __checkTID:number The timer ID used internally for delaying when the tip gets shown.
            
            @class */
        BaseTooltip = pkg.BaseTooltip = new JSClass('BaseTooltip', pkg.View, {
            include: [pkg.RootView],
            
            
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** The default length of time in millis before the tip is shown. */
                TIP_DELAY: 500,
                
                /** The default length of time in millis before the tip is hidden. */
                TIP_HIDE_DELAY: 100
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                this.tipDelay = this.nextTipDelay = BaseTooltip.TIP_DELAY;
                this.tipHideDelay = BaseTooltip.TIP_HIDE_DELAY;
                
                attrs.visible ??= false;
                
                this.callSuper(parent, attrs);
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            /** Sets the tooltip info that will be displayed. 
                @param v {Object} The object has the following keys:
                    parent:myt.View The view to show the tip for.
                    text:string The tip text.
                    tipalign:string Tip alignment, 'left' or 'right'.
                    tipvalign:string Tip vertical alignment, 'above' or 'below'.
                @returns {undefined} */
            setTooltip: function(v) {
                if (this.inited) {
                    this.tooltip = v;
                    if (v) {
                        this.attachToDom(GlobalMouse, '__hndl_mousemove', 'mousemove', true);
                        this.attachToDom(v.parent, 'hideTip', 'mousedown', true);
                        this.attachToDom(v.parent, 'hideTip', 'mouseup', true);
                    }
                }
            },
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @private
                @param {!Object} event The event object.
                @returns {undefined} */
            __hndl_mousemove: function(event) {
                const self = this;
                self._lastPos = pkg.MouseObservable.getMouseFromEvent(event);
                if (checkInTooltip(self)) {
                    clearCheckTipTimer(self);
                    self.__checkTID = setTimeout(
                        () => {
                            delete self.__checkTID;
                            
                            // If the mouse rests in the tooltip's parent, show the tooltip.
                            if (checkInTooltip(self)) self.showTip();
                        },
                        self.nextTipDelay
                    );
                }
            },
            
            /** Called when the tip will be hidden.
                @param {!Object} event The event object.
                @returns {boolean} */
            hideTip: function(event) {
                clearCheckTipTimer(this);
                
                const ttp = this.tooltip?.parent;
                if (ttp) {
                    this.detachFromDom(ttp, 'hideTip', 'mousedown', true);
                    this.detachFromDom(ttp, 'hideTip', 'mouseup', true);
                    this.detachFromDom(GlobalMouse, '__hndl_mousemove', 'mousemove', true);
                    
                    this.nextTipDelay = this.tipDelay;
                    this.setVisible(false);
                }
                
                // Don't consume mouse event since we just want to close the tip as a side effect 
                // of the user action. The typical case for this is the user clicking on a button 
                // while the tooltip for that button is shown.
                return true;
            },
            
            /** Called when the tip will be shown.
                @returns {undefined} */
            showTip: function() {
                // Don't show tooltips while doing drag and drop since tooltips are distracting 
                // while this is going on.
                if (!dragManager.getDragView()) {
                    this.nextTipDelay = this.tipHideDelay;
                    this.bringToFront();
                    this.setVisible(true);
                }
            }
        }),
        
        /** An implementation of a tooltip.
            
            Attributes:
                edgeSize:number the thickness of the "edge" of the tip background.
                edgeColor:string The color used for the edge.
                shadowSize:number The thickness of the shadow.
                shadowColor:string The color of the shadow.
                insetH:number The horizontal inset of the text from the edge.
                insetV:number The vertical inset of the text from the edge.
                tipBgColor:string The color to use for the tip background.
                tipTextColor:string The color to use for the tip text.
            
            @class */
        Tooltip = pkg.Tooltip = new JSClass('Tooltip', BaseTooltip, {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                EDGE_SIZE: 0,
                EDGE_COLOR: '#444',
                SHADOW_SIZE: 2,
                SHADOW_COLOR: '#00000033', // Extra nums are opacity
                HORIZONTAL_INSET: 6,
                VERTICAL_INSET: 3,
                TIP_BG_COLOR: '#444',
                TIP_TEXT_COLOR: '#eee'
            },
            
            
            // Life Cycle //////////////////////////////////////////////////////
            initNode: function(parent, attrs) {
                attrs.edgeSize ??= Tooltip.EDGE_SIZE;
                attrs.edgeColor ??= Tooltip.EDGE_COLOR;
                attrs.shadowSize ??= Tooltip.SHADOW_SIZE;
                attrs.shadowColor ??= Tooltip.SHADOW_COLOR;
                attrs.insetH ??= Tooltip.HORIZONTAL_INSET;
                attrs.insetV ??= Tooltip.VERTICAL_INSET;
                attrs.tipBgColor ??= Tooltip.TIP_BG_COLOR;
                attrs.tipTextColor ??= Tooltip.TIP_TEXT_COLOR;
                
                this.callSuper(parent, attrs);
                
                this._tipText = new pkg.Text(this, {
                    fontSize:'12px', x:this.insetH, y:this.insetV,
                    textColor:this.tipTextColor, whiteSpace:'inherit'
                });
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setEdgeSize: function(v) {this.edgeSize = v;},
            setEdgeColor: function(v) {this.edgeColor = v;},
            setShadowSize: function(v) {this.shadowSize = v;},
            setShadowColor: function(v) {this.shadowColor = v;},
            setInsetH: function(v) {this.insetH = v;},
            setInsetV: function(v) {this.insetV = v;},
            setTipBgColor: function(v) {this.tipBgColor = v;},
            setTipTextColor: function(v) {this.tipTextColor = v;},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @override myt.BaseTooltip. */
            showTip: function() {
                const self = this,
                    tt = self.tooltip,
                    txt = tt.text,
                    ttp = tt.parent,
                    tipText = self._tipText,
                    edgeSize = self.edgeSize,
                    shadowSize = self.shadowSize;
                
                // Size tip text and size it to fit within the maximum text width.
                if (tipText.text !== txt) tipText.setText(txt);
                tipText.setWidth('auto');
                const tipTextWidth = mathMin(tipText.measureNoWrapWidth(), tt.maxTextWidth),
                    tipWidth = tipTextWidth + 2*tipText.x,
                    tipExtentX = tipWidth + 2*edgeSize;
                tipText.setWidth(tipTextWidth);
                tipText.sizeViewToDom();
                
                // Determine position
                const parentPos = ttp.getPagePosition(),
                    tipHeight = tipText.height + 2*tipText.y,
                    tipExtentY = tipHeight + 2*edgeSize,
                    tipY = parentPos.y - tipExtentY + (tt.tipvalign === 'below' ? ttp.height + tipExtentY : 0);
                let tipX = parentPos.x;
                switch (tt.tipalign) {
                    case 'right':
                        tipX -= tipExtentX;
                        // Fall through
                    case 'farright':
                        tipX += ttp.width;
                        break;
                    case 'farleft':
                        tipX -= tipExtentX;
                        break;
                    default: // left
                }
                
                // Apply values and prevent out-of-bounds
                self.setX(mathRound(mathMin(mathMax(tipX, 0), GlobalWindowResize.getWidth() - tipExtentX)));
                self.setY(mathRound(mathMin(mathMax(tipY, 0), GlobalWindowResize.getHeight() - tipExtentY)));
                self.setWidth(tipWidth);
                self.setHeight(tipHeight);
                self.setBgColor(self.tipBgColor);
                self.setBorder([edgeSize, 'solid', self.edgeColor]);
                self.setBoxShadow([shadowSize, shadowSize, shadowSize, self.shadowColor]);
                
                self.callSuper();
            }
        }),
        
        /** A mixin that adds tooltip support to a view.
            
            Requires:
                myt.MouseOver
            
            Events:
                tooltip:string
                tipAlign:string
                tipValign:string
                tipClass:JS.Class
            
            Attributes:
                tooltip:string The tip text to display.
                tipAlign:string The horizontal alignment of the tooltip relative to the view the 
                    tip is being shown for. Supported values are 'left', 'farleft', 'right' and 
                    'farright'. Defaults to 'left'.
                tipValign:string The vertical alignment of the tooltip relative to the view the 
                    tip is being shown for. Supported values are 'above' and 'below'. Defaults 
                    to 'above'.
                maxTextWidth:number The maximum width of the tooltip text.
                tipClass:JS.Class The class to use to instantiate the tooltip.
            
            @class */
        TooltipMixin = pkg.TooltipMixin = new JS.Module('TooltipMixin', {
            // Class Methods and Attributes ////////////////////////////////////
            extend: {
                /** The default class to use for tooltip views. If a project wants to use a special 
                    tip class everywhere it should override this. */
                TIP_CLASS: Tooltip,
                MAX_TEXT_WIDTH: 280
            },
            
            
            // Accessors ///////////////////////////////////////////////////////
            setTooltip: function(v) {
                // Supresses the myt.View tooltip behavior.
                this.callSuper('');
                
                this.set('tooltip', v, true);
            },
            getTooltip: function() {return this.tooltip;},
            setTipAlign: function(v) {this.set('tipAlign', v, true);},
            setTipValign: function(v) {this.set('tipValign', v, true);},
            setMaxTextWidth: function(v) {this.set('maxTextWidth', v, true);},
            setTipClass: function(v) {this.set('tipClass', v, true);},
            
            
            // Methods /////////////////////////////////////////////////////////
            /** @overrides myt.MouseOver. */
            doSmoothMouseOver: function(isOver) {
                const self = this,
                    tooltip = self.getTooltip();
                
                self.callSuper(isOver);
                
                if (isOver && tooltip) {
                    // Use configured class or default if none defined.
                    const tipClass = self.tipClass ?? TooltipMixin.TIP_CLASS;
                    
                    // Destroy tip if it's not the correct class.
                    if (tooltipView && !(tooltipView instanceof tipClass)) {
                        tooltipView.destroy();
                        tooltipView = null;
                    }
                    
                    // Create new instance.
                    if (!tooltipView) {
                        // Create tooltip div if necessary
                        let elem = document.getElementById(tooltipDomId);
                        if (!elem) {
                            elem = pkg.DomElementProxy.createElement('div', {position:'absolute'});
                            
                            // Make the div a child of the body element so it can be in front of 
                            // pretty much anything in the document.
                            pkg.getElement().appendChild(elem);
                        }
                        tooltipView = new tipClass(elem, {domId:tooltipDomId});
                    }
                    
                    tooltipView.setTooltip({
                        parent:self, 
                        text:tooltip, 
                        tipalign:self.tipAlign, 
                        tipvalign:self.tipValign,
                        maxTextWidth:self.maxTextWidth || TooltipMixin.MAX_TEXT_WIDTH
                    });
                }
            }
        });
})(myt);


(pkg => {
    const math = Math,
        {min:mathMin, max:mathMax} = math;
    
    /** An ordered collection of points that can be applied to a canvas.
        
        Attributes:
            vectors:array The data is stored in a single array with the x coordinate first and 
                the y coordinate second.
            _boundingBox:object the cached bounding box if it has been calculated.
        
        @class */
    pkg.Path = new JS.Class('Path', {
        // Constructor /////////////////////////////////////////////////////////
        /** Create a new Path.
            @param {?Array} vectors
            @returns {undefined} */
        initialize: function(vectors) {
            this.setVectors(vectors ?? []);
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        setVectors: function(v) {
            this._boundingBox = null;
            this.vectors = v;
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Copy the data from the provided Path into this one.
            @param {!Object} path - An myt.Path
            @returns {undefined} */
        copyFrom: function(path) {
            this.vectors = path.vectors.slice();
            this._boundingBox = null;
        },
        
        /** Draws this path into the provided drawview.
            @param {!Object} canvas
            @returns {undefined} */
        drawInto: function(canvas) {
            canvas.beginPath();
            const vecs = this.vectors;
            let len = vecs.length, 
                i = 0;
            canvas.moveTo(vecs[i++], vecs[i++]);
            for (; len > i;) canvas.lineTo(vecs[i++], vecs[i++]);
            canvas.closePath();
        },
        
        /** Shift this path by the provided x and y amount.
            @param {number} dx
            @param {number} dy
            @returns {undefined} */
        translate: function(dx, dy) {
            const vecs = this.vectors;
            let i = vecs.length;
            while (i) {
                vecs[--i] += dy;
                vecs[--i] += dx;
            }
            this._boundingBox = null;
        },
        
        /** Scales the path by the provided amount.
            @param {number} magnitude
            @returns {undefined} */
        scale: function(magnitude) {
            const vecs = this.vectors;
            let i = vecs.length;
            while (i) {
                vecs[--i] *= magnitude;
                vecs[--i] *= magnitude;
            }
            this._boundingBox = null;
        },
        
        /** Rotates this path around 0,0 by the provided angle in radians.
            @param {number} a
            @returns {undefined} */
        rotate: function(a) {
            const cosA = math.cos(a),
                sinA = math.sin(a),
                vecs = this.vectors,
                len = vecs.length;
            for (let i = 0; len > i;) {
                const xNew = vecs[i] * cosA - vecs[i + 1] * sinA,
                    yNew = vecs[i] * sinA + vecs[i + 1] * cosA;
                vecs[i++] = xNew;
                vecs[i++] = yNew;
            }
            this._boundingBox = null;
        },
        
        /** Rotates this path around the provided origin by the provided angle in radians.
            @param {number} angle - The angle in radians
            @param {number} xOrigin - The x coordinate to rotate around.
            @param {number} yOrigin - The y coordinate to rotate around.
            @returns {undefined} */
        rotateAroundOrigin: function(angle, xOrigin, yOrigin) {
            this.translate(-xOrigin, -yOrigin);
            this.rotate(angle);
            this.translate(xOrigin, yOrigin);
        },
        
        /** Gets the bounding box for this path.
            @return {!Object} with properties x, y, width and height or null if no bounding box 
                could be calculated. */
        getBoundingBox: function() {
            if (this._boundingBox) return this._boundingBox;
            
            const vecs = this.vectors;
            let i = vecs.length, minX, maxX, minY, maxY;
            if (i >= 2) {
                minY = maxY = vecs[--i];
                minX = maxX = vecs[--i];
                while (i) {
                    const y = vecs[--i],
                        x = vecs[--i];
                    minY = mathMin(y, minY);
                    maxY = mathMax(y, maxY);
                    minX = mathMin(x, minX);
                    maxX = mathMax(x, maxX);
                }
                return this._boundingBox = {x:minX, y:minY, width:maxX - minX, height:maxY - minY};
            }
            
            return this._boundingBox = null;
        },
        
        /** Gets the center point of the bounding box for the path.
            @returns {!Object} with properties x and y or null if no bounding box could 
                be calculated. */
        getCenter: function() {
            const box = this.getBoundingBox();
            return box ? {
                x:box.x + box.width / 2,
                y:box.y + box.height / 2
            } : null;
        },
        
        /** Tests if the provided point is inside this path.
            @param {number|!Object} x - The x coordinate to test. Or a point object with x and 
                y properties.
            @param {number} y - The y coordinate to test.
            @returns {boolean} true if inside, false otherwise. */
        isPointInPath: function(x, y) {
            if (typeof x === 'object') {
                y = x.y;
                x = x.x;
            }
            return pkg.Geometry.isPointInPath(x, y, this.getBoundingBox(), this.vectors);
        }
    });
})(myt);


(pkg => {
    const consoleWarn = console.warn,
        
        PI = Math.PI,
        HALF_PI = PI / 2,
        ONE_AND_A_HALF_PI = PI * 3 / 2,
        AccessorSupport = pkg.AccessorSupport,
        
        mixin = {};
    
    for (const funcName of [
        'save','restore','scale','rotate','translate','transform','setTransform',
        'clearRect','fillRect','strokeRect','beginPath','closePath','moveTo','lineTo',
        'quadraticCurveTo','bezierCurveTo','arcTo','rect','arc','fill','stroke','clip',
        'isPointInPath','fillText','strokeText','drawImage','createImageData','putImageData'
    ]) {
        mixin[funcName] = function(...args) {
            this.__ctx[funcName](...args);
        };
    }
    
    for (const funcName of [
        'createLinearGradient','createRadialGradient','createPattern','measureText','getImageData'
    ]) {
        mixin[funcName] = function(...args) {
            return this.__ctx[funcName](...args);
        };
    }
    
    for (const propName of [
        'fillStyle','strokeStyle','shadowColor','shadowBlur','shadowOffsetX','shadowOffsetY',
        'lineWidth','lineCap','lineJoin','miterLimit','font','textAlign','textBaseline',
        'globalAlpha','globalCompositeOperation'
    ]) {
        mixin[AccessorSupport.generateSetterName(propName)] = function(v) {
            this.__ctx[propName] = v;
        };
        mixin[AccessorSupport.generateGetterName(propName)] = function() {
            return this.__ctx[propName];
        };
    }
    
    /** A view for programatic drawing. This view is backed by an html canvas element.
        
        Attributes:
            Same as HTML canvas element.
        
        Private Attributes:
            __cvs: A reference to the canvas dom element.
            __ctx: A reference to the 2D drawing context.
        
        @class */
    pkg.Canvas = new JS.Class('Canvas', pkg.BackView, {
        include:[mixin],
        
        
        // Life Cycle //////////////////////////////////////////////////////////
        /** @overrides myt.View */
        createOurDomElement: function(parent) {
            const elements = this.callSuper(parent),
                innerElem = Array.isArray(elements) ? elements[1] : elements,
                canvas = this.__cvs = document.createElement('canvas');
            canvas.className = 'mytUnselectable';
            innerElem.appendChild(canvas);
            canvas.style.position = 'absolute';
            
            this.__ctx = canvas.getContext('2d');
            
            return elements;
        },
        
        
        // Accessors ///////////////////////////////////////////////////////////
        /** @overrides myt.View
            Needed because canvas must also set width/height attribute.
            See: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#attr-canvas-width */
        setWidth: function(v) {
            if (0 > v) v = 0;
            this.__cvs.setAttribute('width', v);
            this.callSuper(v);
        },
        
        /** @overrides myt.View
            Needed because canvas must also set width/height attribute.
            See: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#attr-canvas-width */
        setHeight: function(v) {
            if (0 > v) v = 0;
            this.__cvs.setAttribute('height', v);
            this.callSuper(v);
        },
        
        
        // Methods /////////////////////////////////////////////////////////////
        /** Clears the drawing context. Anything currently drawn will be erased. */
        clear: function() {
            // Store the current transform matrix, then apply the identity matrix to make clearing 
            // simpler then restore the transform.
            const ctx = this.__ctx;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, this.width, this.height);
            ctx.restore();
        },
        
        dataURItoBlob: function(dataURI, dataTYPE) {
            const binary = atob(dataURI.split(',')[1]), 
                len = binary.length,
                array = [];
            for (let i = 0; i < len;) array.push(binary.charCodeAt(i++));
            return new Blob([new Uint8Array(array)], {type: dataTYPE});
        },
        
        getDataURL: function(mimeType, opt) {
            return this.__cvs.toDataURL(mimeType, opt);
        },
        
        getImageFile: function(imageType, filename, opt) {
            let extension;
            switch (imageType) {
                case 'png': case 'PNG':
                    extension = 'png';
                    break;
                case 'jpg': case 'JPG': case 'jpeg': case 'JPEG':
                    extension = 'jpeg';
                    // opt should be a quality number between 0.0 (worst) and 1.0 (best)
                    opt ??= 0.5;
                    break;
                default:
                    consoleWarn('Unexpected image type', imageType);
                    extension = imageType.toLowerCase();
            }
            const mimeType = 'image/' + extension,
                blob = this.dataURItoBlob(this.getDataURL(mimeType, opt), mimeType);
            if (filename) blob.name = filename + '.' + extension;
            return blob;
        },
        
        /** Draws a circle
            @param x:number the x location of the center of the circle.
            @param y:number the y location of the center of the circle.
            @param radius:number the radius of the circle.
            @returns {undefined} */
        circle: function(x, y, radius) {
            this.__ctx.arc(x, y, radius, 0, 2 * PI);
        },
        
        /** Draws a rounded rect into the provided drawview.
            @param {number} r - The radius of the corners.
            @param {number} thickness - The thickness of the line. If thickness is zero or less a 
                fill will be done rather than an outline.
            @param {number} left
            @param {number} top
            @param {number} w
            @param {number} h
            @returns {!Object} The canvas for function chaining. */
        drawRoundedRect: function(r, thickness, left, top, w, h) {
            const self = this,
                lineTo = self.lineTo.bind(self),
                arc = self.arc.bind(self);
            
            let bottom = top + h,
                right = left + w;
            
            // We create a single path for both an outer and inner rounded rect. The reason for 
            // this is that filling looks much better than stroking.
            self.beginPath();
            
            self.moveTo(left, top + r);
            
            lineTo(left, bottom - r);
            arc(left + r, bottom - r, r, PI, HALF_PI, true);
            
            lineTo(right - r, bottom);
            arc(right - r, bottom - r, r, HALF_PI, 0, true);
            
            lineTo(right, top + r);
            arc(right - r, top + r, r, 0, ONE_AND_A_HALF_PI, true);
            
            lineTo(left + r, top);
            arc(left + r, top + r, r, ONE_AND_A_HALF_PI, PI, true);
            
            self.closePath();
            
            if (thickness > 0) {
                r -= thickness;
                left += thickness;
                right -= thickness;
                top += thickness;
                bottom -= thickness;
                
                self.moveTo(left, top + r);
                
                arc(left + r, top + r, r, PI, ONE_AND_A_HALF_PI);
                
                lineTo(right - r, top);
                arc(right - r, top + r, r, ONE_AND_A_HALF_PI, 0);
                
                lineTo(right, bottom - r);
                arc(right - r, bottom - r, r, 0, HALF_PI);
                
                lineTo(left + r, bottom);
                arc(left + r, bottom - r, r, HALF_PI, PI);
                
                self.closePath();
            }
            return self;
        },
        
        /** Draws a rect outline into the provided drawview.
            @param {number} thickness - The thickness of the line.
            @param {number} left
            @param {number} top
            @param {number} w
            @param {number} h
            @returns {!Object} The canvas for function chaining. */
        drawRectOutline: function(thickness, left, top, w, h) {
            const self = this,
                bottom = top + h, 
                right = left + w,
                ileft = left + thickness,
                iright = right - thickness,
                itop = top + thickness,
                ibottom = bottom - thickness,
                lineTo = self.lineTo.bind(self);
            
            self.beginPath();
            
            self.moveTo(left, top);
            lineTo(left, bottom);
            lineTo(right, bottom);
            lineTo(right, top);
            lineTo(left, top);
            
            lineTo(ileft, itop);
            lineTo(iright, itop);
            lineTo(iright, ibottom);
            lineTo(ileft, ibottom);
            lineTo(ileft, itop);
            
            self.closePath();
            
            return self;
        },
        
        /** Draws a rounded rect with one or more flat corners.
            @param {number} rTL - the radius for the top left corner.
            @param {number} rTR - the radius for the top right corner.
            @param {number} rBL - the radius for the bottom left corner.
            @param {number} rBR - the radius for the bottom right corner.
            @param {number} left
            @param {number} top
            @param {number} w
            @param {number} h
            @returns {!Object} The canvas for function chaining. */
        drawPartiallyRoundedRect: function(rTL, rTR, rBL, rBR, left, top, w, h) {
            const self = this,
                bottom = top + h, 
                right = left + w,
                lineTo = self.lineTo.bind(self),
                quadraticCurveTo = self.quadraticCurveTo.bind(self);
            
            self.beginPath();
            
            self.moveTo(left, top + rTL);
            
            lineTo(left, bottom - rBL);
            if (rBL > 0) quadraticCurveTo(left, bottom, left + rBL, bottom);
            
            lineTo(right - rBR, bottom);
            if (rBR > 0) quadraticCurveTo(right, bottom, right, bottom - rBR);
            
            lineTo(right, top + rTR);
            if (rTR > 0) quadraticCurveTo(right, top, right - rTR, top);
            
            lineTo(left + rTL, top);
            if (rTL > 0) quadraticCurveTo(left, top, left, top + rTL);
            
            self.closePath();
            return self;
        },
        
        /** Draws an annulus filled with a gradient.
            @param {number} centerX - The x location of the origin of the annulus.
            @param {number} centerY - The y location of the origin of the annulus.
            @param {number} r - The outer radius of the annulus in pixels.
            @param {number} ir - The inner radius of the annulus in pixels.
            @param {number} startAngle - The start of the annulus in radians.
            @param {number} endAngle - The end of the annulus in radians.
            @param {!Array} colors - An array of objects that contains the colors to blend between 
                and the angle they occur at. The object has two properties, "angle" (in radians) 
                and "color". The "color" may be either a hex color string or a myt.Color object.
                A computed value "colorDelta" will be pushed onto it during the execution of
                this function.
            @param {number} [segments] - The number of segments to draw for half a circle. 
                Defaults to 60.
            @returns {!Object} The canvas for function chaining. */
        drawAnnulus: function(centerX, centerY, r, ir, startAngle, endAngle, colors, segments=60) {
            const self = this,
                Color = pkg.Color;
            
            // Convert string based hex colors to myt.Color objects.
            for (const config of colors) {
                if (typeof config.color === 'string') config.color = Color.makeColorFromHexString(config.color);
            }
            
            // Calculate Colors
            if (segments < 1) {
                consoleWarn('Invalid segements', segments);
                segments = 60;
            }
            
            let angleDelta = PI / segments,
                i = 0;
            
            for (const limit = colors.length - 1; i < limit;) {
                const config = colors[i++],
                    {angle:curAngle, color:curColor} = config,
                    {angle:nextAngle, color:nextColor} = colors[i],
                    angleDiff = nextAngle - curAngle,
                    slices = Math.round(angleDiff / angleDelta),
                    diff = curColor.getDiffFrom(nextColor);
                config.colorDelta = {red:diff.red / slices, green:diff.green / slices, blue:diff.blue / slices};
            }
            
            const path = new pkg.Path([centerX + r, centerY, centerX + ir, centerY]);
            path.rotateAroundOrigin(startAngle, centerX, centerY);
            const vectors = path.vectors;
            let angle = startAngle,
                ix1,
                iy1,
                x1,
                y1,
                [x2, y2, ix2, iy2] = vectors,
                diffCount = 0,
                
                // Antialiasing issues means we need to draw each polygon with a small overlap to 
                // fill the gap.
                angleOverlap =  PI / 360;
            
            i = 0;
            
            while (endAngle > angle) {
                // Shift angle and points
                x1 = x2;
                y1 = y2;
                ix1 = ix2;
                iy1 = iy2;
                
                // Calculate new angle and points
                angle += angleDelta;
                if (angle > endAngle) {
                    angleDelta += endAngle - angle;
                    angleOverlap = 0;
                    angle = endAngle;
                }
                path.rotateAroundOrigin(angleDelta + angleOverlap, centerX, centerY);
                [x2, y2, ix2, iy2] = vectors;
                
                // Draw part
                self.beginPath();
                self.moveTo(x1, y1);
                self.lineTo(ix1, iy1);
                self.lineTo(ix2, iy2);
                self.lineTo(x2, y2);
                self.closePath();
                
                const {color, colorDelta} = colors[i];
                self.setFillStyle(Color.rgbToHex(
                    color.red + (diffCount * colorDelta.red),
                    color.green + (diffCount * colorDelta.green),
                    color.blue + (diffCount * colorDelta.blue),
                    true
                ));
                self.fill();
                
                if (angleOverlap > 0) {
                    path.rotateAroundOrigin(-angleOverlap, centerX, centerY);
                    [x2, y2, ix2, iy2] = vectors;
                }
                
                // Increment color
                diffCount++;
                if (angle >= colors[i + 1].angle) {
                    diffCount = 0;
                    i++;
                }
            }
            return self;
        }
    });
})(myt);

/** Provides a dependency target that pulls in all of the myt package. */
myt.all = true;

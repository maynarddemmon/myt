#!/usr/bin/env node

// Gather Arguments
const fs = require('fs'),
    arguments = process.argv.splice(2),
    manifestFile = arguments[0],
    targetFile = arguments[1],
    rootPath = arguments[2],
    outputSourceMap = arguments[3] === 'true',
    doLintChecks = arguments[4] === 'true',
    requiredFiles = arguments.splice(5);

// Basic argument validation
if (!manifestFile) return console.error('No manifest file provided.');
if (!targetFile) return console.error('No target file provided.');
if (!rootPath) return console.error('No root path provided.');
if (!requiredFiles.length > 0) return console.error('No required file provided.');

// We now know we have a targetFile so generate the min filename too.
let minifiedFilePath = targetFile.substring(0, targetFile.length - 2) + 'min.js';

// JS Build
const jsBuild = (manifest, root, include, callback) => {
    const http = require('http'),
        https = require('https'),
        url = require('url'),
        path = require('path'),
        HTTP_REGEX = /^https?:/i,
        die = msg => {
            if (msg) console.error(' [ERROR] ' + msg);
            process.exit(1);
        },
        P = require('./package');
    
    P.ROOT = path.resolve(root);
    P.ENV.JS = P;
    P.ENV.JSCLASS_PATH = path.dirname(manifest);
    
    // Pull in the manifest file
    require(path.resolve(manifest));
    
    // Creates the list of packages needed for the include list. Resolves
    // the depends and uses information so that the resulting packages list
    // is in dependency order.
    const packages = [];
    include.forEach(inc => {
        const expand = (Package, name, deps) => {
            const pkg = Package._getByName(name);
            pkg._deps.list.forEach(p => {expand(Package, p, deps)});
            if (deps.indexOf(pkg) === -1) deps.push(pkg);
            pkg._uses.list.forEach(p => {expand(Package, p, deps)});
        }
        expand(P.Package, inc, packages);
    });
    
    // Extract the file paths out of the packages list. This is necessary
    // because each file() declaration in the manifest file can declare more
    // than one file.
    const includedFiles = [];
    packages.forEach(pkg => {
        let paths = pkg._loader;
        if (!(paths instanceof Array)) die('Cannot bundle ' + pkg + ': no path specified in your manifest');
        paths = paths.filter(p => {return !HTTP_REGEX.test(p)});
        paths.forEach(loader => {includedFiles.push(loader)});
    });
    
    const read = (file, readCallback) => {
        console.error(' [READ] ' + file);
        if (HTTP_REGEX.test(file)) {
            const uri     = url.parse(file),
                client  = (uri.protocol === 'https:') ? https : http,
                port    = uri.port || (client === https ? '443' : '80'),
                options = {host:uri.hostname, port:port, path:uri.pathname},
                chunks  = [];
            let length  = 0;
            
            client.get(options, response => {
                if (response.statusCode < 200 || response.statusCode >= 300) die('Request unsuccessful: ' + file);
                
                response.addListener('data', chunk => {
                    chunks.push(chunk)
                    length += chunk.length
                });
                response.addListener('end', () => {
                    let offset = 0;
                    const body = new Buffer(length);
                    chunks.forEach(chunk => {
                        chunk.copy(body, offset);
                        offset += chunk.length;
                    });
                    readCallback(body)
                });
            }).on('error', () => {
                die('Request unsuccessful: ' + file);
            });
        } else {
            fs.readFile(file, (error, content) => {
                if (error) die('Cannot find file ' + file + ', please check your --root setting');
                readCallback(content);
            })
        }
    }
    
    // Iterate over the included files in order reading each one in and
    // ultimately concatenating them all together and ultimately execute the
    // callback function
    const source = [],
        bundle = (root, files, i) => {
            if (i >= files.length) {
                callback(source.join('\n\n'));
            } else {
                read(files[i], code => {
                    source.push(code.toString('utf8'));
                    bundle(root, files, i + 1);
                })
            }
        };
    bundle(P.ROOT, includedFiles, 0);
};

// Remove old files
console.info("Try to remove old files:");
const removeFile = path => {
    try {
        fs.unlinkSync(path);
        console.info('  Removed: ' + path);
    } catch (e) {
        console.info('  Could not remove: ' + path);
    }
};
removeFile(targetFile);
removeFile(minifiedFilePath);
removeFile(minifiedFilePath + '.map');

// Now use jsbuild to combine files
console.info("Concatenating files:");
jsBuild(manifestFile, rootPath, requiredFiles, concatenatedData => {
    fs.writeFileSync(targetFile, concatenatedData, {"encoding":'utf8'});
    
    // Setup opts
    const opts = {
          js: targetFile,
          js_output_file: minifiedFilePath,
          language_out: 'ECMASCRIPT_2021'
        };
    if (doLintChecks) opts.jscomp_warning = 'lintChecks';
    if (outputSourceMap) {
        // Get just the filename without any leading directories
        const parts = minifiedFilePath.split('/');
        
        opts.source_map_format = 'V3';
        opts.create_source_map = minifiedFilePath + '.map';
        opts.output_wrapper = '%output%\n//# sourceMappingURL=./' + parts[parts.length - 1] + '.map';
    }
    
    const ClosureCompiler = require('google-closure-compiler').compiler,
        compilerInstance = new ClosureCompiler(opts);
    
    // Force native compilation. Assume linux unless we can determine otherwise.
    let compilerPlatform = 'linux';
    switch (process.platform) {
        case 'win32': compilerPlatform = 'windows'; break;
        case 'darwin': compilerPlatform = 'osx'; break;
    }
    compilerInstance.JAR_PATH = null;
    compilerInstance.javaPath = require('google-closure-compiler-' + compilerPlatform);
    
    console.info("Executing native compilation for platform: " + compilerPlatform + " with opts:", opts);
    compilerInstance.run((exitCode, stdOut, stdErr) => {
        if (exitCode) console.error('exitCode: ' + exitCode);
        if (stdOut) console.info('stdout: ' + stdOut);
        if (stdErr) console.error('stderr: ' + stdErr);
        
        // Inject a sourceRoot into the source map file.
        if (outputSourceMap) {
            const src = minifiedFilePath + '.map',
                fileData = fs.readFileSync(src, 'utf8');
            fs.writeFileSync(src, '{\n"sourceRoot":"../",' + fileData.substring(1), {"encoding":'utf8'});
        }
    });
});
